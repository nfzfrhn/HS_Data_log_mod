
HS_DataLog.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00019e90  080001c0  080001c0  000101c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000010e0  0801a050  0801a050  0002a050  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801b130  0801b130  00030318  2**0
                  CONTENTS
  4 .ARM          00000008  0801b130  0801b130  0002b130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801b138  0801b138  00030318  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  0801b138  0801b138  0002b138  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  0801b140  0801b140  0002b140  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000318  20000000  0801b148  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00019e64  20000318  0801b460  00030318  2**3
                  ALLOC
 10 ._user_heap_stack 00066004  2001a17c  0801b460  0003a17c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00030318  2**0
                  CONTENTS, READONLY
 12 .debug_info   000b18d8  00000000  00000000  00030348  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000ea8e  00000000  00000000  000e1c20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0006c607  00000000  00000000  000f06ae  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00003500  00000000  00000000  0015ccb5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 0000e840  00000000  00000000  001601b5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00048a47  00000000  00000000  0016e9f5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0007dae3  00000000  00000000  001b743c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    001708d7  00000000  00000000  00234f1f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000053  00000000  00000000  003a57f6  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000cdbc  00000000  00000000  003a584c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001c0 <__do_global_dtors_aux>:
 80001c0:	b510      	push	{r4, lr}
 80001c2:	4c05      	ldr	r4, [pc, #20]	; (80001d8 <__do_global_dtors_aux+0x18>)
 80001c4:	7823      	ldrb	r3, [r4, #0]
 80001c6:	b933      	cbnz	r3, 80001d6 <__do_global_dtors_aux+0x16>
 80001c8:	4b04      	ldr	r3, [pc, #16]	; (80001dc <__do_global_dtors_aux+0x1c>)
 80001ca:	b113      	cbz	r3, 80001d2 <__do_global_dtors_aux+0x12>
 80001cc:	4804      	ldr	r0, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x20>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	2301      	movs	r3, #1
 80001d4:	7023      	strb	r3, [r4, #0]
 80001d6:	bd10      	pop	{r4, pc}
 80001d8:	20000318 	.word	0x20000318
 80001dc:	00000000 	.word	0x00000000
 80001e0:	0801a034 	.word	0x0801a034

080001e4 <frame_dummy>:
 80001e4:	b508      	push	{r3, lr}
 80001e6:	4b03      	ldr	r3, [pc, #12]	; (80001f4 <frame_dummy+0x10>)
 80001e8:	b11b      	cbz	r3, 80001f2 <frame_dummy+0xe>
 80001ea:	4903      	ldr	r1, [pc, #12]	; (80001f8 <frame_dummy+0x14>)
 80001ec:	4803      	ldr	r0, [pc, #12]	; (80001fc <frame_dummy+0x18>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	bd08      	pop	{r3, pc}
 80001f4:	00000000 	.word	0x00000000
 80001f8:	2000031c 	.word	0x2000031c
 80001fc:	0801a034 	.word	0x0801a034

08000200 <strcmp>:
 8000200:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000204:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000208:	2a01      	cmp	r2, #1
 800020a:	bf28      	it	cs
 800020c:	429a      	cmpcs	r2, r3
 800020e:	d0f7      	beq.n	8000200 <strcmp>
 8000210:	1ad0      	subs	r0, r2, r3
 8000212:	4770      	bx	lr

08000214 <strlen>:
 8000214:	4603      	mov	r3, r0
 8000216:	f813 2b01 	ldrb.w	r2, [r3], #1
 800021a:	2a00      	cmp	r2, #0
 800021c:	d1fb      	bne.n	8000216 <strlen+0x2>
 800021e:	1a18      	subs	r0, r3, r0
 8000220:	3801      	subs	r0, #1
 8000222:	4770      	bx	lr
	...

08000230 <memchr>:
 8000230:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000234:	2a10      	cmp	r2, #16
 8000236:	db2b      	blt.n	8000290 <memchr+0x60>
 8000238:	f010 0f07 	tst.w	r0, #7
 800023c:	d008      	beq.n	8000250 <memchr+0x20>
 800023e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000242:	3a01      	subs	r2, #1
 8000244:	428b      	cmp	r3, r1
 8000246:	d02d      	beq.n	80002a4 <memchr+0x74>
 8000248:	f010 0f07 	tst.w	r0, #7
 800024c:	b342      	cbz	r2, 80002a0 <memchr+0x70>
 800024e:	d1f6      	bne.n	800023e <memchr+0xe>
 8000250:	b4f0      	push	{r4, r5, r6, r7}
 8000252:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000256:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800025a:	f022 0407 	bic.w	r4, r2, #7
 800025e:	f07f 0700 	mvns.w	r7, #0
 8000262:	2300      	movs	r3, #0
 8000264:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000268:	3c08      	subs	r4, #8
 800026a:	ea85 0501 	eor.w	r5, r5, r1
 800026e:	ea86 0601 	eor.w	r6, r6, r1
 8000272:	fa85 f547 	uadd8	r5, r5, r7
 8000276:	faa3 f587 	sel	r5, r3, r7
 800027a:	fa86 f647 	uadd8	r6, r6, r7
 800027e:	faa5 f687 	sel	r6, r5, r7
 8000282:	b98e      	cbnz	r6, 80002a8 <memchr+0x78>
 8000284:	d1ee      	bne.n	8000264 <memchr+0x34>
 8000286:	bcf0      	pop	{r4, r5, r6, r7}
 8000288:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800028c:	f002 0207 	and.w	r2, r2, #7
 8000290:	b132      	cbz	r2, 80002a0 <memchr+0x70>
 8000292:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000296:	3a01      	subs	r2, #1
 8000298:	ea83 0301 	eor.w	r3, r3, r1
 800029c:	b113      	cbz	r3, 80002a4 <memchr+0x74>
 800029e:	d1f8      	bne.n	8000292 <memchr+0x62>
 80002a0:	2000      	movs	r0, #0
 80002a2:	4770      	bx	lr
 80002a4:	3801      	subs	r0, #1
 80002a6:	4770      	bx	lr
 80002a8:	2d00      	cmp	r5, #0
 80002aa:	bf06      	itte	eq
 80002ac:	4635      	moveq	r5, r6
 80002ae:	3803      	subeq	r0, #3
 80002b0:	3807      	subne	r0, #7
 80002b2:	f015 0f01 	tst.w	r5, #1
 80002b6:	d107      	bne.n	80002c8 <memchr+0x98>
 80002b8:	3001      	adds	r0, #1
 80002ba:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002be:	bf02      	ittt	eq
 80002c0:	3001      	addeq	r0, #1
 80002c2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002c6:	3001      	addeq	r0, #1
 80002c8:	bcf0      	pop	{r4, r5, r6, r7}
 80002ca:	3801      	subs	r0, #1
 80002cc:	4770      	bx	lr
 80002ce:	bf00      	nop

080002d0 <__aeabi_drsub>:
 80002d0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002d4:	e002      	b.n	80002dc <__adddf3>
 80002d6:	bf00      	nop

080002d8 <__aeabi_dsub>:
 80002d8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002dc <__adddf3>:
 80002dc:	b530      	push	{r4, r5, lr}
 80002de:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002e2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002e6:	ea94 0f05 	teq	r4, r5
 80002ea:	bf08      	it	eq
 80002ec:	ea90 0f02 	teqeq	r0, r2
 80002f0:	bf1f      	itttt	ne
 80002f2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002f6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002fa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002fe:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000302:	f000 80e2 	beq.w	80004ca <__adddf3+0x1ee>
 8000306:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800030a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800030e:	bfb8      	it	lt
 8000310:	426d      	neglt	r5, r5
 8000312:	dd0c      	ble.n	800032e <__adddf3+0x52>
 8000314:	442c      	add	r4, r5
 8000316:	ea80 0202 	eor.w	r2, r0, r2
 800031a:	ea81 0303 	eor.w	r3, r1, r3
 800031e:	ea82 0000 	eor.w	r0, r2, r0
 8000322:	ea83 0101 	eor.w	r1, r3, r1
 8000326:	ea80 0202 	eor.w	r2, r0, r2
 800032a:	ea81 0303 	eor.w	r3, r1, r3
 800032e:	2d36      	cmp	r5, #54	; 0x36
 8000330:	bf88      	it	hi
 8000332:	bd30      	pophi	{r4, r5, pc}
 8000334:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000338:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800033c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000340:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000344:	d002      	beq.n	800034c <__adddf3+0x70>
 8000346:	4240      	negs	r0, r0
 8000348:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800034c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000350:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000354:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000358:	d002      	beq.n	8000360 <__adddf3+0x84>
 800035a:	4252      	negs	r2, r2
 800035c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000360:	ea94 0f05 	teq	r4, r5
 8000364:	f000 80a7 	beq.w	80004b6 <__adddf3+0x1da>
 8000368:	f1a4 0401 	sub.w	r4, r4, #1
 800036c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000370:	db0d      	blt.n	800038e <__adddf3+0xb2>
 8000372:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000376:	fa22 f205 	lsr.w	r2, r2, r5
 800037a:	1880      	adds	r0, r0, r2
 800037c:	f141 0100 	adc.w	r1, r1, #0
 8000380:	fa03 f20e 	lsl.w	r2, r3, lr
 8000384:	1880      	adds	r0, r0, r2
 8000386:	fa43 f305 	asr.w	r3, r3, r5
 800038a:	4159      	adcs	r1, r3
 800038c:	e00e      	b.n	80003ac <__adddf3+0xd0>
 800038e:	f1a5 0520 	sub.w	r5, r5, #32
 8000392:	f10e 0e20 	add.w	lr, lr, #32
 8000396:	2a01      	cmp	r2, #1
 8000398:	fa03 fc0e 	lsl.w	ip, r3, lr
 800039c:	bf28      	it	cs
 800039e:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003a2:	fa43 f305 	asr.w	r3, r3, r5
 80003a6:	18c0      	adds	r0, r0, r3
 80003a8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003b0:	d507      	bpl.n	80003c2 <__adddf3+0xe6>
 80003b2:	f04f 0e00 	mov.w	lr, #0
 80003b6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003ba:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003be:	eb6e 0101 	sbc.w	r1, lr, r1
 80003c2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003c6:	d31b      	bcc.n	8000400 <__adddf3+0x124>
 80003c8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003cc:	d30c      	bcc.n	80003e8 <__adddf3+0x10c>
 80003ce:	0849      	lsrs	r1, r1, #1
 80003d0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003d4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003d8:	f104 0401 	add.w	r4, r4, #1
 80003dc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003e0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003e4:	f080 809a 	bcs.w	800051c <__adddf3+0x240>
 80003e8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003ec:	bf08      	it	eq
 80003ee:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003f2:	f150 0000 	adcs.w	r0, r0, #0
 80003f6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003fa:	ea41 0105 	orr.w	r1, r1, r5
 80003fe:	bd30      	pop	{r4, r5, pc}
 8000400:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000404:	4140      	adcs	r0, r0
 8000406:	eb41 0101 	adc.w	r1, r1, r1
 800040a:	3c01      	subs	r4, #1
 800040c:	bf28      	it	cs
 800040e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000412:	d2e9      	bcs.n	80003e8 <__adddf3+0x10c>
 8000414:	f091 0f00 	teq	r1, #0
 8000418:	bf04      	itt	eq
 800041a:	4601      	moveq	r1, r0
 800041c:	2000      	moveq	r0, #0
 800041e:	fab1 f381 	clz	r3, r1
 8000422:	bf08      	it	eq
 8000424:	3320      	addeq	r3, #32
 8000426:	f1a3 030b 	sub.w	r3, r3, #11
 800042a:	f1b3 0220 	subs.w	r2, r3, #32
 800042e:	da0c      	bge.n	800044a <__adddf3+0x16e>
 8000430:	320c      	adds	r2, #12
 8000432:	dd08      	ble.n	8000446 <__adddf3+0x16a>
 8000434:	f102 0c14 	add.w	ip, r2, #20
 8000438:	f1c2 020c 	rsb	r2, r2, #12
 800043c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000440:	fa21 f102 	lsr.w	r1, r1, r2
 8000444:	e00c      	b.n	8000460 <__adddf3+0x184>
 8000446:	f102 0214 	add.w	r2, r2, #20
 800044a:	bfd8      	it	le
 800044c:	f1c2 0c20 	rsble	ip, r2, #32
 8000450:	fa01 f102 	lsl.w	r1, r1, r2
 8000454:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000458:	bfdc      	itt	le
 800045a:	ea41 010c 	orrle.w	r1, r1, ip
 800045e:	4090      	lslle	r0, r2
 8000460:	1ae4      	subs	r4, r4, r3
 8000462:	bfa2      	ittt	ge
 8000464:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000468:	4329      	orrge	r1, r5
 800046a:	bd30      	popge	{r4, r5, pc}
 800046c:	ea6f 0404 	mvn.w	r4, r4
 8000470:	3c1f      	subs	r4, #31
 8000472:	da1c      	bge.n	80004ae <__adddf3+0x1d2>
 8000474:	340c      	adds	r4, #12
 8000476:	dc0e      	bgt.n	8000496 <__adddf3+0x1ba>
 8000478:	f104 0414 	add.w	r4, r4, #20
 800047c:	f1c4 0220 	rsb	r2, r4, #32
 8000480:	fa20 f004 	lsr.w	r0, r0, r4
 8000484:	fa01 f302 	lsl.w	r3, r1, r2
 8000488:	ea40 0003 	orr.w	r0, r0, r3
 800048c:	fa21 f304 	lsr.w	r3, r1, r4
 8000490:	ea45 0103 	orr.w	r1, r5, r3
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f1c4 040c 	rsb	r4, r4, #12
 800049a:	f1c4 0220 	rsb	r2, r4, #32
 800049e:	fa20 f002 	lsr.w	r0, r0, r2
 80004a2:	fa01 f304 	lsl.w	r3, r1, r4
 80004a6:	ea40 0003 	orr.w	r0, r0, r3
 80004aa:	4629      	mov	r1, r5
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	fa21 f004 	lsr.w	r0, r1, r4
 80004b2:	4629      	mov	r1, r5
 80004b4:	bd30      	pop	{r4, r5, pc}
 80004b6:	f094 0f00 	teq	r4, #0
 80004ba:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004be:	bf06      	itte	eq
 80004c0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004c4:	3401      	addeq	r4, #1
 80004c6:	3d01      	subne	r5, #1
 80004c8:	e74e      	b.n	8000368 <__adddf3+0x8c>
 80004ca:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ce:	bf18      	it	ne
 80004d0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004d4:	d029      	beq.n	800052a <__adddf3+0x24e>
 80004d6:	ea94 0f05 	teq	r4, r5
 80004da:	bf08      	it	eq
 80004dc:	ea90 0f02 	teqeq	r0, r2
 80004e0:	d005      	beq.n	80004ee <__adddf3+0x212>
 80004e2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004e6:	bf04      	itt	eq
 80004e8:	4619      	moveq	r1, r3
 80004ea:	4610      	moveq	r0, r2
 80004ec:	bd30      	pop	{r4, r5, pc}
 80004ee:	ea91 0f03 	teq	r1, r3
 80004f2:	bf1e      	ittt	ne
 80004f4:	2100      	movne	r1, #0
 80004f6:	2000      	movne	r0, #0
 80004f8:	bd30      	popne	{r4, r5, pc}
 80004fa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004fe:	d105      	bne.n	800050c <__adddf3+0x230>
 8000500:	0040      	lsls	r0, r0, #1
 8000502:	4149      	adcs	r1, r1
 8000504:	bf28      	it	cs
 8000506:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800050a:	bd30      	pop	{r4, r5, pc}
 800050c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000510:	bf3c      	itt	cc
 8000512:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000516:	bd30      	popcc	{r4, r5, pc}
 8000518:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800051c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000520:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000524:	f04f 0000 	mov.w	r0, #0
 8000528:	bd30      	pop	{r4, r5, pc}
 800052a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800052e:	bf1a      	itte	ne
 8000530:	4619      	movne	r1, r3
 8000532:	4610      	movne	r0, r2
 8000534:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000538:	bf1c      	itt	ne
 800053a:	460b      	movne	r3, r1
 800053c:	4602      	movne	r2, r0
 800053e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000542:	bf06      	itte	eq
 8000544:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000548:	ea91 0f03 	teqeq	r1, r3
 800054c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000550:	bd30      	pop	{r4, r5, pc}
 8000552:	bf00      	nop

08000554 <__aeabi_ui2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f04f 0500 	mov.w	r5, #0
 800056c:	f04f 0100 	mov.w	r1, #0
 8000570:	e750      	b.n	8000414 <__adddf3+0x138>
 8000572:	bf00      	nop

08000574 <__aeabi_i2d>:
 8000574:	f090 0f00 	teq	r0, #0
 8000578:	bf04      	itt	eq
 800057a:	2100      	moveq	r1, #0
 800057c:	4770      	bxeq	lr
 800057e:	b530      	push	{r4, r5, lr}
 8000580:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000584:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000588:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800058c:	bf48      	it	mi
 800058e:	4240      	negmi	r0, r0
 8000590:	f04f 0100 	mov.w	r1, #0
 8000594:	e73e      	b.n	8000414 <__adddf3+0x138>
 8000596:	bf00      	nop

08000598 <__aeabi_f2d>:
 8000598:	0042      	lsls	r2, r0, #1
 800059a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800059e:	ea4f 0131 	mov.w	r1, r1, rrx
 80005a2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005a6:	bf1f      	itttt	ne
 80005a8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005ac:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005b0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005b4:	4770      	bxne	lr
 80005b6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005ba:	bf08      	it	eq
 80005bc:	4770      	bxeq	lr
 80005be:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005c2:	bf04      	itt	eq
 80005c4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005c8:	4770      	bxeq	lr
 80005ca:	b530      	push	{r4, r5, lr}
 80005cc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005d0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005d4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005d8:	e71c      	b.n	8000414 <__adddf3+0x138>
 80005da:	bf00      	nop

080005dc <__aeabi_ul2d>:
 80005dc:	ea50 0201 	orrs.w	r2, r0, r1
 80005e0:	bf08      	it	eq
 80005e2:	4770      	bxeq	lr
 80005e4:	b530      	push	{r4, r5, lr}
 80005e6:	f04f 0500 	mov.w	r5, #0
 80005ea:	e00a      	b.n	8000602 <__aeabi_l2d+0x16>

080005ec <__aeabi_l2d>:
 80005ec:	ea50 0201 	orrs.w	r2, r0, r1
 80005f0:	bf08      	it	eq
 80005f2:	4770      	bxeq	lr
 80005f4:	b530      	push	{r4, r5, lr}
 80005f6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005fa:	d502      	bpl.n	8000602 <__aeabi_l2d+0x16>
 80005fc:	4240      	negs	r0, r0
 80005fe:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000602:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000606:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800060a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800060e:	f43f aed8 	beq.w	80003c2 <__adddf3+0xe6>
 8000612:	f04f 0203 	mov.w	r2, #3
 8000616:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800061a:	bf18      	it	ne
 800061c:	3203      	addne	r2, #3
 800061e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000622:	bf18      	it	ne
 8000624:	3203      	addne	r2, #3
 8000626:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800062a:	f1c2 0320 	rsb	r3, r2, #32
 800062e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000632:	fa20 f002 	lsr.w	r0, r0, r2
 8000636:	fa01 fe03 	lsl.w	lr, r1, r3
 800063a:	ea40 000e 	orr.w	r0, r0, lr
 800063e:	fa21 f102 	lsr.w	r1, r1, r2
 8000642:	4414      	add	r4, r2
 8000644:	e6bd      	b.n	80003c2 <__adddf3+0xe6>
 8000646:	bf00      	nop

08000648 <__aeabi_dmul>:
 8000648:	b570      	push	{r4, r5, r6, lr}
 800064a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800064e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000652:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000656:	bf1d      	ittte	ne
 8000658:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800065c:	ea94 0f0c 	teqne	r4, ip
 8000660:	ea95 0f0c 	teqne	r5, ip
 8000664:	f000 f8de 	bleq	8000824 <__aeabi_dmul+0x1dc>
 8000668:	442c      	add	r4, r5
 800066a:	ea81 0603 	eor.w	r6, r1, r3
 800066e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000672:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000676:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800067a:	bf18      	it	ne
 800067c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000680:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000684:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000688:	d038      	beq.n	80006fc <__aeabi_dmul+0xb4>
 800068a:	fba0 ce02 	umull	ip, lr, r0, r2
 800068e:	f04f 0500 	mov.w	r5, #0
 8000692:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000696:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800069a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800069e:	f04f 0600 	mov.w	r6, #0
 80006a2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006a6:	f09c 0f00 	teq	ip, #0
 80006aa:	bf18      	it	ne
 80006ac:	f04e 0e01 	orrne.w	lr, lr, #1
 80006b0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006b4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006b8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006bc:	d204      	bcs.n	80006c8 <__aeabi_dmul+0x80>
 80006be:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006c2:	416d      	adcs	r5, r5
 80006c4:	eb46 0606 	adc.w	r6, r6, r6
 80006c8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006cc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006d0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006d4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006d8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006dc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006e0:	bf88      	it	hi
 80006e2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006e6:	d81e      	bhi.n	8000726 <__aeabi_dmul+0xde>
 80006e8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006ec:	bf08      	it	eq
 80006ee:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006f2:	f150 0000 	adcs.w	r0, r0, #0
 80006f6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006fa:	bd70      	pop	{r4, r5, r6, pc}
 80006fc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000700:	ea46 0101 	orr.w	r1, r6, r1
 8000704:	ea40 0002 	orr.w	r0, r0, r2
 8000708:	ea81 0103 	eor.w	r1, r1, r3
 800070c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000710:	bfc2      	ittt	gt
 8000712:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000716:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800071a:	bd70      	popgt	{r4, r5, r6, pc}
 800071c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000720:	f04f 0e00 	mov.w	lr, #0
 8000724:	3c01      	subs	r4, #1
 8000726:	f300 80ab 	bgt.w	8000880 <__aeabi_dmul+0x238>
 800072a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800072e:	bfde      	ittt	le
 8000730:	2000      	movle	r0, #0
 8000732:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000736:	bd70      	pople	{r4, r5, r6, pc}
 8000738:	f1c4 0400 	rsb	r4, r4, #0
 800073c:	3c20      	subs	r4, #32
 800073e:	da35      	bge.n	80007ac <__aeabi_dmul+0x164>
 8000740:	340c      	adds	r4, #12
 8000742:	dc1b      	bgt.n	800077c <__aeabi_dmul+0x134>
 8000744:	f104 0414 	add.w	r4, r4, #20
 8000748:	f1c4 0520 	rsb	r5, r4, #32
 800074c:	fa00 f305 	lsl.w	r3, r0, r5
 8000750:	fa20 f004 	lsr.w	r0, r0, r4
 8000754:	fa01 f205 	lsl.w	r2, r1, r5
 8000758:	ea40 0002 	orr.w	r0, r0, r2
 800075c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000760:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000764:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000768:	fa21 f604 	lsr.w	r6, r1, r4
 800076c:	eb42 0106 	adc.w	r1, r2, r6
 8000770:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000774:	bf08      	it	eq
 8000776:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800077a:	bd70      	pop	{r4, r5, r6, pc}
 800077c:	f1c4 040c 	rsb	r4, r4, #12
 8000780:	f1c4 0520 	rsb	r5, r4, #32
 8000784:	fa00 f304 	lsl.w	r3, r0, r4
 8000788:	fa20 f005 	lsr.w	r0, r0, r5
 800078c:	fa01 f204 	lsl.w	r2, r1, r4
 8000790:	ea40 0002 	orr.w	r0, r0, r2
 8000794:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000798:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800079c:	f141 0100 	adc.w	r1, r1, #0
 80007a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007a4:	bf08      	it	eq
 80007a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007aa:	bd70      	pop	{r4, r5, r6, pc}
 80007ac:	f1c4 0520 	rsb	r5, r4, #32
 80007b0:	fa00 f205 	lsl.w	r2, r0, r5
 80007b4:	ea4e 0e02 	orr.w	lr, lr, r2
 80007b8:	fa20 f304 	lsr.w	r3, r0, r4
 80007bc:	fa01 f205 	lsl.w	r2, r1, r5
 80007c0:	ea43 0302 	orr.w	r3, r3, r2
 80007c4:	fa21 f004 	lsr.w	r0, r1, r4
 80007c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007cc:	fa21 f204 	lsr.w	r2, r1, r4
 80007d0:	ea20 0002 	bic.w	r0, r0, r2
 80007d4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007d8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007dc:	bf08      	it	eq
 80007de:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007e2:	bd70      	pop	{r4, r5, r6, pc}
 80007e4:	f094 0f00 	teq	r4, #0
 80007e8:	d10f      	bne.n	800080a <__aeabi_dmul+0x1c2>
 80007ea:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007ee:	0040      	lsls	r0, r0, #1
 80007f0:	eb41 0101 	adc.w	r1, r1, r1
 80007f4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007f8:	bf08      	it	eq
 80007fa:	3c01      	subeq	r4, #1
 80007fc:	d0f7      	beq.n	80007ee <__aeabi_dmul+0x1a6>
 80007fe:	ea41 0106 	orr.w	r1, r1, r6
 8000802:	f095 0f00 	teq	r5, #0
 8000806:	bf18      	it	ne
 8000808:	4770      	bxne	lr
 800080a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800080e:	0052      	lsls	r2, r2, #1
 8000810:	eb43 0303 	adc.w	r3, r3, r3
 8000814:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000818:	bf08      	it	eq
 800081a:	3d01      	subeq	r5, #1
 800081c:	d0f7      	beq.n	800080e <__aeabi_dmul+0x1c6>
 800081e:	ea43 0306 	orr.w	r3, r3, r6
 8000822:	4770      	bx	lr
 8000824:	ea94 0f0c 	teq	r4, ip
 8000828:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800082c:	bf18      	it	ne
 800082e:	ea95 0f0c 	teqne	r5, ip
 8000832:	d00c      	beq.n	800084e <__aeabi_dmul+0x206>
 8000834:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000838:	bf18      	it	ne
 800083a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800083e:	d1d1      	bne.n	80007e4 <__aeabi_dmul+0x19c>
 8000840:	ea81 0103 	eor.w	r1, r1, r3
 8000844:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000848:	f04f 0000 	mov.w	r0, #0
 800084c:	bd70      	pop	{r4, r5, r6, pc}
 800084e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000852:	bf06      	itte	eq
 8000854:	4610      	moveq	r0, r2
 8000856:	4619      	moveq	r1, r3
 8000858:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800085c:	d019      	beq.n	8000892 <__aeabi_dmul+0x24a>
 800085e:	ea94 0f0c 	teq	r4, ip
 8000862:	d102      	bne.n	800086a <__aeabi_dmul+0x222>
 8000864:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000868:	d113      	bne.n	8000892 <__aeabi_dmul+0x24a>
 800086a:	ea95 0f0c 	teq	r5, ip
 800086e:	d105      	bne.n	800087c <__aeabi_dmul+0x234>
 8000870:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000874:	bf1c      	itt	ne
 8000876:	4610      	movne	r0, r2
 8000878:	4619      	movne	r1, r3
 800087a:	d10a      	bne.n	8000892 <__aeabi_dmul+0x24a>
 800087c:	ea81 0103 	eor.w	r1, r1, r3
 8000880:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000884:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000888:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800088c:	f04f 0000 	mov.w	r0, #0
 8000890:	bd70      	pop	{r4, r5, r6, pc}
 8000892:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000896:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800089a:	bd70      	pop	{r4, r5, r6, pc}

0800089c <__aeabi_ddiv>:
 800089c:	b570      	push	{r4, r5, r6, lr}
 800089e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008a2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008a6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008aa:	bf1d      	ittte	ne
 80008ac:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008b0:	ea94 0f0c 	teqne	r4, ip
 80008b4:	ea95 0f0c 	teqne	r5, ip
 80008b8:	f000 f8a7 	bleq	8000a0a <__aeabi_ddiv+0x16e>
 80008bc:	eba4 0405 	sub.w	r4, r4, r5
 80008c0:	ea81 0e03 	eor.w	lr, r1, r3
 80008c4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008cc:	f000 8088 	beq.w	80009e0 <__aeabi_ddiv+0x144>
 80008d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008d4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008d8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008dc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008e0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008e4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008e8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008ec:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008f0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008f4:	429d      	cmp	r5, r3
 80008f6:	bf08      	it	eq
 80008f8:	4296      	cmpeq	r6, r2
 80008fa:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008fe:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000902:	d202      	bcs.n	800090a <__aeabi_ddiv+0x6e>
 8000904:	085b      	lsrs	r3, r3, #1
 8000906:	ea4f 0232 	mov.w	r2, r2, rrx
 800090a:	1ab6      	subs	r6, r6, r2
 800090c:	eb65 0503 	sbc.w	r5, r5, r3
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800091a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800091e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000922:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000926:	bf22      	ittt	cs
 8000928:	1ab6      	subcs	r6, r6, r2
 800092a:	4675      	movcs	r5, lr
 800092c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000930:	085b      	lsrs	r3, r3, #1
 8000932:	ea4f 0232 	mov.w	r2, r2, rrx
 8000936:	ebb6 0e02 	subs.w	lr, r6, r2
 800093a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800093e:	bf22      	ittt	cs
 8000940:	1ab6      	subcs	r6, r6, r2
 8000942:	4675      	movcs	r5, lr
 8000944:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000948:	085b      	lsrs	r3, r3, #1
 800094a:	ea4f 0232 	mov.w	r2, r2, rrx
 800094e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000952:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000956:	bf22      	ittt	cs
 8000958:	1ab6      	subcs	r6, r6, r2
 800095a:	4675      	movcs	r5, lr
 800095c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000960:	085b      	lsrs	r3, r3, #1
 8000962:	ea4f 0232 	mov.w	r2, r2, rrx
 8000966:	ebb6 0e02 	subs.w	lr, r6, r2
 800096a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800096e:	bf22      	ittt	cs
 8000970:	1ab6      	subcs	r6, r6, r2
 8000972:	4675      	movcs	r5, lr
 8000974:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000978:	ea55 0e06 	orrs.w	lr, r5, r6
 800097c:	d018      	beq.n	80009b0 <__aeabi_ddiv+0x114>
 800097e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000982:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000986:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800098a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800098e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000992:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000996:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800099a:	d1c0      	bne.n	800091e <__aeabi_ddiv+0x82>
 800099c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009a0:	d10b      	bne.n	80009ba <__aeabi_ddiv+0x11e>
 80009a2:	ea41 0100 	orr.w	r1, r1, r0
 80009a6:	f04f 0000 	mov.w	r0, #0
 80009aa:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009ae:	e7b6      	b.n	800091e <__aeabi_ddiv+0x82>
 80009b0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009b4:	bf04      	itt	eq
 80009b6:	4301      	orreq	r1, r0
 80009b8:	2000      	moveq	r0, #0
 80009ba:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009be:	bf88      	it	hi
 80009c0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009c4:	f63f aeaf 	bhi.w	8000726 <__aeabi_dmul+0xde>
 80009c8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009cc:	bf04      	itt	eq
 80009ce:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009d2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009d6:	f150 0000 	adcs.w	r0, r0, #0
 80009da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009de:	bd70      	pop	{r4, r5, r6, pc}
 80009e0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009e4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009e8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009ec:	bfc2      	ittt	gt
 80009ee:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009f2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009f6:	bd70      	popgt	{r4, r5, r6, pc}
 80009f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009fc:	f04f 0e00 	mov.w	lr, #0
 8000a00:	3c01      	subs	r4, #1
 8000a02:	e690      	b.n	8000726 <__aeabi_dmul+0xde>
 8000a04:	ea45 0e06 	orr.w	lr, r5, r6
 8000a08:	e68d      	b.n	8000726 <__aeabi_dmul+0xde>
 8000a0a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a0e:	ea94 0f0c 	teq	r4, ip
 8000a12:	bf08      	it	eq
 8000a14:	ea95 0f0c 	teqeq	r5, ip
 8000a18:	f43f af3b 	beq.w	8000892 <__aeabi_dmul+0x24a>
 8000a1c:	ea94 0f0c 	teq	r4, ip
 8000a20:	d10a      	bne.n	8000a38 <__aeabi_ddiv+0x19c>
 8000a22:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a26:	f47f af34 	bne.w	8000892 <__aeabi_dmul+0x24a>
 8000a2a:	ea95 0f0c 	teq	r5, ip
 8000a2e:	f47f af25 	bne.w	800087c <__aeabi_dmul+0x234>
 8000a32:	4610      	mov	r0, r2
 8000a34:	4619      	mov	r1, r3
 8000a36:	e72c      	b.n	8000892 <__aeabi_dmul+0x24a>
 8000a38:	ea95 0f0c 	teq	r5, ip
 8000a3c:	d106      	bne.n	8000a4c <__aeabi_ddiv+0x1b0>
 8000a3e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a42:	f43f aefd 	beq.w	8000840 <__aeabi_dmul+0x1f8>
 8000a46:	4610      	mov	r0, r2
 8000a48:	4619      	mov	r1, r3
 8000a4a:	e722      	b.n	8000892 <__aeabi_dmul+0x24a>
 8000a4c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a50:	bf18      	it	ne
 8000a52:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a56:	f47f aec5 	bne.w	80007e4 <__aeabi_dmul+0x19c>
 8000a5a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a5e:	f47f af0d 	bne.w	800087c <__aeabi_dmul+0x234>
 8000a62:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a66:	f47f aeeb 	bne.w	8000840 <__aeabi_dmul+0x1f8>
 8000a6a:	e712      	b.n	8000892 <__aeabi_dmul+0x24a>

08000a6c <__gedf2>:
 8000a6c:	f04f 3cff 	mov.w	ip, #4294967295
 8000a70:	e006      	b.n	8000a80 <__cmpdf2+0x4>
 8000a72:	bf00      	nop

08000a74 <__ledf2>:
 8000a74:	f04f 0c01 	mov.w	ip, #1
 8000a78:	e002      	b.n	8000a80 <__cmpdf2+0x4>
 8000a7a:	bf00      	nop

08000a7c <__cmpdf2>:
 8000a7c:	f04f 0c01 	mov.w	ip, #1
 8000a80:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a84:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a88:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a8c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a90:	bf18      	it	ne
 8000a92:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a96:	d01b      	beq.n	8000ad0 <__cmpdf2+0x54>
 8000a98:	b001      	add	sp, #4
 8000a9a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a9e:	bf0c      	ite	eq
 8000aa0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000aa4:	ea91 0f03 	teqne	r1, r3
 8000aa8:	bf02      	ittt	eq
 8000aaa:	ea90 0f02 	teqeq	r0, r2
 8000aae:	2000      	moveq	r0, #0
 8000ab0:	4770      	bxeq	lr
 8000ab2:	f110 0f00 	cmn.w	r0, #0
 8000ab6:	ea91 0f03 	teq	r1, r3
 8000aba:	bf58      	it	pl
 8000abc:	4299      	cmppl	r1, r3
 8000abe:	bf08      	it	eq
 8000ac0:	4290      	cmpeq	r0, r2
 8000ac2:	bf2c      	ite	cs
 8000ac4:	17d8      	asrcs	r0, r3, #31
 8000ac6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000aca:	f040 0001 	orr.w	r0, r0, #1
 8000ace:	4770      	bx	lr
 8000ad0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000ad4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ad8:	d102      	bne.n	8000ae0 <__cmpdf2+0x64>
 8000ada:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000ade:	d107      	bne.n	8000af0 <__cmpdf2+0x74>
 8000ae0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ae4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ae8:	d1d6      	bne.n	8000a98 <__cmpdf2+0x1c>
 8000aea:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000aee:	d0d3      	beq.n	8000a98 <__cmpdf2+0x1c>
 8000af0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000af4:	4770      	bx	lr
 8000af6:	bf00      	nop

08000af8 <__aeabi_cdrcmple>:
 8000af8:	4684      	mov	ip, r0
 8000afa:	4610      	mov	r0, r2
 8000afc:	4662      	mov	r2, ip
 8000afe:	468c      	mov	ip, r1
 8000b00:	4619      	mov	r1, r3
 8000b02:	4663      	mov	r3, ip
 8000b04:	e000      	b.n	8000b08 <__aeabi_cdcmpeq>
 8000b06:	bf00      	nop

08000b08 <__aeabi_cdcmpeq>:
 8000b08:	b501      	push	{r0, lr}
 8000b0a:	f7ff ffb7 	bl	8000a7c <__cmpdf2>
 8000b0e:	2800      	cmp	r0, #0
 8000b10:	bf48      	it	mi
 8000b12:	f110 0f00 	cmnmi.w	r0, #0
 8000b16:	bd01      	pop	{r0, pc}

08000b18 <__aeabi_dcmpeq>:
 8000b18:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b1c:	f7ff fff4 	bl	8000b08 <__aeabi_cdcmpeq>
 8000b20:	bf0c      	ite	eq
 8000b22:	2001      	moveq	r0, #1
 8000b24:	2000      	movne	r0, #0
 8000b26:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b2a:	bf00      	nop

08000b2c <__aeabi_dcmplt>:
 8000b2c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b30:	f7ff ffea 	bl	8000b08 <__aeabi_cdcmpeq>
 8000b34:	bf34      	ite	cc
 8000b36:	2001      	movcc	r0, #1
 8000b38:	2000      	movcs	r0, #0
 8000b3a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b3e:	bf00      	nop

08000b40 <__aeabi_dcmple>:
 8000b40:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b44:	f7ff ffe0 	bl	8000b08 <__aeabi_cdcmpeq>
 8000b48:	bf94      	ite	ls
 8000b4a:	2001      	movls	r0, #1
 8000b4c:	2000      	movhi	r0, #0
 8000b4e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b52:	bf00      	nop

08000b54 <__aeabi_dcmpge>:
 8000b54:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b58:	f7ff ffce 	bl	8000af8 <__aeabi_cdrcmple>
 8000b5c:	bf94      	ite	ls
 8000b5e:	2001      	movls	r0, #1
 8000b60:	2000      	movhi	r0, #0
 8000b62:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b66:	bf00      	nop

08000b68 <__aeabi_dcmpgt>:
 8000b68:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b6c:	f7ff ffc4 	bl	8000af8 <__aeabi_cdrcmple>
 8000b70:	bf34      	ite	cc
 8000b72:	2001      	movcc	r0, #1
 8000b74:	2000      	movcs	r0, #0
 8000b76:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b7a:	bf00      	nop

08000b7c <__aeabi_dcmpun>:
 8000b7c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b80:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b84:	d102      	bne.n	8000b8c <__aeabi_dcmpun+0x10>
 8000b86:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b8a:	d10a      	bne.n	8000ba2 <__aeabi_dcmpun+0x26>
 8000b8c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b90:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b94:	d102      	bne.n	8000b9c <__aeabi_dcmpun+0x20>
 8000b96:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b9a:	d102      	bne.n	8000ba2 <__aeabi_dcmpun+0x26>
 8000b9c:	f04f 0000 	mov.w	r0, #0
 8000ba0:	4770      	bx	lr
 8000ba2:	f04f 0001 	mov.w	r0, #1
 8000ba6:	4770      	bx	lr

08000ba8 <__aeabi_d2iz>:
 8000ba8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000bac:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000bb0:	d215      	bcs.n	8000bde <__aeabi_d2iz+0x36>
 8000bb2:	d511      	bpl.n	8000bd8 <__aeabi_d2iz+0x30>
 8000bb4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000bb8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000bbc:	d912      	bls.n	8000be4 <__aeabi_d2iz+0x3c>
 8000bbe:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bc2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000bc6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000bca:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000bce:	fa23 f002 	lsr.w	r0, r3, r2
 8000bd2:	bf18      	it	ne
 8000bd4:	4240      	negne	r0, r0
 8000bd6:	4770      	bx	lr
 8000bd8:	f04f 0000 	mov.w	r0, #0
 8000bdc:	4770      	bx	lr
 8000bde:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000be2:	d105      	bne.n	8000bf0 <__aeabi_d2iz+0x48>
 8000be4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000be8:	bf08      	it	eq
 8000bea:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000bee:	4770      	bx	lr
 8000bf0:	f04f 0000 	mov.w	r0, #0
 8000bf4:	4770      	bx	lr
 8000bf6:	bf00      	nop

08000bf8 <__aeabi_d2uiz>:
 8000bf8:	004a      	lsls	r2, r1, #1
 8000bfa:	d211      	bcs.n	8000c20 <__aeabi_d2uiz+0x28>
 8000bfc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000c00:	d211      	bcs.n	8000c26 <__aeabi_d2uiz+0x2e>
 8000c02:	d50d      	bpl.n	8000c20 <__aeabi_d2uiz+0x28>
 8000c04:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000c08:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000c0c:	d40e      	bmi.n	8000c2c <__aeabi_d2uiz+0x34>
 8000c0e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c12:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000c16:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000c1a:	fa23 f002 	lsr.w	r0, r3, r2
 8000c1e:	4770      	bx	lr
 8000c20:	f04f 0000 	mov.w	r0, #0
 8000c24:	4770      	bx	lr
 8000c26:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000c2a:	d102      	bne.n	8000c32 <__aeabi_d2uiz+0x3a>
 8000c2c:	f04f 30ff 	mov.w	r0, #4294967295
 8000c30:	4770      	bx	lr
 8000c32:	f04f 0000 	mov.w	r0, #0
 8000c36:	4770      	bx	lr

08000c38 <__aeabi_d2f>:
 8000c38:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000c3c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000c40:	bf24      	itt	cs
 8000c42:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000c46:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000c4a:	d90d      	bls.n	8000c68 <__aeabi_d2f+0x30>
 8000c4c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000c50:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c54:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c58:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000c5c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000c60:	bf08      	it	eq
 8000c62:	f020 0001 	biceq.w	r0, r0, #1
 8000c66:	4770      	bx	lr
 8000c68:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000c6c:	d121      	bne.n	8000cb2 <__aeabi_d2f+0x7a>
 8000c6e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000c72:	bfbc      	itt	lt
 8000c74:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000c78:	4770      	bxlt	lr
 8000c7a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000c7e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c82:	f1c2 0218 	rsb	r2, r2, #24
 8000c86:	f1c2 0c20 	rsb	ip, r2, #32
 8000c8a:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c8e:	fa20 f002 	lsr.w	r0, r0, r2
 8000c92:	bf18      	it	ne
 8000c94:	f040 0001 	orrne.w	r0, r0, #1
 8000c98:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c9c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ca0:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000ca4:	ea40 000c 	orr.w	r0, r0, ip
 8000ca8:	fa23 f302 	lsr.w	r3, r3, r2
 8000cac:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000cb0:	e7cc      	b.n	8000c4c <__aeabi_d2f+0x14>
 8000cb2:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000cb6:	d107      	bne.n	8000cc8 <__aeabi_d2f+0x90>
 8000cb8:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000cbc:	bf1e      	ittt	ne
 8000cbe:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000cc2:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000cc6:	4770      	bxne	lr
 8000cc8:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000ccc:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000cd0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000cd4:	4770      	bx	lr
 8000cd6:	bf00      	nop

08000cd8 <__aeabi_uldivmod>:
 8000cd8:	b953      	cbnz	r3, 8000cf0 <__aeabi_uldivmod+0x18>
 8000cda:	b94a      	cbnz	r2, 8000cf0 <__aeabi_uldivmod+0x18>
 8000cdc:	2900      	cmp	r1, #0
 8000cde:	bf08      	it	eq
 8000ce0:	2800      	cmpeq	r0, #0
 8000ce2:	bf1c      	itt	ne
 8000ce4:	f04f 31ff 	movne.w	r1, #4294967295
 8000ce8:	f04f 30ff 	movne.w	r0, #4294967295
 8000cec:	f000 b9a4 	b.w	8001038 <__aeabi_idiv0>
 8000cf0:	f1ad 0c08 	sub.w	ip, sp, #8
 8000cf4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000cf8:	f000 f83c 	bl	8000d74 <__udivmoddi4>
 8000cfc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000d00:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000d04:	b004      	add	sp, #16
 8000d06:	4770      	bx	lr

08000d08 <__aeabi_d2lz>:
 8000d08:	b538      	push	{r3, r4, r5, lr}
 8000d0a:	2200      	movs	r2, #0
 8000d0c:	2300      	movs	r3, #0
 8000d0e:	4604      	mov	r4, r0
 8000d10:	460d      	mov	r5, r1
 8000d12:	f7ff ff0b 	bl	8000b2c <__aeabi_dcmplt>
 8000d16:	b928      	cbnz	r0, 8000d24 <__aeabi_d2lz+0x1c>
 8000d18:	4620      	mov	r0, r4
 8000d1a:	4629      	mov	r1, r5
 8000d1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000d20:	f000 b80a 	b.w	8000d38 <__aeabi_d2ulz>
 8000d24:	4620      	mov	r0, r4
 8000d26:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 8000d2a:	f000 f805 	bl	8000d38 <__aeabi_d2ulz>
 8000d2e:	4240      	negs	r0, r0
 8000d30:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000d34:	bd38      	pop	{r3, r4, r5, pc}
 8000d36:	bf00      	nop

08000d38 <__aeabi_d2ulz>:
 8000d38:	b5d0      	push	{r4, r6, r7, lr}
 8000d3a:	4b0c      	ldr	r3, [pc, #48]	; (8000d6c <__aeabi_d2ulz+0x34>)
 8000d3c:	2200      	movs	r2, #0
 8000d3e:	4606      	mov	r6, r0
 8000d40:	460f      	mov	r7, r1
 8000d42:	f7ff fc81 	bl	8000648 <__aeabi_dmul>
 8000d46:	f7ff ff57 	bl	8000bf8 <__aeabi_d2uiz>
 8000d4a:	4604      	mov	r4, r0
 8000d4c:	f7ff fc02 	bl	8000554 <__aeabi_ui2d>
 8000d50:	4b07      	ldr	r3, [pc, #28]	; (8000d70 <__aeabi_d2ulz+0x38>)
 8000d52:	2200      	movs	r2, #0
 8000d54:	f7ff fc78 	bl	8000648 <__aeabi_dmul>
 8000d58:	4602      	mov	r2, r0
 8000d5a:	460b      	mov	r3, r1
 8000d5c:	4630      	mov	r0, r6
 8000d5e:	4639      	mov	r1, r7
 8000d60:	f7ff faba 	bl	80002d8 <__aeabi_dsub>
 8000d64:	f7ff ff48 	bl	8000bf8 <__aeabi_d2uiz>
 8000d68:	4621      	mov	r1, r4
 8000d6a:	bdd0      	pop	{r4, r6, r7, pc}
 8000d6c:	3df00000 	.word	0x3df00000
 8000d70:	41f00000 	.word	0x41f00000

08000d74 <__udivmoddi4>:
 8000d74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000d78:	9d08      	ldr	r5, [sp, #32]
 8000d7a:	4604      	mov	r4, r0
 8000d7c:	468c      	mov	ip, r1
 8000d7e:	2b00      	cmp	r3, #0
 8000d80:	f040 8083 	bne.w	8000e8a <__udivmoddi4+0x116>
 8000d84:	428a      	cmp	r2, r1
 8000d86:	4617      	mov	r7, r2
 8000d88:	d947      	bls.n	8000e1a <__udivmoddi4+0xa6>
 8000d8a:	fab2 f282 	clz	r2, r2
 8000d8e:	b142      	cbz	r2, 8000da2 <__udivmoddi4+0x2e>
 8000d90:	f1c2 0020 	rsb	r0, r2, #32
 8000d94:	fa24 f000 	lsr.w	r0, r4, r0
 8000d98:	4091      	lsls	r1, r2
 8000d9a:	4097      	lsls	r7, r2
 8000d9c:	ea40 0c01 	orr.w	ip, r0, r1
 8000da0:	4094      	lsls	r4, r2
 8000da2:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000da6:	0c23      	lsrs	r3, r4, #16
 8000da8:	fbbc f6f8 	udiv	r6, ip, r8
 8000dac:	fa1f fe87 	uxth.w	lr, r7
 8000db0:	fb08 c116 	mls	r1, r8, r6, ip
 8000db4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000db8:	fb06 f10e 	mul.w	r1, r6, lr
 8000dbc:	4299      	cmp	r1, r3
 8000dbe:	d909      	bls.n	8000dd4 <__udivmoddi4+0x60>
 8000dc0:	18fb      	adds	r3, r7, r3
 8000dc2:	f106 30ff 	add.w	r0, r6, #4294967295
 8000dc6:	f080 8119 	bcs.w	8000ffc <__udivmoddi4+0x288>
 8000dca:	4299      	cmp	r1, r3
 8000dcc:	f240 8116 	bls.w	8000ffc <__udivmoddi4+0x288>
 8000dd0:	3e02      	subs	r6, #2
 8000dd2:	443b      	add	r3, r7
 8000dd4:	1a5b      	subs	r3, r3, r1
 8000dd6:	b2a4      	uxth	r4, r4
 8000dd8:	fbb3 f0f8 	udiv	r0, r3, r8
 8000ddc:	fb08 3310 	mls	r3, r8, r0, r3
 8000de0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000de4:	fb00 fe0e 	mul.w	lr, r0, lr
 8000de8:	45a6      	cmp	lr, r4
 8000dea:	d909      	bls.n	8000e00 <__udivmoddi4+0x8c>
 8000dec:	193c      	adds	r4, r7, r4
 8000dee:	f100 33ff 	add.w	r3, r0, #4294967295
 8000df2:	f080 8105 	bcs.w	8001000 <__udivmoddi4+0x28c>
 8000df6:	45a6      	cmp	lr, r4
 8000df8:	f240 8102 	bls.w	8001000 <__udivmoddi4+0x28c>
 8000dfc:	3802      	subs	r0, #2
 8000dfe:	443c      	add	r4, r7
 8000e00:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000e04:	eba4 040e 	sub.w	r4, r4, lr
 8000e08:	2600      	movs	r6, #0
 8000e0a:	b11d      	cbz	r5, 8000e14 <__udivmoddi4+0xa0>
 8000e0c:	40d4      	lsrs	r4, r2
 8000e0e:	2300      	movs	r3, #0
 8000e10:	e9c5 4300 	strd	r4, r3, [r5]
 8000e14:	4631      	mov	r1, r6
 8000e16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000e1a:	b902      	cbnz	r2, 8000e1e <__udivmoddi4+0xaa>
 8000e1c:	deff      	udf	#255	; 0xff
 8000e1e:	fab2 f282 	clz	r2, r2
 8000e22:	2a00      	cmp	r2, #0
 8000e24:	d150      	bne.n	8000ec8 <__udivmoddi4+0x154>
 8000e26:	1bcb      	subs	r3, r1, r7
 8000e28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000e2c:	fa1f f887 	uxth.w	r8, r7
 8000e30:	2601      	movs	r6, #1
 8000e32:	fbb3 fcfe 	udiv	ip, r3, lr
 8000e36:	0c21      	lsrs	r1, r4, #16
 8000e38:	fb0e 331c 	mls	r3, lr, ip, r3
 8000e3c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000e40:	fb08 f30c 	mul.w	r3, r8, ip
 8000e44:	428b      	cmp	r3, r1
 8000e46:	d907      	bls.n	8000e58 <__udivmoddi4+0xe4>
 8000e48:	1879      	adds	r1, r7, r1
 8000e4a:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000e4e:	d202      	bcs.n	8000e56 <__udivmoddi4+0xe2>
 8000e50:	428b      	cmp	r3, r1
 8000e52:	f200 80e9 	bhi.w	8001028 <__udivmoddi4+0x2b4>
 8000e56:	4684      	mov	ip, r0
 8000e58:	1ac9      	subs	r1, r1, r3
 8000e5a:	b2a3      	uxth	r3, r4
 8000e5c:	fbb1 f0fe 	udiv	r0, r1, lr
 8000e60:	fb0e 1110 	mls	r1, lr, r0, r1
 8000e64:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 8000e68:	fb08 f800 	mul.w	r8, r8, r0
 8000e6c:	45a0      	cmp	r8, r4
 8000e6e:	d907      	bls.n	8000e80 <__udivmoddi4+0x10c>
 8000e70:	193c      	adds	r4, r7, r4
 8000e72:	f100 33ff 	add.w	r3, r0, #4294967295
 8000e76:	d202      	bcs.n	8000e7e <__udivmoddi4+0x10a>
 8000e78:	45a0      	cmp	r8, r4
 8000e7a:	f200 80d9 	bhi.w	8001030 <__udivmoddi4+0x2bc>
 8000e7e:	4618      	mov	r0, r3
 8000e80:	eba4 0408 	sub.w	r4, r4, r8
 8000e84:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000e88:	e7bf      	b.n	8000e0a <__udivmoddi4+0x96>
 8000e8a:	428b      	cmp	r3, r1
 8000e8c:	d909      	bls.n	8000ea2 <__udivmoddi4+0x12e>
 8000e8e:	2d00      	cmp	r5, #0
 8000e90:	f000 80b1 	beq.w	8000ff6 <__udivmoddi4+0x282>
 8000e94:	2600      	movs	r6, #0
 8000e96:	e9c5 0100 	strd	r0, r1, [r5]
 8000e9a:	4630      	mov	r0, r6
 8000e9c:	4631      	mov	r1, r6
 8000e9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000ea2:	fab3 f683 	clz	r6, r3
 8000ea6:	2e00      	cmp	r6, #0
 8000ea8:	d14a      	bne.n	8000f40 <__udivmoddi4+0x1cc>
 8000eaa:	428b      	cmp	r3, r1
 8000eac:	d302      	bcc.n	8000eb4 <__udivmoddi4+0x140>
 8000eae:	4282      	cmp	r2, r0
 8000eb0:	f200 80b8 	bhi.w	8001024 <__udivmoddi4+0x2b0>
 8000eb4:	1a84      	subs	r4, r0, r2
 8000eb6:	eb61 0103 	sbc.w	r1, r1, r3
 8000eba:	2001      	movs	r0, #1
 8000ebc:	468c      	mov	ip, r1
 8000ebe:	2d00      	cmp	r5, #0
 8000ec0:	d0a8      	beq.n	8000e14 <__udivmoddi4+0xa0>
 8000ec2:	e9c5 4c00 	strd	r4, ip, [r5]
 8000ec6:	e7a5      	b.n	8000e14 <__udivmoddi4+0xa0>
 8000ec8:	f1c2 0320 	rsb	r3, r2, #32
 8000ecc:	fa20 f603 	lsr.w	r6, r0, r3
 8000ed0:	4097      	lsls	r7, r2
 8000ed2:	fa01 f002 	lsl.w	r0, r1, r2
 8000ed6:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000eda:	40d9      	lsrs	r1, r3
 8000edc:	4330      	orrs	r0, r6
 8000ede:	0c03      	lsrs	r3, r0, #16
 8000ee0:	fbb1 f6fe 	udiv	r6, r1, lr
 8000ee4:	fa1f f887 	uxth.w	r8, r7
 8000ee8:	fb0e 1116 	mls	r1, lr, r6, r1
 8000eec:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000ef0:	fb06 f108 	mul.w	r1, r6, r8
 8000ef4:	4299      	cmp	r1, r3
 8000ef6:	fa04 f402 	lsl.w	r4, r4, r2
 8000efa:	d909      	bls.n	8000f10 <__udivmoddi4+0x19c>
 8000efc:	18fb      	adds	r3, r7, r3
 8000efe:	f106 3cff 	add.w	ip, r6, #4294967295
 8000f02:	f080 808d 	bcs.w	8001020 <__udivmoddi4+0x2ac>
 8000f06:	4299      	cmp	r1, r3
 8000f08:	f240 808a 	bls.w	8001020 <__udivmoddi4+0x2ac>
 8000f0c:	3e02      	subs	r6, #2
 8000f0e:	443b      	add	r3, r7
 8000f10:	1a5b      	subs	r3, r3, r1
 8000f12:	b281      	uxth	r1, r0
 8000f14:	fbb3 f0fe 	udiv	r0, r3, lr
 8000f18:	fb0e 3310 	mls	r3, lr, r0, r3
 8000f1c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000f20:	fb00 f308 	mul.w	r3, r0, r8
 8000f24:	428b      	cmp	r3, r1
 8000f26:	d907      	bls.n	8000f38 <__udivmoddi4+0x1c4>
 8000f28:	1879      	adds	r1, r7, r1
 8000f2a:	f100 3cff 	add.w	ip, r0, #4294967295
 8000f2e:	d273      	bcs.n	8001018 <__udivmoddi4+0x2a4>
 8000f30:	428b      	cmp	r3, r1
 8000f32:	d971      	bls.n	8001018 <__udivmoddi4+0x2a4>
 8000f34:	3802      	subs	r0, #2
 8000f36:	4439      	add	r1, r7
 8000f38:	1acb      	subs	r3, r1, r3
 8000f3a:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8000f3e:	e778      	b.n	8000e32 <__udivmoddi4+0xbe>
 8000f40:	f1c6 0c20 	rsb	ip, r6, #32
 8000f44:	fa03 f406 	lsl.w	r4, r3, r6
 8000f48:	fa22 f30c 	lsr.w	r3, r2, ip
 8000f4c:	431c      	orrs	r4, r3
 8000f4e:	fa20 f70c 	lsr.w	r7, r0, ip
 8000f52:	fa01 f306 	lsl.w	r3, r1, r6
 8000f56:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 8000f5a:	fa21 f10c 	lsr.w	r1, r1, ip
 8000f5e:	431f      	orrs	r7, r3
 8000f60:	0c3b      	lsrs	r3, r7, #16
 8000f62:	fbb1 f9fe 	udiv	r9, r1, lr
 8000f66:	fa1f f884 	uxth.w	r8, r4
 8000f6a:	fb0e 1119 	mls	r1, lr, r9, r1
 8000f6e:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8000f72:	fb09 fa08 	mul.w	sl, r9, r8
 8000f76:	458a      	cmp	sl, r1
 8000f78:	fa02 f206 	lsl.w	r2, r2, r6
 8000f7c:	fa00 f306 	lsl.w	r3, r0, r6
 8000f80:	d908      	bls.n	8000f94 <__udivmoddi4+0x220>
 8000f82:	1861      	adds	r1, r4, r1
 8000f84:	f109 30ff 	add.w	r0, r9, #4294967295
 8000f88:	d248      	bcs.n	800101c <__udivmoddi4+0x2a8>
 8000f8a:	458a      	cmp	sl, r1
 8000f8c:	d946      	bls.n	800101c <__udivmoddi4+0x2a8>
 8000f8e:	f1a9 0902 	sub.w	r9, r9, #2
 8000f92:	4421      	add	r1, r4
 8000f94:	eba1 010a 	sub.w	r1, r1, sl
 8000f98:	b2bf      	uxth	r7, r7
 8000f9a:	fbb1 f0fe 	udiv	r0, r1, lr
 8000f9e:	fb0e 1110 	mls	r1, lr, r0, r1
 8000fa2:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8000fa6:	fb00 f808 	mul.w	r8, r0, r8
 8000faa:	45b8      	cmp	r8, r7
 8000fac:	d907      	bls.n	8000fbe <__udivmoddi4+0x24a>
 8000fae:	19e7      	adds	r7, r4, r7
 8000fb0:	f100 31ff 	add.w	r1, r0, #4294967295
 8000fb4:	d22e      	bcs.n	8001014 <__udivmoddi4+0x2a0>
 8000fb6:	45b8      	cmp	r8, r7
 8000fb8:	d92c      	bls.n	8001014 <__udivmoddi4+0x2a0>
 8000fba:	3802      	subs	r0, #2
 8000fbc:	4427      	add	r7, r4
 8000fbe:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000fc2:	eba7 0708 	sub.w	r7, r7, r8
 8000fc6:	fba0 8902 	umull	r8, r9, r0, r2
 8000fca:	454f      	cmp	r7, r9
 8000fcc:	46c6      	mov	lr, r8
 8000fce:	4649      	mov	r1, r9
 8000fd0:	d31a      	bcc.n	8001008 <__udivmoddi4+0x294>
 8000fd2:	d017      	beq.n	8001004 <__udivmoddi4+0x290>
 8000fd4:	b15d      	cbz	r5, 8000fee <__udivmoddi4+0x27a>
 8000fd6:	ebb3 020e 	subs.w	r2, r3, lr
 8000fda:	eb67 0701 	sbc.w	r7, r7, r1
 8000fde:	fa07 fc0c 	lsl.w	ip, r7, ip
 8000fe2:	40f2      	lsrs	r2, r6
 8000fe4:	ea4c 0202 	orr.w	r2, ip, r2
 8000fe8:	40f7      	lsrs	r7, r6
 8000fea:	e9c5 2700 	strd	r2, r7, [r5]
 8000fee:	2600      	movs	r6, #0
 8000ff0:	4631      	mov	r1, r6
 8000ff2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000ff6:	462e      	mov	r6, r5
 8000ff8:	4628      	mov	r0, r5
 8000ffa:	e70b      	b.n	8000e14 <__udivmoddi4+0xa0>
 8000ffc:	4606      	mov	r6, r0
 8000ffe:	e6e9      	b.n	8000dd4 <__udivmoddi4+0x60>
 8001000:	4618      	mov	r0, r3
 8001002:	e6fd      	b.n	8000e00 <__udivmoddi4+0x8c>
 8001004:	4543      	cmp	r3, r8
 8001006:	d2e5      	bcs.n	8000fd4 <__udivmoddi4+0x260>
 8001008:	ebb8 0e02 	subs.w	lr, r8, r2
 800100c:	eb69 0104 	sbc.w	r1, r9, r4
 8001010:	3801      	subs	r0, #1
 8001012:	e7df      	b.n	8000fd4 <__udivmoddi4+0x260>
 8001014:	4608      	mov	r0, r1
 8001016:	e7d2      	b.n	8000fbe <__udivmoddi4+0x24a>
 8001018:	4660      	mov	r0, ip
 800101a:	e78d      	b.n	8000f38 <__udivmoddi4+0x1c4>
 800101c:	4681      	mov	r9, r0
 800101e:	e7b9      	b.n	8000f94 <__udivmoddi4+0x220>
 8001020:	4666      	mov	r6, ip
 8001022:	e775      	b.n	8000f10 <__udivmoddi4+0x19c>
 8001024:	4630      	mov	r0, r6
 8001026:	e74a      	b.n	8000ebe <__udivmoddi4+0x14a>
 8001028:	f1ac 0c02 	sub.w	ip, ip, #2
 800102c:	4439      	add	r1, r7
 800102e:	e713      	b.n	8000e58 <__udivmoddi4+0xe4>
 8001030:	3802      	subs	r0, #2
 8001032:	443c      	add	r4, r7
 8001034:	e724      	b.n	8000e80 <__udivmoddi4+0x10c>
 8001036:	bf00      	nop

08001038 <__aeabi_idiv0>:
 8001038:	4770      	bx	lr
 800103a:	bf00      	nop

0800103c <create_JSON_SubSensorDescriptor>:
  json_object_dotset_number(JSON_SensorStatus, "comChannelNumber", sensor_status->comChannelNumber);
}


static void create_JSON_SubSensorDescriptor(COM_SubSensorDescriptor_t *sub_sensor_descriptor, JSON_Value *tempJSON)
{
 800103c:	b570      	push	{r4, r5, r6, lr}
 800103e:	460d      	mov	r5, r1
 8001040:	4604      	mov	r4, r0
  uint32_t ii = 0;
  
  JSON_Value *tempJSONarray = json_value_init_object();
 8001042:	f014 f8bb 	bl	80151bc <json_value_init_object>
 8001046:	4606      	mov	r6, r0
  JSON_Array *JSON_SensorArray = json_value_get_array(tempJSONarray);
 8001048:	f013 fd58 	bl	8014afc <json_value_get_array>
  JSON_Object *JSON_SubSensorDescriptor= json_value_get_object(tempJSON);
 800104c:	4628      	mov	r0, r5
 800104e:	f013 fd4d 	bl	8014aec <json_value_get_object>
 8001052:	4605      	mov	r5, r0
  
  json_object_dotset_number(JSON_SubSensorDescriptor, "id", sub_sensor_descriptor->id);
 8001054:	7820      	ldrb	r0, [r4, #0]
 8001056:	f7ff fa7d 	bl	8000554 <__aeabi_ui2d>
 800105a:	ec41 0b10 	vmov	d0, r0, r1
 800105e:	493a      	ldr	r1, [pc, #232]	; (8001148 <create_JSON_SubSensorDescriptor+0x10c>)
 8001060:	4628      	mov	r0, r5
 8001062:	f014 fbfb 	bl	801585c <json_object_dotset_number>
  
  switch (sub_sensor_descriptor->sensorType)
 8001066:	7863      	ldrb	r3, [r4, #1]
 8001068:	3b01      	subs	r3, #1
 800106a:	2b06      	cmp	r3, #6
 800106c:	d865      	bhi.n	800113a <create_JSON_SubSensorDescriptor+0xfe>
 800106e:	e8df f003 	tbb	[pc, r3]
 8001072:	4640      	.short	0x4640
 8001074:	5e58524c 	.word	0x5e58524c
 8001078:	04          	.byte	0x04
 8001079:	00          	.byte	0x00
    break;
  case COM_TYPE_HUM:
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "HUM");
    break;
  case COM_TYPE_MIC:
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "MIC");
 800107a:	4a34      	ldr	r2, [pc, #208]	; (800114c <create_JSON_SubSensorDescriptor+0x110>)
 800107c:	4934      	ldr	r1, [pc, #208]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 800107e:	4628      	mov	r0, r5
 8001080:	f014 fbd0 	bl	8015824 <json_object_dotset_string>
  default:
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "NA");
    break;      
  }
  
  json_object_dotset_number(JSON_SubSensorDescriptor, "dataPerSample", sub_sensor_descriptor->dataPerSample);
 8001084:	78a0      	ldrb	r0, [r4, #2]
 8001086:	f7ff fa65 	bl	8000554 <__aeabi_ui2d>
 800108a:	ec41 0b10 	vmov	d0, r0, r1
 800108e:	4931      	ldr	r1, [pc, #196]	; (8001154 <create_JSON_SubSensorDescriptor+0x118>)
 8001090:	4628      	mov	r0, r5
 8001092:	f014 fbe3 	bl	801585c <json_object_dotset_number>
  json_object_dotset_string(JSON_SubSensorDescriptor, "unit", sub_sensor_descriptor->unit);  
 8001096:	4930      	ldr	r1, [pc, #192]	; (8001158 <create_JSON_SubSensorDescriptor+0x11c>)
 8001098:	1ce2      	adds	r2, r4, #3
 800109a:	4628      	mov	r0, r5
 800109c:	f014 fbc2 	bl	8015824 <json_object_dotset_string>
  json_object_dotset_value(JSON_SubSensorDescriptor, "fs.values", json_value_init_array());
 80010a0:	f014 f8ac 	bl	80151fc <json_value_init_array>
 80010a4:	492d      	ldr	r1, [pc, #180]	; (800115c <create_JSON_SubSensorDescriptor+0x120>)
 80010a6:	4602      	mov	r2, r0
 80010a8:	4628      	mov	r0, r5
 80010aa:	f014 faf5 	bl	8015698 <json_object_dotset_value>
  JSON_SensorArray = json_object_dotget_array(JSON_SubSensorDescriptor, "fs.values");
 80010ae:	4628      	mov	r0, r5
 80010b0:	492a      	ldr	r1, [pc, #168]	; (800115c <create_JSON_SubSensorDescriptor+0x120>)
 80010b2:	f013 fce9 	bl	8014a88 <json_object_dotget_array>
  
  while (sub_sensor_descriptor->FS[ii] > 0)
 80010b6:	edd4 7a05 	vldr	s15, [r4, #20]
 80010ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80010be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  JSON_SensorArray = json_object_dotget_array(JSON_SubSensorDescriptor, "fs.values");
 80010c2:	4605      	mov	r5, r0
  while (sub_sensor_descriptor->FS[ii] > 0)
 80010c4:	dd10      	ble.n	80010e8 <create_JSON_SubSensorDescriptor+0xac>
 80010c6:	3418      	adds	r4, #24
  {
    json_array_append_number(JSON_SensorArray, sub_sensor_descriptor->FS[ii]);
 80010c8:	ee17 0a90 	vmov	r0, s15
 80010cc:	f7ff fa64 	bl	8000598 <__aeabi_f2d>
 80010d0:	ec41 0b10 	vmov	d0, r0, r1
 80010d4:	4628      	mov	r0, r5
 80010d6:	f014 fa13 	bl	8015500 <json_array_append_number>
  while (sub_sensor_descriptor->FS[ii] > 0)
 80010da:	ecf4 7a01 	vldmia	r4!, {s15}
 80010de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80010e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80010e6:	dcef      	bgt.n	80010c8 <create_JSON_SubSensorDescriptor+0x8c>
    ii++;
  }  
  json_value_free(tempJSONarray);
 80010e8:	4630      	mov	r0, r6
}
 80010ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  json_value_free(tempJSONarray);
 80010ee:	f013 bd0d 	b.w	8014b0c <json_value_free>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "ACC");
 80010f2:	4a1b      	ldr	r2, [pc, #108]	; (8001160 <create_JSON_SubSensorDescriptor+0x124>)
 80010f4:	4916      	ldr	r1, [pc, #88]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 80010f6:	4628      	mov	r0, r5
 80010f8:	f014 fb94 	bl	8015824 <json_object_dotset_string>
    break;
 80010fc:	e7c2      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "MAG");
 80010fe:	4a19      	ldr	r2, [pc, #100]	; (8001164 <create_JSON_SubSensorDescriptor+0x128>)
 8001100:	4913      	ldr	r1, [pc, #76]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 8001102:	4628      	mov	r0, r5
 8001104:	f014 fb8e 	bl	8015824 <json_object_dotset_string>
    break;
 8001108:	e7bc      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "GYRO");
 800110a:	4a17      	ldr	r2, [pc, #92]	; (8001168 <create_JSON_SubSensorDescriptor+0x12c>)
 800110c:	4910      	ldr	r1, [pc, #64]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 800110e:	4628      	mov	r0, r5
 8001110:	f014 fb88 	bl	8015824 <json_object_dotset_string>
    break;
 8001114:	e7b6      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "TEMP");
 8001116:	4a15      	ldr	r2, [pc, #84]	; (800116c <create_JSON_SubSensorDescriptor+0x130>)
 8001118:	490d      	ldr	r1, [pc, #52]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 800111a:	4628      	mov	r0, r5
 800111c:	f014 fb82 	bl	8015824 <json_object_dotset_string>
    break;
 8001120:	e7b0      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "PRESS");
 8001122:	4a13      	ldr	r2, [pc, #76]	; (8001170 <create_JSON_SubSensorDescriptor+0x134>)
 8001124:	490a      	ldr	r1, [pc, #40]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 8001126:	4628      	mov	r0, r5
 8001128:	f014 fb7c 	bl	8015824 <json_object_dotset_string>
    break;
 800112c:	e7aa      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "HUM");
 800112e:	4a11      	ldr	r2, [pc, #68]	; (8001174 <create_JSON_SubSensorDescriptor+0x138>)
 8001130:	4907      	ldr	r1, [pc, #28]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 8001132:	4628      	mov	r0, r5
 8001134:	f014 fb76 	bl	8015824 <json_object_dotset_string>
    break;
 8001138:	e7a4      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
    json_object_dotset_string(JSON_SubSensorDescriptor, "sensorType", "NA");
 800113a:	4a0f      	ldr	r2, [pc, #60]	; (8001178 <create_JSON_SubSensorDescriptor+0x13c>)
 800113c:	4904      	ldr	r1, [pc, #16]	; (8001150 <create_JSON_SubSensorDescriptor+0x114>)
 800113e:	4628      	mov	r0, r5
 8001140:	f014 fb70 	bl	8015824 <json_object_dotset_string>
    break;      
 8001144:	e79e      	b.n	8001084 <create_JSON_SubSensorDescriptor+0x48>
 8001146:	bf00      	nop
 8001148:	0801aaa0 	.word	0x0801aaa0
 800114c:	0801a624 	.word	0x0801a624
 8001150:	0801a5f8 	.word	0x0801a5f8
 8001154:	0801a62c 	.word	0x0801a62c
 8001158:	0801a63c 	.word	0x0801a63c
 800115c:	0801a644 	.word	0x0801a644
 8001160:	0801a5f4 	.word	0x0801a5f4
 8001164:	0801a604 	.word	0x0801a604
 8001168:	0801a608 	.word	0x0801a608
 800116c:	0801a610 	.word	0x0801a610
 8001170:	0801a618 	.word	0x0801a618
 8001174:	0801a620 	.word	0x0801a620
 8001178:	0801a628 	.word	0x0801a628

0800117c <create_JSON_SensorDescriptor>:
{
 800117c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800117e:	4606      	mov	r6, r0
 8001180:	b083      	sub	sp, #12
  JSON_Object *JSON_SensorDescriptor = json_value_get_object(tempJSON);
 8001182:	4608      	mov	r0, r1
 8001184:	f013 fcb2 	bl	8014aec <json_value_get_object>
  json_object_dotset_string(JSON_SensorDescriptor, "name", sensor_descriptor->name);  
 8001188:	4950      	ldr	r1, [pc, #320]	; (80012cc <create_JSON_SensorDescriptor+0x150>)
 800118a:	1c72      	adds	r2, r6, #1
  JSON_Object *JSON_SensorDescriptor = json_value_get_object(tempJSON);
 800118c:	4607      	mov	r7, r0
  json_object_dotset_string(JSON_SensorDescriptor, "name", sensor_descriptor->name);  
 800118e:	f014 fb49 	bl	8015824 <json_object_dotset_string>
  switch (sensor_descriptor->dataType)
 8001192:	7c73      	ldrb	r3, [r6, #17]
 8001194:	2b06      	cmp	r3, #6
 8001196:	f200 8093 	bhi.w	80012c0 <create_JSON_SensorDescriptor+0x144>
 800119a:	e8df f003 	tbb	[pc, r3]
 800119e:	736d      	.short	0x736d
 80011a0:	8b857f79 	.word	0x8b857f79
 80011a4:	04          	.byte	0x04
 80011a5:	00          	.byte	0x00
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "float");
 80011a6:	4a4a      	ldr	r2, [pc, #296]	; (80012d0 <create_JSON_SensorDescriptor+0x154>)
 80011a8:	494a      	ldr	r1, [pc, #296]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 80011aa:	4638      	mov	r0, r7
 80011ac:	f014 fb3a 	bl	8015824 <json_object_dotset_string>
  json_object_dotset_number(JSON_SensorDescriptor, "samplesPerTs.min", sensor_descriptor->samplesPerTimestamp[0]);  
 80011b0:	f8b6 0054 	ldrh.w	r0, [r6, #84]	; 0x54
 80011b4:	f7ff f9ce 	bl	8000554 <__aeabi_ui2d>
 80011b8:	ec41 0b10 	vmov	d0, r0, r1
 80011bc:	4946      	ldr	r1, [pc, #280]	; (80012d8 <create_JSON_SensorDescriptor+0x15c>)
 80011be:	4638      	mov	r0, r7
 80011c0:	f014 fb4c 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SensorDescriptor, "samplesPerTs.max", sensor_descriptor->samplesPerTimestamp[1]);  
 80011c4:	f8b6 0056 	ldrh.w	r0, [r6, #86]	; 0x56
 80011c8:	f7ff f9c4 	bl	8000554 <__aeabi_ui2d>
 80011cc:	ec41 0b10 	vmov	d0, r0, r1
 80011d0:	4942      	ldr	r1, [pc, #264]	; (80012dc <create_JSON_SensorDescriptor+0x160>)
 80011d2:	4638      	mov	r0, r7
 80011d4:	f014 fb42 	bl	801585c <json_object_dotset_number>
  json_object_dotset_string(JSON_SensorDescriptor, "samplesPerTs.dataType", "int16_t");  
 80011d8:	4a41      	ldr	r2, [pc, #260]	; (80012e0 <create_JSON_SensorDescriptor+0x164>)
 80011da:	4942      	ldr	r1, [pc, #264]	; (80012e4 <create_JSON_SensorDescriptor+0x168>)
 80011dc:	4638      	mov	r0, r7
 80011de:	f014 fb21 	bl	8015824 <json_object_dotset_string>
  json_object_dotset_value(JSON_SensorDescriptor, "odr.values", json_value_init_array());
 80011e2:	f014 f80b 	bl	80151fc <json_value_init_array>
 80011e6:	4940      	ldr	r1, [pc, #256]	; (80012e8 <create_JSON_SensorDescriptor+0x16c>)
 80011e8:	4602      	mov	r2, r0
 80011ea:	4638      	mov	r0, r7
 80011ec:	f014 fa54 	bl	8015698 <json_object_dotset_value>
  JSON_Array *JSON_SensorArray = json_object_dotget_array(JSON_SensorDescriptor, "odr.values");
 80011f0:	493d      	ldr	r1, [pc, #244]	; (80012e8 <create_JSON_SensorDescriptor+0x16c>)
 80011f2:	4638      	mov	r0, r7
 80011f4:	f013 fc48 	bl	8014a88 <json_object_dotget_array>
  while (sensor_descriptor->ODR[ii] > 0)
 80011f8:	edd6 7a05 	vldr	s15, [r6, #20]
 80011fc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8001200:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  JSON_Array *JSON_SensorArray = json_object_dotget_array(JSON_SensorDescriptor, "odr.values");
 8001204:	4605      	mov	r5, r0
  while (sensor_descriptor->ODR[ii] > 0)
 8001206:	dd11      	ble.n	800122c <create_JSON_SensorDescriptor+0xb0>
 8001208:	f106 0418 	add.w	r4, r6, #24
    json_array_append_number(JSON_SensorArray, sensor_descriptor->ODR[ii]);
 800120c:	ee17 0a90 	vmov	r0, s15
 8001210:	f7ff f9c2 	bl	8000598 <__aeabi_f2d>
 8001214:	ec41 0b10 	vmov	d0, r0, r1
 8001218:	4628      	mov	r0, r5
 800121a:	f014 f971 	bl	8015500 <json_array_append_number>
  while (sensor_descriptor->ODR[ii] > 0)
 800121e:	ecf4 7a01 	vldmia	r4!, {s15}
 8001222:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8001226:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800122a:	dcef      	bgt.n	800120c <create_JSON_SensorDescriptor+0x90>
  json_object_dotset_value(JSON_SensorDescriptor, "subSensorDescriptor", json_value_init_array());  
 800122c:	f013 ffe6 	bl	80151fc <json_value_init_array>
 8001230:	492e      	ldr	r1, [pc, #184]	; (80012ec <create_JSON_SensorDescriptor+0x170>)
 8001232:	4602      	mov	r2, r0
 8001234:	4638      	mov	r0, r7
 8001236:	f014 fa2f 	bl	8015698 <json_object_dotset_value>
  JSON_SensorArray1 = json_object_dotget_array(JSON_SensorDescriptor, "subSensorDescriptor"); 
 800123a:	4638      	mov	r0, r7
 800123c:	492b      	ldr	r1, [pc, #172]	; (80012ec <create_JSON_SensorDescriptor+0x170>)
 800123e:	f013 fc23 	bl	8014a88 <json_object_dotget_array>
  for (ii = 0; ii < sensor_descriptor->nSubSensors; ii++)
 8001242:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
  JSON_SensorArray1 = json_object_dotget_array(JSON_SensorDescriptor, "subSensorDescriptor"); 
 8001246:	4607      	mov	r7, r0
  for (ii = 0; ii < sensor_descriptor->nSubSensors; ii++)
 8001248:	b1a3      	cbz	r3, 8001274 <create_JSON_SensorDescriptor+0xf8>
 800124a:	f106 055c 	add.w	r5, r6, #92	; 0x5c
 800124e:	2400      	movs	r4, #0
    tempJSON1 = json_value_init_object();  
 8001250:	f013 ffb4 	bl	80151bc <json_value_init_object>
 8001254:	4601      	mov	r1, r0
    create_JSON_SubSensorDescriptor(&sensor_descriptor->subSensorDescriptor[ii], tempJSON1);  
 8001256:	9001      	str	r0, [sp, #4]
 8001258:	4628      	mov	r0, r5
 800125a:	f7ff feef 	bl	800103c <create_JSON_SubSensorDescriptor>
    json_array_append_value(JSON_SensorArray1,tempJSON1);
 800125e:	9901      	ldr	r1, [sp, #4]
 8001260:	4638      	mov	r0, r7
 8001262:	f014 f911 	bl	8015488 <json_array_append_value>
  for (ii = 0; ii < sensor_descriptor->nSubSensors; ii++)
 8001266:	f896 3058 	ldrb.w	r3, [r6, #88]	; 0x58
 800126a:	3401      	adds	r4, #1
 800126c:	42a3      	cmp	r3, r4
 800126e:	f105 0554 	add.w	r5, r5, #84	; 0x54
 8001272:	d8ed      	bhi.n	8001250 <create_JSON_SensorDescriptor+0xd4>
}
 8001274:	b003      	add	sp, #12
 8001276:	bdf0      	pop	{r4, r5, r6, r7, pc}
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "uint8_t");
 8001278:	4a1d      	ldr	r2, [pc, #116]	; (80012f0 <create_JSON_SensorDescriptor+0x174>)
 800127a:	4916      	ldr	r1, [pc, #88]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 800127c:	4638      	mov	r0, r7
 800127e:	f014 fad1 	bl	8015824 <json_object_dotset_string>
    break;
 8001282:	e795      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "int8_t");
 8001284:	4a1b      	ldr	r2, [pc, #108]	; (80012f4 <create_JSON_SensorDescriptor+0x178>)
 8001286:	4913      	ldr	r1, [pc, #76]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 8001288:	4638      	mov	r0, r7
 800128a:	f014 facb 	bl	8015824 <json_object_dotset_string>
    break;
 800128e:	e78f      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "uint16_t");
 8001290:	4a19      	ldr	r2, [pc, #100]	; (80012f8 <create_JSON_SensorDescriptor+0x17c>)
 8001292:	4910      	ldr	r1, [pc, #64]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 8001294:	4638      	mov	r0, r7
 8001296:	f014 fac5 	bl	8015824 <json_object_dotset_string>
    break;
 800129a:	e789      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "int16_t");
 800129c:	4a10      	ldr	r2, [pc, #64]	; (80012e0 <create_JSON_SensorDescriptor+0x164>)
 800129e:	490d      	ldr	r1, [pc, #52]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 80012a0:	4638      	mov	r0, r7
 80012a2:	f014 fabf 	bl	8015824 <json_object_dotset_string>
    break;
 80012a6:	e783      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "uint32_t");
 80012a8:	4a14      	ldr	r2, [pc, #80]	; (80012fc <create_JSON_SensorDescriptor+0x180>)
 80012aa:	490a      	ldr	r1, [pc, #40]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 80012ac:	4638      	mov	r0, r7
 80012ae:	f014 fab9 	bl	8015824 <json_object_dotset_string>
    break;
 80012b2:	e77d      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "int32_t");
 80012b4:	4a12      	ldr	r2, [pc, #72]	; (8001300 <create_JSON_SensorDescriptor+0x184>)
 80012b6:	4907      	ldr	r1, [pc, #28]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 80012b8:	4638      	mov	r0, r7
 80012ba:	f014 fab3 	bl	8015824 <json_object_dotset_string>
    break;
 80012be:	e777      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
    json_object_dotset_string(JSON_SensorDescriptor, "dataType", "NA");
 80012c0:	4a10      	ldr	r2, [pc, #64]	; (8001304 <create_JSON_SensorDescriptor+0x188>)
 80012c2:	4904      	ldr	r1, [pc, #16]	; (80012d4 <create_JSON_SensorDescriptor+0x158>)
 80012c4:	4638      	mov	r0, r7
 80012c6:	f014 faad 	bl	8015824 <json_object_dotset_string>
    break;
 80012ca:	e771      	b.n	80011b0 <create_JSON_SensorDescriptor+0x34>
 80012cc:	0801a650 	.word	0x0801a650
 80012d0:	0801a69c 	.word	0x0801a69c
 80012d4:	0801a660 	.word	0x0801a660
 80012d8:	0801a6a4 	.word	0x0801a6a4
 80012dc:	0801a6b8 	.word	0x0801a6b8
 80012e0:	0801a680 	.word	0x0801a680
 80012e4:	0801a6cc 	.word	0x0801a6cc
 80012e8:	0801a6e4 	.word	0x0801a6e4
 80012ec:	0801a6f0 	.word	0x0801a6f0
 80012f0:	0801a658 	.word	0x0801a658
 80012f4:	0801a66c 	.word	0x0801a66c
 80012f8:	0801a674 	.word	0x0801a674
 80012fc:	0801a688 	.word	0x0801a688
 8001300:	0801a694 	.word	0x0801a694
 8001304:	0801a628 	.word	0x0801a628

08001308 <create_JSON_SensorStatus>:
{
 8001308:	b538      	push	{r3, r4, r5, lr}
 800130a:	4605      	mov	r5, r0
  JSON_Object *JSON_SensorStatus= json_value_get_object(tempJSON);
 800130c:	4608      	mov	r0, r1
 800130e:	f013 fbed 	bl	8014aec <json_value_get_object>
 8001312:	4604      	mov	r4, r0
  json_object_dotset_number(JSON_SensorStatus, "odr", sensor_status->ODR);
 8001314:	6828      	ldr	r0, [r5, #0]
 8001316:	f7ff f93f 	bl	8000598 <__aeabi_f2d>
 800131a:	ec41 0b10 	vmov	d0, r0, r1
 800131e:	4921      	ldr	r1, [pc, #132]	; (80013a4 <create_JSON_SensorStatus+0x9c>)
 8001320:	4620      	mov	r0, r4
 8001322:	f014 fa9b 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SensorStatus, "odrMeasured", sensor_status->measuredODR);
 8001326:	6868      	ldr	r0, [r5, #4]
 8001328:	f7ff f936 	bl	8000598 <__aeabi_f2d>
 800132c:	ec41 0b10 	vmov	d0, r0, r1
 8001330:	491d      	ldr	r1, [pc, #116]	; (80013a8 <create_JSON_SensorStatus+0xa0>)
 8001332:	4620      	mov	r0, r4
 8001334:	f014 fa92 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SensorStatus, "initialOffset", sensor_status->initialOffset);
 8001338:	68a8      	ldr	r0, [r5, #8]
 800133a:	f7ff f92d 	bl	8000598 <__aeabi_f2d>
 800133e:	ec41 0b10 	vmov	d0, r0, r1
 8001342:	491a      	ldr	r1, [pc, #104]	; (80013ac <create_JSON_SensorStatus+0xa4>)
 8001344:	4620      	mov	r0, r4
 8001346:	f014 fa89 	bl	801585c <json_object_dotset_number>
  json_object_dotset_boolean(JSON_SensorStatus, "isActive", sensor_status->isActive);
 800134a:	7baa      	ldrb	r2, [r5, #14]
 800134c:	4918      	ldr	r1, [pc, #96]	; (80013b0 <create_JSON_SensorStatus+0xa8>)
 800134e:	4620      	mov	r0, r4
 8001350:	f014 facc 	bl	80158ec <json_object_dotset_boolean>
  json_object_dotset_number(JSON_SensorStatus, "samplesPerTs", sensor_status->samplesPerTimestamp);
 8001354:	89a8      	ldrh	r0, [r5, #12]
 8001356:	f7ff f8fd 	bl	8000554 <__aeabi_ui2d>
 800135a:	ec41 0b10 	vmov	d0, r0, r1
 800135e:	4915      	ldr	r1, [pc, #84]	; (80013b4 <create_JSON_SensorStatus+0xac>)
 8001360:	4620      	mov	r0, r4
 8001362:	f014 fa7b 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SensorStatus, "usbDataPacketSize", sensor_status->usbDataPacketSize);
 8001366:	8a28      	ldrh	r0, [r5, #16]
 8001368:	f7ff f8f4 	bl	8000554 <__aeabi_ui2d>
 800136c:	ec41 0b10 	vmov	d0, r0, r1
 8001370:	4911      	ldr	r1, [pc, #68]	; (80013b8 <create_JSON_SensorStatus+0xb0>)
 8001372:	4620      	mov	r0, r4
 8001374:	f014 fa72 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SensorStatus, "sdWriteBufferSize", sensor_status->sdWriteBufferSize);
 8001378:	6968      	ldr	r0, [r5, #20]
 800137a:	f7ff f8eb 	bl	8000554 <__aeabi_ui2d>
 800137e:	ec41 0b10 	vmov	d0, r0, r1
 8001382:	490e      	ldr	r1, [pc, #56]	; (80013bc <create_JSON_SensorStatus+0xb4>)
 8001384:	4620      	mov	r0, r4
 8001386:	f014 fa69 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SensorStatus, "comChannelNumber", sensor_status->comChannelNumber);
 800138a:	f9b5 0018 	ldrsh.w	r0, [r5, #24]
 800138e:	f7ff f8f1 	bl	8000574 <__aeabi_i2d>
 8001392:	ec41 0b10 	vmov	d0, r0, r1
 8001396:	4620      	mov	r0, r4
 8001398:	4909      	ldr	r1, [pc, #36]	; (80013c0 <create_JSON_SensorStatus+0xb8>)
}
 800139a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  json_object_dotset_number(JSON_SensorStatus, "comChannelNumber", sensor_status->comChannelNumber);
 800139e:	f014 ba5d 	b.w	801585c <json_object_dotset_number>
 80013a2:	bf00      	nop
 80013a4:	0801a704 	.word	0x0801a704
 80013a8:	0801a708 	.word	0x0801a708
 80013ac:	0801a714 	.word	0x0801a714
 80013b0:	0801a724 	.word	0x0801a724
 80013b4:	0801a730 	.word	0x0801a730
 80013b8:	0801a740 	.word	0x0801a740
 80013bc:	0801a754 	.word	0x0801a754
 80013c0:	0801a768 	.word	0x0801a768

080013c4 <parse_Status_from_JSON>:
{  
 80013c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80013c8:	ed2d 8b02 	vpush	{d8}
 80013cc:	b083      	sub	sp, #12
 80013ce:	460e      	mov	r6, r1
  JSON_Value *tempJSON = json_parse_string(SerializedJSON);
 80013d0:	f013 fedc 	bl	801518c <json_parse_string>
 80013d4:	ee08 0a10 	vmov	s16, r0
  JSON_Object *JSON_ParseHandler = json_value_get_object(tempJSON);
 80013d8:	f013 fb88 	bl	8014aec <json_value_get_object>
  if (json_object_dothas_value(JSON_ParseHandler,"odr"))
 80013dc:	4989      	ldr	r1, [pc, #548]	; (8001604 <parse_Status_from_JSON+0x240>)
  JSON_Object *JSON_ParseHandler = json_value_get_object(tempJSON);
 80013de:	4604      	mov	r4, r0
  if (json_object_dothas_value(JSON_ParseHandler,"odr"))
 80013e0:	f013 fb68 	bl	8014ab4 <json_object_dothas_value>
 80013e4:	2800      	cmp	r0, #0
 80013e6:	d12d      	bne.n	8001444 <parse_Status_from_JSON+0x80>
  if (json_object_dothas_value(JSON_ParseHandler,"usbDataPacketSize"))
 80013e8:	4987      	ldr	r1, [pc, #540]	; (8001608 <parse_Status_from_JSON+0x244>)
 80013ea:	4620      	mov	r0, r4
 80013ec:	f013 fb62 	bl	8014ab4 <json_object_dothas_value>
 80013f0:	2800      	cmp	r0, #0
 80013f2:	d136      	bne.n	8001462 <parse_Status_from_JSON+0x9e>
  if (json_object_dothas_value(JSON_ParseHandler,"sdWriteBufferSize"))
 80013f4:	4985      	ldr	r1, [pc, #532]	; (800160c <parse_Status_from_JSON+0x248>)
 80013f6:	4620      	mov	r0, r4
 80013f8:	f013 fb5c 	bl	8014ab4 <json_object_dothas_value>
 80013fc:	2800      	cmp	r0, #0
 80013fe:	d13f      	bne.n	8001480 <parse_Status_from_JSON+0xbc>
  if (json_object_dothas_value(JSON_ParseHandler,"comChannelNumber"))
 8001400:	4983      	ldr	r1, [pc, #524]	; (8001610 <parse_Status_from_JSON+0x24c>)
 8001402:	4620      	mov	r0, r4
 8001404:	f013 fb56 	bl	8014ab4 <json_object_dothas_value>
 8001408:	2800      	cmp	r0, #0
 800140a:	d148      	bne.n	800149e <parse_Status_from_JSON+0xda>
  if (json_object_dothas_value(JSON_ParseHandler,"samplesPerTs"))
 800140c:	4981      	ldr	r1, [pc, #516]	; (8001614 <parse_Status_from_JSON+0x250>)
 800140e:	4620      	mov	r0, r4
 8001410:	f013 fb50 	bl	8014ab4 <json_object_dothas_value>
 8001414:	2800      	cmp	r0, #0
 8001416:	d151      	bne.n	80014bc <parse_Status_from_JSON+0xf8>
  if (json_object_dothas_value(JSON_ParseHandler,"isActive"))
 8001418:	497f      	ldr	r1, [pc, #508]	; (8001618 <parse_Status_from_JSON+0x254>)
 800141a:	4620      	mov	r0, r4
 800141c:	f013 fb4a 	bl	8014ab4 <json_object_dothas_value>
 8001420:	2800      	cmp	r0, #0
 8001422:	d15a      	bne.n	80014da <parse_Status_from_JSON+0x116>
  if (json_object_dothas_value(JSON_ParseHandler,"subSensorStatus"))
 8001424:	497d      	ldr	r1, [pc, #500]	; (800161c <parse_Status_from_JSON+0x258>)
 8001426:	4620      	mov	r0, r4
 8001428:	f013 fb44 	bl	8014ab4 <json_object_dothas_value>
 800142c:	2800      	cmp	r0, #0
 800142e:	d163      	bne.n	80014f8 <parse_Status_from_JSON+0x134>
  json_value_free(tempJSON);
 8001430:	ee18 0a10 	vmov	r0, s16
 8001434:	f013 fb6a 	bl	8014b0c <json_value_free>
}
 8001438:	2000      	movs	r0, #0
 800143a:	b003      	add	sp, #12
 800143c:	ecbd 8b02 	vpop	{d8}
 8001440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    sensorStatus->ODR = json_object_dotget_number(JSON_ParseHandler, "odr");
 8001444:	496f      	ldr	r1, [pc, #444]	; (8001604 <parse_Status_from_JSON+0x240>)
 8001446:	4620      	mov	r0, r4
 8001448:	f013 fb0a 	bl	8014a60 <json_object_dotget_number>
 800144c:	ec51 0b10 	vmov	r0, r1, d0
 8001450:	f7ff fbf2 	bl	8000c38 <__aeabi_d2f>
  if (json_object_dothas_value(JSON_ParseHandler,"usbDataPacketSize"))
 8001454:	496c      	ldr	r1, [pc, #432]	; (8001608 <parse_Status_from_JSON+0x244>)
    sensorStatus->ODR = json_object_dotget_number(JSON_ParseHandler, "odr");
 8001456:	6030      	str	r0, [r6, #0]
  if (json_object_dothas_value(JSON_ParseHandler,"usbDataPacketSize"))
 8001458:	4620      	mov	r0, r4
 800145a:	f013 fb2b 	bl	8014ab4 <json_object_dothas_value>
 800145e:	2800      	cmp	r0, #0
 8001460:	d0c8      	beq.n	80013f4 <parse_Status_from_JSON+0x30>
    sensorStatus->usbDataPacketSize = (uint16_t) json_object_dotget_number(JSON_ParseHandler, "usbDataPacketSize");
 8001462:	4969      	ldr	r1, [pc, #420]	; (8001608 <parse_Status_from_JSON+0x244>)
 8001464:	4620      	mov	r0, r4
 8001466:	f013 fafb 	bl	8014a60 <json_object_dotget_number>
 800146a:	ec51 0b10 	vmov	r0, r1, d0
 800146e:	f7ff fbc3 	bl	8000bf8 <__aeabi_d2uiz>
  if (json_object_dothas_value(JSON_ParseHandler,"sdWriteBufferSize"))
 8001472:	4966      	ldr	r1, [pc, #408]	; (800160c <parse_Status_from_JSON+0x248>)
    sensorStatus->usbDataPacketSize = (uint16_t) json_object_dotget_number(JSON_ParseHandler, "usbDataPacketSize");
 8001474:	8230      	strh	r0, [r6, #16]
  if (json_object_dothas_value(JSON_ParseHandler,"sdWriteBufferSize"))
 8001476:	4620      	mov	r0, r4
 8001478:	f013 fb1c 	bl	8014ab4 <json_object_dothas_value>
 800147c:	2800      	cmp	r0, #0
 800147e:	d0bf      	beq.n	8001400 <parse_Status_from_JSON+0x3c>
    sensorStatus->sdWriteBufferSize = (uint32_t) json_object_dotget_number(JSON_ParseHandler, "sdWriteBufferSize");
 8001480:	4962      	ldr	r1, [pc, #392]	; (800160c <parse_Status_from_JSON+0x248>)
 8001482:	4620      	mov	r0, r4
 8001484:	f013 faec 	bl	8014a60 <json_object_dotget_number>
 8001488:	ec51 0b10 	vmov	r0, r1, d0
 800148c:	f7ff fbb4 	bl	8000bf8 <__aeabi_d2uiz>
  if (json_object_dothas_value(JSON_ParseHandler,"comChannelNumber"))
 8001490:	495f      	ldr	r1, [pc, #380]	; (8001610 <parse_Status_from_JSON+0x24c>)
    sensorStatus->sdWriteBufferSize = (uint32_t) json_object_dotget_number(JSON_ParseHandler, "sdWriteBufferSize");
 8001492:	6170      	str	r0, [r6, #20]
  if (json_object_dothas_value(JSON_ParseHandler,"comChannelNumber"))
 8001494:	4620      	mov	r0, r4
 8001496:	f013 fb0d 	bl	8014ab4 <json_object_dothas_value>
 800149a:	2800      	cmp	r0, #0
 800149c:	d0b6      	beq.n	800140c <parse_Status_from_JSON+0x48>
    sensorStatus->comChannelNumber = (int16_t) json_object_dotget_number(JSON_ParseHandler, "comChannelNumber");
 800149e:	495c      	ldr	r1, [pc, #368]	; (8001610 <parse_Status_from_JSON+0x24c>)
 80014a0:	4620      	mov	r0, r4
 80014a2:	f013 fadd 	bl	8014a60 <json_object_dotget_number>
 80014a6:	ec51 0b10 	vmov	r0, r1, d0
 80014aa:	f7ff fb7d 	bl	8000ba8 <__aeabi_d2iz>
  if (json_object_dothas_value(JSON_ParseHandler,"samplesPerTs"))
 80014ae:	4959      	ldr	r1, [pc, #356]	; (8001614 <parse_Status_from_JSON+0x250>)
    sensorStatus->comChannelNumber = (int16_t) json_object_dotget_number(JSON_ParseHandler, "comChannelNumber");
 80014b0:	8330      	strh	r0, [r6, #24]
  if (json_object_dothas_value(JSON_ParseHandler,"samplesPerTs"))
 80014b2:	4620      	mov	r0, r4
 80014b4:	f013 fafe 	bl	8014ab4 <json_object_dothas_value>
 80014b8:	2800      	cmp	r0, #0
 80014ba:	d0ad      	beq.n	8001418 <parse_Status_from_JSON+0x54>
    sensorStatus->samplesPerTimestamp = (uint16_t)json_object_dotget_number(JSON_ParseHandler, "samplesPerTs");
 80014bc:	4955      	ldr	r1, [pc, #340]	; (8001614 <parse_Status_from_JSON+0x250>)
 80014be:	4620      	mov	r0, r4
 80014c0:	f013 face 	bl	8014a60 <json_object_dotget_number>
 80014c4:	ec51 0b10 	vmov	r0, r1, d0
 80014c8:	f7ff fb96 	bl	8000bf8 <__aeabi_d2uiz>
  if (json_object_dothas_value(JSON_ParseHandler,"isActive"))
 80014cc:	4952      	ldr	r1, [pc, #328]	; (8001618 <parse_Status_from_JSON+0x254>)
    sensorStatus->samplesPerTimestamp = (uint16_t)json_object_dotget_number(JSON_ParseHandler, "samplesPerTs");
 80014ce:	81b0      	strh	r0, [r6, #12]
  if (json_object_dothas_value(JSON_ParseHandler,"isActive"))
 80014d0:	4620      	mov	r0, r4
 80014d2:	f013 faef 	bl	8014ab4 <json_object_dothas_value>
 80014d6:	2800      	cmp	r0, #0
 80014d8:	d0a4      	beq.n	8001424 <parse_Status_from_JSON+0x60>
    if (json_object_dotget_boolean(JSON_ParseHandler,"isActive") == 1)
 80014da:	494f      	ldr	r1, [pc, #316]	; (8001618 <parse_Status_from_JSON+0x254>)
 80014dc:	4620      	mov	r0, r4
 80014de:	f013 fadd 	bl	8014a9c <json_object_dotget_boolean>
 80014e2:	2801      	cmp	r0, #1
      sensorStatus->isActive = 0;
 80014e4:	bf16      	itet	ne
 80014e6:	2300      	movne	r3, #0
      sensorStatus->isActive = 1;
 80014e8:	73b0      	strbeq	r0, [r6, #14]
      sensorStatus->isActive = 0;
 80014ea:	73b3      	strbne	r3, [r6, #14]
  if (json_object_dothas_value(JSON_ParseHandler,"subSensorStatus"))
 80014ec:	494b      	ldr	r1, [pc, #300]	; (800161c <parse_Status_from_JSON+0x258>)
 80014ee:	4620      	mov	r0, r4
 80014f0:	f013 fae0 	bl	8014ab4 <json_object_dothas_value>
 80014f4:	2800      	cmp	r0, #0
 80014f6:	d09b      	beq.n	8001430 <parse_Status_from_JSON+0x6c>
    JSON_subSensorParser = json_object_dotget_array(JSON_ParseHandler, "subSensorStatus");    
 80014f8:	4948      	ldr	r1, [pc, #288]	; (800161c <parse_Status_from_JSON+0x258>)
 80014fa:	4620      	mov	r0, r4
 80014fc:	f013 fac4 	bl	8014a88 <json_object_dotget_array>
 8001500:	4680      	mov	r8, r0
    size = (uint32_t)json_array_get_count(JSON_subSensorParser);
 8001502:	f013 faef 	bl	8014ae4 <json_array_get_count>
    for (ii = 0; ii < size; ii++)
 8001506:	9000      	str	r0, [sp, #0]
 8001508:	2800      	cmp	r0, #0
 800150a:	d091      	beq.n	8001430 <parse_Status_from_JSON+0x6c>
 800150c:	4f44      	ldr	r7, [pc, #272]	; (8001620 <parse_Status_from_JSON+0x25c>)
      if (json_object_dothas_value(JSON_subSensorObj,"id"))  
 800150e:	f8df b114 	ldr.w	fp, [pc, #276]	; 8001624 <parse_Status_from_JSON+0x260>
      if (json_object_dothas_value(JSON_subSensorObj,"fs"))
 8001512:	f8df a114 	ldr.w	sl, [pc, #276]	; 8001628 <parse_Status_from_JSON+0x264>
      if (json_object_dothas_value(JSON_subSensorObj,"sensitivity"))
 8001516:	f8df 9114 	ldr.w	r9, [pc, #276]	; 800162c <parse_Status_from_JSON+0x268>
    for (ii = 0; ii < size; ii++)
 800151a:	2500      	movs	r5, #0
 800151c:	e017      	b.n	800154e <parse_Status_from_JSON+0x18a>
        subid = ii;
 800151e:	b26b      	sxtb	r3, r5
      if (json_object_dothas_value(JSON_subSensorObj,"fs"))
 8001520:	4651      	mov	r1, sl
 8001522:	4620      	mov	r0, r4
        subid = ii;
 8001524:	703b      	strb	r3, [r7, #0]
      if (json_object_dothas_value(JSON_subSensorObj,"fs"))
 8001526:	f013 fac5 	bl	8014ab4 <json_object_dothas_value>
 800152a:	bb50      	cbnz	r0, 8001582 <parse_Status_from_JSON+0x1be>
      if (json_object_dothas_value(JSON_subSensorObj,"sensitivity"))
 800152c:	4649      	mov	r1, r9
 800152e:	4620      	mov	r0, r4
 8001530:	f013 fac0 	bl	8014ab4 <json_object_dothas_value>
 8001534:	2800      	cmp	r0, #0
 8001536:	d13b      	bne.n	80015b0 <parse_Status_from_JSON+0x1ec>
      if (json_object_dothas_value(JSON_subSensorObj,"isActive"))
 8001538:	4937      	ldr	r1, [pc, #220]	; (8001618 <parse_Status_from_JSON+0x254>)
 800153a:	4620      	mov	r0, r4
 800153c:	f013 faba 	bl	8014ab4 <json_object_dothas_value>
 8001540:	2800      	cmp	r0, #0
 8001542:	d14c      	bne.n	80015de <parse_Status_from_JSON+0x21a>
    for (ii = 0; ii < size; ii++)
 8001544:	9b00      	ldr	r3, [sp, #0]
 8001546:	3501      	adds	r5, #1
 8001548:	42ab      	cmp	r3, r5
 800154a:	f43f af71 	beq.w	8001430 <parse_Status_from_JSON+0x6c>
      JSON_subSensorObj = json_array_get_object(JSON_subSensorParser,ii);      
 800154e:	4629      	mov	r1, r5
 8001550:	4640      	mov	r0, r8
 8001552:	f013 fab7 	bl	8014ac4 <json_array_get_object>
      if (json_object_dothas_value(JSON_subSensorObj,"id"))  
 8001556:	4659      	mov	r1, fp
      JSON_subSensorObj = json_array_get_object(JSON_subSensorParser,ii);      
 8001558:	4604      	mov	r4, r0
      if (json_object_dothas_value(JSON_subSensorObj,"id"))  
 800155a:	f013 faab 	bl	8014ab4 <json_object_dothas_value>
 800155e:	2800      	cmp	r0, #0
 8001560:	d0dd      	beq.n	800151e <parse_Status_from_JSON+0x15a>
        subid = (int8_t)json_object_dotget_number(JSON_subSensorObj, "id");
 8001562:	4659      	mov	r1, fp
 8001564:	4620      	mov	r0, r4
 8001566:	f013 fa7b 	bl	8014a60 <json_object_dotget_number>
 800156a:	ec51 0b10 	vmov	r0, r1, d0
 800156e:	f7ff fb1b 	bl	8000ba8 <__aeabi_d2iz>
 8001572:	b240      	sxtb	r0, r0
 8001574:	7038      	strb	r0, [r7, #0]
      if (json_object_dothas_value(JSON_subSensorObj,"fs"))
 8001576:	4651      	mov	r1, sl
 8001578:	4620      	mov	r0, r4
 800157a:	f013 fa9b 	bl	8014ab4 <json_object_dothas_value>
 800157e:	2800      	cmp	r0, #0
 8001580:	d0d4      	beq.n	800152c <parse_Status_from_JSON+0x168>
        sensorStatus->subSensorStatus[subid].FS = json_object_dotget_number(JSON_subSensorObj, "fs");
 8001582:	4651      	mov	r1, sl
 8001584:	4620      	mov	r0, r4
 8001586:	f013 fa6b 	bl	8014a60 <json_object_dotget_number>
 800158a:	783b      	ldrb	r3, [r7, #0]
 800158c:	b25b      	sxtb	r3, r3
 800158e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8001592:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8001596:	ec51 0b10 	vmov	r0, r1, d0
 800159a:	9301      	str	r3, [sp, #4]
 800159c:	f7ff fb4c 	bl	8000c38 <__aeabi_d2f>
 80015a0:	9b01      	ldr	r3, [sp, #4]
      if (json_object_dothas_value(JSON_subSensorObj,"sensitivity"))
 80015a2:	4649      	mov	r1, r9
        sensorStatus->subSensorStatus[subid].FS = json_object_dotget_number(JSON_subSensorObj, "fs");
 80015a4:	61d8      	str	r0, [r3, #28]
      if (json_object_dothas_value(JSON_subSensorObj,"sensitivity"))
 80015a6:	4620      	mov	r0, r4
 80015a8:	f013 fa84 	bl	8014ab4 <json_object_dothas_value>
 80015ac:	2800      	cmp	r0, #0
 80015ae:	d0c3      	beq.n	8001538 <parse_Status_from_JSON+0x174>
        sensorStatus->subSensorStatus[subid].sensitivity = json_object_dotget_number(JSON_subSensorObj, "sensitivity");
 80015b0:	4649      	mov	r1, r9
 80015b2:	4620      	mov	r0, r4
 80015b4:	f013 fa54 	bl	8014a60 <json_object_dotget_number>
 80015b8:	783b      	ldrb	r3, [r7, #0]
 80015ba:	b25b      	sxtb	r3, r3
 80015bc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80015c0:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80015c4:	ec51 0b10 	vmov	r0, r1, d0
 80015c8:	9301      	str	r3, [sp, #4]
 80015ca:	f7ff fb35 	bl	8000c38 <__aeabi_d2f>
 80015ce:	9b01      	ldr	r3, [sp, #4]
      if (json_object_dothas_value(JSON_subSensorObj,"isActive"))
 80015d0:	4911      	ldr	r1, [pc, #68]	; (8001618 <parse_Status_from_JSON+0x254>)
        sensorStatus->subSensorStatus[subid].sensitivity = json_object_dotget_number(JSON_subSensorObj, "sensitivity");
 80015d2:	6218      	str	r0, [r3, #32]
      if (json_object_dothas_value(JSON_subSensorObj,"isActive"))
 80015d4:	4620      	mov	r0, r4
 80015d6:	f013 fa6d 	bl	8014ab4 <json_object_dothas_value>
 80015da:	2800      	cmp	r0, #0
 80015dc:	d0b2      	beq.n	8001544 <parse_Status_from_JSON+0x180>
        if (json_object_dotget_boolean(JSON_subSensorObj,"isActive") == 1)
 80015de:	490e      	ldr	r1, [pc, #56]	; (8001618 <parse_Status_from_JSON+0x254>)
 80015e0:	4620      	mov	r0, r4
 80015e2:	f013 fa5b 	bl	8014a9c <json_object_dotget_boolean>
          sensorStatus->subSensorStatus[subid].isActive = 1;
 80015e6:	783b      	ldrb	r3, [r7, #0]
 80015e8:	b25b      	sxtb	r3, r3
 80015ea:	eb03 0343 	add.w	r3, r3, r3, lsl #1
        if (json_object_dotget_boolean(JSON_subSensorObj,"isActive") == 1)
 80015ee:	2801      	cmp	r0, #1
          sensorStatus->subSensorStatus[subid].isActive = 1;
 80015f0:	eb06 0383 	add.w	r3, r6, r3, lsl #2
          sensorStatus->subSensorStatus[subid].isActive = 0;
 80015f4:	bf16      	itet	ne
 80015f6:	2200      	movne	r2, #0
          sensorStatus->subSensorStatus[subid].isActive = 1;
 80015f8:	f883 0024 	strbeq.w	r0, [r3, #36]	; 0x24
          sensorStatus->subSensorStatus[subid].isActive = 0;
 80015fc:	f883 2024 	strbne.w	r2, [r3, #36]	; 0x24
 8001600:	e7a0      	b.n	8001544 <parse_Status_from_JSON+0x180>
 8001602:	bf00      	nop
 8001604:	0801a704 	.word	0x0801a704
 8001608:	0801a740 	.word	0x0801a740
 800160c:	0801a754 	.word	0x0801a754
 8001610:	0801a768 	.word	0x0801a768
 8001614:	0801a730 	.word	0x0801a730
 8001618:	0801a724 	.word	0x0801a724
 800161c:	0801a77c 	.word	0x0801a77c
 8001620:	20000000 	.word	0x20000000
 8001624:	0801aaa0 	.word	0x0801aaa0
 8001628:	0801a78c 	.word	0x0801a78c
 800162c:	0801a790 	.word	0x0801a790

08001630 <create_JSON_Sensor>:
{
 8001630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001634:	4681      	mov	r9, r0
 8001636:	b083      	sub	sp, #12
  JSON_Object *JSON_Sensor = json_value_get_object(tempJSON);
 8001638:	4608      	mov	r0, r1
  uint8_t nSensor = sensor->sensorDescriptor.id;
 800163a:	f899 4000 	ldrb.w	r4, [r9]
  uint8_t nSubSensors = sensor->sensorDescriptor.nSubSensors; 
 800163e:	f899 a058 	ldrb.w	sl, [r9, #88]	; 0x58
  JSON_Object *JSON_Sensor = json_value_get_object(tempJSON);
 8001642:	f013 fa53 	bl	8014aec <json_value_get_object>
 8001646:	4680      	mov	r8, r0
  json_object_dotset_number(JSON_Sensor, "id", nSensor);
 8001648:	4620      	mov	r0, r4
 800164a:	f7fe ff83 	bl	8000554 <__aeabi_ui2d>
 800164e:	ec41 0b10 	vmov	d0, r0, r1
 8001652:	494c      	ldr	r1, [pc, #304]	; (8001784 <create_JSON_Sensor+0x154>)
 8001654:	4640      	mov	r0, r8
 8001656:	f014 f901 	bl	801585c <json_object_dotset_number>
  JSON_Value *DescriptorJSON = json_value_init_object();
 800165a:	f013 fdaf 	bl	80151bc <json_value_init_object>
  json_object_set_value(JSON_Sensor, "sensorDescriptor", DescriptorJSON);
 800165e:	494a      	ldr	r1, [pc, #296]	; (8001788 <create_JSON_Sensor+0x158>)
 8001660:	4602      	mov	r2, r0
  JSON_Value *DescriptorJSON = json_value_init_object();
 8001662:	4604      	mov	r4, r0
  json_object_set_value(JSON_Sensor, "sensorDescriptor", DescriptorJSON);
 8001664:	4640      	mov	r0, r8
 8001666:	f013 ffb1 	bl	80155cc <json_object_set_value>
  create_JSON_SensorDescriptor(&sensor->sensorDescriptor, DescriptorJSON); 
 800166a:	4621      	mov	r1, r4
 800166c:	4648      	mov	r0, r9
 800166e:	f7ff fd85 	bl	800117c <create_JSON_SensorDescriptor>
  json_object_dotset_value(JSON_Sensor, "sensorDescriptor.subSensorDescriptor", json_value_init_array());
 8001672:	f013 fdc3 	bl	80151fc <json_value_init_array>
 8001676:	4945      	ldr	r1, [pc, #276]	; (800178c <create_JSON_Sensor+0x15c>)
 8001678:	4602      	mov	r2, r0
 800167a:	4640      	mov	r0, r8
 800167c:	f014 f80c 	bl	8015698 <json_object_dotset_value>
  JSON_SensorArray1 = json_object_dotget_array(JSON_Sensor, "sensorDescriptor.subSensorDescriptor"); 
 8001680:	4942      	ldr	r1, [pc, #264]	; (800178c <create_JSON_Sensor+0x15c>)
 8001682:	4640      	mov	r0, r8
 8001684:	f013 fa00 	bl	8014a88 <json_object_dotget_array>
  for (ii = 0; ii < nSubSensors; ii++)
 8001688:	f1ba 0f00 	cmp.w	sl, #0
 800168c:	d05f      	beq.n	800174e <create_JSON_Sensor+0x11e>
 800168e:	f109 055c 	add.w	r5, r9, #92	; 0x5c
 8001692:	2754      	movs	r7, #84	; 0x54
 8001694:	4606      	mov	r6, r0
 8001696:	fb17 570a 	smlabb	r7, r7, sl, r5
 800169a:	464c      	mov	r4, r9
    tempJSON1 = json_value_init_object();  
 800169c:	f013 fd8e 	bl	80151bc <json_value_init_object>
 80016a0:	4601      	mov	r1, r0
    create_JSON_SubSensorDescriptor(&sensor->sensorDescriptor.subSensorDescriptor[ii], tempJSON1);  
 80016a2:	9001      	str	r0, [sp, #4]
 80016a4:	4628      	mov	r0, r5
 80016a6:	f7ff fcc9 	bl	800103c <create_JSON_SubSensorDescriptor>
    json_array_append_value(JSON_SensorArray1,tempJSON1);
 80016aa:	3554      	adds	r5, #84	; 0x54
 80016ac:	9901      	ldr	r1, [sp, #4]
 80016ae:	4630      	mov	r0, r6
 80016b0:	f013 feea 	bl	8015488 <json_array_append_value>
  for (ii = 0; ii < nSubSensors; ii++)
 80016b4:	42bd      	cmp	r5, r7
 80016b6:	d1f1      	bne.n	800169c <create_JSON_Sensor+0x6c>
  JSON_Value *statusJSON = json_value_init_object();
 80016b8:	f013 fd80 	bl	80151bc <json_value_init_object>
  json_object_set_value(JSON_Sensor, "sensorStatus", statusJSON);
 80016bc:	4934      	ldr	r1, [pc, #208]	; (8001790 <create_JSON_Sensor+0x160>)

static void create_JSON_SubSensorStatus(COM_SubSensorStatus_t *sub_sensor_status, JSON_Value *tempJSON)
{
  JSON_Object *JSON_SubSensorStatus = json_value_get_object(tempJSON);
  
  json_object_dotset_number(JSON_SubSensorStatus, "fs", sub_sensor_status->FS);
 80016be:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 800179c <create_JSON_Sensor+0x16c>
  json_object_dotset_number(JSON_SubSensorStatus, "sensitivity", sub_sensor_status->sensitivity);
 80016c2:	4f34      	ldr	r7, [pc, #208]	; (8001794 <create_JSON_Sensor+0x164>)
  json_object_set_value(JSON_Sensor, "sensorStatus", statusJSON);
 80016c4:	4602      	mov	r2, r0
  JSON_Value *statusJSON = json_value_init_object();
 80016c6:	4605      	mov	r5, r0
  json_object_set_value(JSON_Sensor, "sensorStatus", statusJSON);
 80016c8:	4640      	mov	r0, r8
 80016ca:	f013 ff7f 	bl	80155cc <json_object_set_value>
  create_JSON_SensorStatus(&sensor->sensorStatus, statusJSON); 
 80016ce:	4629      	mov	r1, r5
 80016d0:	f509 70d6 	add.w	r0, r9, #428	; 0x1ac
 80016d4:	f7ff fe18 	bl	8001308 <create_JSON_SensorStatus>
  json_object_dotset_value(JSON_Sensor, "sensorStatus.subSensorStatus", json_value_init_array());
 80016d8:	f013 fd90 	bl	80151fc <json_value_init_array>
 80016dc:	492e      	ldr	r1, [pc, #184]	; (8001798 <create_JSON_Sensor+0x168>)
 80016de:	4602      	mov	r2, r0
 80016e0:	4640      	mov	r0, r8
 80016e2:	f013 ffd9 	bl	8015698 <json_object_dotset_value>
  JSON_SensorArray2= json_object_dotget_array(JSON_Sensor, "sensorStatus.subSensorStatus"); 
 80016e6:	4640      	mov	r0, r8
 80016e8:	492b      	ldr	r1, [pc, #172]	; (8001798 <create_JSON_Sensor+0x168>)
  json_object_dotset_boolean(JSON_SubSensorStatus, "isActive", sub_sensor_status->isActive);
 80016ea:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 80017a0 <create_JSON_Sensor+0x170>
  JSON_SensorArray2= json_object_dotget_array(JSON_Sensor, "sensorStatus.subSensorStatus"); 
 80016ee:	f013 f9cb 	bl	8014a88 <json_object_dotget_array>
 80016f2:	230c      	movs	r3, #12
 80016f4:	4606      	mov	r6, r0
  for (ii = 0; ii < nSubSensors; ii++)
 80016f6:	fb13 990a 	smlabb	r9, r3, sl, r9
    tempJSON2 = json_value_init_object();  
 80016fa:	f013 fd5f 	bl	80151bc <json_value_init_object>
 80016fe:	4682      	mov	sl, r0
  JSON_Object *JSON_SubSensorStatus = json_value_get_object(tempJSON);
 8001700:	f013 f9f4 	bl	8014aec <json_value_get_object>
 8001704:	4605      	mov	r5, r0
  json_object_dotset_number(JSON_SubSensorStatus, "fs", sub_sensor_status->FS);
 8001706:	f8d4 01c8 	ldr.w	r0, [r4, #456]	; 0x1c8
 800170a:	f7fe ff45 	bl	8000598 <__aeabi_f2d>
 800170e:	ec41 0b10 	vmov	d0, r0, r1
 8001712:	4659      	mov	r1, fp
 8001714:	4628      	mov	r0, r5
 8001716:	f014 f8a1 	bl	801585c <json_object_dotset_number>
  json_object_dotset_number(JSON_SubSensorStatus, "sensitivity", sub_sensor_status->sensitivity);
 800171a:	f8d4 01cc 	ldr.w	r0, [r4, #460]	; 0x1cc
 800171e:	f7fe ff3b 	bl	8000598 <__aeabi_f2d>
 8001722:	ec41 0b10 	vmov	d0, r0, r1
 8001726:	4639      	mov	r1, r7
 8001728:	4628      	mov	r0, r5
 800172a:	f014 f897 	bl	801585c <json_object_dotset_number>
  json_object_dotset_boolean(JSON_SubSensorStatus, "isActive", sub_sensor_status->isActive);
 800172e:	f894 21d0 	ldrb.w	r2, [r4, #464]	; 0x1d0
 8001732:	4641      	mov	r1, r8
 8001734:	4628      	mov	r0, r5
 8001736:	f014 f8d9 	bl	80158ec <json_object_dotset_boolean>
    json_array_append_value(JSON_SensorArray2,tempJSON2);
 800173a:	340c      	adds	r4, #12
 800173c:	4651      	mov	r1, sl
 800173e:	4630      	mov	r0, r6
 8001740:	f013 fea2 	bl	8015488 <json_array_append_value>
  for (ii = 0; ii < nSubSensors; ii++)
 8001744:	45a1      	cmp	r9, r4
 8001746:	d1d8      	bne.n	80016fa <create_JSON_Sensor+0xca>
}
 8001748:	b003      	add	sp, #12
 800174a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  JSON_Value *statusJSON = json_value_init_object();
 800174e:	f013 fd35 	bl	80151bc <json_value_init_object>
  json_object_set_value(JSON_Sensor, "sensorStatus", statusJSON);
 8001752:	490f      	ldr	r1, [pc, #60]	; (8001790 <create_JSON_Sensor+0x160>)
 8001754:	4602      	mov	r2, r0
  JSON_Value *statusJSON = json_value_init_object();
 8001756:	4604      	mov	r4, r0
  json_object_set_value(JSON_Sensor, "sensorStatus", statusJSON);
 8001758:	4640      	mov	r0, r8
 800175a:	f013 ff37 	bl	80155cc <json_object_set_value>
  create_JSON_SensorStatus(&sensor->sensorStatus, statusJSON); 
 800175e:	4621      	mov	r1, r4
 8001760:	f509 70d6 	add.w	r0, r9, #428	; 0x1ac
 8001764:	f7ff fdd0 	bl	8001308 <create_JSON_SensorStatus>
  json_object_dotset_value(JSON_Sensor, "sensorStatus.subSensorStatus", json_value_init_array());
 8001768:	f013 fd48 	bl	80151fc <json_value_init_array>
 800176c:	490a      	ldr	r1, [pc, #40]	; (8001798 <create_JSON_Sensor+0x168>)
 800176e:	4602      	mov	r2, r0
 8001770:	4640      	mov	r0, r8
 8001772:	f013 ff91 	bl	8015698 <json_object_dotset_value>
  JSON_SensorArray2= json_object_dotget_array(JSON_Sensor, "sensorStatus.subSensorStatus"); 
 8001776:	4908      	ldr	r1, [pc, #32]	; (8001798 <create_JSON_Sensor+0x168>)
 8001778:	4640      	mov	r0, r8
}
 800177a:	b003      	add	sp, #12
 800177c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  JSON_SensorArray2= json_object_dotget_array(JSON_Sensor, "sensorStatus.subSensorStatus"); 
 8001780:	f013 b982 	b.w	8014a88 <json_object_dotget_array>
 8001784:	0801aaa0 	.word	0x0801aaa0
 8001788:	0801a79c 	.word	0x0801a79c
 800178c:	0801a7b0 	.word	0x0801a7b0
 8001790:	0801a7d8 	.word	0x0801a7d8
 8001794:	0801a790 	.word	0x0801a790
 8001798:	0801a7e8 	.word	0x0801a7e8
 800179c:	0801a78c 	.word	0x0801a78c
 80017a0:	0801a724 	.word	0x0801a724

080017a4 <HSD_JSON_set_allocation_functions>:
{
 80017a4:	b510      	push	{r4, lr}
 80017a6:	460c      	mov	r4, r1
  json_set_allocation_functions(malloc_function, free_function);
 80017a8:	f014 f8ca 	bl	8015940 <json_set_allocation_functions>
  JSON_free_function = free_function;
 80017ac:	4b01      	ldr	r3, [pc, #4]	; (80017b4 <HSD_JSON_set_allocation_functions+0x10>)
}
 80017ae:	2000      	movs	r0, #0
  JSON_free_function = free_function;
 80017b0:	601c      	str	r4, [r3, #0]
}
 80017b2:	bd10      	pop	{r4, pc}
 80017b4:	20000334 	.word	0x20000334

080017b8 <HSD_JSON_free>:
{
 80017b8:	b508      	push	{r3, lr}
  JSON_free_function(mem);
 80017ba:	4b02      	ldr	r3, [pc, #8]	; (80017c4 <HSD_JSON_free+0xc>)
 80017bc:	681b      	ldr	r3, [r3, #0]
 80017be:	4798      	blx	r3
}
 80017c0:	2000      	movs	r0, #0
 80017c2:	bd08      	pop	{r3, pc}
 80017c4:	20000334 	.word	0x20000334

080017c8 <HSD_JSON_serialize_Device>:
{
 80017c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80017cc:	b082      	sub	sp, #8
 80017ce:	4604      	mov	r4, r0
 80017d0:	460f      	mov	r7, r1
 80017d2:	4690      	mov	r8, r2
  tempJSON = json_value_init_object();
 80017d4:	f013 fcf2 	bl	80151bc <json_value_init_object>
 80017d8:	4606      	mov	r6, r0
  JSON_Device = json_value_get_object(tempJSON);
 80017da:	f013 f987 	bl	8014aec <json_value_get_object>
  json_object_dotset_string(JSON_Device, "device.deviceInfo.serialNumber", device->deviceDescriptor.serialNumber);
 80017de:	492b      	ldr	r1, [pc, #172]	; (800188c <HSD_JSON_serialize_Device+0xc4>)
  JSON_Device = json_value_get_object(tempJSON);
 80017e0:	4605      	mov	r5, r0
  json_object_dotset_string(JSON_Device, "device.deviceInfo.serialNumber", device->deviceDescriptor.serialNumber);
 80017e2:	4622      	mov	r2, r4
 80017e4:	f014 f81e 	bl	8015824 <json_object_dotset_string>
  json_object_dotset_string(JSON_Device, "device.deviceInfo.alias", device->deviceDescriptor.alias);
 80017e8:	f104 0215 	add.w	r2, r4, #21
 80017ec:	4928      	ldr	r1, [pc, #160]	; (8001890 <HSD_JSON_serialize_Device+0xc8>)
 80017ee:	4628      	mov	r0, r5
 80017f0:	f014 f818 	bl	8015824 <json_object_dotset_string>
  json_object_dotset_number(JSON_Device, "device.deviceInfo.nSensor", device->deviceDescriptor.nSensor);
 80017f4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80017f6:	f7fe fead 	bl	8000554 <__aeabi_ui2d>
 80017fa:	ec41 0b10 	vmov	d0, r0, r1
 80017fe:	4925      	ldr	r1, [pc, #148]	; (8001894 <HSD_JSON_serialize_Device+0xcc>)
 8001800:	4628      	mov	r0, r5
 8001802:	f014 f82b 	bl	801585c <json_object_dotset_number>
  json_object_dotset_value(JSON_Device, "device.sensor", json_value_init_array());
 8001806:	f013 fcf9 	bl	80151fc <json_value_init_array>
 800180a:	4923      	ldr	r1, [pc, #140]	; (8001898 <HSD_JSON_serialize_Device+0xd0>)
 800180c:	4602      	mov	r2, r0
 800180e:	4628      	mov	r0, r5
 8001810:	f013 ff42 	bl	8015698 <json_object_dotset_value>
  JSON_SensorArray = json_object_dotget_array(JSON_Device, "device.sensor");
 8001814:	4920      	ldr	r1, [pc, #128]	; (8001898 <HSD_JSON_serialize_Device+0xd0>)
 8001816:	4628      	mov	r0, r5
 8001818:	f013 f936 	bl	8014a88 <json_object_dotget_array>
  for(i = 0; i < device->deviceDescriptor.nSensor; i++)
 800181c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800181e:	b1ab      	cbz	r3, 800184c <HSD_JSON_serialize_Device+0x84>
 8001820:	4605      	mov	r5, r0
 8001822:	f104 0928 	add.w	r9, r4, #40	; 0x28
 8001826:	f04f 0a00 	mov.w	sl, #0
    tempJSON1 = json_value_init_object();  
 800182a:	f013 fcc7 	bl	80151bc <json_value_init_object>
 800182e:	4601      	mov	r1, r0
    create_JSON_Sensor(device->sensors[i], tempJSON1);    
 8001830:	9001      	str	r0, [sp, #4]
 8001832:	f859 0f04 	ldr.w	r0, [r9, #4]!
 8001836:	f7ff fefb 	bl	8001630 <create_JSON_Sensor>
    json_array_append_value(JSON_SensorArray,tempJSON1);
 800183a:	9901      	ldr	r1, [sp, #4]
 800183c:	4628      	mov	r0, r5
 800183e:	f013 fe23 	bl	8015488 <json_array_append_value>
  for(i = 0; i < device->deviceDescriptor.nSensor; i++)
 8001842:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001844:	f10a 0a01 	add.w	sl, sl, #1
 8001848:	459a      	cmp	sl, r3
 800184a:	d3ee      	bcc.n	800182a <HSD_JSON_serialize_Device+0x62>
  if (pretty == 1)
 800184c:	f1b8 0f01 	cmp.w	r8, #1
    *serialized_string = json_serialize_to_string_pretty(tempJSON);
 8001850:	4630      	mov	r0, r6
  if (pretty == 1)
 8001852:	d00d      	beq.n	8001870 <HSD_JSON_serialize_Device+0xa8>
    *serialized_string = json_serialize_to_string(tempJSON);
 8001854:	f013 fdaa 	bl	80153ac <json_serialize_to_string>
 8001858:	6038      	str	r0, [r7, #0]
    size = json_serialization_size(tempJSON);    
 800185a:	4630      	mov	r0, r6
 800185c:	f013 fd98 	bl	8015390 <json_serialization_size>
 8001860:	4604      	mov	r4, r0
  json_value_free(tempJSON);
 8001862:	4630      	mov	r0, r6
 8001864:	f013 f952 	bl	8014b0c <json_value_free>
}
 8001868:	4620      	mov	r0, r4
 800186a:	b002      	add	sp, #8
 800186c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    *serialized_string = json_serialize_to_string_pretty(tempJSON);
 8001870:	f013 fdda 	bl	8015428 <json_serialize_to_string_pretty>
 8001874:	6038      	str	r0, [r7, #0]
    size = json_serialization_size_pretty(tempJSON);    
 8001876:	4630      	mov	r0, r6
 8001878:	f013 fdc8 	bl	801540c <json_serialization_size_pretty>
 800187c:	4604      	mov	r4, r0
  json_value_free(tempJSON);
 800187e:	4630      	mov	r0, r6
 8001880:	f013 f944 	bl	8014b0c <json_value_free>
}
 8001884:	4620      	mov	r0, r4
 8001886:	b002      	add	sp, #8
 8001888:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800188c:	0801a808 	.word	0x0801a808
 8001890:	0801a828 	.word	0x0801a828
 8001894:	0801a840 	.word	0x0801a840
 8001898:	0801a85c 	.word	0x0801a85c

0800189c <HSD_JSON_parse_Device>:
{
 800189c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80018a0:	468a      	mov	sl, r1
  JSON_Value *tempJSON = json_parse_string(SerializedJSON);
 80018a2:	f013 fc73 	bl	801518c <json_parse_string>
 80018a6:	4605      	mov	r5, r0
  JSON_Object *JSON_ParseHandler = json_value_get_object(tempJSON);
 80018a8:	f013 f920 	bl	8014aec <json_value_get_object>
  if (json_object_dothas_value(JSON_ParseHandler,"device.sensor"))
 80018ac:	491a      	ldr	r1, [pc, #104]	; (8001918 <HSD_JSON_parse_Device+0x7c>)
  JSON_Object *JSON_ParseHandler = json_value_get_object(tempJSON);
 80018ae:	4604      	mov	r4, r0
  if (json_object_dothas_value(JSON_ParseHandler,"device.sensor"))
 80018b0:	f013 f900 	bl	8014ab4 <json_object_dothas_value>
 80018b4:	b928      	cbnz	r0, 80018c2 <HSD_JSON_parse_Device+0x26>
  json_value_free(tempJSON);
 80018b6:	4628      	mov	r0, r5
 80018b8:	f013 f928 	bl	8014b0c <json_value_free>
}
 80018bc:	2000      	movs	r0, #0
 80018be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    JSON_subSensorParser = json_object_dotget_array(JSON_ParseHandler, "device.sensor");    
 80018c2:	4915      	ldr	r1, [pc, #84]	; (8001918 <HSD_JSON_parse_Device+0x7c>)
 80018c4:	4620      	mov	r0, r4
 80018c6:	f013 f8df 	bl	8014a88 <json_object_dotget_array>
 80018ca:	4681      	mov	r9, r0
    size = (uint32_t)json_array_get_count(JSON_subSensorParser);
 80018cc:	f013 f90a 	bl	8014ae4 <json_array_get_count>
    for (ii = 0; ii < size; ii++)
 80018d0:	4607      	mov	r7, r0
 80018d2:	2800      	cmp	r0, #0
 80018d4:	d0ef      	beq.n	80018b6 <HSD_JSON_parse_Device+0x1a>
      if (json_object_dothas_value(JSON_subSensorObj,"sensorStatus"))
 80018d6:	f8df 8044 	ldr.w	r8, [pc, #68]	; 800191c <HSD_JSON_parse_Device+0x80>
        parse_Status_from_JSON(StatusText, &Device->sensors[ii]->sensorStatus);
 80018da:	f10a 0a2c 	add.w	sl, sl, #44	; 0x2c
    for (ii = 0; ii < size; ii++)
 80018de:	2400      	movs	r4, #0
 80018e0:	e002      	b.n	80018e8 <HSD_JSON_parse_Device+0x4c>
 80018e2:	3401      	adds	r4, #1
 80018e4:	42a7      	cmp	r7, r4
 80018e6:	d0e6      	beq.n	80018b6 <HSD_JSON_parse_Device+0x1a>
      JSON_subSensorObj = json_array_get_object(JSON_subSensorParser,ii);
 80018e8:	4621      	mov	r1, r4
 80018ea:	4648      	mov	r0, r9
 80018ec:	f013 f8ea 	bl	8014ac4 <json_array_get_object>
      if (json_object_dothas_value(JSON_subSensorObj,"sensorStatus"))
 80018f0:	4641      	mov	r1, r8
      JSON_subSensorObj = json_array_get_object(JSON_subSensorParser,ii);
 80018f2:	4606      	mov	r6, r0
      if (json_object_dothas_value(JSON_subSensorObj,"sensorStatus"))
 80018f4:	f013 f8de 	bl	8014ab4 <json_object_dothas_value>
 80018f8:	2800      	cmp	r0, #0
 80018fa:	d0f2      	beq.n	80018e2 <HSD_JSON_parse_Device+0x46>
        StatusText = json_serialize_to_string(json_object_get_value(JSON_subSensorObj,"sensorStatus"));
 80018fc:	4641      	mov	r1, r8
 80018fe:	4630      	mov	r0, r6
 8001900:	f013 f81a 	bl	8014938 <json_object_get_value>
 8001904:	f013 fd52 	bl	80153ac <json_serialize_to_string>
        parse_Status_from_JSON(StatusText, &Device->sensors[ii]->sensorStatus);
 8001908:	f85a 1024 	ldr.w	r1, [sl, r4, lsl #2]
 800190c:	f501 71d6 	add.w	r1, r1, #428	; 0x1ac
 8001910:	f7ff fd58 	bl	80013c4 <parse_Status_from_JSON>
 8001914:	e7e5      	b.n	80018e2 <HSD_JSON_parse_Device+0x46>
 8001916:	bf00      	nop
 8001918:	0801a85c 	.word	0x0801a85c
 800191c:	0801a7d8 	.word	0x0801a7d8

08001920 <COM_AddSensor>:
* @brief Add Sensor to Db
* @param None
* @retval Sensor unique sID
*/
int32_t COM_AddSensor(void)
{  
 8001920:	b538      	push	{r3, r4, r5, lr}
  uint32_t ii = COM_device.deviceDescriptor.nSensor;
 8001922:	4c0c      	ldr	r4, [pc, #48]	; (8001954 <COM_AddSensor+0x34>)
 8001924:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  
  COM_device.sensors[ii] = calloc(1, sizeof(COM_Sensor_t));   
 8001926:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
 800192a:	2001      	movs	r0, #1
 800192c:	f014 f88c 	bl	8015a48 <calloc>
 8001930:	f105 030a 	add.w	r3, r5, #10
 8001934:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8001938:	6058      	str	r0, [r3, #4]
  
  if(COM_device.sensors[ii] == NULL)
 800193a:	685a      	ldr	r2, [r3, #4]
 800193c:	b13a      	cbz	r2, 800194e <COM_AddSensor+0x2e>
    return -1;
  
  COM_device.sensors[ii]->sensorDescriptor.id = ii;
 800193e:	685b      	ldr	r3, [r3, #4]
 8001940:	701d      	strb	r5, [r3, #0]
  COM_device.deviceDescriptor.nSensor++;
 8001942:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001944:	3301      	adds	r3, #1
 8001946:	62a3      	str	r3, [r4, #40]	; 0x28
  return COM_device.deviceDescriptor.nSensor - 1;
 8001948:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800194a:	3801      	subs	r0, #1
}
 800194c:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 800194e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001952:	bd38      	pop	{r3, r4, r5, pc}
 8001954:	20000338 	.word	0x20000338

08001958 <COM_GetDevice>:
* @retval whole device Structure
*/
COM_Device_t * COM_GetDevice(void)
{
  return (COM_Device_t *)&COM_device;
}
 8001958:	4800      	ldr	r0, [pc, #0]	; (800195c <COM_GetDevice+0x4>)
 800195a:	4770      	bx	lr
 800195c:	20000338 	.word	0x20000338

08001960 <COM_GetDeviceDescriptor>:
* @retval Device Descriptor
*/
COM_DeviceDescriptor_t * COM_GetDeviceDescriptor(void)
{
  return (COM_DeviceDescriptor_t *)&(COM_device.deviceDescriptor);
}
 8001960:	4800      	ldr	r0, [pc, #0]	; (8001964 <COM_GetDeviceDescriptor+0x4>)
 8001962:	4770      	bx	lr
 8001964:	20000338 	.word	0x20000338

08001968 <COM_GetSensor>:
* @param None
* @retval Sensor unique sID
*/
COM_Sensor_t * COM_GetSensor(uint8_t sID)
{
  return COM_device.sensors[sID];
 8001968:	4b02      	ldr	r3, [pc, #8]	; (8001974 <COM_GetSensor+0xc>)
 800196a:	300a      	adds	r0, #10
 800196c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8001970:	6858      	ldr	r0, [r3, #4]
}
 8001972:	4770      	bx	lr
 8001974:	20000338 	.word	0x20000338

08001978 <COM_GetSensorDescriptor>:
* @param None
* @retval Sensor unique sID
*/
COM_SensorDescriptor_t * COM_GetSensorDescriptor(uint8_t sID)
{
    return &(COM_device.sensors[sID]->sensorDescriptor);  
 8001978:	4b02      	ldr	r3, [pc, #8]	; (8001984 <COM_GetSensorDescriptor+0xc>)
 800197a:	300a      	adds	r0, #10
 800197c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8001980:	6858      	ldr	r0, [r3, #4]
}
 8001982:	4770      	bx	lr
 8001984:	20000338 	.word	0x20000338

08001988 <COM_GetSensorStatus>:
* @param None
* @retval Sensor unique sID
*/
COM_SensorStatus_t * COM_GetSensorStatus(uint8_t sID)
{
    return &(COM_device.sensors[sID]->sensorStatus);  
 8001988:	4b03      	ldr	r3, [pc, #12]	; (8001998 <COM_GetSensorStatus+0x10>)
 800198a:	300a      	adds	r0, #10
 800198c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8001990:	6858      	ldr	r0, [r3, #4]
}
 8001992:	f500 70d6 	add.w	r0, r0, #428	; 0x1ac
 8001996:	4770      	bx	lr
 8001998:	20000338 	.word	0x20000338

0800199c <COM_GetSubSensorDescriptor>:
* @param None
* @retval Sensor unique sID
*/
COM_SubSensorDescriptor_t * COM_GetSubSensorDescriptor(uint8_t sID, uint8_t ssID)
{
    return &(COM_device.sensors[sID]->sensorDescriptor.subSensorDescriptor[ssID]);  
 800199c:	4b04      	ldr	r3, [pc, #16]	; (80019b0 <COM_GetSubSensorDescriptor+0x14>)
 800199e:	300a      	adds	r0, #10
 80019a0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80019a4:	2354      	movs	r3, #84	; 0x54
 80019a6:	6840      	ldr	r0, [r0, #4]
 80019a8:	fb03 0001 	mla	r0, r3, r1, r0
}
 80019ac:	305c      	adds	r0, #92	; 0x5c
 80019ae:	4770      	bx	lr
 80019b0:	20000338 	.word	0x20000338

080019b4 <COM_GetSubSensorNumber>:
* @param Sensor unique sID
* @retval number of subsensors
*/
uint8_t COM_GetSubSensorNumber(uint8_t sID)
{
    return COM_device.sensors[sID]->sensorDescriptor.nSubSensors;  
 80019b4:	4b03      	ldr	r3, [pc, #12]	; (80019c4 <COM_GetSubSensorNumber+0x10>)
 80019b6:	300a      	adds	r0, #10
 80019b8:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80019bc:	685b      	ldr	r3, [r3, #4]
}
 80019be:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
 80019c2:	4770      	bx	lr
 80019c4:	20000338 	.word	0x20000338

080019c8 <COM_IsOdrLegal>:

uint8_t COM_IsOdrLegal(float value, uint8_t sID)
{
  uint16_t i = 0;
  uint8_t ret = 0;
  float * list = COM_device.sensors[sID]->sensorDescriptor.ODR;
 80019c8:	4b12      	ldr	r3, [pc, #72]	; (8001a14 <COM_IsOdrLegal+0x4c>)
 80019ca:	300a      	adds	r0, #10
 80019cc:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  while(list[i] != COM_END_OF_LIST_FLOAT)
 80019d0:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
  float * list = COM_device.sensors[sID]->sensorDescriptor.ODR;
 80019d4:	6859      	ldr	r1, [r3, #4]
  while(list[i] != COM_END_OF_LIST_FLOAT)
 80019d6:	edd1 7a05 	vldr	s15, [r1, #20]
 80019da:	eef4 7a47 	vcmp.f32	s15, s14
 80019de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float * list = COM_device.sensors[sID]->sensorDescriptor.ODR;
 80019e2:	f101 0114 	add.w	r1, r1, #20
  uint8_t ret = 0;
 80019e6:	f04f 0000 	mov.w	r0, #0
  while(list[i] != COM_END_OF_LIST_FLOAT)
 80019ea:	d012      	beq.n	8001a12 <COM_IsOdrLegal+0x4a>
  uint16_t i = 0;
 80019ec:	4603      	mov	r3, r0
  {
    if(list[i] == value)
      ret = 1;
    i++;
 80019ee:	3301      	adds	r3, #1
 80019f0:	b29b      	uxth	r3, r3
  while(list[i] != COM_END_OF_LIST_FLOAT)
 80019f2:	eb01 0283 	add.w	r2, r1, r3, lsl #2
      ret = 1;
 80019f6:	eef4 7a40 	vcmp.f32	s15, s0
  while(list[i] != COM_END_OF_LIST_FLOAT)
 80019fa:	edd2 7a00 	vldr	s15, [r2]
      ret = 1;
 80019fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  while(list[i] != COM_END_OF_LIST_FLOAT)
 8001a02:	eef4 7a47 	vcmp.f32	s15, s14
      ret = 1;
 8001a06:	bf08      	it	eq
 8001a08:	2001      	moveq	r0, #1
  while(list[i] != COM_END_OF_LIST_FLOAT)
 8001a0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001a0e:	d1ee      	bne.n	80019ee <COM_IsOdrLegal+0x26>
 8001a10:	4770      	bx	lr
  }
  
  return ret;
}
 8001a12:	4770      	bx	lr
 8001a14:	20000338 	.word	0x20000338

08001a18 <set_default_description>:
* @brief Set default device description
* @param None
* @retval None
*/
void set_default_description(void)
{  
 8001a18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  COM_Sensor_t * tempSensor;
  COM_DeviceDescriptor_t * tempDeviceDescriptor;
  tempDeviceDescriptor = COM_GetDeviceDescriptor();
 8001a1a:	f7ff ffa1 	bl	8001960 <COM_GetDeviceDescriptor>
  deviceserial[1] = *(uint32_t*)DEVICE_ID_REG_2;
 8001a1e:	4a48      	ldr	r2, [pc, #288]	; (8001b40 <set_default_description+0x128>)
  deviceserial[0] = *(uint32_t*)DEVICE_ID_REG_1;
 8001a20:	4948      	ldr	r1, [pc, #288]	; (8001b44 <set_default_description+0x12c>)
  deviceserial[1] = *(uint32_t*)DEVICE_ID_REG_2;
 8001a22:	6812      	ldr	r2, [r2, #0]
  deviceserial[2] = *(uint32_t*)DEVICE_ID_REG_3; 
 8001a24:	4b48      	ldr	r3, [pc, #288]	; (8001b48 <set_default_description+0x130>)
  deviceserial[0] = *(uint32_t*)DEVICE_ID_REG_1;
 8001a26:	680e      	ldr	r6, [r1, #0]
  deviceserial[2] = *(uint32_t*)DEVICE_ID_REG_3; 
 8001a28:	681b      	ldr	r3, [r3, #0]
  n = sprintf(p, "%05u", x);
 8001a2a:	4d48      	ldr	r5, [pc, #288]	; (8001b4c <set_default_description+0x134>)
  n = sprintf(p, "%03u", waf_num);
 8001a2c:	4948      	ldr	r1, [pc, #288]	; (8001b50 <set_default_description+0x138>)
  
  /* SUBSENSOR 0 DESCRIPTOR */
  tempSensor->sensorDescriptor.subSensorDescriptor[0].id = 0;
  tempSensor->sensorDescriptor.subSensorDescriptor[0].sensorType = COM_TYPE_ACC; 
  tempSensor->sensorDescriptor.subSensorDescriptor[0].dataPerSample = 3;
  strcpy(tempSensor->sensorDescriptor.subSensorDescriptor[0].unit, "mg"); 
 8001a2e:	4f49      	ldr	r7, [pc, #292]	; (8001b54 <set_default_description+0x13c>)
  tempDeviceDescriptor = COM_GetDeviceDescriptor();
 8001a30:	4604      	mov	r4, r0
  id[0] = (deviceserial[1]>>8) & 0xFF;
 8001a32:	0a10      	lsrs	r0, r2, #8
 8001a34:	7020      	strb	r0, [r4, #0]
  id[1] = (deviceserial[1]>>16) & 0xFF;
 8001a36:	0c10      	lsrs	r0, r2, #16
 8001a38:	7060      	strb	r0, [r4, #1]
  id[2] = (deviceserial[1]>>24) & 0xFF;  
 8001a3a:	0e10      	lsrs	r0, r2, #24
 8001a3c:	70a0      	strb	r0, [r4, #2]
  id[4] = (deviceserial[2]>>8) & 0xFF;
 8001a3e:	0a18      	lsrs	r0, r3, #8
  id[3] = (deviceserial[2]) & 0xFF;
 8001a40:	70e3      	strb	r3, [r4, #3]
  id[4] = (deviceserial[2]>>8) & 0xFF;
 8001a42:	7120      	strb	r0, [r4, #4]
  id[5] = (deviceserial[2]>>16) & 0xFF;
 8001a44:	0c18      	lsrs	r0, r3, #16
  id[6] = (deviceserial[2]>>24) & 0xFF;
 8001a46:	0e1b      	lsrs	r3, r3, #24
 8001a48:	71a3      	strb	r3, [r4, #6]
  id[5] = (deviceserial[2]>>16) & 0xFF;
 8001a4a:	7160      	strb	r0, [r4, #5]
  n = sprintf(p, "%03u", waf_num);
 8001a4c:	b2d2      	uxtb	r2, r2
 8001a4e:	1de0      	adds	r0, r4, #7
 8001a50:	f014 ffda 	bl	8016a08 <siprintf>
  n = sprintf(p, "%05u", x);
 8001a54:	0c32      	lsrs	r2, r6, #16
 8001a56:	4629      	mov	r1, r5
 8001a58:	f104 000a 	add.w	r0, r4, #10
 8001a5c:	f014 ffd4 	bl	8016a08 <siprintf>
  n = sprintf(p, "%05u", y);
 8001a60:	b2b2      	uxth	r2, r6
 8001a62:	4629      	mov	r1, r5
 8001a64:	f104 000f 	add.w	r0, r4, #15
 8001a68:	f014 ffce 	bl	8016a08 <siprintf>
  strcpy(tempDeviceDescriptor->alias, "STWIN_001"); 
 8001a6c:	4b3a      	ldr	r3, [pc, #232]	; (8001b58 <set_default_description+0x140>)
  iis3dwb_com_id = COM_AddSensor();
 8001a6e:	4d3b      	ldr	r5, [pc, #236]	; (8001b5c <set_default_description+0x144>)
  tempSensor->sensorDescriptor.ODR[0] = 26667.0f;
 8001a70:	4e3b      	ldr	r6, [pc, #236]	; (8001b60 <set_default_description+0x148>)
  strcpy(tempDeviceDescriptor->alias, "STWIN_001"); 
 8001a72:	cb03      	ldmia	r3!, {r0, r1}
  *p = '\0';
 8001a74:	2200      	movs	r2, #0
  strcpy(tempDeviceDescriptor->alias, "STWIN_001"); 
 8001a76:	881b      	ldrh	r3, [r3, #0]
  *p = '\0';
 8001a78:	7522      	strb	r2, [r4, #20]
  strcpy(tempDeviceDescriptor->alias, "STWIN_001"); 
 8001a7a:	f8a4 301d 	strh.w	r3, [r4, #29]
 8001a7e:	f8c4 1019 	str.w	r1, [r4, #25]
 8001a82:	f8c4 0015 	str.w	r0, [r4, #21]
  iis3dwb_com_id = COM_AddSensor();
 8001a86:	f7ff ff4b 	bl	8001920 <COM_AddSensor>
 8001a8a:	b2c0      	uxtb	r0, r0
 8001a8c:	7028      	strb	r0, [r5, #0]
  tempSensor = COM_GetSensor(iis3dwb_com_id);
 8001a8e:	f7ff ff6b 	bl	8001968 <COM_GetSensor>
  strcpy(tempSensor->sensorDescriptor.name, "IIS3DWB"); 
 8001a92:	4a34      	ldr	r2, [pc, #208]	; (8001b64 <set_default_description+0x14c>)
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[4] = COM_END_OF_LIST_FLOAT;
  
  /* SUBSENSOR 0 STATUS */
  tempSensor->sensorStatus.subSensorStatus[0].FS = 16.0f;						// Grprozess sensor
  tempSensor->sensorStatus.subSensorStatus[0].isActive = 1;
  tempSensor->sensorStatus.subSensorStatus[0].sensitivity = 0.061f *  tempSensor->sensorStatus.subSensorStatus[0].FS/2;			// Grprozess sensor 0.48800000548362732
 8001a94:	4c34      	ldr	r4, [pc, #208]	; (8001b68 <set_default_description+0x150>)
  tempSensor = COM_GetSensor(iis3dwb_com_id);
 8001a96:	4603      	mov	r3, r0
  strcpy(tempSensor->sensorDescriptor.name, "IIS3DWB"); 
 8001a98:	ca03      	ldmia	r2!, {r0, r1}
  tempSensor->sensorDescriptor.samplesPerTimestamp[0] = 0;
 8001a9a:	f04f 727a 	mov.w	r2, #65536000	; 0x3e80000
 8001a9e:	655a      	str	r2, [r3, #84]	; 0x54
  tempSensor->sensorStatus.samplesPerTimestamp = 1000;
 8001aa0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001aa4:	f8a3 21b8 	strh.w	r2, [r3, #440]	; 0x1b8
  tempSensor->sensorStatus.usbDataPacketSize = 3000;
 8001aa8:	f640 32b8 	movw	r2, #3000	; 0xbb8
 8001aac:	f8a3 21bc 	strh.w	r2, [r3, #444]	; 0x1bc
  tempSensor->sensorStatus.sdWriteBufferSize = WRITE_BUFFER_SIZE_IIS3DWB;
 8001ab0:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
 8001ab4:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
  n = sprintf(p, "%05u", y);
 8001ab8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  tempSensor->sensorStatus.comChannelNumber = -1;
 8001abc:	f8a3 21c4 	strh.w	r2, [r3, #452]	; 0x1c4
  tempSensor->sensorDescriptor.subSensorDescriptor[0].id = 0;
 8001ac0:	f44f 7280 	mov.w	r2, #256	; 0x100
  strcpy(tempSensor->sensorDescriptor.name, "IIS3DWB"); 
 8001ac4:	f8c3 1005 	str.w	r1, [r3, #5]
  tempSensor->sensorDescriptor.subSensorDescriptor[0].id = 0;
 8001ac8:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
  strcpy(tempSensor->sensorDescriptor.subSensorDescriptor[0].unit, "mg"); 
 8001acc:	8839      	ldrh	r1, [r7, #0]
 8001ace:	78ba      	ldrb	r2, [r7, #2]
 8001ad0:	f8a3 105f 	strh.w	r1, [r3, #95]	; 0x5f
 8001ad4:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[0] = 2.0f; 
 8001ad8:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[1] = 4.0f;
 8001adc:	f04f 4281 	mov.w	r2, #1082130432	; 0x40800000
  tempSensor->sensorStatus.subSensorStatus[0].sensitivity = 0.061f *  tempSensor->sensorStatus.subSensorStatus[0].FS/2;			// Grprozess sensor 0.48800000548362732
 8001ae0:	f8c3 41cc 	str.w	r4, [r3, #460]	; 0x1cc
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[0] = 2.0f; 
 8001ae4:	6719      	str	r1, [r3, #112]	; 0x70

  IIS3DWB_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001ae6:	4c21      	ldr	r4, [pc, #132]	; (8001b6c <set_default_description+0x154>)
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[1] = 4.0f;
 8001ae8:	675a      	str	r2, [r3, #116]	; 0x74
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[2] = 8.0f;
 8001aea:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
  tempSensor->sensorDescriptor.dataType = DATA_TYPE_INT16;
 8001aee:	2203      	movs	r2, #3
  strcpy(tempSensor->sensorDescriptor.name, "IIS3DWB"); 
 8001af0:	f8c3 0001 	str.w	r0, [r3, #1]
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[2] = 8.0f;
 8001af4:	6799      	str	r1, [r3, #120]	; 0x78
  tempSensor->sensorDescriptor.dataType = DATA_TYPE_INT16;
 8001af6:	745a      	strb	r2, [r3, #17]
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[3] = 16.0f;
 8001af8:	f04f 4183 	mov.w	r1, #1098907648	; 0x41800000
  tempSensor->sensorDescriptor.subSensorDescriptor[0].dataPerSample = 3;
 8001afc:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
  tempSensor->sensorDescriptor.ODR[1] = COM_END_OF_LIST_FLOAT;  /* Terminate list */
 8001b00:	4f1b      	ldr	r7, [pc, #108]	; (8001b70 <set_default_description+0x158>)
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[3] = 16.0f;
 8001b02:	67d9      	str	r1, [r3, #124]	; 0x7c
  tempSensor->sensorDescriptor.nSubSensors = 1;
 8001b04:	2201      	movs	r2, #1
  tempSensor->sensorStatus.measuredODR = 0.0f;
 8001b06:	2000      	movs	r0, #0
  tempSensor->sensorDescriptor.nSubSensors = 1;
 8001b08:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
  tempSensor->sensorStatus.isActive = 1;
 8001b0c:	f883 21ba 	strb.w	r2, [r3, #442]	; 0x1ba
  tempSensor->sensorStatus.subSensorStatus[0].isActive = 1;
 8001b10:	f883 21d0 	strb.w	r2, [r3, #464]	; 0x1d0
  tempSensor->sensorStatus.subSensorStatus[0].FS = 16.0f;						// Grprozess sensor
 8001b14:	f8c3 11c8 	str.w	r1, [r3, #456]	; 0x1c8
  tempSensor->sensorDescriptor.ODR[0] = 26667.0f;
 8001b18:	615e      	str	r6, [r3, #20]
  tempSensor->sensorStatus.ODR = 26667.0f;
 8001b1a:	f8c3 61ac 	str.w	r6, [r3, #428]	; 0x1ac
  tempSensor->sensorDescriptor.ODR[1] = COM_END_OF_LIST_FLOAT;  /* Terminate list */
 8001b1e:	619f      	str	r7, [r3, #24]
  tempSensor->sensorDescriptor.subSensorDescriptor[0].FS[4] = COM_END_OF_LIST_FLOAT;
 8001b20:	f8c3 7080 	str.w	r7, [r3, #128]	; 0x80
  tempSensor->sensorStatus.measuredODR = 0.0f;
 8001b24:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
  tempSensor->sensorStatus.initialOffset = 0.0f;
 8001b28:	f8c3 01b4 	str.w	r0, [r3, #436]	; 0x1b4
  IIS3DWB_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001b2c:	6026      	str	r6, [r4, #0]
  IIS3DWB_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  IIS3DWB_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
  
  maxWriteTimeSensor[iis3dwb_com_id] = 1000 * WRITE_BUFFER_SIZE_IIS3DWB / (uint32_t)(IIS3DWB_Init_Param.ODR * 6); 
 8001b2e:	4b11      	ldr	r3, [pc, #68]	; (8001b74 <set_default_description+0x15c>)
  IIS3DWB_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001b30:	6061      	str	r1, [r4, #4]
  maxWriteTimeSensor[iis3dwb_com_id] = 1000 * WRITE_BUFFER_SIZE_IIS3DWB / (uint32_t)(IIS3DWB_Init_Param.ODR * 6); 
 8001b32:	7829      	ldrb	r1, [r5, #0]
  IIS3DWB_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001b34:	7522      	strb	r2, [r4, #20]
  maxWriteTimeSensor[iis3dwb_com_id] = 1000 * WRITE_BUFFER_SIZE_IIS3DWB / (uint32_t)(IIS3DWB_Init_Param.ODR * 6); 
 8001b36:	22c7      	movs	r2, #199	; 0xc7
 8001b38:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
  STTS751_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  STTS751_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  

  maxWriteTimeSensor[stts751_com_id] = 1000 * WRITE_BUFFER_SIZE_STTS751 / (uint32_t)(STTS751_Init_Param.ODR * 4); 
#endif
}
 8001b3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001b3e:	bf00      	nop
 8001b40:	1fff7594 	.word	0x1fff7594
 8001b44:	1fff7590 	.word	0x1fff7590
 8001b48:	1fff7598 	.word	0x1fff7598
 8001b4c:	0801a8fc 	.word	0x0801a8fc
 8001b50:	0801a8f4 	.word	0x0801a8f4
 8001b54:	0801a918 	.word	0x0801a918
 8001b58:	0801a904 	.word	0x0801a904
 8001b5c:	20017291 	.word	0x20017291
 8001b60:	46d05600 	.word	0x46d05600
 8001b64:	0801a910 	.word	0x0801a910
 8001b68:	3ef9db23 	.word	0x3ef9db23
 8001b6c:	20010e3c 	.word	0x20010e3c
 8001b70:	bf800000 	.word	0xbf800000
 8001b74:	20016f98 	.word	0x20016f98

08001b78 <update_sensorStatus>:

void update_sensorStatus(COM_SensorStatus_t * oldSensorStatus, COM_SensorStatus_t * newSensorStatus, uint8_t sID)
{
  /* Check differencies between oldSensorStatus and newSensorStatus, act properly*/
  /* ODR */
  if(oldSensorStatus->ODR != newSensorStatus->ODR)
 8001b78:	ed91 0a00 	vldr	s0, [r1]
 8001b7c:	edd0 7a00 	vldr	s15, [r0]
 8001b80:	eef4 7a40 	vcmp.f32	s15, s0
 8001b84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 8001b88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001b8c:	4604      	mov	r4, r0
 8001b8e:	460d      	mov	r5, r1
 8001b90:	4616      	mov	r6, r2
  if(oldSensorStatus->ODR != newSensorStatus->ODR)
 8001b92:	f040 80f2 	bne.w	8001d7a <update_sensorStatus+0x202>
      oldSensorStatus->ODR = newSensorStatus->ODR; /* Todo Setters and getters */
    }
  }
  
  /* isActive */
  if(oldSensorStatus->isActive != newSensorStatus->isActive)
 8001b96:	7bab      	ldrb	r3, [r5, #14]
 8001b98:	7ba2      	ldrb	r2, [r4, #14]
 8001b9a:	429a      	cmp	r2, r3
  {
    oldSensorStatus->isActive = newSensorStatus->isActive;
 8001b9c:	bf18      	it	ne
 8001b9e:	73a3      	strbne	r3, [r4, #14]
  }
  
  /* subsensor: FS, is Active*/
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001ba0:	4630      	mov	r0, r6
 8001ba2:	f7ff ff07 	bl	80019b4 <COM_GetSubSensorNumber>
 8001ba6:	2800      	cmp	r0, #0
 8001ba8:	f000 809b 	beq.w	8001ce2 <update_sensorStatus+0x16a>
  {
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001bac:	edd5 7a07 	vldr	s15, [r5, #28]
 8001bb0:	ed94 7a07 	vldr	s14, [r4, #28]
    {
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
    }
    
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001bb4:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001bb8:	eef4 7a47 	vcmp.f32	s15, s14
 8001bbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
 8001bc0:	bf18      	it	ne
 8001bc2:	edc4 7a07 	vstrne	s15, [r4, #28]
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001bc6:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 8001bca:	429a      	cmp	r2, r3
    {
      oldSensorStatus->subSensorStatus[i].isActive = newSensorStatus->subSensorStatus[i].isActive; /* Todo Setters and getters */
 8001bcc:	bf18      	it	ne
 8001bce:	f884 3024 	strbne.w	r3, [r4, #36]	; 0x24
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001bd2:	4630      	mov	r0, r6
 8001bd4:	f7ff feee 	bl	80019b4 <COM_GetSubSensorNumber>
 8001bd8:	2801      	cmp	r0, #1
 8001bda:	f240 8082 	bls.w	8001ce2 <update_sensorStatus+0x16a>
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001bde:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8001be2:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001be6:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001bea:	eeb4 7a67 	vcmp.f32	s14, s15
 8001bee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
 8001bf2:	bf18      	it	ne
 8001bf4:	edc4 7a0a 	vstrne	s15, [r4, #40]	; 0x28
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001bf8:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 8001bfc:	429a      	cmp	r2, r3
      oldSensorStatus->subSensorStatus[i].isActive = newSensorStatus->subSensorStatus[i].isActive; /* Todo Setters and getters */
 8001bfe:	bf18      	it	ne
 8001c00:	f884 3030 	strbne.w	r3, [r4, #48]	; 0x30
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001c04:	4630      	mov	r0, r6
 8001c06:	f7ff fed5 	bl	80019b4 <COM_GetSubSensorNumber>
 8001c0a:	2802      	cmp	r0, #2
 8001c0c:	d969      	bls.n	8001ce2 <update_sensorStatus+0x16a>
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001c0e:	edd5 7a0d 	vldr	s15, [r5, #52]	; 0x34
 8001c12:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001c16:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001c1a:	eeb4 7a67 	vcmp.f32	s14, s15
 8001c1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
 8001c22:	bf18      	it	ne
 8001c24:	edc4 7a0d 	vstrne	s15, [r4, #52]	; 0x34
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001c28:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
 8001c2c:	429a      	cmp	r2, r3
      oldSensorStatus->subSensorStatus[i].isActive = newSensorStatus->subSensorStatus[i].isActive; /* Todo Setters and getters */
 8001c2e:	bf18      	it	ne
 8001c30:	f884 303c 	strbne.w	r3, [r4, #60]	; 0x3c
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001c34:	4630      	mov	r0, r6
 8001c36:	f7ff febd 	bl	80019b4 <COM_GetSubSensorNumber>
 8001c3a:	2803      	cmp	r0, #3
 8001c3c:	d951      	bls.n	8001ce2 <update_sensorStatus+0x16a>
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001c3e:	edd5 7a10 	vldr	s15, [r5, #64]	; 0x40
 8001c42:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001c46:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001c4a:	eeb4 7a67 	vcmp.f32	s14, s15
 8001c4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
 8001c52:	bf18      	it	ne
 8001c54:	edc4 7a10 	vstrne	s15, [r4, #64]	; 0x40
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001c58:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 8001c5c:	429a      	cmp	r2, r3
      oldSensorStatus->subSensorStatus[i].isActive = newSensorStatus->subSensorStatus[i].isActive; /* Todo Setters and getters */
 8001c5e:	bf18      	it	ne
 8001c60:	f884 3048 	strbne.w	r3, [r4, #72]	; 0x48
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001c64:	4630      	mov	r0, r6
 8001c66:	f7ff fea5 	bl	80019b4 <COM_GetSubSensorNumber>
 8001c6a:	2804      	cmp	r0, #4
 8001c6c:	d939      	bls.n	8001ce2 <update_sensorStatus+0x16a>
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001c6e:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
 8001c72:	ed94 7a13 	vldr	s14, [r4, #76]	; 0x4c
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001c76:	f894 2054 	ldrb.w	r2, [r4, #84]	; 0x54
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001c7a:	eeb4 7a67 	vcmp.f32	s14, s15
 8001c7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
 8001c82:	bf18      	it	ne
 8001c84:	edc4 7a13 	vstrne	s15, [r4, #76]	; 0x4c
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001c88:	f895 3054 	ldrb.w	r3, [r5, #84]	; 0x54
 8001c8c:	429a      	cmp	r2, r3
      oldSensorStatus->subSensorStatus[i].isActive = newSensorStatus->subSensorStatus[i].isActive; /* Todo Setters and getters */
 8001c8e:	bf18      	it	ne
 8001c90:	f884 3054 	strbne.w	r3, [r4, #84]	; 0x54
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001c94:	4630      	mov	r0, r6
 8001c96:	f7ff fe8d 	bl	80019b4 <COM_GetSubSensorNumber>
 8001c9a:	f04f 0905 	mov.w	r9, #5
 8001c9e:	4548      	cmp	r0, r9
 8001ca0:	4627      	mov	r7, r4
 8001ca2:	46a8      	mov	r8, r5
 8001ca4:	dd1d      	ble.n	8001ce2 <update_sensorStatus+0x16a>
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001ca6:	edd8 7a16 	vldr	s15, [r8, #88]	; 0x58
 8001caa:	ed97 7a16 	vldr	s14, [r7, #88]	; 0x58
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001cae:	f897 2060 	ldrb.w	r2, [r7, #96]	; 0x60
    if(oldSensorStatus->subSensorStatus[i].FS != newSensorStatus->subSensorStatus[i].FS)
 8001cb2:	eeb4 7a67 	vcmp.f32	s14, s15
 8001cb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      oldSensorStatus->subSensorStatus[i].FS = newSensorStatus->subSensorStatus[i].FS; /* Todo Setters and getters */
 8001cba:	bf18      	it	ne
 8001cbc:	edc7 7a16 	vstrne	s15, [r7, #88]	; 0x58
    if(oldSensorStatus->subSensorStatus[i].isActive != newSensorStatus->subSensorStatus[i].isActive)
 8001cc0:	f898 3060 	ldrb.w	r3, [r8, #96]	; 0x60
 8001cc4:	429a      	cmp	r2, r3
      oldSensorStatus->subSensorStatus[i].isActive = newSensorStatus->subSensorStatus[i].isActive; /* Todo Setters and getters */
 8001cc6:	bf18      	it	ne
 8001cc8:	f887 3060 	strbne.w	r3, [r7, #96]	; 0x60
  for (int i = 0; i < COM_GetSubSensorNumber(sID); i++)
 8001ccc:	4630      	mov	r0, r6
 8001cce:	f7ff fe71 	bl	80019b4 <COM_GetSubSensorNumber>
 8001cd2:	f109 0901 	add.w	r9, r9, #1
 8001cd6:	4548      	cmp	r0, r9
 8001cd8:	f107 070c 	add.w	r7, r7, #12
 8001cdc:	f108 080c 	add.w	r8, r8, #12
 8001ce0:	dce1      	bgt.n	8001ca6 <update_sensorStatus+0x12e>
    }
  }
  
  if (sID == iis3dwb_com_id)
 8001ce2:	4b30      	ldr	r3, [pc, #192]	; (8001da4 <update_sensorStatus+0x22c>)
 8001ce4:	781b      	ldrb	r3, [r3, #0]
 8001ce6:	42b3      	cmp	r3, r6
 8001ce8:	d03a      	beq.n	8001d60 <update_sensorStatus+0x1e8>
  {
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
  }
  else if (sID == iis2dh_com_id)
 8001cea:	4b2f      	ldr	r3, [pc, #188]	; (8001da8 <update_sensorStatus+0x230>)
 8001cec:	781b      	ldrb	r3, [r3, #0]
 8001cee:	42b3      	cmp	r3, r6
 8001cf0:	d029      	beq.n	8001d46 <update_sensorStatus+0x1ce>
    else
    {
      oldSensorStatus->subSensorStatus[0].sensitivity = 0.0625f *  oldSensorStatus->subSensorStatus[0].FS/2;
    }
  }
  else if (sID == ism330dhcx_com_id)
 8001cf2:	4b2e      	ldr	r3, [pc, #184]	; (8001dac <update_sensorStatus+0x234>)
 8001cf4:	781b      	ldrb	r3, [r3, #0]
 8001cf6:	42b3      	cmp	r3, r6
 8001cf8:	d117      	bne.n	8001d2a <update_sensorStatus+0x1b2>
  {        
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
    oldSensorStatus->subSensorStatus[1].sensitivity = 4.375f * oldSensorStatus->subSensorStatus[1].FS/125.0f;
 8001cfa:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
 8001cfe:	eddf 5a2c 	vldr	s11, [pc, #176]	; 8001db0 <update_sensorStatus+0x238>
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d02:	eddf 6a2c 	vldr	s13, [pc, #176]	; 8001db4 <update_sensorStatus+0x23c>
    oldSensorStatus->subSensorStatus[1].sensitivity = 4.375f * oldSensorStatus->subSensorStatus[1].FS/125.0f;
 8001d06:	ed9f 6a2c 	vldr	s12, [pc, #176]	; 8001db8 <update_sensorStatus+0x240>
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d0a:	edd4 7a07 	vldr	s15, [r4, #28]
    oldSensorStatus->subSensorStatus[1].sensitivity = 4.375f * oldSensorStatus->subSensorStatus[1].FS/125.0f;
 8001d0e:	ee27 7a25 	vmul.f32	s14, s14, s11
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d12:	ee67 7aa6 	vmul.f32	s15, s15, s13
    oldSensorStatus->subSensorStatus[1].sensitivity = 4.375f * oldSensorStatus->subSensorStatus[1].FS/125.0f;
 8001d16:	eec7 6a06 	vdiv.f32	s13, s14, s12
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d1a:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8001d1e:	ee67 7a87 	vmul.f32	s15, s15, s14
    oldSensorStatus->subSensorStatus[1].sensitivity = 4.375f * oldSensorStatus->subSensorStatus[1].FS/125.0f;
 8001d22:	edc4 6a0b 	vstr	s13, [r4, #44]	; 0x2c
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d26:	edc4 7a08 	vstr	s15, [r4, #32]
  }
  
  /* CHANNEL NUMBER */
  if(oldSensorStatus->comChannelNumber != newSensorStatus->comChannelNumber)
 8001d2a:	f9b5 3018 	ldrsh.w	r3, [r5, #24]
 8001d2e:	f9b4 2018 	ldrsh.w	r2, [r4, #24]
 8001d32:	429a      	cmp	r2, r3
  {
    oldSensorStatus->comChannelNumber = newSensorStatus->comChannelNumber; /* Todo Setters and getters */         
 8001d34:	bf18      	it	ne
 8001d36:	8323      	strhne	r3, [r4, #24]
  }  
  
   /* CHANNEL NUMBER */
  if(oldSensorStatus->samplesPerTimestamp != newSensorStatus->samplesPerTimestamp)
 8001d38:	89a2      	ldrh	r2, [r4, #12]
 8001d3a:	89ab      	ldrh	r3, [r5, #12]
 8001d3c:	429a      	cmp	r2, r3
  {
    oldSensorStatus->samplesPerTimestamp = newSensorStatus->samplesPerTimestamp; /* Todo Setters and getters */         
 8001d3e:	bf18      	it	ne
 8001d40:	81a3      	strhne	r3, [r4, #12]
  }  
}
 8001d42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (oldSensorStatus->subSensorStatus[0].FS == 16.0f)
 8001d46:	edd4 7a07 	vldr	s15, [r4, #28]
 8001d4a:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
 8001d4e:	eef4 7a47 	vcmp.f32	s15, s14
 8001d52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001d56:	d119      	bne.n	8001d8c <update_sensorStatus+0x214>
      oldSensorStatus->subSensorStatus[0].sensitivity = 0.75f;
 8001d58:	f04f 537d 	mov.w	r3, #1061158912	; 0x3f400000
 8001d5c:	6223      	str	r3, [r4, #32]
 8001d5e:	e7e4      	b.n	8001d2a <update_sensorStatus+0x1b2>
    oldSensorStatus->subSensorStatus[0].sensitivity = 0.061f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d60:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8001db4 <update_sensorStatus+0x23c>
 8001d64:	edd4 7a07 	vldr	s15, [r4, #28]
 8001d68:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001d6c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8001d70:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001d74:	edc4 7a08 	vstr	s15, [r4, #32]
 8001d78:	e7d7      	b.n	8001d2a <update_sensorStatus+0x1b2>
    if(COM_IsOdrLegal(newSensorStatus->ODR, sID))
 8001d7a:	4610      	mov	r0, r2
 8001d7c:	f7ff fe24 	bl	80019c8 <COM_IsOdrLegal>
 8001d80:	2800      	cmp	r0, #0
 8001d82:	f43f af08 	beq.w	8001b96 <update_sensorStatus+0x1e>
      oldSensorStatus->ODR = newSensorStatus->ODR; /* Todo Setters and getters */
 8001d86:	682b      	ldr	r3, [r5, #0]
 8001d88:	6023      	str	r3, [r4, #0]
 8001d8a:	e704      	b.n	8001b96 <update_sensorStatus+0x1e>
      oldSensorStatus->subSensorStatus[0].sensitivity = 0.0625f *  oldSensorStatus->subSensorStatus[0].FS/2;
 8001d8c:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8001dbc <update_sensorStatus+0x244>
 8001d90:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001d94:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8001d98:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001d9c:	edc4 7a08 	vstr	s15, [r4, #32]
 8001da0:	e7c3      	b.n	8001d2a <update_sensorStatus+0x1b2>
 8001da2:	bf00      	nop
 8001da4:	20017291 	.word	0x20017291
 8001da8:	20016fc0 	.word	0x20016fc0
 8001dac:	20016f96 	.word	0x20016f96
 8001db0:	408c0000 	.word	0x408c0000
 8001db4:	3d79db23 	.word	0x3d79db23
 8001db8:	42fa0000 	.word	0x42fa0000
 8001dbc:	3d800000 	.word	0x3d800000

08001dc0 <update_sensors_config>:

void update_sensors_config(void)
{  
 8001dc0:	b538      	push	{r3, r4, r5, lr}
  COM_Sensor_t * tempSensor;  
  
  tempSensor = COM_GetSensor(iis3dwb_com_id);  
 8001dc2:	4b4a      	ldr	r3, [pc, #296]	; (8001eec <update_sensors_config+0x12c>)
  IIS3DWB_Init_Param.ODR = tempSensor->sensorStatus.ODR;
  IIS3DWB_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  IIS3DWB_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
  
  tempSensor = COM_GetSensor(hts221_com_id);
 8001dc4:	4d4a      	ldr	r5, [pc, #296]	; (8001ef0 <update_sensors_config+0x130>)
  tempSensor = COM_GetSensor(iis3dwb_com_id);  
 8001dc6:	7818      	ldrb	r0, [r3, #0]
 8001dc8:	f7ff fdce 	bl	8001968 <COM_GetSensor>
  IIS3DWB_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001dcc:	4b49      	ldr	r3, [pc, #292]	; (8001ef4 <update_sensors_config+0x134>)
 8001dce:	f8d0 41ac 	ldr.w	r4, [r0, #428]	; 0x1ac
  IIS3DWB_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001dd2:	f8d0 11c8 	ldr.w	r1, [r0, #456]	; 0x1c8
  IIS3DWB_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001dd6:	f890 21d0 	ldrb.w	r2, [r0, #464]	; 0x1d0
  tempSensor = COM_GetSensor(hts221_com_id);
 8001dda:	7828      	ldrb	r0, [r5, #0]
  IIS3DWB_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001ddc:	601c      	str	r4, [r3, #0]
  IIS3DWB_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001dde:	6059      	str	r1, [r3, #4]
  IIS3DWB_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001de0:	751a      	strb	r2, [r3, #20]
  tempSensor = COM_GetSensor(hts221_com_id);
 8001de2:	f7ff fdc1 	bl	8001968 <COM_GetSensor>
 8001de6:	4603      	mov	r3, r0
  HTS221_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001de8:	4a43      	ldr	r2, [pc, #268]	; (8001ef8 <update_sensors_config+0x138>)
  HTS221_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  HTS221_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
  HTS221_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
  HTS221_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive;
  
  tempSensor = COM_GetSensor(iis2dh_com_id);
 8001dea:	4844      	ldr	r0, [pc, #272]	; (8001efc <update_sensors_config+0x13c>)
  HTS221_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001dec:	f8d3 11ac 	ldr.w	r1, [r3, #428]	; 0x1ac
  HTS221_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001df0:	f8d3 51c8 	ldr.w	r5, [r3, #456]	; 0x1c8
  HTS221_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
 8001df4:	f8d3 41d4 	ldr.w	r4, [r3, #468]	; 0x1d4
  HTS221_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001df8:	6011      	str	r1, [r2, #0]
  tempSensor = COM_GetSensor(iis2dh_com_id);
 8001dfa:	7800      	ldrb	r0, [r0, #0]
  HTS221_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001dfc:	f893 11d0 	ldrb.w	r1, [r3, #464]	; 0x1d0
  HTS221_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive;
 8001e00:	f893 31dc 	ldrb.w	r3, [r3, #476]	; 0x1dc
  HTS221_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e04:	6055      	str	r5, [r2, #4]
  HTS221_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
 8001e06:	6094      	str	r4, [r2, #8]
  HTS221_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001e08:	7511      	strb	r1, [r2, #20]
  HTS221_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive;
 8001e0a:	7553      	strb	r3, [r2, #21]
  tempSensor = COM_GetSensor(iis2dh_com_id);
 8001e0c:	f7ff fdac 	bl	8001968 <COM_GetSensor>
  IIS2DH_Init_Param.ODR = tempSensor->sensorStatus.ODR;
  IIS2DH_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  IIS2DH_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
  
  tempSensor = COM_GetSensor(iis2mdc_com_id);
 8001e10:	4d3b      	ldr	r5, [pc, #236]	; (8001f00 <update_sensors_config+0x140>)
  IIS2DH_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e12:	4b3c      	ldr	r3, [pc, #240]	; (8001f04 <update_sensors_config+0x144>)
 8001e14:	f8d0 41ac 	ldr.w	r4, [r0, #428]	; 0x1ac
  IIS2DH_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e18:	f8d0 11c8 	ldr.w	r1, [r0, #456]	; 0x1c8
  IIS2DH_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001e1c:	f890 21d0 	ldrb.w	r2, [r0, #464]	; 0x1d0
  tempSensor = COM_GetSensor(iis2mdc_com_id);
 8001e20:	7828      	ldrb	r0, [r5, #0]
  IIS2DH_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e22:	601c      	str	r4, [r3, #0]
  IIS2DH_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e24:	6059      	str	r1, [r3, #4]
  IIS2DH_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001e26:	751a      	strb	r2, [r3, #20]
  tempSensor = COM_GetSensor(iis2mdc_com_id);
 8001e28:	f7ff fd9e 	bl	8001968 <COM_GetSensor>
  IIS2MDC_Init_Param.ODR = tempSensor->sensorStatus.ODR;
  IIS2MDC_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  IIS2MDC_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
  
  tempSensor = COM_GetSensor(imp34dt05_com_id);
 8001e2c:	4d36      	ldr	r5, [pc, #216]	; (8001f08 <update_sensors_config+0x148>)
  IIS2MDC_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e2e:	4b37      	ldr	r3, [pc, #220]	; (8001f0c <update_sensors_config+0x14c>)
 8001e30:	f8d0 41ac 	ldr.w	r4, [r0, #428]	; 0x1ac
  IIS2MDC_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e34:	f8d0 11c8 	ldr.w	r1, [r0, #456]	; 0x1c8
  IIS2MDC_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001e38:	f890 21d0 	ldrb.w	r2, [r0, #464]	; 0x1d0
  tempSensor = COM_GetSensor(imp34dt05_com_id);
 8001e3c:	7828      	ldrb	r0, [r5, #0]
  IIS2MDC_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e3e:	601c      	str	r4, [r3, #0]
  IIS2MDC_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e40:	6059      	str	r1, [r3, #4]
  IIS2MDC_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001e42:	751a      	strb	r2, [r3, #20]
  tempSensor = COM_GetSensor(imp34dt05_com_id);
 8001e44:	f7ff fd90 	bl	8001968 <COM_GetSensor>
  IMP34DT05_Init_Param.ODR = tempSensor->sensorStatus.ODR;
  IMP34DT05_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  IMP34DT05_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
  
  tempSensor = COM_GetSensor(ism330dhcx_com_id);
 8001e48:	4d31      	ldr	r5, [pc, #196]	; (8001f10 <update_sensors_config+0x150>)
  IMP34DT05_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e4a:	4b32      	ldr	r3, [pc, #200]	; (8001f14 <update_sensors_config+0x154>)
 8001e4c:	f8d0 41ac 	ldr.w	r4, [r0, #428]	; 0x1ac
  IMP34DT05_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e50:	f8d0 11c8 	ldr.w	r1, [r0, #456]	; 0x1c8
  IMP34DT05_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001e54:	f890 21d0 	ldrb.w	r2, [r0, #464]	; 0x1d0
  tempSensor = COM_GetSensor(ism330dhcx_com_id);
 8001e58:	7828      	ldrb	r0, [r5, #0]
  IMP34DT05_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e5a:	601c      	str	r4, [r3, #0]
  IMP34DT05_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e5c:	6059      	str	r1, [r3, #4]
  IMP34DT05_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001e5e:	751a      	strb	r2, [r3, #20]
  tempSensor = COM_GetSensor(ism330dhcx_com_id);
 8001e60:	f7ff fd82 	bl	8001968 <COM_GetSensor>
 8001e64:	4603      	mov	r3, r0
  ISM330DHCX_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e66:	4a2c      	ldr	r2, [pc, #176]	; (8001f18 <update_sensors_config+0x158>)
  ISM330DHCX_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  ISM330DHCX_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
  ISM330DHCX_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
  ISM330DHCX_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive;
  
  tempSensor = COM_GetSensor(lps22hh_com_id);
 8001e68:	482c      	ldr	r0, [pc, #176]	; (8001f1c <update_sensors_config+0x15c>)
  ISM330DHCX_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e6a:	f8d3 11ac 	ldr.w	r1, [r3, #428]	; 0x1ac
  ISM330DHCX_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e6e:	f8d3 51c8 	ldr.w	r5, [r3, #456]	; 0x1c8
  ISM330DHCX_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
 8001e72:	f8d3 41d4 	ldr.w	r4, [r3, #468]	; 0x1d4
  ISM330DHCX_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e76:	6011      	str	r1, [r2, #0]
  tempSensor = COM_GetSensor(lps22hh_com_id);
 8001e78:	7800      	ldrb	r0, [r0, #0]
  ISM330DHCX_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001e7a:	f893 11d0 	ldrb.w	r1, [r3, #464]	; 0x1d0
  ISM330DHCX_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive;
 8001e7e:	f893 31dc 	ldrb.w	r3, [r3, #476]	; 0x1dc
  ISM330DHCX_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e82:	6055      	str	r5, [r2, #4]
  ISM330DHCX_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
 8001e84:	6094      	str	r4, [r2, #8]
  ISM330DHCX_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001e86:	7511      	strb	r1, [r2, #20]
  ISM330DHCX_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive;
 8001e88:	7553      	strb	r3, [r2, #21]
  tempSensor = COM_GetSensor(lps22hh_com_id);
 8001e8a:	f7ff fd6d 	bl	8001968 <COM_GetSensor>
 8001e8e:	4603      	mov	r3, r0
  LPS22HH_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e90:	4a23      	ldr	r2, [pc, #140]	; (8001f20 <update_sensors_config+0x160>)
  LPS22HH_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  LPS22HH_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
  LPS22HH_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
  LPS22HH_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive; 
  
  tempSensor = COM_GetSensor(mp23abs1_com_id);
 8001e92:	4824      	ldr	r0, [pc, #144]	; (8001f24 <update_sensors_config+0x164>)
  LPS22HH_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001e94:	f8d3 11ac 	ldr.w	r1, [r3, #428]	; 0x1ac
  LPS22HH_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001e98:	f8d3 51c8 	ldr.w	r5, [r3, #456]	; 0x1c8
  LPS22HH_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
 8001e9c:	f8d3 41d4 	ldr.w	r4, [r3, #468]	; 0x1d4
  LPS22HH_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001ea0:	6011      	str	r1, [r2, #0]
  tempSensor = COM_GetSensor(mp23abs1_com_id);
 8001ea2:	7800      	ldrb	r0, [r0, #0]
  LPS22HH_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001ea4:	f893 11d0 	ldrb.w	r1, [r3, #464]	; 0x1d0
  LPS22HH_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive; 
 8001ea8:	f893 31dc 	ldrb.w	r3, [r3, #476]	; 0x1dc
  LPS22HH_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001eac:	6055      	str	r5, [r2, #4]
  LPS22HH_Init_Param.FS[1] = tempSensor->sensorStatus.subSensorStatus[1].FS;
 8001eae:	6094      	str	r4, [r2, #8]
  LPS22HH_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;
 8001eb0:	7511      	strb	r1, [r2, #20]
  LPS22HH_Init_Param.subSensorActive[1] = tempSensor->sensorStatus.subSensorStatus[1].isActive; 
 8001eb2:	7553      	strb	r3, [r2, #21]
  tempSensor = COM_GetSensor(mp23abs1_com_id);
 8001eb4:	f7ff fd58 	bl	8001968 <COM_GetSensor>
  MP23ABS1_Init_Param.ODR = tempSensor->sensorStatus.ODR;
  MP23ABS1_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  MP23ABS1_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
  
  tempSensor = COM_GetSensor(stts751_com_id);
 8001eb8:	4d1b      	ldr	r5, [pc, #108]	; (8001f28 <update_sensors_config+0x168>)
  MP23ABS1_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001eba:	4b1c      	ldr	r3, [pc, #112]	; (8001f2c <update_sensors_config+0x16c>)
 8001ebc:	f8d0 41ac 	ldr.w	r4, [r0, #428]	; 0x1ac
  MP23ABS1_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001ec0:	f8d0 11c8 	ldr.w	r1, [r0, #456]	; 0x1c8
  MP23ABS1_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001ec4:	f890 21d0 	ldrb.w	r2, [r0, #464]	; 0x1d0
  tempSensor = COM_GetSensor(stts751_com_id);
 8001ec8:	7828      	ldrb	r0, [r5, #0]
  MP23ABS1_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001eca:	601c      	str	r4, [r3, #0]
  MP23ABS1_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001ecc:	6059      	str	r1, [r3, #4]
  MP23ABS1_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001ece:	751a      	strb	r2, [r3, #20]
  tempSensor = COM_GetSensor(stts751_com_id);
 8001ed0:	f7ff fd4a 	bl	8001968 <COM_GetSensor>
  STTS751_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001ed4:	4b16      	ldr	r3, [pc, #88]	; (8001f30 <update_sensors_config+0x170>)
  STTS751_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
  STTS751_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001ed6:	f890 21d0 	ldrb.w	r2, [r0, #464]	; 0x1d0
  STTS751_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001eda:	f8d0 41ac 	ldr.w	r4, [r0, #428]	; 0x1ac
  STTS751_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001ede:	f8d0 11c8 	ldr.w	r1, [r0, #456]	; 0x1c8
  STTS751_Init_Param.subSensorActive[0] = tempSensor->sensorStatus.subSensorStatus[0].isActive;  
 8001ee2:	751a      	strb	r2, [r3, #20]
  STTS751_Init_Param.ODR = tempSensor->sensorStatus.ODR;
 8001ee4:	601c      	str	r4, [r3, #0]
  STTS751_Init_Param.FS[0] = tempSensor->sensorStatus.subSensorStatus[0].FS;
 8001ee6:	6059      	str	r1, [r3, #4]
  
}
 8001ee8:	bd38      	pop	{r3, r4, r5, pc}
 8001eea:	bf00      	nop
 8001eec:	20017291 	.word	0x20017291
 8001ef0:	20016ef8 	.word	0x20016ef8
 8001ef4:	20010e3c 	.word	0x20010e3c
 8001ef8:	20010db0 	.word	0x20010db0
 8001efc:	20016fc0 	.word	0x20016fc0
 8001f00:	20016f94 	.word	0x20016f94
 8001f04:	20010dec 	.word	0x20010dec
 8001f08:	20017290 	.word	0x20017290
 8001f0c:	20010e18 	.word	0x20010e18
 8001f10:	20016f96 	.word	0x20016f96
 8001f14:	20012ed8 	.word	0x20012ed8
 8001f18:	20016eb4 	.word	0x20016eb4
 8001f1c:	20016f08 	.word	0x20016f08
 8001f20:	20016ee0 	.word	0x20016ee0
 8001f24:	20016fc1 	.word	0x20016fc1
 8001f28:	20016f95 	.word	0x20016f95
 8001f2c:	200174f0 	.word	0x200174f0
 8001f30:	2001994c 	.word	0x2001994c

08001f34 <HTS221_Start>:
}

void HTS221_Start(void)
{
  HTS221_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(HTS221_Thread_Id);
 8001f34:	4a03      	ldr	r2, [pc, #12]	; (8001f44 <HTS221_Start+0x10>)
  HTS221_Sensor_State = newState;
 8001f36:	4b04      	ldr	r3, [pc, #16]	; (8001f48 <HTS221_Start+0x14>)
  osThreadResume(HTS221_Thread_Id);
 8001f38:	6810      	ldr	r0, [r2, #0]
  HTS221_Sensor_State = newState;
 8001f3a:	2203      	movs	r2, #3
 8001f3c:	701a      	strb	r2, [r3, #0]
  osThreadResume(HTS221_Thread_Id);
 8001f3e:	f00f b8e7 	b.w	8011110 <osThreadResume>
 8001f42:	bf00      	nop
 8001f44:	20010dc8 	.word	0x20010dc8
 8001f48:	20000004 	.word	0x20000004

08001f4c <HTS221_Stop>:
  HTS221_Sensor_State = newState;
 8001f4c:	4b01      	ldr	r3, [pc, #4]	; (8001f54 <HTS221_Stop+0x8>)
 8001f4e:	2201      	movs	r2, #1
 8001f50:	701a      	strb	r2, [r3, #0]
}

void HTS221_Stop(void)
{
  HTS221_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 8001f52:	4770      	bx	lr
 8001f54:	20000004 	.word	0x20000004

08001f58 <IIS2DH_Start>:
}

void IIS2DH_Start(void)
{
  IIS2DH_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(IIS2DH_Thread_Id);
 8001f58:	4a03      	ldr	r2, [pc, #12]	; (8001f68 <IIS2DH_Start+0x10>)
  IIS2DH_Sensor_State = newState;
 8001f5a:	4b04      	ldr	r3, [pc, #16]	; (8001f6c <IIS2DH_Start+0x14>)
  osThreadResume(IIS2DH_Thread_Id);
 8001f5c:	6810      	ldr	r0, [r2, #0]
  IIS2DH_Sensor_State = newState;
 8001f5e:	2203      	movs	r2, #3
 8001f60:	701a      	strb	r2, [r3, #0]
  osThreadResume(IIS2DH_Thread_Id);
 8001f62:	f00f b8d5 	b.w	8011110 <osThreadResume>
 8001f66:	bf00      	nop
 8001f68:	20010dd8 	.word	0x20010dd8
 8001f6c:	20000024 	.word	0x20000024

08001f70 <IIS2DH_Stop>:
  IIS2DH_Sensor_State = newState;
 8001f70:	4b01      	ldr	r3, [pc, #4]	; (8001f78 <IIS2DH_Stop+0x8>)
 8001f72:	2201      	movs	r2, #1
 8001f74:	701a      	strb	r2, [r3, #0]
}

void IIS2DH_Stop(void)
{
  IIS2DH_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 8001f76:	4770      	bx	lr
 8001f78:	20000024 	.word	0x20000024

08001f7c <IIS2MDC_Start>:
}

void IIS2MDC_Start(void)
{
  IIS2MDC_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(IIS2MDC_Thread_Id);
 8001f7c:	4a03      	ldr	r2, [pc, #12]	; (8001f8c <IIS2MDC_Start+0x10>)
  IIS2MDC_Sensor_State = newState;
 8001f7e:	4b04      	ldr	r3, [pc, #16]	; (8001f90 <IIS2MDC_Start+0x14>)
  osThreadResume(IIS2MDC_Thread_Id);
 8001f80:	6810      	ldr	r0, [r2, #0]
  IIS2MDC_Sensor_State = newState;
 8001f82:	2203      	movs	r2, #3
 8001f84:	701a      	strb	r2, [r3, #0]
  osThreadResume(IIS2MDC_Thread_Id);
 8001f86:	f00f b8c3 	b.w	8011110 <osThreadResume>
 8001f8a:	bf00      	nop
 8001f8c:	20010e30 	.word	0x20010e30
 8001f90:	20000044 	.word	0x20000044

08001f94 <IIS2MDC_Stop>:
  IIS2MDC_Sensor_State = newState;
 8001f94:	4b01      	ldr	r3, [pc, #4]	; (8001f9c <IIS2MDC_Stop+0x8>)
 8001f96:	2201      	movs	r2, #1
 8001f98:	701a      	strb	r2, [r3, #0]
}

void IIS2MDC_Stop(void)
{
  IIS2MDC_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 8001f9a:	4770      	bx	lr
 8001f9c:	20000044 	.word	0x20000044

08001fa0 <IIS3DWB_Int_Callback>:



static void IIS3DWB_Int_Callback(void)
{
  tim_value = hsm_tim.Instance->CNT;
 8001fa0:	4a03      	ldr	r2, [pc, #12]	; (8001fb0 <IIS3DWB_Int_Callback+0x10>)
 8001fa2:	4b04      	ldr	r3, [pc, #16]	; (8001fb4 <IIS3DWB_Int_Callback+0x14>)
 8001fa4:	6812      	ldr	r2, [r2, #0]
  osSemaphoreRelease(iis3dwb_data_ready_sem_id);
 8001fa6:	6858      	ldr	r0, [r3, #4]
  tim_value = hsm_tim.Instance->CNT;
 8001fa8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001faa:	601a      	str	r2, [r3, #0]
  osSemaphoreRelease(iis3dwb_data_ready_sem_id);
 8001fac:	f00e bf6a 	b.w	8010e84 <osSemaphoreRelease>
 8001fb0:	200197a4 	.word	0x200197a4
 8001fb4:	200003e0 	.word	0x200003e0

08001fb8 <IIS3DWB_Peripheral_Init>:
{
 8001fb8:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001fba:	2400      	movs	r4, #0
{
 8001fbc:	b08c      	sub	sp, #48	; 0x30
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001fbe:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8001fc2:	e9cd 4408 	strd	r4, r4, [sp, #32]
  __HAL_RCC_GPIOB_CLK_ENABLE();		//SPI2_CS
 8001fc6:	4b35      	ldr	r3, [pc, #212]	; (800209c <IIS3DWB_Peripheral_Init+0xe4>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001fc8:	940a      	str	r4, [sp, #40]	; 0x28
  __HAL_RCC_GPIOB_CLK_ENABLE();		//SPI2_CS
 8001fca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_WritePin(IIS3DWB_SPI_CS_GPIO_Port, IIS3DWB_SPI_CS_Pin, GPIO_PIN_SET);
 8001fcc:	4e34      	ldr	r6, [pc, #208]	; (80020a0 <IIS3DWB_Peripheral_Init+0xe8>)
  HAL_EXTI_GetHandle(&iis3dwb_exti, EXTI_LINE_5);
 8001fce:	4d35      	ldr	r5, [pc, #212]	; (80020a4 <IIS3DWB_Peripheral_Init+0xec>)
  __HAL_RCC_GPIOB_CLK_ENABLE();		//SPI2_CS
 8001fd0:	f042 0202 	orr.w	r2, r2, #2
 8001fd4:	64da      	str	r2, [r3, #76]	; 0x4c
 8001fd6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001fd8:	f002 0202 	and.w	r2, r2, #2
 8001fdc:	9201      	str	r2, [sp, #4]
 8001fde:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();		//SPI2_MOSI,SPI2_INT
 8001fe0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001fe2:	f042 0204 	orr.w	r2, r2, #4
 8001fe6:	64da      	str	r2, [r3, #76]	; 0x4c
 8001fe8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001fea:	f002 0204 	and.w	r2, r2, #4
 8001fee:	9202      	str	r2, [sp, #8]
 8001ff0:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();		//SPI2_CLK,SPI2_MISO
 8001ff2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001ff4:	f042 0208 	orr.w	r2, r2, #8
 8001ff8:	64da      	str	r2, [r3, #76]	; 0x4c
 8001ffa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001ffc:	f002 0208 	and.w	r2, r2, #8
 8002000:	9203      	str	r2, [sp, #12]
 8002002:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOF_CLK_ENABLE();		//SEL_3_4
 8002004:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002006:	f042 0220 	orr.w	r2, r2, #32
 800200a:	64da      	str	r2, [r3, #76]	; 0x4c
 800200c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800200e:	f002 0220 	and.w	r2, r2, #32
 8002012:	9204      	str	r2, [sp, #16]
 8002014:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOG_CLK_ENABLE();		//SEL_1_2
 8002016:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8002018:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800201c:	64da      	str	r2, [r3, #76]	; 0x4c
 800201e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002020:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002024:	9305      	str	r3, [sp, #20]
  HAL_GPIO_WritePin(IIS3DWB_SPI_CS_GPIO_Port, IIS3DWB_SPI_CS_Pin, GPIO_PIN_SET);
 8002026:	4630      	mov	r0, r6
 8002028:	2201      	movs	r2, #1
 800202a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  __HAL_RCC_GPIOG_CLK_ENABLE();		//SEL_1_2
 800202e:	9b05      	ldr	r3, [sp, #20]
  HAL_GPIO_WritePin(IIS3DWB_SPI_CS_GPIO_Port, IIS3DWB_SPI_CS_Pin, GPIO_PIN_SET);
 8002030:	f003 ff64 	bl	8005efc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(IIS3DWB_1_2_SEL_GPIO_Port, IIS3DWB_1_2_SEL_Pin, GPIO_PIN_RESET);
 8002034:	4622      	mov	r2, r4
 8002036:	481c      	ldr	r0, [pc, #112]	; (80020a8 <IIS3DWB_Peripheral_Init+0xf0>)
 8002038:	2101      	movs	r1, #1
 800203a:	f003 ff5f 	bl	8005efc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(IIS3DWB_3_4_SEL_GPIO_Port, IIS3DWB_3_4_SEL_Pin, GPIO_PIN_SET);
 800203e:	481b      	ldr	r0, [pc, #108]	; (80020ac <IIS3DWB_Peripheral_Init+0xf4>)
 8002040:	2201      	movs	r2, #1
 8002042:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8002046:	f003 ff59 	bl	8005efc <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = IIS3DWB_SPI_CS_Pin;
 800204a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800204e:	2301      	movs	r3, #1
 8002050:	e9cd 2306 	strd	r2, r3, [sp, #24]
  HAL_GPIO_Init(IIS3DWB_SPI_CS_GPIO_Port, &GPIO_InitStruct);
 8002054:	4630      	mov	r0, r6
 8002056:	a906      	add	r1, sp, #24
  GPIO_InitStruct.Pin = IIS3DWB_SPI_CS_Pin;
 8002058:	2200      	movs	r2, #0
 800205a:	2302      	movs	r3, #2
 800205c:	e9cd 2308 	strd	r2, r3, [sp, #32]
  HAL_GPIO_Init(IIS3DWB_SPI_CS_GPIO_Port, &GPIO_InitStruct);
 8002060:	f003 fe26 	bl	8005cb0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin =  IIS3DWB_INT1_Pin ;
 8002064:	4b12      	ldr	r3, [pc, #72]	; (80020b0 <IIS3DWB_Peripheral_Init+0xf8>)
  HAL_GPIO_Init(IIS3DWB_INT1_GPIO_Port, &GPIO_InitStruct);
 8002066:	4813      	ldr	r0, [pc, #76]	; (80020b4 <IIS3DWB_Peripheral_Init+0xfc>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002068:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(IIS3DWB_INT1_GPIO_Port, &GPIO_InitStruct);
 800206a:	a906      	add	r1, sp, #24
  GPIO_InitStruct.Pin =  IIS3DWB_INT1_Pin ;
 800206c:	2220      	movs	r2, #32
 800206e:	e9cd 2306 	strd	r2, r3, [sp, #24]
  HAL_GPIO_Init(IIS3DWB_INT1_GPIO_Port, &GPIO_InitStruct);
 8002072:	f003 fe1d 	bl	8005cb0 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
 8002076:	4622      	mov	r2, r4
 8002078:	2105      	movs	r1, #5
 800207a:	2017      	movs	r0, #23
 800207c:	f003 fc22 	bl	80058c4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 8002080:	2017      	movs	r0, #23
 8002082:	f003 fc57 	bl	8005934 <HAL_NVIC_EnableIRQ>
  HAL_EXTI_GetHandle(&iis3dwb_exti, EXTI_LINE_5);
 8002086:	490c      	ldr	r1, [pc, #48]	; (80020b8 <IIS3DWB_Peripheral_Init+0x100>)
 8002088:	4628      	mov	r0, r5
 800208a:	f003 fdf3 	bl	8005c74 <HAL_EXTI_GetHandle>
  HAL_EXTI_RegisterCallback(&iis3dwb_exti,  HAL_EXTI_COMMON_CB_ID, IIS3DWB_Int_Callback);
 800208e:	4a0b      	ldr	r2, [pc, #44]	; (80020bc <IIS3DWB_Peripheral_Init+0x104>)
 8002090:	4621      	mov	r1, r4
 8002092:	4628      	mov	r0, r5
 8002094:	f003 fde8 	bl	8005c68 <HAL_EXTI_RegisterCallback>
}
 8002098:	b00c      	add	sp, #48	; 0x30
 800209a:	bd70      	pop	{r4, r5, r6, pc}
 800209c:	40021000 	.word	0x40021000
 80020a0:	48000400 	.word	0x48000400
 80020a4:	20010e54 	.word	0x20010e54
 80020a8:	48001800 	.word	0x48001800
 80020ac:	48001400 	.word	0x48001400
 80020b0:	10110000 	.word	0x10110000
 80020b4:	48000800 	.word	0x48000800
 80020b8:	16000005 	.word	0x16000005
 80020bc:	08001fa1 	.word	0x08001fa1

080020c0 <IIS3DWB_OS_Init>:
{  
 80020c0:	b530      	push	{r4, r5, lr}
  iis3dwb_data_read_cmplt_sem_id = osSemaphoreCreate(osSemaphore(iis3dwb_data_read_cmplt_sem), 1);
 80020c2:	4c16      	ldr	r4, [pc, #88]	; (800211c <IIS3DWB_OS_Init+0x5c>)
 80020c4:	4d16      	ldr	r5, [pc, #88]	; (8002120 <IIS3DWB_OS_Init+0x60>)
{  
 80020c6:	b087      	sub	sp, #28
  iis3dwb_data_read_cmplt_sem_id = osSemaphoreCreate(osSemaphore(iis3dwb_data_read_cmplt_sem), 1);
 80020c8:	4620      	mov	r0, r4
 80020ca:	2101      	movs	r1, #1
 80020cc:	f00e fe9a 	bl	8010e04 <osSemaphoreCreate>
  vQueueAddToRegistry( iis3dwb_data_read_cmplt_sem_id, "iis3dwb_data_read_cmplt_sem_id" );
 80020d0:	4914      	ldr	r1, [pc, #80]	; (8002124 <IIS3DWB_OS_Init+0x64>)
  iis3dwb_data_read_cmplt_sem_id = osSemaphoreCreate(osSemaphore(iis3dwb_data_read_cmplt_sem), 1);
 80020d2:	60a8      	str	r0, [r5, #8]
  vQueueAddToRegistry( iis3dwb_data_read_cmplt_sem_id, "iis3dwb_data_read_cmplt_sem_id" );
 80020d4:	f00f ff00 	bl	8011ed8 <vQueueAddToRegistry>
  osSemaphoreWait(iis3dwb_data_read_cmplt_sem_id,osWaitForever);
 80020d8:	68a8      	ldr	r0, [r5, #8]
 80020da:	f04f 31ff 	mov.w	r1, #4294967295
 80020de:	f00e fea5 	bl	8010e2c <osSemaphoreWait>
  iis3dwb_data_ready_sem_id = osSemaphoreCreate(osSemaphore(iis3dwb_data_ready_sem), 1);
 80020e2:	1d20      	adds	r0, r4, #4
 80020e4:	2101      	movs	r1, #1
 80020e6:	f00e fe8d 	bl	8010e04 <osSemaphoreCreate>
  vQueueAddToRegistry( iis3dwb_data_ready_sem_id, "iis3dwb_data_ready_sem_id" );
 80020ea:	490f      	ldr	r1, [pc, #60]	; (8002128 <IIS3DWB_OS_Init+0x68>)
  iis3dwb_data_ready_sem_id = osSemaphoreCreate(osSemaphore(iis3dwb_data_ready_sem), 1);
 80020ec:	6068      	str	r0, [r5, #4]
  osThreadDef(IIS3DWB_Acquisition_Thread, IIS3DWB_Thread, IIS3DWB_THREAD_PRIO, 1, configMINIMAL_STACK_SIZE);  
 80020ee:	3408      	adds	r4, #8
  vQueueAddToRegistry( iis3dwb_data_ready_sem_id, "iis3dwb_data_ready_sem_id" );
 80020f0:	f00f fef2 	bl	8011ed8 <vQueueAddToRegistry>
  osSemaphoreWait(iis3dwb_data_ready_sem_id,  osWaitForever);
 80020f4:	6868      	ldr	r0, [r5, #4]
 80020f6:	f04f 31ff 	mov.w	r1, #4294967295
 80020fa:	f00e fe97 	bl	8010e2c <osSemaphoreWait>
  osThreadDef(IIS3DWB_Acquisition_Thread, IIS3DWB_Thread, IIS3DWB_THREAD_PRIO, 1, configMINIMAL_STACK_SIZE);  
 80020fe:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002100:	ad01      	add	r5, sp, #4
 8002102:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002104:	6823      	ldr	r3, [r4, #0]
 8002106:	602b      	str	r3, [r5, #0]
  IIS3DWB_Thread_Id = osThreadCreate(osThread(IIS3DWB_Acquisition_Thread), NULL); 
 8002108:	2100      	movs	r1, #0
 800210a:	a801      	add	r0, sp, #4
 800210c:	f00e fe62 	bl	8010dd4 <osThreadCreate>
 8002110:	4b06      	ldr	r3, [pc, #24]	; (800212c <IIS3DWB_OS_Init+0x6c>)
 8002112:	6018      	str	r0, [r3, #0]
  osThreadSuspend(IIS3DWB_Thread_Id);
 8002114:	f00e fff6 	bl	8011104 <osThreadSuspend>
}
 8002118:	b007      	add	sp, #28
 800211a:	bd30      	pop	{r4, r5, pc}
 800211c:	0801a050 	.word	0x0801a050
 8002120:	200003e0 	.word	0x200003e0
 8002124:	0801a938 	.word	0x0801a938
 8002128:	0801a958 	.word	0x0801a958
 800212c:	20010e5c 	.word	0x20010e5c

08002130 <IIS3DWB_Start>:
}

void IIS3DWB_Start(void)
{
  IIS3DWB_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(IIS3DWB_Thread_Id);
 8002130:	4a03      	ldr	r2, [pc, #12]	; (8002140 <IIS3DWB_Start+0x10>)
  IIS3DWB_Sensor_State = newState;
 8002132:	4b04      	ldr	r3, [pc, #16]	; (8002144 <IIS3DWB_Start+0x14>)
  osThreadResume(IIS3DWB_Thread_Id);
 8002134:	6810      	ldr	r0, [r2, #0]
  IIS3DWB_Sensor_State = newState;
 8002136:	2203      	movs	r2, #3
 8002138:	701a      	strb	r2, [r3, #0]
  osThreadResume(IIS3DWB_Thread_Id);
 800213a:	f00e bfe9 	b.w	8011110 <osThreadResume>
 800213e:	bf00      	nop
 8002140:	20010e5c 	.word	0x20010e5c
 8002144:	20000064 	.word	0x20000064

08002148 <IIS3DWB_Stop>:
  IIS3DWB_Sensor_State = newState;
 8002148:	4b01      	ldr	r3, [pc, #4]	; (8002150 <IIS3DWB_Stop+0x8>)
 800214a:	2201      	movs	r2, #1
 800214c:	701a      	strb	r2, [r3, #0]
}

void IIS3DWB_Stop(void)
{
  IIS3DWB_Set_State(SM_SENSOR_STATE_SUSPENDING);  
}
 800214e:	4770      	bx	lr
 8002150:	20000064 	.word	0x20000064

08002154 <IIS3DWB_Thread>:
{
 8002154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002158:	4e90      	ldr	r6, [pc, #576]	; (800239c <IIS3DWB_Thread+0x248>)
 800215a:	4d91      	ldr	r5, [pc, #580]	; (80023a0 <IIS3DWB_Thread+0x24c>)
 800215c:	f8df a250 	ldr.w	sl, [pc, #592]	; 80023b0 <IIS3DWB_Thread+0x25c>
 8002160:	f8df b250 	ldr.w	fp, [pc, #592]	; 80023b4 <IIS3DWB_Thread+0x260>
 8002164:	4634      	mov	r4, r6
 8002166:	b083      	sub	sp, #12
  vTaskSetApplicationTaskTag( NULL, (TaskHookFunction_t)TASK_IIS3DWB_DEBUG_PIN );
 8002168:	2101      	movs	r1, #1
 800216a:	2000      	movs	r0, #0
 800216c:	f010 fb6c 	bl	8012848 <vTaskSetApplicationTaskTag>
  volatile uint16_t fifo_level = 0;
 8002170:	2300      	movs	r3, #0
 8002172:	f814 8b04 	ldrb.w	r8, [r4], #4
 8002176:	f8ad 3006 	strh.w	r3, [sp, #6]
 800217a:	f505 7763 	add.w	r7, r5, #908	; 0x38c
    if (IIS3DWB_Sensor_State == SM_SENSOR_STATE_INITIALIZING)
 800217e:	f1b8 0f03 	cmp.w	r8, #3
 8002182:	f040 8091 	bne.w	80022a8 <IIS3DWB_Thread+0x154>
      ts_iis3dwb = 0;
 8002186:	2200      	movs	r2, #0
 8002188:	2300      	movs	r3, #0
      iis3dwb_device_id_get( &iis3dwb_ctx_instance, (uint8_t *)&reg0);
 800218a:	f10d 0102 	add.w	r1, sp, #2
      tim_value_old = 0;
 800218e:	f04f 0900 	mov.w	r9, #0
      iis3dwb_device_id_get( &iis3dwb_ctx_instance, (uint8_t *)&reg0);
 8002192:	4620      	mov	r0, r4
      ts_iis3dwb = 0;
 8002194:	e9c5 23e4 	strd	r2, r3, [r5, #912]	; 0x390
      tim_value_old = 0;
 8002198:	f8c5 9398 	str.w	r9, [r5, #920]	; 0x398
      iis3dwb_device_id_get( &iis3dwb_ctx_instance, (uint8_t *)&reg0);
 800219c:	f001 ff96 	bl	80040cc <iis3dwb_device_id_get>
      iis3dwb_reset_set(&iis3dwb_ctx_instance, 1);
 80021a0:	2101      	movs	r1, #1
 80021a2:	4620      	mov	r0, r4
 80021a4:	f001 ff9c 	bl	80040e0 <iis3dwb_reset_set>
      iis3dwb_read_reg(&iis3dwb_ctx_instance, IIS3DWB_CTRL1_XL, (uint8_t *)&reg0, 1);
 80021a8:	2301      	movs	r3, #1
 80021aa:	f10d 0202 	add.w	r2, sp, #2
 80021ae:	2110      	movs	r1, #16
 80021b0:	4620      	mov	r0, r4
 80021b2:	f001 ff47 	bl	8004044 <iis3dwb_read_reg>
      reg0 |= 0xA0;
 80021b6:	f89d c002 	ldrb.w	ip, [sp, #2]
      iis3dwb_write_reg(&iis3dwb_ctx_instance, IIS3DWB_CTRL1_XL, (uint8_t *)&reg0, 1);
 80021ba:	2301      	movs	r3, #1
      reg0 |= 0xA0;
 80021bc:	f06c 0c5f 	orn	ip, ip, #95	; 0x5f
      iis3dwb_write_reg(&iis3dwb_ctx_instance, IIS3DWB_CTRL1_XL, (uint8_t *)&reg0, 1);
 80021c0:	f10d 0202 	add.w	r2, sp, #2
 80021c4:	2110      	movs	r1, #16
 80021c6:	4620      	mov	r0, r4
      reg0 |= 0xA0;
 80021c8:	f88d c002 	strb.w	ip, [sp, #2]
      iis3dwb_write_reg(&iis3dwb_ctx_instance, IIS3DWB_CTRL1_XL, (uint8_t *)&reg0, 1);
 80021cc:	f001 ff42 	bl	8004054 <iis3dwb_write_reg>
      iis3dwb_i2c_interface_set(&iis3dwb_ctx_instance, IIS3DWB_I2C_DISABLE);
 80021d0:	2101      	movs	r1, #1
 80021d2:	4620      	mov	r0, r4
 80021d4:	f001 ffd6 	bl	8004184 <iis3dwb_i2c_interface_set>
      iis3dwb_fifo_mode_set(&iis3dwb_ctx_instance, IIS3DWB_STREAM_MODE); 
 80021d8:	2106      	movs	r1, #6
 80021da:	4620      	mov	r0, r4
 80021dc:	f002 f83e 	bl	800425c <iis3dwb_fifo_mode_set>
      iis3dwb_fifo_watermark_set(&iis3dwb_ctx_instance, IIS3DWB_WTM_LEVEL);
 80021e0:	2180      	movs	r1, #128	; 0x80
 80021e2:	4620      	mov	r0, r4
 80021e4:	f001 fffc 	bl	80041e0 <iis3dwb_fifo_watermark_set>
      iis3dwb_data_ready_mode_set(&iis3dwb_ctx_instance, IIS3DWB_DRDY_PULSED);
 80021e8:	2101      	movs	r1, #1
 80021ea:	4620      	mov	r0, r4
 80021ec:	f001 ff54 	bl	8004098 <iis3dwb_data_ready_mode_set>
      if(IIS3DWB_Init_Param.FS[0] < 3.0f)
 80021f0:	edda 7a01 	vldr	s15, [sl, #4]
 80021f4:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
 80021f8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80021fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002200:	d466      	bmi.n	80022d0 <IIS3DWB_Thread+0x17c>
      else if(IIS3DWB_Init_Param.FS[0] < 5.0f)
 8002202:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
 8002206:	eef4 7ac7 	vcmpe.f32	s15, s14
 800220a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800220e:	d464      	bmi.n	80022da <IIS3DWB_Thread+0x186>
      else if(IIS3DWB_Init_Param.FS[0] < 9.0f)
 8002210:	eeb2 7a02 	vmov.f32	s14, #34	; 0x41100000  9.0
 8002214:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002218:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800221c:	d462      	bmi.n	80022e4 <IIS3DWB_Thread+0x190>
      else if(IIS3DWB_Init_Param.FS[0] < 17.0f)
 800221e:	eeb3 7a01 	vmov.f32	s14, #49	; 0x41880000  17.0
 8002222:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002226:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800222a:	d460      	bmi.n	80022ee <IIS3DWB_Thread+0x19a>
      iis3dwb_xl_hp_path_on_out_set(&iis3dwb_ctx_instance,IIS3DWB_LP_ODR_DIV_20);					// Grprozess sensor
 800222c:	2182      	movs	r1, #130	; 0x82
 800222e:	4620      	mov	r0, r4
 8002230:	f001 ff70 	bl	8004114 <iis3dwb_xl_hp_path_on_out_set>
      *(uint8_t*)&(pin_int1_route.int1_ctrl) = 0;
 8002234:	2308      	movs	r3, #8
      iis3dwb_pin_int1_route_set(&iis3dwb_ctx_instance, &pin_int1_route);
 8002236:	a901      	add	r1, sp, #4
 8002238:	4620      	mov	r0, r4
      *(uint8_t*)&(pin_int1_route.int1_ctrl) = 0;
 800223a:	f8ad 3004 	strh.w	r3, [sp, #4]
      iis3dwb_pin_int1_route_set(&iis3dwb_ctx_instance, &pin_int1_route);
 800223e:	f001 ffbb 	bl	80041b8 <iis3dwb_pin_int1_route_set>
      iis3dwb_fifo_xl_batch_set(&iis3dwb_ctx_instance, IIS3DWB_XL_BATCHED_AT_26k7Hz);
 8002242:	210a      	movs	r1, #10
 8002244:	4620      	mov	r0, r4
 8002246:	f001 ffef 	bl	8004228 <iis3dwb_fifo_xl_batch_set>
      HAL_NVIC_EnableIRQ(IIS3DWB_INT1_EXTI_IRQn); 
 800224a:	2017      	movs	r0, #23
 800224c:	f003 fb72 	bl	8005934 <HAL_NVIC_EnableIRQ>
      IIS3DWB_Sensor_State = SM_SENSOR_STATE_RUNNING;      
 8002250:	2300      	movs	r3, #0
 8002252:	7033      	strb	r3, [r6, #0]
      osSemaphoreWait(iis3dwb_data_ready_sem_id,  osWaitForever);     
 8002254:	6868      	ldr	r0, [r5, #4]
 8002256:	f04f 31ff 	mov.w	r1, #4294967295
 800225a:	f00e fde7 	bl	8010e2c <osSemaphoreWait>
      if(IIS3DWB_Sensor_State == SM_SENSOR_STATE_RUNNING) /* Change of state can happen while task blocked */
 800225e:	f896 8000 	ldrb.w	r8, [r6]
 8002262:	f1b8 0f00 	cmp.w	r8, #0
 8002266:	d18a      	bne.n	800217e <IIS3DWB_Thread+0x2a>
        iis3dwb_read_reg(&iis3dwb_ctx_instance, IIS3DWB_FIFO_STATUS1, &reg0, 1);
 8002268:	2301      	movs	r3, #1
 800226a:	f10d 0202 	add.w	r2, sp, #2
 800226e:	213a      	movs	r1, #58	; 0x3a
 8002270:	4620      	mov	r0, r4
 8002272:	f001 fee7 	bl	8004044 <iis3dwb_read_reg>
        iis3dwb_read_reg(&iis3dwb_ctx_instance, IIS3DWB_FIFO_STATUS2, &reg1, 1);        
 8002276:	2301      	movs	r3, #1
 8002278:	f10d 0203 	add.w	r2, sp, #3
 800227c:	213b      	movs	r1, #59	; 0x3b
 800227e:	4620      	mov	r0, r4
 8002280:	f001 fee0 	bl	8004044 <iis3dwb_read_reg>
        fifo_level = ((reg1 & 0x03) << 8) + reg0; 
 8002284:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8002288:	f89d 3002 	ldrb.w	r3, [sp, #2]
 800228c:	020a      	lsls	r2, r1, #8
 800228e:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8002292:	4413      	add	r3, r2
 8002294:	f8ad 3006 	strh.w	r3, [sp, #6]
        if((reg1) & 0x80  && (fifo_level>=IIS3DWB_SAMPLES_PER_IT) )
 8002298:	060b      	lsls	r3, r1, #24
 800229a:	d42d      	bmi.n	80022f8 <IIS3DWB_Thread+0x1a4>
 800229c:	f896 8000 	ldrb.w	r8, [r6]
    if (IIS3DWB_Sensor_State == SM_SENSOR_STATE_INITIALIZING)
 80022a0:	f1b8 0f03 	cmp.w	r8, #3
 80022a4:	f43f af6f 	beq.w	8002186 <IIS3DWB_Thread+0x32>
    else if(IIS3DWB_Sensor_State == SM_SENSOR_STATE_RUNNING)
 80022a8:	f1b8 0f00 	cmp.w	r8, #0
 80022ac:	d0d2      	beq.n	8002254 <IIS3DWB_Thread+0x100>
    else if ( IIS3DWB_Sensor_State == SM_SENSOR_STATE_SUSPENDING)
 80022ae:	f1b8 0f01 	cmp.w	r8, #1
 80022b2:	f47f af64 	bne.w	800217e <IIS3DWB_Thread+0x2a>
      iis3dwb_fifo_xl_batch_set(&iis3dwb_ctx_instance, IIS3DWB_XL_NOT_BATCHED);
 80022b6:	2100      	movs	r1, #0
 80022b8:	4620      	mov	r0, r4
 80022ba:	f001 ffb5 	bl	8004228 <iis3dwb_fifo_xl_batch_set>
      IIS3DWB_Sensor_State = SM_SENSOR_STATE_SUSPENDED;
 80022be:	2302      	movs	r3, #2
      osThreadSuspend(IIS3DWB_Thread_Id);
 80022c0:	f8db 0000 	ldr.w	r0, [fp]
      IIS3DWB_Sensor_State = SM_SENSOR_STATE_SUSPENDED;
 80022c4:	7033      	strb	r3, [r6, #0]
      osThreadSuspend(IIS3DWB_Thread_Id);
 80022c6:	f00e ff1d 	bl	8011104 <osThreadSuspend>
 80022ca:	f896 8000 	ldrb.w	r8, [r6]
 80022ce:	e756      	b.n	800217e <IIS3DWB_Thread+0x2a>
        iis3dwb_xl_full_scale_set(&iis3dwb_ctx_instance, IIS3DWB_2g);
 80022d0:	4649      	mov	r1, r9
 80022d2:	4620      	mov	r0, r4
 80022d4:	f001 fec6 	bl	8004064 <iis3dwb_xl_full_scale_set>
 80022d8:	e7a8      	b.n	800222c <IIS3DWB_Thread+0xd8>
        iis3dwb_xl_full_scale_set(&iis3dwb_ctx_instance, IIS3DWB_4g);
 80022da:	2102      	movs	r1, #2
 80022dc:	4620      	mov	r0, r4
 80022de:	f001 fec1 	bl	8004064 <iis3dwb_xl_full_scale_set>
 80022e2:	e7a3      	b.n	800222c <IIS3DWB_Thread+0xd8>
        iis3dwb_xl_full_scale_set(&iis3dwb_ctx_instance, IIS3DWB_8g);
 80022e4:	4641      	mov	r1, r8
 80022e6:	4620      	mov	r0, r4
 80022e8:	f001 febc 	bl	8004064 <iis3dwb_xl_full_scale_set>
 80022ec:	e79e      	b.n	800222c <IIS3DWB_Thread+0xd8>
        iis3dwb_xl_full_scale_set(&iis3dwb_ctx_instance, IIS3DWB_16g);
 80022ee:	2101      	movs	r1, #1
 80022f0:	4620      	mov	r0, r4
 80022f2:	f001 feb7 	bl	8004064 <iis3dwb_xl_full_scale_set>
 80022f6:	e799      	b.n	800222c <IIS3DWB_Thread+0xd8>
        if((reg1) & 0x80  && (fifo_level>=IIS3DWB_SAMPLES_PER_IT) )
 80022f8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80022fc:	b29b      	uxth	r3, r3
 80022fe:	2b7f      	cmp	r3, #127	; 0x7f
 8002300:	d9cc      	bls.n	800229c <IIS3DWB_Thread+0x148>
          if(tim_value >= tim_value_old)
 8002302:	682a      	ldr	r2, [r5, #0]
 8002304:	f8d5 3398 	ldr.w	r3, [r5, #920]	; 0x398
 8002308:	429a      	cmp	r2, r3
            period = tim_value - tim_value_old;
 800230a:	682b      	ldr	r3, [r5, #0]
 800230c:	f8d5 2398 	ldr.w	r2, [r5, #920]	; 0x398
            period = tim_value + (0xFFFFFFFF - tim_value_old);
 8002310:	bf38      	it	cc
 8002312:	f103 33ff 	addcc.w	r3, r3, #4294967295
 8002316:	1a9b      	subs	r3, r3, r2
 8002318:	f8c5 339c 	str.w	r3, [r5, #924]	; 0x39c
          tim_value_old = tim_value;
 800231c:	682b      	ldr	r3, [r5, #0]
 800231e:	f8c5 3398 	str.w	r3, [r5, #920]	; 0x398
          ts_iis3dwb +=  period;
 8002322:	f8d5 239c 	ldr.w	r2, [r5, #924]	; 0x39c
 8002326:	e9d5 89e4 	ldrd	r8, r9, [r5, #912]	; 0x390
 800232a:	eb18 0802 	adds.w	r8, r8, r2
          iis3dwb_read_reg(&iis3dwb_ctx_instance, IIS3DWB_FIFO_DATA_OUT_TAG, (uint8_t *)iis3dwb_mem, IIS3DWB_SAMPLES_PER_IT * 7);
 800232e:	f44f 7360 	mov.w	r3, #896	; 0x380
 8002332:	4a1c      	ldr	r2, [pc, #112]	; (80023a4 <IIS3DWB_Thread+0x250>)
          ts_iis3dwb +=  period;
 8002334:	f149 0900 	adc.w	r9, r9, #0
          iis3dwb_read_reg(&iis3dwb_ctx_instance, IIS3DWB_FIFO_DATA_OUT_TAG, (uint8_t *)iis3dwb_mem, IIS3DWB_SAMPLES_PER_IT * 7);
 8002338:	2178      	movs	r1, #120	; 0x78
 800233a:	4620      	mov	r0, r4
          ts_iis3dwb +=  period;
 800233c:	e9c5 89e4 	strd	r8, r9, [r5, #912]	; 0x390
          iis3dwb_read_reg(&iis3dwb_ctx_instance, IIS3DWB_FIFO_DATA_OUT_TAG, (uint8_t *)iis3dwb_mem, IIS3DWB_SAMPLES_PER_IT * 7);
 8002340:	f001 fe80 	bl	8004044 <iis3dwb_read_reg>
          for (i = 0; i < IIS3DWB_SAMPLES_PER_IT; i++)    
 8002344:	4a18      	ldr	r2, [pc, #96]	; (80023a8 <IIS3DWB_Thread+0x254>)
          int16_t * p16src = (int16_t *)iis3dwb_mem;
 8002346:	1f93      	subs	r3, r2, #6
            *p16dest++ = *p16src++;
 8002348:	f9b3 1001 	ldrsh.w	r1, [r3, #1]
 800234c:	f822 1c06 	strh.w	r1, [r2, #-6]
            *p16dest++ = *p16src++;
 8002350:	f9b3 1003 	ldrsh.w	r1, [r3, #3]
 8002354:	f822 1c04 	strh.w	r1, [r2, #-4]
            *p16dest++ = *p16src++;
 8002358:	4619      	mov	r1, r3
 800235a:	3307      	adds	r3, #7
 800235c:	f9b1 1005 	ldrsh.w	r1, [r1, #5]
 8002360:	f822 1c02 	strh.w	r1, [r2, #-2]
          for (i = 0; i < IIS3DWB_SAMPLES_PER_IT; i++)    
 8002364:	42bb      	cmp	r3, r7
 8002366:	f102 0206 	add.w	r2, r2, #6
 800236a:	d1ed      	bne.n	8002348 <IIS3DWB_Thread+0x1f4>
          IIS3DWB_Data_Ready((uint8_t *)iis3dwb_mem, IIS3DWB_SAMPLES_PER_IT * 6, (double)ts_iis3dwb/(double)SystemCoreClock);        
 800236c:	e9d5 01e4 	ldrd	r0, r1, [r5, #912]	; 0x390
 8002370:	f7fe f934 	bl	80005dc <__aeabi_ul2d>
 8002374:	4b0d      	ldr	r3, [pc, #52]	; (80023ac <IIS3DWB_Thread+0x258>)
 8002376:	4680      	mov	r8, r0
 8002378:	6818      	ldr	r0, [r3, #0]
 800237a:	4689      	mov	r9, r1
 800237c:	f7fe f8ea 	bl	8000554 <__aeabi_ui2d>
 8002380:	4602      	mov	r2, r0
 8002382:	460b      	mov	r3, r1
 8002384:	4640      	mov	r0, r8
 8002386:	4649      	mov	r1, r9
 8002388:	f7fe fa88 	bl	800089c <__aeabi_ddiv>
 800238c:	ec41 0b10 	vmov	d0, r0, r1
 8002390:	4804      	ldr	r0, [pc, #16]	; (80023a4 <IIS3DWB_Thread+0x250>)
 8002392:	f44f 7140 	mov.w	r1, #768	; 0x300
 8002396:	f000 fc1f 	bl	8002bd8 <IIS3DWB_Data_Ready>
 800239a:	e77f      	b.n	800229c <IIS3DWB_Thread+0x148>
 800239c:	20000064 	.word	0x20000064
 80023a0:	200003e0 	.word	0x200003e0
 80023a4:	200003ec 	.word	0x200003ec
 80023a8:	200003f2 	.word	0x200003f2
 80023ac:	20000124 	.word	0x20000124
 80023b0:	20010e3c 	.word	0x20010e3c
 80023b4:	20010e5c 	.word	0x20010e5c

080023b8 <IMP34DT05_Start>:
}

void IMP34DT05_Start(void)
{
  IMP34DT05_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(IMP34DT05_Thread_Id);
 80023b8:	4a03      	ldr	r2, [pc, #12]	; (80023c8 <IMP34DT05_Start+0x10>)
  IMP34DT05_Sensor_State = newState;
 80023ba:	4b04      	ldr	r3, [pc, #16]	; (80023cc <IMP34DT05_Start+0x14>)
  osThreadResume(IMP34DT05_Thread_Id);
 80023bc:	6810      	ldr	r0, [r2, #0]
  IMP34DT05_Sensor_State = newState;
 80023be:	2203      	movs	r2, #3
 80023c0:	701a      	strb	r2, [r3, #0]
  osThreadResume(IMP34DT05_Thread_Id);
 80023c2:	f00e bea5 	b.w	8011110 <osThreadResume>
 80023c6:	bf00      	nop
 80023c8:	20010e60 	.word	0x20010e60
 80023cc:	20000084 	.word	0x20000084

080023d0 <IMP34DT05_Stop>:
  IMP34DT05_Sensor_State = newState;
 80023d0:	4b01      	ldr	r3, [pc, #4]	; (80023d8 <IMP34DT05_Stop+0x8>)
 80023d2:	2201      	movs	r2, #1
 80023d4:	701a      	strb	r2, [r3, #0]
}

void IMP34DT05_Stop(void)
{
  IMP34DT05_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 80023d6:	4770      	bx	lr
 80023d8:	20000084 	.word	0x20000084

080023dc <ISM330DHCX_Start>:
}

void ISM330DHCX_Start(void)
{
  ISM330DHCX_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(ISM330DHCX_Thread_Id);
 80023dc:	4a03      	ldr	r2, [pc, #12]	; (80023ec <ISM330DHCX_Start+0x10>)
  ISM330DHCX_Sensor_State = newState;
 80023de:	4b04      	ldr	r3, [pc, #16]	; (80023f0 <ISM330DHCX_Start+0x14>)
  osThreadResume(ISM330DHCX_Thread_Id);
 80023e0:	6810      	ldr	r0, [r2, #0]
  ISM330DHCX_Sensor_State = newState;
 80023e2:	2203      	movs	r2, #3
 80023e4:	701a      	strb	r2, [r3, #0]
  osThreadResume(ISM330DHCX_Thread_Id);
 80023e6:	f00e be93 	b.w	8011110 <osThreadResume>
 80023ea:	bf00      	nop
 80023ec:	20016ed4 	.word	0x20016ed4
 80023f0:	20000088 	.word	0x20000088

080023f4 <ISM330DHCX_Stop>:
  ISM330DHCX_Sensor_State = newState;
 80023f4:	4b01      	ldr	r3, [pc, #4]	; (80023fc <ISM330DHCX_Stop+0x8>)
 80023f6:	2201      	movs	r2, #1
 80023f8:	701a      	strb	r2, [r3, #0]
}

void ISM330DHCX_Stop(void)
{  
  ISM330DHCX_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 80023fa:	4770      	bx	lr
 80023fc:	20000088 	.word	0x20000088

08002400 <LPS22HH_Start>:
}

void LPS22HH_Start(void)
{
  LPS22HH_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(LPS22HH_Thread_Id);
 8002400:	4a03      	ldr	r2, [pc, #12]	; (8002410 <LPS22HH_Start+0x10>)
  LPS22HH_Sensor_State = newState;
 8002402:	4b04      	ldr	r3, [pc, #16]	; (8002414 <LPS22HH_Start+0x14>)
  osThreadResume(LPS22HH_Thread_Id);
 8002404:	6810      	ldr	r0, [r2, #0]
  LPS22HH_Sensor_State = newState;
 8002406:	2203      	movs	r2, #3
 8002408:	701a      	strb	r2, [r3, #0]
  osThreadResume(LPS22HH_Thread_Id);
 800240a:	f00e be81 	b.w	8011110 <osThreadResume>
 800240e:	bf00      	nop
 8002410:	20016edc 	.word	0x20016edc
 8002414:	200000a8 	.word	0x200000a8

08002418 <LPS22HH_Stop>:
  LPS22HH_Sensor_State = newState;
 8002418:	4b01      	ldr	r3, [pc, #4]	; (8002420 <LPS22HH_Stop+0x8>)
 800241a:	2201      	movs	r2, #1
 800241c:	701a      	strb	r2, [r3, #0]
}

void LPS22HH_Stop(void)
{
  LPS22HH_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 800241e:	4770      	bx	lr
 8002420:	200000a8 	.word	0x200000a8

08002424 <BC_Int_Callback>:
 * @brief  Battery Charger Interrupt callback
 * @param  None
 * @retval None
 */
void BC_Int_Callback(void)
{
 8002424:	b508      	push	{r3, lr}
	if(HAL_GetTick() - t_stwin > 4000)
 8002426:	f002 fbdb 	bl	8004be0 <HAL_GetTick>
 800242a:	4b06      	ldr	r3, [pc, #24]	; (8002444 <BC_Int_Callback+0x20>)
 800242c:	681b      	ldr	r3, [r3, #0]
 800242e:	1ac0      	subs	r0, r0, r3
 8002430:	f5b0 6f7a 	cmp.w	r0, #4000	; 0xfa0
 8002434:	d800      	bhi.n	8002438 <BC_Int_Callback+0x14>
	{
		BSP_BC_CmdSend(SHIPPING_MODE_ON);
	}
}
 8002436:	bd08      	pop	{r3, pc}
 8002438:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		BSP_BC_CmdSend(SHIPPING_MODE_ON);
 800243c:	2017      	movs	r0, #23
 800243e:	f002 b827 	b.w	8004490 <BSP_BC_CmdSend>
 8002442:	bf00      	nop
 8002444:	200014a8 	.word	0x200014a8

08002448 <HAL_UART_MspInit>:
    __HAL_RCC_USART2_CLK_ENABLE();
 8002448:	4b0d      	ldr	r3, [pc, #52]	; (8002480 <HAL_UART_MspInit+0x38>)
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800244a:	480e      	ldr	r0, [pc, #56]	; (8002484 <HAL_UART_MspInit+0x3c>)
    __HAL_RCC_USART2_CLK_ENABLE();
 800244c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
{
 800244e:	b570      	push	{r4, r5, r6, lr}
    __HAL_RCC_USART2_CLK_ENABLE();
 8002450:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8002454:	659a      	str	r2, [r3, #88]	; 0x58
 8002456:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    GPIO_InitStruct.Pin = USART_CR2_RXINV|USART2_RTS_Pin|USART2_TX_Pin;
 8002458:	4c0b      	ldr	r4, [pc, #44]	; (8002488 <HAL_UART_MspInit+0x40>)
{
 800245a:	b088      	sub	sp, #32
    __HAL_RCC_USART2_CLK_ENABLE();
 800245c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8002460:	2107      	movs	r1, #7
    __HAL_RCC_USART2_CLK_ENABLE();
 8002462:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = USART_CR2_RXINV|USART2_RTS_Pin|USART2_TX_Pin;
 8002464:	2200      	movs	r2, #0
 8002466:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8002468:	9106      	str	r1, [sp, #24]
    GPIO_InitStruct.Pin = USART_CR2_RXINV|USART2_RTS_Pin|USART2_TX_Pin;
 800246a:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800246c:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = USART_CR2_RXINV|USART2_RTS_Pin|USART2_TX_Pin;
 800246e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8002472:	e9cd 2304 	strd	r2, r3, [sp, #16]
    __HAL_RCC_USART2_CLK_ENABLE();
 8002476:	9e01      	ldr	r6, [sp, #4]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002478:	f003 fc1a 	bl	8005cb0 <HAL_GPIO_Init>
}
 800247c:	b008      	add	sp, #32
 800247e:	bd70      	pop	{r4, r5, r6, pc}
 8002480:	40021000 	.word	0x40021000
 8002484:	48000c00 	.word	0x48000c00
 8002488:	00010030 	.word	0x00010030

0800248c <SystemClock_Config>:
{
 800248c:	b570      	push	{r4, r5, r6, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800248e:	2100      	movs	r1, #0
{
 8002490:	b0c0      	sub	sp, #256	; 0x100
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8002492:	460c      	mov	r4, r1
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8002494:	2244      	movs	r2, #68	; 0x44
 8002496:	a806      	add	r0, sp, #24
 8002498:	f013 fd7a 	bl	8015f90 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800249c:	4621      	mov	r1, r4
 800249e:	a818      	add	r0, sp, #96	; 0x60
 80024a0:	229c      	movs	r2, #156	; 0x9c
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80024a2:	e9cd 4400 	strd	r4, r4, [sp]
 80024a6:	e9cd 4402 	strd	r4, r4, [sp, #8]
 80024aa:	9404      	str	r4, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80024ac:	f013 fd70 	bl	8015f90 <memset>
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) != HAL_OK)
 80024b0:	4620      	mov	r0, r4
 80024b2:	f004 fc1f 	bl	8006cf4 <HAL_PWREx_ControlVoltageScaling>
 80024b6:	b100      	cbz	r0, 80024ba <SystemClock_Config+0x2e>
 * @param  None
 * @retval None
 */
static void Error_Handler(void)
{
	while(1);
 80024b8:	e7fe      	b.n	80024b8 <SystemClock_Config+0x2c>
  HAL_PWR_EnableBkUpAccess();
 80024ba:	f004 fbbb 	bl	8006c34 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 80024be:	4a28      	ldr	r2, [pc, #160]	; (8002560 <SystemClock_Config+0xd4>)
 80024c0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80024c4:	f023 0318 	bic.w	r3, r3, #24
 80024c8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 80024cc:	2201      	movs	r2, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80024ce:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80024d0:	2103      	movs	r1, #3
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 80024d2:	9208      	str	r2, [sp, #32]
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 80024d4:	920f      	str	r2, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80024d6:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLN = 20;
 80024d8:	2214      	movs	r2, #20
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE
 80024da:	2425      	movs	r4, #37	; 0x25
 80024dc:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 80024e0:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80024e4:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLM = 2;
 80024e6:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80024e8:	9316      	str	r3, [sp, #88]	; 0x58
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE
 80024ea:	e9cd 4506 	strd	r4, r5, [sp, #24]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80024ee:	9111      	str	r1, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLN = 20;
 80024f0:	9213      	str	r2, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80024f2:	f004 fd5b 	bl	8006fac <HAL_RCC_OscConfig>
 80024f6:	4603      	mov	r3, r0
 80024f8:	b100      	cbz	r0, 80024fc <SystemClock_Config+0x70>
	while(1);
 80024fa:	e7fe      	b.n	80024fa <SystemClock_Config+0x6e>
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80024fc:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80024fe:	220f      	movs	r2, #15
 8002500:	2303      	movs	r3, #3
 8002502:	e9cd 2300 	strd	r2, r3, [sp]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8002506:	4668      	mov	r0, sp
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002508:	2300      	movs	r3, #0
 800250a:	2200      	movs	r2, #0
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 800250c:	2105      	movs	r1, #5
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800250e:	e9cd 2302 	strd	r2, r3, [sp, #8]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 8002512:	f005 f861 	bl	80075d8 <HAL_RCC_ClockConfig>
 8002516:	4603      	mov	r3, r0
 8002518:	b100      	cbz	r0, 800251c <SystemClock_Config+0x90>
	while(1);
 800251a:	e7fe      	b.n	800251a <SystemClock_Config+0x8e>
  PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLLP;
 800251c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_SDMMC1 |RCC_PERIPHCLK_ADC;
 8002520:	4c10      	ldr	r4, [pc, #64]	; (8002564 <SystemClock_Config+0xd8>)
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8002522:	9328      	str	r3, [sp, #160]	; 0xa0
  PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLLP;
 8002524:	9236      	str	r2, [sp, #216]	; 0xd8
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_SDMMC1 |RCC_PERIPHCLK_ADC;
 8002526:	2360      	movs	r3, #96	; 0x60
 8002528:	2205      	movs	r2, #5
 800252a:	e9cd 231a 	strd	r2, r3, [sp, #104]	; 0x68
 800252e:	2503      	movs	r5, #3
 8002530:	4b0d      	ldr	r3, [pc, #52]	; (8002568 <SystemClock_Config+0xdc>)
 8002532:	e9cd 4518 	strd	r4, r5, [sp, #96]	; 0x60
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 8002536:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800253a:	f44f 7180 	mov.w	r1, #256	; 0x100
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_SDMMC1 |RCC_PERIPHCLK_ADC;
 800253e:	2419      	movs	r4, #25
 8002540:	2504      	movs	r5, #4
 8002542:	2204      	movs	r2, #4
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002544:	a818      	add	r0, sp, #96	; 0x60
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_SDMMC1 |RCC_PERIPHCLK_ADC;
 8002546:	e9cd 451c 	strd	r4, r5, [sp, #112]	; 0x70
 800254a:	e9cd 231e 	strd	r2, r3, [sp, #120]	; 0x78
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 800254e:	9638      	str	r6, [sp, #224]	; 0xe0
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8002550:	913e      	str	r1, [sp, #248]	; 0xf8
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8002552:	f005 faa9 	bl	8007aa8 <HAL_RCCEx_PeriphCLKConfig>
 8002556:	b908      	cbnz	r0, 800255c <SystemClock_Config+0xd0>
}
 8002558:	b040      	add	sp, #256	; 0x100
 800255a:	bd70      	pop	{r4, r5, r6, pc}
	while(1);
 800255c:	e7fe      	b.n	800255c <SystemClock_Config+0xd0>
 800255e:	bf00      	nop
 8002560:	40021000 	.word	0x40021000
 8002564:	000a4002 	.word	0x000a4002
 8002568:	01010000 	.word	0x01010000

0800256c <PVD_Config>:
	__HAL_RCC_PWR_CLK_ENABLE();
 800256c:	4b10      	ldr	r3, [pc, #64]	; (80025b0 <PVD_Config+0x44>)
{
 800256e:	b500      	push	{lr}
	__HAL_RCC_PWR_CLK_ENABLE();
 8002570:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8002572:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002576:	659a      	str	r2, [r3, #88]	; 0x58
 8002578:	6d9b      	ldr	r3, [r3, #88]	; 0x58
{
 800257a:	b085      	sub	sp, #20
	HAL_NVIC_SetPriority(PVD_PVM_IRQn, 0, 0);
 800257c:	2200      	movs	r2, #0
	__HAL_RCC_PWR_CLK_ENABLE();
 800257e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
	HAL_NVIC_SetPriority(PVD_PVM_IRQn, 0, 0);
 8002582:	4611      	mov	r1, r2
	__HAL_RCC_PWR_CLK_ENABLE();
 8002584:	9301      	str	r3, [sp, #4]
	HAL_NVIC_SetPriority(PVD_PVM_IRQn, 0, 0);
 8002586:	2001      	movs	r0, #1
	__HAL_RCC_PWR_CLK_ENABLE();
 8002588:	9b01      	ldr	r3, [sp, #4]
	HAL_NVIC_SetPriority(PVD_PVM_IRQn, 0, 0);
 800258a:	f003 f99b 	bl	80058c4 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(PVD_PVM_IRQn);
 800258e:	2001      	movs	r0, #1
 8002590:	f003 f9d0 	bl	8005934 <HAL_NVIC_EnableIRQ>
	sConfigPVD.PVDLevel = PWR_PVDLEVEL_6;
 8002594:	220c      	movs	r2, #12
 8002596:	f04f 1301 	mov.w	r3, #65537	; 0x10001
	HAL_PWR_ConfigPVD(&sConfigPVD);
 800259a:	a802      	add	r0, sp, #8
	sConfigPVD.PVDLevel = PWR_PVDLEVEL_6;
 800259c:	e9cd 2302 	strd	r2, r3, [sp, #8]
	HAL_PWR_ConfigPVD(&sConfigPVD);
 80025a0:	f004 fb50 	bl	8006c44 <HAL_PWR_ConfigPVD>
	HAL_PWR_EnablePVD();
 80025a4:	f004 fb8c 	bl	8006cc0 <HAL_PWR_EnablePVD>
}
 80025a8:	b005      	add	sp, #20
 80025aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80025ae:	bf00      	nop
 80025b0:	40021000 	.word	0x40021000

080025b4 <main>:
{
 80025b4:	b580      	push	{r7, lr}
	__HAL_RCC_PWR_CLK_ENABLE();
 80025b6:	4c5b      	ldr	r4, [pc, #364]	; (8002724 <main+0x170>)
	t_stwin = HAL_GetTick();
 80025b8:	4e5b      	ldr	r6, [pc, #364]	; (8002728 <main+0x174>)
{
 80025ba:	b08e      	sub	sp, #56	; 0x38
	HAL_Init();
 80025bc:	f002 faf4 	bl	8004ba8 <HAL_Init>
	SystemClock_Config();
 80025c0:	f7ff ff64 	bl	800248c <SystemClock_Config>
	__HAL_RCC_PWR_CLK_ENABLE();
 80025c4:	6da2      	ldr	r2, [r4, #88]	; 0x58
  hsd1.Instance = SDMMC1;
 80025c6:	4b59      	ldr	r3, [pc, #356]	; (800272c <main+0x178>)
 80025c8:	4959      	ldr	r1, [pc, #356]	; (8002730 <main+0x17c>)
	__HAL_RCC_PWR_CLK_ENABLE();
 80025ca:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80025ce:	65a2      	str	r2, [r4, #88]	; 0x58
 80025d0:	6da2      	ldr	r2, [r4, #88]	; 0x58
  hsd1.Instance = SDMMC1;
 80025d2:	6019      	str	r1, [r3, #0]
	__HAL_RCC_PWR_CLK_ENABLE();
 80025d4:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 80025d8:	2500      	movs	r5, #0
	__HAL_RCC_PWR_CLK_ENABLE();
 80025da:	9201      	str	r2, [sp, #4]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 80025dc:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80025e0:	60da      	str	r2, [r3, #12]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 80025e2:	e9c3 5501 	strd	r5, r5, [r3, #4]
  hsd1.Init.ClockDiv = 0;
 80025e6:	e9c3 5504 	strd	r5, r5, [r3, #16]
  hsd1.Init.Transceiver = SDMMC_TRANSCEIVER_DISABLE;
 80025ea:	619d      	str	r5, [r3, #24]
	__HAL_RCC_PWR_CLK_ENABLE();
 80025ec:	9901      	ldr	r1, [sp, #4]
	BSP_BC_Init();
 80025ee:	f002 f8bd 	bl	800476c <BSP_BC_Init>
	BSP_BC_BatMS_Init();
 80025f2:	f001 ff71 	bl	80044d8 <BSP_BC_BatMS_Init>
	BSP_BC_CmdSend(BATMS_ON);
 80025f6:	200a      	movs	r0, #10
 80025f8:	f001 ff4a 	bl	8004490 <BSP_BC_CmdSend>
	HAL_EXTI_GetHandle(&BC_exti, EXTI_LINE_10);
 80025fc:	494d      	ldr	r1, [pc, #308]	; (8002734 <main+0x180>)
 80025fe:	484e      	ldr	r0, [pc, #312]	; (8002738 <main+0x184>)
 8002600:	f003 fb38 	bl	8005c74 <HAL_EXTI_GetHandle>
	HAL_EXTI_RegisterCallback(&BC_exti,  HAL_EXTI_COMMON_CB_ID, BC_Int_Callback);
 8002604:	4a4d      	ldr	r2, [pc, #308]	; (800273c <main+0x188>)
 8002606:	484c      	ldr	r0, [pc, #304]	; (8002738 <main+0x184>)
 8002608:	4629      	mov	r1, r5
 800260a:	f003 fb2d 	bl	8005c68 <HAL_EXTI_RegisterCallback>
	t_stwin = HAL_GetTick();
 800260e:	f002 fae7 	bl	8004be0 <HAL_GetTick>
 8002612:	6030      	str	r0, [r6, #0]
	PVD_Config();
 8002614:	f7ff ffaa 	bl	800256c <PVD_Config>
	BSP_LED_Init(LED1);					/* Green */
 8002618:	4628      	mov	r0, r5
 800261a:	f001 feef 	bl	80043fc <BSP_LED_Init>
	BSP_LED_Init(LED2);   				/* Orange */
 800261e:	2001      	movs	r0, #1
 8002620:	f001 feec 	bl	80043fc <BSP_LED_Init>
	__HAL_RCC_GPIOA_CLK_ENABLE();			/* PA13, 14 are for DEBUG */
 8002624:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
	HSD_JSON_set_allocation_functions(HSD_malloc, HSD_free);
 8002626:	4946      	ldr	r1, [pc, #280]	; (8002740 <main+0x18c>)
 8002628:	4846      	ldr	r0, [pc, #280]	; (8002744 <main+0x190>)
	__HAL_RCC_GPIOA_CLK_ENABLE();			/* PA13, 14 are for DEBUG */
 800262a:	f043 0301 	orr.w	r3, r3, #1
 800262e:	64e3      	str	r3, [r4, #76]	; 0x4c
 8002630:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
	huart2.Instance = USART2;
 8002632:	4c45      	ldr	r4, [pc, #276]	; (8002748 <main+0x194>)
	__HAL_RCC_GPIOA_CLK_ENABLE();			/* PA13, 14 are for DEBUG */
 8002634:	f003 0301 	and.w	r3, r3, #1
 8002638:	9302      	str	r3, [sp, #8]
 800263a:	9b02      	ldr	r3, [sp, #8]
	HSD_JSON_set_allocation_functions(HSD_malloc, HSD_free);
 800263c:	f7ff f8b2 	bl	80017a4 <HSD_JSON_set_allocation_functions>
	set_default_description();
 8002640:	f7ff f9ea 	bl	8001a18 <set_default_description>
	BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
 8002644:	2101      	movs	r1, #1
 8002646:	4628      	mov	r0, r5
 8002648:	f001 fea0 	bl	800438c <BSP_PB_Init>
	huart2.Init.Mode = UART_MODE_TX_RX;
 800264c:	f04f 080c 	mov.w	r8, #12
	BSP_PB_PWR_Init();
 8002650:	f001 fe72 	bl	8004338 <BSP_PB_PWR_Init>
	SM_Peripheral_Init();
 8002654:	f001 fb56 	bl	8003d04 <SM_Peripheral_Init>
	SM_OS_Init();
 8002658:	f001 fa50 	bl	8003afc <SM_OS_Init>
	huart2.Instance = USART2;
 800265c:	493b      	ldr	r1, [pc, #236]	; (800274c <main+0x198>)
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800265e:	60a5      	str	r5, [r4, #8]
	huart2.Init.BaudRate = 115200;
 8002660:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
	huart2.Init.HwFlowCtl = UART_HWCONTROL_RTS;
 8002664:	f44f 7380 	mov.w	r3, #256	; 0x100
	if (HAL_UART_Init(&huart2) != HAL_OK)
 8002668:	4620      	mov	r0, r4
	huart2.Init.Parity = UART_PARITY_NONE;
 800266a:	e9c4 5503 	strd	r5, r5, [r4, #12]
	huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800266e:	e9c4 5507 	strd	r5, r5, [r4, #28]
	huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8002672:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	huart2.Init.Mode = UART_MODE_TX_RX;
 8002676:	e9c4 8305 	strd	r8, r3, [r4, #20]
	huart2.Instance = USART2;
 800267a:	6021      	str	r1, [r4, #0]
	huart2.Init.BaudRate = 115200;
 800267c:	6062      	str	r2, [r4, #4]
	if (HAL_UART_Init(&huart2) != HAL_OK)
 800267e:	f007 fd7f 	bl	800a180 <HAL_UART_Init>
 8002682:	b100      	cbz	r0, 8002686 <main+0xd2>
	while(1);
 8002684:	e7fe      	b.n	8002684 <main+0xd0>
	if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8002686:	4601      	mov	r1, r0
 8002688:	4620      	mov	r0, r4
 800268a:	f008 fc3b 	bl	800af04 <HAL_UARTEx_SetTxFifoThreshold>
 800268e:	4601      	mov	r1, r0
 8002690:	b100      	cbz	r0, 8002694 <main+0xe0>
	while(1);
 8002692:	e7fe      	b.n	8002692 <main+0xde>
	if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8002694:	4620      	mov	r0, r4
 8002696:	f008 fc87 	bl	800afa8 <HAL_UARTEx_SetRxFifoThreshold>
 800269a:	b100      	cbz	r0, 800269e <main+0xea>
	while(1);
 800269c:	e7fe      	b.n	800269c <main+0xe8>
	if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 800269e:	4620      	mov	r0, r4
 80026a0:	f008 fc12 	bl	800aec8 <HAL_UARTEx_DisableFifoMode>
 80026a4:	4605      	mov	r5, r0
 80026a6:	2800      	cmp	r0, #0
 80026a8:	d13b      	bne.n	8002722 <main+0x16e>
  IIS3DWB_Peripheral_Init();
 80026aa:	f7ff fc85 	bl	8001fb8 <IIS3DWB_Peripheral_Init>
	SDM_Peripheral_Init();
 80026ae:	f000 fb1b 	bl	8002ce8 <SDM_Peripheral_Init>
  IIS3DWB_OS_Init();
 80026b2:	f7ff fd05 	bl	80020c0 <IIS3DWB_OS_Init>
	SDM_OS_Init();
 80026b6:	f000 fb19 	bl	8002cec <SDM_OS_Init>
	char wakeUp [] = {"MCU WAKE UP"};
 80026ba:	4b25      	ldr	r3, [pc, #148]	; (8002750 <main+0x19c>)
 80026bc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80026c0:	af05      	add	r7, sp, #20
 80026c2:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	HAL_UART_Transmit(&huart2, (uint8_t *) wakeUp, sizeof(wakeUp), HAL_MAX_DELAY);
 80026c6:	f04f 33ff 	mov.w	r3, #4294967295
 80026ca:	4639      	mov	r1, r7
 80026cc:	4642      	mov	r2, r8
 80026ce:	4620      	mov	r0, r4
 80026d0:	f008 fb54 	bl	800ad7c <HAL_UART_Transmit>
	BSP_BC_GetVoltageAndLevel(&mvLevel, &batteryLevel);
 80026d4:	1d31      	adds	r1, r6, #4
 80026d6:	f106 0008 	add.w	r0, r6, #8
 80026da:	f001 ff5f 	bl	800459c <BSP_BC_GetVoltageAndLevel>
	char soc [21] = {"SOC in % :"};
 80026de:	4b1d      	ldr	r3, [pc, #116]	; (8002754 <main+0x1a0>)
 80026e0:	f8cd 502b 	str.w	r5, [sp, #43]	; 0x2b
 80026e4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80026e8:	ab08      	add	r3, sp, #32
 80026ea:	c303      	stmia	r3!, {r0, r1}
 80026ec:	f823 2b02 	strh.w	r2, [r3], #2
 80026f0:	0c17      	lsrs	r7, r2, #16
	itoa(batteryLevel,batVal,10);
 80026f2:	a903      	add	r1, sp, #12
 80026f4:	220a      	movs	r2, #10
 80026f6:	6870      	ldr	r0, [r6, #4]
	char soc [21] = {"SOC in % :"};
 80026f8:	701f      	strb	r7, [r3, #0]
 80026fa:	f8cd 502f 	str.w	r5, [sp, #47]	; 0x2f
 80026fe:	f8ad 5033 	strh.w	r5, [sp, #51]	; 0x33
	itoa(batteryLevel,batVal,10);
 8002702:	f013 fba3 	bl	8015e4c <itoa>
	strcat(soc, batVal);
 8002706:	a903      	add	r1, sp, #12
 8002708:	a808      	add	r0, sp, #32
 800270a:	f014 f9e9 	bl	8016ae0 <strcat>
	HAL_UART_Transmit(&huart2, (uint8_t *) soc, sizeof(soc), HAL_MAX_DELAY);
 800270e:	a908      	add	r1, sp, #32
 8002710:	f04f 33ff 	mov.w	r3, #4294967295
 8002714:	2215      	movs	r2, #21
 8002716:	4620      	mov	r0, r4
 8002718:	f008 fb30 	bl	800ad7c <HAL_UART_Transmit>
	osKernelStart();
 800271c:	f00e fb54 	bl	8010dc8 <osKernelStart>
	while(1);
 8002720:	e7fe      	b.n	8002720 <main+0x16c>
	while(1);
 8002722:	e7fe      	b.n	8002722 <main+0x16e>
 8002724:	40021000 	.word	0x40021000
 8002728:	200014a8 	.word	0x200014a8
 800272c:	20016f0c 	.word	0x20016f0c
 8002730:	50062400 	.word	0x50062400
 8002734:	1600000a 	.word	0x1600000a
 8002738:	20017298 	.word	0x20017298
 800273c:	08002425 	.word	0x08002425
 8002740:	08015f31 	.word	0x08015f31
 8002744:	08015f21 	.word	0x08015f21
 8002748:	200172a4 	.word	0x200172a4
 800274c:	40004400 	.word	0x40004400
 8002750:	0801a974 	.word	0x0801a974
 8002754:	0801a06c 	.word	0x0801a06c

08002758 <vApplicationIdleHook>:
	if(SD_Logging_Enabled)
 8002758:	4b2a      	ldr	r3, [pc, #168]	; (8002804 <vApplicationIdleHook+0xac>)
 800275a:	681b      	ldr	r3, [r3, #0]
{
 800275c:	b510      	push	{r4, lr}
	if(SD_Logging_Enabled)
 800275e:	b9fb      	cbnz	r3, 80027a0 <vApplicationIdleHook+0x48>
	if (!SD_Logging_Active)
 8002760:	4b29      	ldr	r3, [pc, #164]	; (8002808 <vApplicationIdleHook+0xb0>)
 8002762:	781b      	ldrb	r3, [r3, #0]
 8002764:	b9db      	cbnz	r3, 800279e <vApplicationIdleHook+0x46>
		if(com_status == HS_DATALOG_USB_STARTED)
 8002766:	4b29      	ldr	r3, [pc, #164]	; (800280c <vApplicationIdleHook+0xb4>)
 8002768:	781b      	ldrb	r3, [r3, #0]
 800276a:	2b01      	cmp	r3, #1
 800276c:	d01b      	beq.n	80027a6 <vApplicationIdleHook+0x4e>
			if (!BSP_SD_IsDetected())
 800276e:	f002 f911 	bl	8004994 <BSP_SD_IsDetected>
 8002772:	bb68      	cbnz	r0, 80027d0 <vApplicationIdleHook+0x78>
				if(!(HAL_GetTick()%200))
 8002774:	f002 fa34 	bl	8004be0 <HAL_GetTick>
 8002778:	4c25      	ldr	r4, [pc, #148]	; (8002810 <vApplicationIdleHook+0xb8>)
 800277a:	4b26      	ldr	r3, [pc, #152]	; (8002814 <vApplicationIdleHook+0xbc>)
 800277c:	fb04 f000 	mul.w	r0, r4, r0
 8002780:	ebb3 0ff0 	cmp.w	r3, r0, ror #3
 8002784:	d237      	bcs.n	80027f6 <vApplicationIdleHook+0x9e>
					if(!(HAL_GetTick()%100))
 8002786:	f002 fa2b 	bl	8004be0 <HAL_GetTick>
 800278a:	4b23      	ldr	r3, [pc, #140]	; (8002818 <vApplicationIdleHook+0xc0>)
 800278c:	fb04 f000 	mul.w	r0, r4, r0
 8002790:	ebb3 0fb0 	cmp.w	r3, r0, ror #2
 8002794:	d318      	bcc.n	80027c8 <vApplicationIdleHook+0x70>
					BSP_LED_Off(LED_ORANGE);
 8002796:	2001      	movs	r0, #1
 8002798:	f001 fe6c 	bl	8004474 <BSP_LED_Off>
 800279c:	e014      	b.n	80027c8 <vApplicationIdleHook+0x70>
}
 800279e:	bd10      	pop	{r4, pc}
		SDM_AutosaveFile();
 80027a0:	f001 f8a8 	bl	80038f4 <SDM_AutosaveFile>
 80027a4:	e7dc      	b.n	8002760 <vApplicationIdleHook+0x8>
			if(!(HAL_GetTick()%100))
 80027a6:	f002 fa1b 	bl	8004be0 <HAL_GetTick>
 80027aa:	4c19      	ldr	r4, [pc, #100]	; (8002810 <vApplicationIdleHook+0xb8>)
 80027ac:	4b1a      	ldr	r3, [pc, #104]	; (8002818 <vApplicationIdleHook+0xc0>)
 80027ae:	fb04 f000 	mul.w	r0, r4, r0
 80027b2:	ebb3 0fb0 	cmp.w	r3, r0, ror #2
 80027b6:	d21e      	bcs.n	80027f6 <vApplicationIdleHook+0x9e>
				if(!(HAL_GetTick()%50))
 80027b8:	f002 fa12 	bl	8004be0 <HAL_GetTick>
 80027bc:	4b17      	ldr	r3, [pc, #92]	; (800281c <vApplicationIdleHook+0xc4>)
 80027be:	fb04 f000 	mul.w	r0, r4, r0
 80027c2:	ebb3 0f70 	cmp.w	r3, r0, ror #1
 80027c6:	d2e6      	bcs.n	8002796 <vApplicationIdleHook+0x3e>
}
 80027c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					SDM_StartMeasurements();
 80027cc:	f001 b848 	b.w	8003860 <SDM_StartMeasurements>
				if(!(HAL_GetTick()%1000))
 80027d0:	f002 fa06 	bl	8004be0 <HAL_GetTick>
 80027d4:	4b12      	ldr	r3, [pc, #72]	; (8002820 <vApplicationIdleHook+0xc8>)
 80027d6:	4a13      	ldr	r2, [pc, #76]	; (8002824 <vApplicationIdleHook+0xcc>)
 80027d8:	fb03 f000 	mul.w	r0, r3, r0
 80027dc:	ebb2 0ff0 	cmp.w	r2, r0, ror #3
 80027e0:	d209      	bcs.n	80027f6 <vApplicationIdleHook+0x9e>
					if(!(HAL_GetTick()%50))
 80027e2:	f002 f9fd 	bl	8004be0 <HAL_GetTick>
 80027e6:	4b0a      	ldr	r3, [pc, #40]	; (8002810 <vApplicationIdleHook+0xb8>)
 80027e8:	4a0c      	ldr	r2, [pc, #48]	; (800281c <vApplicationIdleHook+0xc4>)
 80027ea:	fb03 f000 	mul.w	r0, r3, r0
 80027ee:	ebb2 0f70 	cmp.w	r2, r0, ror #1
 80027f2:	d3e9      	bcc.n	80027c8 <vApplicationIdleHook+0x70>
 80027f4:	e7cf      	b.n	8002796 <vApplicationIdleHook+0x3e>
				BSP_LED_On(LED_ORANGE);
 80027f6:	2001      	movs	r0, #1
 80027f8:	f001 fe2e 	bl	8004458 <BSP_LED_On>
}
 80027fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					SDM_StartMeasurements();
 8002800:	f001 b82e 	b.w	8003860 <SDM_StartMeasurements>
 8002804:	20001700 	.word	0x20001700
 8002808:	200016f0 	.word	0x200016f0
 800280c:	2000038c 	.word	0x2000038c
 8002810:	c28f5c29 	.word	0xc28f5c29
 8002814:	0147ae14 	.word	0x0147ae14
 8002818:	028f5c28 	.word	0x028f5c28
 800281c:	051eb851 	.word	0x051eb851
 8002820:	26e978d5 	.word	0x26e978d5
 8002824:	00418937 	.word	0x00418937

08002828 <SENSOR_Generic_Data_Ready>:
{ 
 8002828:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800282c:	ed2d 8b06 	vpush	{d8-d10}
 8002830:	eeb0 8a40 	vmov.f32	s16, s0
 8002834:	eef0 8a60 	vmov.f32	s17, s1
	COM_SensorStatus_t * tempStatus = COM_GetSensorStatus(sId);
 8002838:	b2c3      	uxtb	r3, r0
{ 
 800283a:	b085      	sub	sp, #20
 800283c:	4606      	mov	r6, r0
	COM_SensorStatus_t * tempStatus = COM_GetSensorStatus(sId);
 800283e:	4618      	mov	r0, r3
 8002840:	461c      	mov	r4, r3
 8002842:	ee0a 3a10 	vmov	s20, r3
{ 
 8002846:	4617      	mov	r7, r2
 8002848:	ec5a 9b10 	vmov	r9, sl, d0
 800284c:	4688      	mov	r8, r1
	COM_SensorStatus_t * tempStatus = COM_GetSensorStatus(sId);
 800284e:	f7ff f89b 	bl	8001988 <COM_GetSensorStatus>
 8002852:	4605      	mov	r5, r0
	COM_SensorDescriptor_t * tempDescriptor = COM_GetSensorDescriptor(sId);
 8002854:	4620      	mov	r0, r4
 8002856:	f7ff f88f 	bl	8001978 <COM_GetSensorDescriptor>
	if (sensor_first_dataReady[sId]) // Discard first set of sensor data
 800285a:	4bcf      	ldr	r3, [pc, #828]	; (8002b98 <SENSOR_Generic_Data_Ready+0x370>)
 800285c:	5d9a      	ldrb	r2, [r3, r6]
 800285e:	b1ca      	cbz	r2, 8002894 <SENSOR_Generic_Data_Ready+0x6c>
		sensor_n_samples_acc[sId] = 0.0f;
 8002860:	4cce      	ldr	r4, [pc, #824]	; (8002b9c <SENSOR_Generic_Data_Ready+0x374>)
 8002862:	eb04 0186 	add.w	r1, r4, r6, lsl #2
		sensor_first_dataReady[sId] = 0;
 8002866:	2200      	movs	r2, #0
		sensor_n_samples_acc[sId] = 0.0f;
 8002868:	2000      	movs	r0, #0
		sensor_first_dataReady[sId] = 0;
 800286a:	559a      	strb	r2, [r3, r6]
		sensor_n_samples_acc[sId] = 0.0f;
 800286c:	60c8      	str	r0, [r1, #12]
		tempStatus->initialOffset = (float)timeStamp;
 800286e:	4648      	mov	r0, r9
 8002870:	4651      	mov	r1, sl
 8002872:	f7fe f9e1 	bl	8000c38 <__aeabi_d2f>
		sensor_n_samples_to_timestamp[sId] = tempStatus->samplesPerTimestamp;
 8002876:	eb04 0346 	add.w	r3, r4, r6, lsl #1
		old_time_stamp[sId] = timeStamp;
 800287a:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
		sensor_n_samples_to_timestamp[sId] = tempStatus->samplesPerTimestamp;
 800287e:	89aa      	ldrh	r2, [r5, #12]
		tempStatus->initialOffset = (float)timeStamp;
 8002880:	60a8      	str	r0, [r5, #8]
		old_time_stamp[sId] = timeStamp;
 8002882:	e9c6 9a0e 	strd	r9, sl, [r6, #56]	; 0x38
		sensor_n_samples_to_timestamp[sId] = tempStatus->samplesPerTimestamp;
 8002886:	f8a3 2090 	strh.w	r2, [r3, #144]	; 0x90
}
 800288a:	b005      	add	sp, #20
 800288c:	ecbd 8b06 	vpop	{d8-d10}
 8002890:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(tempDescriptor->dataType == DATA_TYPE_FLOAT || tempDescriptor->dataType == DATA_TYPE_INT32 || tempDescriptor->dataType == DATA_TYPE_UINT32)
 8002894:	f890 a011 	ldrb.w	sl, [r0, #17]
 8002898:	f1aa 0304 	sub.w	r3, sl, #4
 800289c:	2b02      	cmp	r3, #2
 800289e:	4604      	mov	r4, r0
 80028a0:	d938      	bls.n	8002914 <SENSOR_Generic_Data_Ready+0xec>
		else if(tempDescriptor->dataType == DATA_TYPE_UINT16 || tempDescriptor->dataType == DATA_TYPE_INT16)
 80028a2:	f1aa 0302 	sub.w	r3, sl, #2
 80028a6:	2b01      	cmp	r3, #1
 80028a8:	f240 8117 	bls.w	8002ada <SENSOR_Generic_Data_Ready+0x2b2>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 80028ac:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
			nBytesPerSample = 4;
 80028b0:	f1ba 0f01 	cmp.w	sl, #1
 80028b4:	bf8c      	ite	hi
 80028b6:	f04f 0a00 	movhi.w	sl, #0
 80028ba:	f04f 0a01 	movls.w	sl, #1
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 80028be:	f1b9 0f00 	cmp.w	r9, #0
 80028c2:	d12e      	bne.n	8002922 <SENSOR_Generic_Data_Ready+0xfa>
		sensor_n_samples_acc[sId] = (float)(size / nBytesPerSample);
 80028c4:	fbb7 f4f9 	udiv	r4, r7, r9
 80028c8:	ee07 4a90 	vmov	s15, r4
 80028cc:	4bb3      	ldr	r3, [pc, #716]	; (8002b9c <SENSOR_Generic_Data_Ready+0x374>)
 80028ce:	9300      	str	r3, [sp, #0]
 80028d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80028d4:	461f      	mov	r7, r3
 80028d6:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 80028da:	edc3 7a03 	vstr	s15, [r3, #12]
		tempStatus->measuredODR = sensor_n_samples_acc[sId]/(timeStamp - old_time_stamp[sId]);
 80028de:	ee17 0a90 	vmov	r0, s15
 80028e2:	f7fd fe59 	bl	8000598 <__aeabi_f2d>
 80028e6:	eb07 07c6 	add.w	r7, r7, r6, lsl #3
 80028ea:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 80028ee:	468b      	mov	fp, r1
 80028f0:	4682      	mov	sl, r0
 80028f2:	ec51 0b18 	vmov	r0, r1, d8
 80028f6:	f7fd fcef 	bl	80002d8 <__aeabi_dsub>
 80028fa:	4602      	mov	r2, r0
 80028fc:	460b      	mov	r3, r1
 80028fe:	4650      	mov	r0, sl
 8002900:	4659      	mov	r1, fp
 8002902:	f7fd ffcb 	bl	800089c <__aeabi_ddiv>
 8002906:	f7fe f997 	bl	8000c38 <__aeabi_d2f>
		old_time_stamp[sId] = timeStamp;
 800290a:	46cb      	mov	fp, r9
		tempStatus->measuredODR = sensor_n_samples_acc[sId]/(timeStamp - old_time_stamp[sId]);
 800290c:	6068      	str	r0, [r5, #4]
		old_time_stamp[sId] = timeStamp;
 800290e:	ed87 8b0e 	vstr	d8, [r7, #56]	; 0x38
		while(toSend > 0)
 8002912:	e066      	b.n	80029e2 <SENSOR_Generic_Data_Ready+0x1ba>
			nBytesPerSample = 4;
 8002914:	f04f 0a04 	mov.w	sl, #4
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 8002918:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
 800291c:	f1b9 0f00 	cmp.w	r9, #0
 8002920:	d0d0      	beq.n	80028c4 <SENSOR_Generic_Data_Ready+0x9c>
			if (tempStatus->subSensorStatus[i].isActive)
 8002922:	f895 b024 	ldrb.w	fp, [r5, #36]	; 0x24
 8002926:	f1bb 0f00 	cmp.w	fp, #0
 800292a:	f040 8101 	bne.w	8002b30 <SENSOR_Generic_Data_Ready+0x308>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 800292e:	f1b9 0f01 	cmp.w	r9, #1
 8002932:	d92b      	bls.n	800298c <SENSOR_Generic_Data_Ready+0x164>
			if (tempStatus->subSensorStatus[i].isActive)
 8002934:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
 8002938:	2b00      	cmp	r3, #0
 800293a:	f040 8103 	bne.w	8002b44 <SENSOR_Generic_Data_Ready+0x31c>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 800293e:	f1b9 0f02 	cmp.w	r9, #2
 8002942:	d923      	bls.n	800298c <SENSOR_Generic_Data_Ready+0x164>
			if (tempStatus->subSensorStatus[i].isActive)
 8002944:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
 8002948:	2b00      	cmp	r3, #0
 800294a:	f040 80c9 	bne.w	8002ae0 <SENSOR_Generic_Data_Ready+0x2b8>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 800294e:	f1b9 0f03 	cmp.w	r9, #3
 8002952:	d91b      	bls.n	800298c <SENSOR_Generic_Data_Ready+0x164>
			if (tempStatus->subSensorStatus[i].isActive)
 8002954:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 8002958:	2b00      	cmp	r3, #0
 800295a:	f040 80cd 	bne.w	8002af8 <SENSOR_Generic_Data_Ready+0x2d0>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 800295e:	f1b9 0f04 	cmp.w	r9, #4
 8002962:	d913      	bls.n	800298c <SENSOR_Generic_Data_Ready+0x164>
			if (tempStatus->subSensorStatus[i].isActive)
 8002964:	f895 3054 	ldrb.w	r3, [r5, #84]	; 0x54
 8002968:	2b00      	cmp	r3, #0
 800296a:	f040 8108 	bne.w	8002b7e <SENSOR_Generic_Data_Ready+0x356>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 800296e:	f1b9 0f05 	cmp.w	r9, #5
 8002972:	d90b      	bls.n	800298c <SENSOR_Generic_Data_Ready+0x164>
 8002974:	462a      	mov	r2, r5
 8002976:	2305      	movs	r3, #5
			if (tempStatus->subSensorStatus[i].isActive)
 8002978:	f892 1060 	ldrb.w	r1, [r2, #96]	; 0x60
 800297c:	2900      	cmp	r1, #0
 800297e:	f040 8115 	bne.w	8002bac <SENSOR_Generic_Data_Ready+0x384>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 8002982:	3301      	adds	r3, #1
 8002984:	4599      	cmp	r9, r3
 8002986:	f102 020c 	add.w	r2, r2, #12
 800298a:	dcf5      	bgt.n	8002978 <SENSOR_Generic_Data_Ready+0x150>
 800298c:	fb0b fb0a 	mul.w	fp, fp, sl
		sensor_n_samples_acc[sId] = (float)(size / nBytesPerSample);
 8002990:	fbb7 f4fb 	udiv	r4, r7, fp
 8002994:	ee07 4a90 	vmov	s15, r4
 8002998:	4b80      	ldr	r3, [pc, #512]	; (8002b9c <SENSOR_Generic_Data_Ready+0x374>)
 800299a:	9300      	str	r3, [sp, #0]
 800299c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80029a0:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 80029a4:	edc3 7a03 	vstr	s15, [r3, #12]
		tempStatus->measuredODR = sensor_n_samples_acc[sId]/(timeStamp - old_time_stamp[sId]);
 80029a8:	ee17 0a90 	vmov	r0, s15
 80029ac:	f7fd fdf4 	bl	8000598 <__aeabi_f2d>
 80029b0:	9b00      	ldr	r3, [sp, #0]
 80029b2:	eb03 09c6 	add.w	r9, r3, r6, lsl #3
 80029b6:	e9d9 230e 	ldrd	r2, r3, [r9, #56]	; 0x38
 80029ba:	ec41 0b19 	vmov	d9, r0, r1
 80029be:	ec51 0b18 	vmov	r0, r1, d8
 80029c2:	f7fd fc89 	bl	80002d8 <__aeabi_dsub>
 80029c6:	4602      	mov	r2, r0
 80029c8:	460b      	mov	r3, r1
 80029ca:	ec51 0b19 	vmov	r0, r1, d9
 80029ce:	f7fd ff65 	bl	800089c <__aeabi_ddiv>
 80029d2:	f7fe f931 	bl	8000c38 <__aeabi_d2f>
		while(toSend > 0)
 80029d6:	455f      	cmp	r7, fp
		tempStatus->measuredODR = sensor_n_samples_acc[sId]/(timeStamp - old_time_stamp[sId]);
 80029d8:	6068      	str	r0, [r5, #4]
		old_time_stamp[sId] = timeStamp;
 80029da:	ed89 8b0e 	vstr	d8, [r9, #56]	; 0x38
		while(toSend > 0)
 80029de:	f4ff af54 	bcc.w	800288a <SENSOR_Generic_Data_Ready+0x62>
 80029e2:	9b00      	ldr	r3, [sp, #0]
 80029e4:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 8002ba8 <SENSOR_Generic_Data_Ready+0x380>
 80029e8:	eb03 0a46 	add.w	sl, r3, r6, lsl #1
 80029ec:	0072      	lsls	r2, r6, #1
 80029ee:	f8ba 3090 	ldrh.w	r3, [sl, #144]	; 0x90
 80029f2:	9201      	str	r2, [sp, #4]
 80029f4:	e031      	b.n	8002a5a <SENSOR_Generic_Data_Ready+0x232>
				else if (com_status == HS_DATALOG_USB_STARTED )
 80029f6:	f899 2000 	ldrb.w	r2, [r9]
 80029fa:	2a01      	cmp	r2, #1
 80029fc:	d047      	beq.n	8002a8e <SENSOR_Generic_Data_Ready+0x266>
				double newTS = timeStamp - ((1.0 / (double)tempStatus->measuredODR) * toSend);
 80029fe:	6868      	ldr	r0, [r5, #4]
				toSend -= sensor_n_samples_to_timestamp[sId];
 8002a00:	1ae4      	subs	r4, r4, r3
				buf+=sensor_n_samples_to_timestamp[sId] * nBytesPerSample;
 8002a02:	fb0b 8803 	mla	r8, fp, r3, r8
				double newTS = timeStamp - ((1.0 / (double)tempStatus->measuredODR) * toSend);
 8002a06:	f7fd fdc7 	bl	8000598 <__aeabi_f2d>
 8002a0a:	4602      	mov	r2, r0
 8002a0c:	460b      	mov	r3, r1
 8002a0e:	2000      	movs	r0, #0
 8002a10:	4963      	ldr	r1, [pc, #396]	; (8002ba0 <SENSOR_Generic_Data_Ready+0x378>)
 8002a12:	f7fd ff43 	bl	800089c <__aeabi_ddiv>
				toSend -= sensor_n_samples_to_timestamp[sId];
 8002a16:	b2a4      	uxth	r4, r4
				double newTS = timeStamp - ((1.0 / (double)tempStatus->measuredODR) * toSend);
 8002a18:	4606      	mov	r6, r0
 8002a1a:	4620      	mov	r0, r4
 8002a1c:	460f      	mov	r7, r1
 8002a1e:	f7fd fda9 	bl	8000574 <__aeabi_i2d>
 8002a22:	4602      	mov	r2, r0
 8002a24:	460b      	mov	r3, r1
 8002a26:	4630      	mov	r0, r6
 8002a28:	4639      	mov	r1, r7
 8002a2a:	f7fd fe0d 	bl	8000648 <__aeabi_dmul>
 8002a2e:	460b      	mov	r3, r1
 8002a30:	4602      	mov	r2, r0
 8002a32:	ec51 0b18 	vmov	r0, r1, d8
 8002a36:	f7fd fc4f 	bl	80002d8 <__aeabi_dsub>
				if(com_status == HS_DATALOG_SD_STARTED)
 8002a3a:	f899 3000 	ldrb.w	r3, [r9]
 8002a3e:	2b02      	cmp	r3, #2
				double newTS = timeStamp - ((1.0 / (double)tempStatus->measuredODR) * toSend);
 8002a40:	e9cd 0102 	strd	r0, r1, [sp, #8]
				if(com_status == HS_DATALOG_SD_STARTED)
 8002a44:	d01b      	beq.n	8002a7e <SENSOR_Generic_Data_Ready+0x256>
				else if (com_status == HS_DATALOG_USB_STARTED )
 8002a46:	f899 3000 	ldrb.w	r3, [r9]
 8002a4a:	2b01      	cmp	r3, #1
 8002a4c:	d029      	beq.n	8002aa2 <SENSOR_Generic_Data_Ready+0x27a>
				sensor_n_samples_to_timestamp[sId] = tempStatus->samplesPerTimestamp;
 8002a4e:	89ab      	ldrh	r3, [r5, #12]
 8002a50:	f8aa 3090 	strh.w	r3, [sl, #144]	; 0x90
		while(toSend > 0)
 8002a54:	2c00      	cmp	r4, #0
 8002a56:	f43f af18 	beq.w	800288a <SENSOR_Generic_Data_Ready+0x62>
			if(toSend < sensor_n_samples_to_timestamp[sId] || sensor_n_samples_to_timestamp[sId] == 0)
 8002a5a:	429c      	cmp	r4, r3
				if(com_status == HS_DATALOG_SD_STARTED)
 8002a5c:	f899 2000 	ldrb.w	r2, [r9]
			if(toSend < sensor_n_samples_to_timestamp[sId] || sensor_n_samples_to_timestamp[sId] == 0)
 8002a60:	d327      	bcc.n	8002ab2 <SENSOR_Generic_Data_Ready+0x28a>
 8002a62:	b333      	cbz	r3, 8002ab2 <SENSOR_Generic_Data_Ready+0x28a>
				if(com_status == HS_DATALOG_SD_STARTED)
 8002a64:	2a02      	cmp	r2, #2
 8002a66:	d1c6      	bne.n	80029f6 <SENSOR_Generic_Data_Ready+0x1ce>
					SDM_Fill_Buffer(sId, (uint8_t *)buf, sensor_n_samples_to_timestamp[sId] * nBytesPerSample);
 8002a68:	fb13 f30b 	smulbb	r3, r3, fp
 8002a6c:	b29a      	uxth	r2, r3
 8002a6e:	ee1a 0a10 	vmov	r0, s20
 8002a72:	4641      	mov	r1, r8
 8002a74:	f000 fa48 	bl	8002f08 <SDM_Fill_Buffer>
 8002a78:	f8ba 3090 	ldrh.w	r3, [sl, #144]	; 0x90
 8002a7c:	e7bf      	b.n	80029fe <SENSOR_Generic_Data_Ready+0x1d6>
					SDM_Fill_Buffer(sId, (uint8_t *)&newTS, 8);
 8002a7e:	2208      	movs	r2, #8
 8002a80:	ee1a 0a10 	vmov	r0, s20
 8002a84:	eb0d 0102 	add.w	r1, sp, r2
 8002a88:	f000 fa3e 	bl	8002f08 <SDM_Fill_Buffer>
 8002a8c:	e7df      	b.n	8002a4e <SENSOR_Generic_Data_Ready+0x226>
					USBD_WCID_STREAMING_FillTxDataBuffer(&USBD_Device, tempStatus->comChannelNumber, (uint8_t *)buf, sensor_n_samples_to_timestamp[sId] * nBytesPerSample);
 8002a8e:	fb0b f303 	mul.w	r3, fp, r3
 8002a92:	7e29      	ldrb	r1, [r5, #24]
 8002a94:	4843      	ldr	r0, [pc, #268]	; (8002ba4 <SENSOR_Generic_Data_Ready+0x37c>)
 8002a96:	4642      	mov	r2, r8
 8002a98:	f00a f872 	bl	800cb80 <USBD_WCID_STREAMING_FillTxDataBuffer>
 8002a9c:	f8ba 3090 	ldrh.w	r3, [sl, #144]	; 0x90
 8002aa0:	e7ad      	b.n	80029fe <SENSOR_Generic_Data_Ready+0x1d6>
					USBD_WCID_STREAMING_FillTxDataBuffer(&USBD_Device, tempStatus->comChannelNumber, (uint8_t *)&newTS, 8);
 8002aa2:	2308      	movs	r3, #8
 8002aa4:	7e29      	ldrb	r1, [r5, #24]
 8002aa6:	483f      	ldr	r0, [pc, #252]	; (8002ba4 <SENSOR_Generic_Data_Ready+0x37c>)
 8002aa8:	eb0d 0203 	add.w	r2, sp, r3
 8002aac:	f00a f868 	bl	800cb80 <USBD_WCID_STREAMING_FillTxDataBuffer>
 8002ab0:	e7cd      	b.n	8002a4e <SENSOR_Generic_Data_Ready+0x226>
				if(com_status == HS_DATALOG_SD_STARTED)
 8002ab2:	2a02      	cmp	r2, #2
 8002ab4:	d052      	beq.n	8002b5c <SENSOR_Generic_Data_Ready+0x334>
				else if (com_status == HS_DATALOG_USB_STARTED )
 8002ab6:	f899 2000 	ldrb.w	r2, [r9]
 8002aba:	2a01      	cmp	r2, #1
 8002abc:	d028      	beq.n	8002b10 <SENSOR_Generic_Data_Ready+0x2e8>
				if(sensor_n_samples_to_timestamp[sId] != 0)
 8002abe:	2b00      	cmp	r3, #0
 8002ac0:	f43f aee3 	beq.w	800288a <SENSOR_Generic_Data_Ready+0x62>
					sensor_n_samples_to_timestamp[sId] -= toSend;
 8002ac4:	e9dd 2100 	ldrd	r2, r1, [sp]
 8002ac8:	440a      	add	r2, r1
 8002aca:	1b1b      	subs	r3, r3, r4
 8002acc:	f8a2 3090 	strh.w	r3, [r2, #144]	; 0x90
}
 8002ad0:	b005      	add	sp, #20
 8002ad2:	ecbd 8b06 	vpop	{d8-d10}
 8002ad6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			nBytesPerSample = 2;
 8002ada:	f04f 0a02 	mov.w	sl, #2
 8002ade:	e71b      	b.n	8002918 <SENSOR_Generic_Data_Ready+0xf0>
				tempSubSensorDescriptor = COM_GetSubSensorDescriptor(sId, i);
 8002ae0:	ee1a 0a10 	vmov	r0, s20
 8002ae4:	2102      	movs	r1, #2
 8002ae6:	f7fe ff59 	bl	800199c <COM_GetSubSensorDescriptor>
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002aea:	7883      	ldrb	r3, [r0, #2]
 8002aec:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
 8002af0:	449b      	add	fp, r3
 8002af2:	fa5f fb8b 	uxtb.w	fp, fp
 8002af6:	e72a      	b.n	800294e <SENSOR_Generic_Data_Ready+0x126>
				tempSubSensorDescriptor = COM_GetSubSensorDescriptor(sId, i);
 8002af8:	ee1a 0a10 	vmov	r0, s20
 8002afc:	2103      	movs	r1, #3
 8002afe:	f7fe ff4d 	bl	800199c <COM_GetSubSensorDescriptor>
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002b02:	7883      	ldrb	r3, [r0, #2]
 8002b04:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
 8002b08:	449b      	add	fp, r3
 8002b0a:	fa5f fb8b 	uxtb.w	fp, fp
 8002b0e:	e726      	b.n	800295e <SENSOR_Generic_Data_Ready+0x136>
					USBD_WCID_STREAMING_FillTxDataBuffer(&USBD_Device, tempStatus->comChannelNumber  , (uint8_t *)buf, toSend * nBytesPerSample);
 8002b10:	fb0b f304 	mul.w	r3, fp, r4
 8002b14:	4642      	mov	r2, r8
 8002b16:	7e29      	ldrb	r1, [r5, #24]
 8002b18:	4822      	ldr	r0, [pc, #136]	; (8002ba4 <SENSOR_Generic_Data_Ready+0x37c>)
 8002b1a:	f00a f831 	bl	800cb80 <USBD_WCID_STREAMING_FillTxDataBuffer>
 8002b1e:	e9dd 3200 	ldrd	r3, r2, [sp]
 8002b22:	4413      	add	r3, r2
 8002b24:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
				if(sensor_n_samples_to_timestamp[sId] != 0)
 8002b28:	2b00      	cmp	r3, #0
 8002b2a:	f43f aeae 	beq.w	800288a <SENSOR_Generic_Data_Ready+0x62>
 8002b2e:	e7c9      	b.n	8002ac4 <SENSOR_Generic_Data_Ready+0x29c>
				tempSubSensorDescriptor = COM_GetSubSensorDescriptor(sId, i);
 8002b30:	ee1a 0a10 	vmov	r0, s20
 8002b34:	2100      	movs	r1, #0
 8002b36:	f7fe ff31 	bl	800199c <COM_GetSubSensorDescriptor>
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002b3a:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
 8002b3e:	f890 b002 	ldrb.w	fp, [r0, #2]
 8002b42:	e6f4      	b.n	800292e <SENSOR_Generic_Data_Ready+0x106>
				tempSubSensorDescriptor = COM_GetSubSensorDescriptor(sId, i);
 8002b44:	ee1a 0a10 	vmov	r0, s20
 8002b48:	2101      	movs	r1, #1
 8002b4a:	f7fe ff27 	bl	800199c <COM_GetSubSensorDescriptor>
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002b4e:	7883      	ldrb	r3, [r0, #2]
 8002b50:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
 8002b54:	449b      	add	fp, r3
 8002b56:	fa5f fb8b 	uxtb.w	fp, fp
 8002b5a:	e6f0      	b.n	800293e <SENSOR_Generic_Data_Ready+0x116>
					SDM_Fill_Buffer(sId , (uint8_t *)buf, toSend * nBytesPerSample);
 8002b5c:	fb14 f20b 	smulbb	r2, r4, fp
 8002b60:	b292      	uxth	r2, r2
 8002b62:	ee1a 0a10 	vmov	r0, s20
 8002b66:	4641      	mov	r1, r8
 8002b68:	f000 f9ce 	bl	8002f08 <SDM_Fill_Buffer>
 8002b6c:	e9dd 3200 	ldrd	r3, r2, [sp]
 8002b70:	4413      	add	r3, r2
 8002b72:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
				if(sensor_n_samples_to_timestamp[sId] != 0)
 8002b76:	2b00      	cmp	r3, #0
 8002b78:	f43f ae87 	beq.w	800288a <SENSOR_Generic_Data_Ready+0x62>
 8002b7c:	e7a2      	b.n	8002ac4 <SENSOR_Generic_Data_Ready+0x29c>
				tempSubSensorDescriptor = COM_GetSubSensorDescriptor(sId, i);
 8002b7e:	ee1a 0a10 	vmov	r0, s20
 8002b82:	2104      	movs	r1, #4
 8002b84:	f7fe ff0a 	bl	800199c <COM_GetSubSensorDescriptor>
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002b88:	7883      	ldrb	r3, [r0, #2]
 8002b8a:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
 8002b8e:	449b      	add	fp, r3
 8002b90:	fa5f fb8b 	uxtb.w	fp, fp
 8002b94:	e6eb      	b.n	800296e <SENSOR_Generic_Data_Ready+0x146>
 8002b96:	bf00      	nop
 8002b98:	200000c8 	.word	0x200000c8
 8002b9c:	200014a8 	.word	0x200014a8
 8002ba0:	3ff00000 	.word	0x3ff00000
 8002ba4:	20016fc4 	.word	0x20016fc4
 8002ba8:	2000038c 	.word	0x2000038c
				tempSubSensorDescriptor = COM_GetSubSensorDescriptor(sId, i);
 8002bac:	b2d9      	uxtb	r1, r3
 8002bae:	ee1a 0a10 	vmov	r0, s20
 8002bb2:	9201      	str	r2, [sp, #4]
 8002bb4:	9300      	str	r3, [sp, #0]
 8002bb6:	f7fe fef1 	bl	800199c <COM_GetSubSensorDescriptor>
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 8002bba:	9b00      	ldr	r3, [sp, #0]
 8002bbc:	f894 9058 	ldrb.w	r9, [r4, #88]	; 0x58
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002bc0:	7881      	ldrb	r1, [r0, #2]
 8002bc2:	9a01      	ldr	r2, [sp, #4]
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 8002bc4:	3301      	adds	r3, #1
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002bc6:	448b      	add	fp, r1
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 8002bc8:	454b      	cmp	r3, r9
 8002bca:	f102 020c 	add.w	r2, r2, #12
				totalDataPerSample += tempSubSensorDescriptor->dataPerSample;
 8002bce:	fa5f fb8b 	uxtb.w	fp, fp
		for (int i = 0; i < tempDescriptor->nSubSensors; i++)
 8002bd2:	f6ff aed1 	blt.w	8002978 <SENSOR_Generic_Data_Ready+0x150>
 8002bd6:	e6d9      	b.n	800298c <SENSOR_Generic_Data_Ready+0x164>

08002bd8 <IIS3DWB_Data_Ready>:
	SENSOR_Generic_Data_Ready(iis3dwb_com_id, buf, size, timeStamp);
 8002bd8:	4b02      	ldr	r3, [pc, #8]	; (8002be4 <IIS3DWB_Data_Ready+0xc>)
{  
 8002bda:	460a      	mov	r2, r1
	SENSOR_Generic_Data_Ready(iis3dwb_com_id, buf, size, timeStamp);
 8002bdc:	4601      	mov	r1, r0
 8002bde:	7818      	ldrb	r0, [r3, #0]
 8002be0:	f7ff be22 	b.w	8002828 <SENSOR_Generic_Data_Ready>
 8002be4:	20017291 	.word	0x20017291

08002be8 <MP23ABS1_Start>:
}

void MP23ABS1_Start(void)
{
  MP23ABS1_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(MP23ABS1_Thread_Id);
 8002be8:	4a03      	ldr	r2, [pc, #12]	; (8002bf8 <MP23ABS1_Start+0x10>)
  MP23ABS1_Sensor_State = newState;
 8002bea:	4b04      	ldr	r3, [pc, #16]	; (8002bfc <MP23ABS1_Start+0x14>)
  osThreadResume(MP23ABS1_Thread_Id);
 8002bec:	6810      	ldr	r0, [r2, #0]
  MP23ABS1_Sensor_State = newState;
 8002bee:	2203      	movs	r2, #3
 8002bf0:	701a      	strb	r2, [r3, #0]
  osThreadResume(MP23ABS1_Thread_Id);
 8002bf2:	f00e ba8d 	b.w	8011110 <osThreadResume>
 8002bf6:	bf00      	nop
 8002bf8:	200174a0 	.word	0x200174a0
 8002bfc:	200000d3 	.word	0x200000d3

08002c00 <MP23ABS1_Stop>:
  MP23ABS1_Sensor_State = newState;
 8002c00:	4b01      	ldr	r3, [pc, #4]	; (8002c08 <MP23ABS1_Stop+0x8>)
 8002c02:	2201      	movs	r2, #1
 8002c04:	701a      	strb	r2, [r3, #0]
}

void MP23ABS1_Stop(void)
{
  MP23ABS1_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 8002c06:	4770      	bx	lr
 8002c08:	200000d3 	.word	0x200000d3

08002c0c <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 8002c0c:	b530      	push	{r4, r5, lr}
  RTC_TimeTypeDef sTime = {0};
 8002c0e:	2400      	movs	r4, #0
{
 8002c10:	b093      	sub	sp, #76	; 0x4c
  RTC_AlarmTypeDef sAlarm = {0};
  RTC_TamperTypeDef sTamper = {0};

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 8002c12:	4d21      	ldr	r5, [pc, #132]	; (8002c98 <MX_RTC_Init+0x8c>)
  RTC_TimeTypeDef sTime = {0};
 8002c14:	9403      	str	r4, [sp, #12]
  RTC_AlarmTypeDef sAlarm = {0};
 8002c16:	4621      	mov	r1, r4
 8002c18:	a807      	add	r0, sp, #28
 8002c1a:	222c      	movs	r2, #44	; 0x2c
  RTC_TimeTypeDef sTime = {0};
 8002c1c:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8002c20:	9402      	str	r4, [sp, #8]
 8002c22:	9406      	str	r4, [sp, #24]
  RTC_DateTypeDef sDate = {0};
 8002c24:	9401      	str	r4, [sp, #4]
  RTC_AlarmTypeDef sAlarm = {0};
 8002c26:	f013 f9b3 	bl	8015f90 <memset>
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
 8002c2a:	23ff      	movs	r3, #255	; 0xff
  hrtc.Instance = RTC;
 8002c2c:	491b      	ldr	r1, [pc, #108]	; (8002c9c <MX_RTC_Init+0x90>)
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8002c2e:	606c      	str	r4, [r5, #4]
  hrtc.Init.AsynchPrediv = 127;
 8002c30:	227f      	movs	r2, #127	; 0x7f
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8002c32:	4628      	mov	r0, r5
  hrtc.Init.SynchPrediv = 255;
 8002c34:	e9c5 2302 	strd	r2, r3, [r5, #8]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 8002c38:	e9c5 4404 	strd	r4, r4, [r5, #16]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8002c3c:	e9c5 4406 	strd	r4, r4, [r5, #24]
  hrtc.Instance = RTC;
 8002c40:	6029      	str	r1, [r5, #0]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8002c42:	f005 fb09 	bl	8008258 <HAL_RTC_Init>
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 8002c46:	a902      	add	r1, sp, #8
 8002c48:	4628      	mov	r0, r5
 8002c4a:	2201      	movs	r2, #1
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8002c4c:	e9cd 4405 	strd	r4, r4, [sp, #20]
  sTime.Hours = 0x0;
 8002c50:	f8ad 4008 	strh.w	r4, [sp, #8]
  sTime.Seconds = 0x0;
 8002c54:	f88d 400a 	strb.w	r4, [sp, #10]
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 8002c58:	f005 fb5c 	bl	8008314 <HAL_RTC_SetTime>
  {
   // Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 8002c5c:	4b10      	ldr	r3, [pc, #64]	; (8002ca0 <MX_RTC_Init+0x94>)
 8002c5e:	9301      	str	r3, [sp, #4]
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 8002c60:	a901      	add	r1, sp, #4
 8002c62:	4628      	mov	r0, r5
 8002c64:	2201      	movs	r2, #1
 8002c66:	f005 fbf3 	bl	8008450 <HAL_RTC_SetDate>
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
  sAlarm.AlarmDateWeekDay = 0x1;
 8002c6a:	2201      	movs	r2, #1
  sAlarm.Alarm = RTC_ALARM_A;
 8002c6c:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8002c70:	a907      	add	r1, sp, #28
 8002c72:	4628      	mov	r0, r5
  sAlarm.AlarmTime.Seconds = 0x10;
 8002c74:	2510      	movs	r5, #16
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8002c76:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 8002c7a:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  sAlarm.AlarmTime.Hours = 0x0;
 8002c7e:	f8ad 401c 	strh.w	r4, [sp, #28]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8002c82:	9408      	str	r4, [sp, #32]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8002c84:	940c      	str	r4, [sp, #48]	; 0x30
  sAlarm.AlarmDateWeekDay = 0x1;
 8002c86:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
  sAlarm.AlarmTime.Seconds = 0x10;
 8002c8a:	f88d 501e 	strb.w	r5, [sp, #30]
  sAlarm.Alarm = RTC_ALARM_A;
 8002c8e:	9311      	str	r3, [sp, #68]	; 0x44
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8002c90:	f005 f9a4 	bl	8007fdc <HAL_RTC_SetAlarm_IT>
  sTamper.TamperPullUp = RTC_TAMPER_PULLUP_ENABLE;
  sTamper.TimeStampOnTamperDetection = RTC_TIMESTAMPONTAMPERDETECTION_ENABLE;



}
 8002c94:	b013      	add	sp, #76	; 0x4c
 8002c96:	bd30      	pop	{r4, r5, pc}
 8002c98:	20017508 	.word	0x20017508
 8002c9c:	40002800 	.word	0x40002800
 8002ca0:	00010101 	.word	0x00010101

08002ca4 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 8002ca4:	b508      	push	{r3, lr}

  if(rtcHandle->Instance==RTC)
 8002ca6:	6802      	ldr	r2, [r0, #0]
 8002ca8:	4b0a      	ldr	r3, [pc, #40]	; (8002cd4 <HAL_RTC_MspInit+0x30>)
 8002caa:	429a      	cmp	r2, r3
 8002cac:	d000      	beq.n	8002cb0 <HAL_RTC_MspInit+0xc>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 8002cae:	bd08      	pop	{r3, pc}
    __HAL_RCC_RTC_ENABLE();
 8002cb0:	4909      	ldr	r1, [pc, #36]	; (8002cd8 <HAL_RTC_MspInit+0x34>)
 8002cb2:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 8002cb6:	2200      	movs	r2, #0
    __HAL_RCC_RTC_ENABLE();
 8002cb8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002cbc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 8002cc0:	2029      	movs	r0, #41	; 0x29
 8002cc2:	4611      	mov	r1, r2
 8002cc4:	f002 fdfe 	bl	80058c4 <HAL_NVIC_SetPriority>
}
 8002cc8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 8002ccc:	2029      	movs	r0, #41	; 0x29
 8002cce:	f002 be31 	b.w	8005934 <HAL_NVIC_EnableIRQ>
 8002cd2:	bf00      	nop
 8002cd4:	40002800 	.word	0x40002800
 8002cd8:	40021000 	.word	0x40021000

08002cdc <HAL_PWR_PVDCallback>:
* @param  None 
* @retval None
*/
void HAL_PWR_PVDCallback(void)
{
  BatteryLow = 1;
 8002cdc:	4b01      	ldr	r3, [pc, #4]	; (8002ce4 <HAL_PWR_PVDCallback+0x8>)
 8002cde:	2201      	movs	r2, #1
 8002ce0:	701a      	strb	r2, [r3, #0]
}
 8002ce2:	4770      	bx	lr
 8002ce4:	20001554 	.word	0x20001554

08002ce8 <SDM_Peripheral_Init>:
}


void SDM_Peripheral_Init(void)
{
  BSP_SD_Detect_Init();   
 8002ce8:	f001 be34 	b.w	8004954 <BSP_SD_Detect_Init>

08002cec <SDM_OS_Init>:
* @brief  Initialize SD Card Manager thread and queue
* @param  None
* @retval None
*/
void SDM_OS_Init(void)
{
 8002cec:	b530      	push	{r4, r5, lr}
  sdioSem_id = osSemaphoreCreate(osSemaphore(sdioSem), 1);
 8002cee:	4c11      	ldr	r4, [pc, #68]	; (8002d34 <SDM_OS_Init+0x48>)
{
 8002cf0:	b087      	sub	sp, #28
  sdioSem_id = osSemaphoreCreate(osSemaphore(sdioSem), 1);
 8002cf2:	2101      	movs	r1, #1
 8002cf4:	4620      	mov	r0, r4
 8002cf6:	f00e f885 	bl	8010e04 <osSemaphoreCreate>
 8002cfa:	4b0f      	ldr	r3, [pc, #60]	; (8002d38 <SDM_OS_Init+0x4c>)
  osSemaphoreWait(sdioSem_id, osWaitForever);
 8002cfc:	f04f 31ff 	mov.w	r1, #4294967295
  sdioSem_id = osSemaphoreCreate(osSemaphore(sdioSem), 1);
 8002d00:	6018      	str	r0, [r3, #0]
  osSemaphoreWait(sdioSem_id, osWaitForever);
 8002d02:	f00e f893 	bl	8010e2c <osSemaphoreWait>
  
  sdThreadQueue_id = osMessageCreate(osMessageQ(sdThreadQueue), NULL);
 8002d06:	1d20      	adds	r0, r4, #4
 8002d08:	2100      	movs	r1, #0
 8002d0a:	f00e f97b 	bl	8011004 <osMessageCreate>
 8002d0e:	4b0b      	ldr	r3, [pc, #44]	; (8002d3c <SDM_OS_Init+0x50>)
  
  vQueueAddToRegistry( sdThreadQueue_id, "sdThreadQueue_id" );
 8002d10:	490b      	ldr	r1, [pc, #44]	; (8002d40 <SDM_OS_Init+0x54>)
  sdThreadQueue_id = osMessageCreate(osMessageQ(sdThreadQueue), NULL);
 8002d12:	6018      	str	r0, [r3, #0]
  
  /* Thread definition: read data */
  osThreadDef(SDM_On_Off_Thread, SDM_Thread, SD_THREAD_PRIO, 1, configMINIMAL_STACK_SIZE*4);
 8002d14:	340c      	adds	r4, #12
  vQueueAddToRegistry( sdThreadQueue_id, "sdThreadQueue_id" );
 8002d16:	f00f f8df 	bl	8011ed8 <vQueueAddToRegistry>
  osThreadDef(SDM_On_Off_Thread, SDM_Thread, SD_THREAD_PRIO, 1, configMINIMAL_STACK_SIZE*4);
 8002d1a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002d1c:	ad01      	add	r5, sp, #4
 8002d1e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002d20:	6823      	ldr	r3, [r4, #0]
 8002d22:	602b      	str	r3, [r5, #0]
  /* Start thread 1 */
  SDM_Thread_Id = osThreadCreate(osThread(SDM_On_Off_Thread), NULL);
 8002d24:	2100      	movs	r1, #0
 8002d26:	a801      	add	r0, sp, #4
 8002d28:	f00e f854 	bl	8010dd4 <osThreadCreate>
 8002d2c:	4b05      	ldr	r3, [pc, #20]	; (8002d44 <SDM_OS_Init+0x58>)
 8002d2e:	6018      	str	r0, [r3, #0]
}
 8002d30:	b007      	add	sp, #28
 8002d32:	bd30      	pop	{r4, r5, pc}
 8002d34:	0801a084 	.word	0x0801a084
 8002d38:	2001965c 	.word	0x2001965c
 8002d3c:	20017be8 	.word	0x20017be8
 8002d40:	0801a9c4 	.word	0x0801a9c4
 8002d44:	2001798c 	.word	0x2001798c

08002d48 <SDM_SD_Init>:
* @brief  Initialize SD Card and file system
* @param  None
* @retval None
*/
void SDM_SD_Init(void)
{
 8002d48:	b508      	push	{r3, lr}
  if(FATFS_LinkDriver(&SD_Driver, SDPath) == 0)
 8002d4a:	490d      	ldr	r1, [pc, #52]	; (8002d80 <SDM_SD_Init+0x38>)
 8002d4c:	480d      	ldr	r0, [pc, #52]	; (8002d84 <SDM_SD_Init+0x3c>)
 8002d4e:	f00d fec7 	bl	8010ae0 <FATFS_LinkDriver>
 8002d52:	b100      	cbz	r0, 8002d56 <SDM_SD_Init+0xe>
        BSP_LED_Off(LED1);
        HAL_Delay(100);
      }
    }
  }
}
 8002d54:	bd08      	pop	{r3, pc}
    if(f_mount(&SDFatFs, (TCHAR const*)SDPath, 0) != FR_OK)
 8002d56:	4602      	mov	r2, r0
 8002d58:	4909      	ldr	r1, [pc, #36]	; (8002d80 <SDM_SD_Init+0x38>)
 8002d5a:	480b      	ldr	r0, [pc, #44]	; (8002d88 <SDM_SD_Init+0x40>)
 8002d5c:	f00c fdfc 	bl	800f958 <f_mount>
 8002d60:	2800      	cmp	r0, #0
 8002d62:	d0f7      	beq.n	8002d54 <SDM_SD_Init+0xc>
        BSP_LED_On(LED1);
 8002d64:	2000      	movs	r0, #0
 8002d66:	f001 fb77 	bl	8004458 <BSP_LED_On>
        HAL_Delay(500);
 8002d6a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002d6e:	f001 ff3d 	bl	8004bec <HAL_Delay>
        BSP_LED_Off(LED1);
 8002d72:	2000      	movs	r0, #0
 8002d74:	f001 fb7e 	bl	8004474 <BSP_LED_Off>
        HAL_Delay(100);
 8002d78:	2064      	movs	r0, #100	; 0x64
 8002d7a:	f001 ff37 	bl	8004bec <HAL_Delay>
      while(1)
 8002d7e:	e7f1      	b.n	8002d64 <SDM_SD_Init+0x1c>
 8002d80:	20017bec 	.word	0x20017bec
 8002d84:	0801a230 	.word	0x0801a230
 8002d88:	20017bf0 	.word	0x20017bf0

08002d8c <SDM_SD_DeInit>:
* @brief  Deinitialize SD Card and file system
* @param  None
* @retval None
*/
void SDM_SD_DeInit(void)
{
 8002d8c:	b508      	push	{r3, lr}
  if(FATFS_UnLinkDriver(SDPath) == 0)
 8002d8e:	480c      	ldr	r0, [pc, #48]	; (8002dc0 <SDM_SD_DeInit+0x34>)
 8002d90:	f00d fec8 	bl	8010b24 <FATFS_UnLinkDriver>
 8002d94:	b100      	cbz	r0, 8002d98 <SDM_SD_DeInit+0xc>
        BSP_LED_Off(LED1);
        HAL_Delay(100);
      }
    }
  }
}
 8002d96:	bd08      	pop	{r3, pc}
    if(f_mount(NULL, (TCHAR const*)SDPath, 0) != FR_OK)
 8002d98:	4909      	ldr	r1, [pc, #36]	; (8002dc0 <SDM_SD_DeInit+0x34>)
 8002d9a:	4602      	mov	r2, r0
 8002d9c:	f00c fddc 	bl	800f958 <f_mount>
 8002da0:	2800      	cmp	r0, #0
 8002da2:	d0f8      	beq.n	8002d96 <SDM_SD_DeInit+0xa>
        BSP_LED_On(LED1);
 8002da4:	2000      	movs	r0, #0
 8002da6:	f001 fb57 	bl	8004458 <BSP_LED_On>
        HAL_Delay(500);
 8002daa:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002dae:	f001 ff1d 	bl	8004bec <HAL_Delay>
        BSP_LED_Off(LED1);
 8002db2:	2000      	movs	r0, #0
 8002db4:	f001 fb5e 	bl	8004474 <BSP_LED_Off>
        HAL_Delay(100);
 8002db8:	2064      	movs	r0, #100	; 0x64
 8002dba:	f001 ff17 	bl	8004bec <HAL_Delay>
      while(1)
 8002dbe:	e7f1      	b.n	8002da4 <SDM_SD_DeInit+0x18>
 8002dc0:	20017bec 	.word	0x20017bec

08002dc4 <SDM_GetLastDirNumber>:
* @brief  Scan SD Card file system to find the latest directory number that includes to the LOG_DIR_PREFIX
* @param  None
* @retval 
*/
uint32_t SDM_GetLastDirNumber(void)
{
 8002dc4:	b530      	push	{r4, r5, lr}
  FRESULT fr;     /* Return value */
  DIR dj;         /* Directory search object */
  FILINFO fno;    /* File information */
  int dir_n = 0, tmp;
  char dir_name[sizeof(LOG_DIR_PREFIX)+1] = LOG_DIR_PREFIX;
 8002dc6:	4b22      	ldr	r3, [pc, #136]	; (8002e50 <SDM_GetLastDirNumber+0x8c>)
  
  dir_name[sizeof(LOG_DIR_PREFIX)-1] = '*';  /* wildcard */
  dir_name[sizeof(LOG_DIR_PREFIX)] = 0;
  
  fr = f_findfirst(&dj, &fno, "", dir_name);  /* Start to search for matching directories */
 8002dc8:	4a22      	ldr	r2, [pc, #136]	; (8002e54 <SDM_GetLastDirNumber+0x90>)
  char dir_name[sizeof(LOG_DIR_PREFIX)+1] = LOG_DIR_PREFIX;
 8002dca:	e893 0003 	ldmia.w	r3, {r0, r1}
{
 8002dce:	b0d7      	sub	sp, #348	; 0x15c
  fr = f_findfirst(&dj, &fno, "", dir_name);  /* Start to search for matching directories */
 8002dd0:	466b      	mov	r3, sp
  char dir_name[sizeof(LOG_DIR_PREFIX)+1] = LOG_DIR_PREFIX;
 8002dd2:	9000      	str	r0, [sp, #0]
  dir_name[sizeof(LOG_DIR_PREFIX)-1] = '*';  /* wildcard */
 8002dd4:	202a      	movs	r0, #42	; 0x2a
  char dir_name[sizeof(LOG_DIR_PREFIX)+1] = LOG_DIR_PREFIX;
 8002dd6:	f8ad 1004 	strh.w	r1, [sp, #4]
  dir_name[sizeof(LOG_DIR_PREFIX)-1] = '*';  /* wildcard */
 8002dda:	f8ad 0006 	strh.w	r0, [sp, #6]
  fr = f_findfirst(&dj, &fno, "", dir_name);  /* Start to search for matching directories */
 8002dde:	a910      	add	r1, sp, #64	; 0x40
 8002de0:	a802      	add	r0, sp, #8
 8002de2:	f00d fc75 	bl	80106d0 <f_findfirst>
  if(fno.fname[0])
 8002de6:	f89d 5056 	ldrb.w	r5, [sp, #86]	; 0x56
 8002dea:	b92d      	cbnz	r5, 8002df8 <SDM_GetLastDirNumber+0x34>
        dir_n = tmp;
      }
    }
  }
  
  f_closedir(&dj);
 8002dec:	a802      	add	r0, sp, #8
 8002dee:	f00d fb8b 	bl	8010508 <f_closedir>
  return (uint32_t)dir_n;
}
 8002df2:	4628      	mov	r0, r5
 8002df4:	b057      	add	sp, #348	; 0x15c
 8002df6:	bd30      	pop	{r4, r5, pc}
    tmp = strtol(&fno.fname[sizeof(LOG_DIR_PREFIX)],NULL,10);
 8002df8:	4604      	mov	r4, r0
 8002dfa:	2100      	movs	r1, #0
 8002dfc:	f10d 005d 	add.w	r0, sp, #93	; 0x5d
 8002e00:	220a      	movs	r2, #10
 8002e02:	f014 fd67 	bl	80178d4 <strtol>
    if(dir_n<tmp)
 8002e06:	ea20 75e0 	bic.w	r5, r0, r0, asr #31
  while (fr == FR_OK && fno.fname[0])
 8002e0a:	2c00      	cmp	r4, #0
 8002e0c:	d1ee      	bne.n	8002dec <SDM_GetLastDirNumber+0x28>
 8002e0e:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
    fr = f_findnext(&dj, &fno);   /* Search for next item */
 8002e12:	a910      	add	r1, sp, #64	; 0x40
 8002e14:	a802      	add	r0, sp, #8
  while (fr == FR_OK && fno.fname[0])
 8002e16:	2b00      	cmp	r3, #0
 8002e18:	d0e8      	beq.n	8002dec <SDM_GetLastDirNumber+0x28>
    fr = f_findnext(&dj, &fno);   /* Search for next item */
 8002e1a:	f00d fbdb 	bl	80105d4 <f_findnext>
    if(fno.fname[0])
 8002e1e:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
    fr = f_findnext(&dj, &fno);   /* Search for next item */
 8002e22:	4604      	mov	r4, r0
    if(fno.fname[0])
 8002e24:	b93b      	cbnz	r3, 8002e36 <SDM_GetLastDirNumber+0x72>
  while (fr == FR_OK && fno.fname[0])
 8002e26:	2c00      	cmp	r4, #0
 8002e28:	d0f1      	beq.n	8002e0e <SDM_GetLastDirNumber+0x4a>
  f_closedir(&dj);
 8002e2a:	a802      	add	r0, sp, #8
 8002e2c:	f00d fb6c 	bl	8010508 <f_closedir>
}
 8002e30:	4628      	mov	r0, r5
 8002e32:	b057      	add	sp, #348	; 0x15c
 8002e34:	bd30      	pop	{r4, r5, pc}
      tmp = strtol(&fno.fname[sizeof(LOG_DIR_PREFIX)],NULL,10);
 8002e36:	220a      	movs	r2, #10
 8002e38:	2100      	movs	r1, #0
 8002e3a:	f10d 005d 	add.w	r0, sp, #93	; 0x5d
 8002e3e:	f014 fd49 	bl	80178d4 <strtol>
      if(tmp > dir_n)
 8002e42:	4285      	cmp	r5, r0
 8002e44:	bfb8      	it	lt
 8002e46:	4605      	movlt	r5, r0
  while (fr == FR_OK && fno.fname[0])
 8002e48:	2c00      	cmp	r4, #0
 8002e4a:	d0e0      	beq.n	8002e0e <SDM_GetLastDirNumber+0x4a>
 8002e4c:	e7ed      	b.n	8002e2a <SDM_GetLastDirNumber+0x66>
 8002e4e:	bf00      	nop
 8002e50:	0801a0a4 	.word	0x0801a0a4
 8002e54:	0801aaac 	.word	0x0801aaac

08002e58 <SDM_Flush_Buffer>:
  return 1;
}

/* Write remaining data to file */
uint8_t SDM_Flush_Buffer(uint32_t id)
{
 8002e58:	b5f0      	push	{r4, r5, r6, r7, lr}
  COM_SensorStatus_t * sensor_status;   
  
  sensor_status = COM_GetSensorStatus(id);
  buf_size = sensor_status->sdWriteBufferSize;
  
  if(SD_WriteBufferIdx[id]>0 && SD_WriteBufferIdx[id]<(buf_size-1))
 8002e5a:	4d28      	ldr	r5, [pc, #160]	; (8002efc <SDM_Flush_Buffer+0xa4>)
{
 8002e5c:	4604      	mov	r4, r0
 8002e5e:	b083      	sub	sp, #12
  sensor_status = COM_GetSensorStatus(id);
 8002e60:	b2c0      	uxtb	r0, r0
 8002e62:	f7fe fd91 	bl	8001988 <COM_GetSensorStatus>
  if(SD_WriteBufferIdx[id]>0 && SD_WriteBufferIdx[id]<(buf_size-1))
 8002e66:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  buf_size = sensor_status->sdWriteBufferSize;
 8002e6a:	6943      	ldr	r3, [r0, #20]
  if(SD_WriteBufferIdx[id]>0 && SD_WriteBufferIdx[id]<(buf_size-1))
 8002e6c:	6851      	ldr	r1, [r2, #4]
 8002e6e:	00a6      	lsls	r6, r4, #2
 8002e70:	b169      	cbz	r1, 8002e8e <SDM_Flush_Buffer+0x36>
 8002e72:	6850      	ldr	r0, [r2, #4]
 8002e74:	1e59      	subs	r1, r3, #1
 8002e76:	4288      	cmp	r0, r1
 8002e78:	d32a      	bcc.n	8002ed0 <SDM_Flush_Buffer+0x78>
  {
    /* flush from the beginning */
    ret = SDM_WriteBuffer(id, SD_WriteBuffer[id], SD_WriteBufferIdx[id]+1);
  }
  else if (SD_WriteBufferIdx[id]>(buf_size-1) && SD_WriteBufferIdx[id]<(buf_size*2-1))
 8002e7a:	19a8      	adds	r0, r5, r6
 8002e7c:	6842      	ldr	r2, [r0, #4]
 8002e7e:	428a      	cmp	r2, r1
 8002e80:	d80a      	bhi.n	8002e98 <SDM_Flush_Buffer+0x40>
  {
    /* flush from half buffer */
    ret =  SDM_WriteBuffer(id, (uint8_t *)(SD_WriteBuffer[id]+buf_size), SD_WriteBufferIdx[id]+1-buf_size);
  }
  
  SD_WriteBufferIdx[id] = 0;
 8002e82:	4435      	add	r5, r6
  uint8_t ret = 0;
 8002e84:	2000      	movs	r0, #0
  SD_WriteBufferIdx[id] = 0;
 8002e86:	2300      	movs	r3, #0
 8002e88:	606b      	str	r3, [r5, #4]
  return ret;
}
 8002e8a:	b003      	add	sp, #12
 8002e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (SD_WriteBufferIdx[id]>(buf_size-1) && SD_WriteBufferIdx[id]<(buf_size*2-1))
 8002e8e:	19a8      	adds	r0, r5, r6
 8002e90:	1e59      	subs	r1, r3, #1
 8002e92:	6842      	ldr	r2, [r0, #4]
 8002e94:	428a      	cmp	r2, r1
 8002e96:	d9f4      	bls.n	8002e82 <SDM_Flush_Buffer+0x2a>
 8002e98:	6841      	ldr	r1, [r0, #4]
 8002e9a:	005a      	lsls	r2, r3, #1
 8002e9c:	3a01      	subs	r2, #1
 8002e9e:	4291      	cmp	r1, r2
 8002ea0:	d2ef      	bcs.n	8002e82 <SDM_Flush_Buffer+0x2a>
    ret =  SDM_WriteBuffer(id, (uint8_t *)(SD_WriteBuffer[id]+buf_size), SD_WriteBufferIdx[id]+1-buf_size);
 8002ea2:	4917      	ldr	r1, [pc, #92]	; (8002f00 <SDM_Flush_Buffer+0xa8>)
 8002ea4:	6842      	ldr	r2, [r0, #4]
 8002ea6:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
  if(f_write(&FileHandler[id], buffer, size, (void *)&byteswritten) != FR_OK)
 8002eaa:	4816      	ldr	r0, [pc, #88]	; (8002f04 <SDM_Flush_Buffer+0xac>)
 8002eac:	f44f 770c 	mov.w	r7, #560	; 0x230
    ret =  SDM_WriteBuffer(id, (uint8_t *)(SD_WriteBuffer[id]+buf_size), SD_WriteBufferIdx[id]+1-buf_size);
 8002eb0:	3201      	adds	r2, #1
  if(f_write(&FileHandler[id], buffer, size, (void *)&byteswritten) != FR_OK)
 8002eb2:	1ad2      	subs	r2, r2, r3
 8002eb4:	4419      	add	r1, r3
 8002eb6:	fb07 0004 	mla	r0, r7, r4, r0
 8002eba:	ab01      	add	r3, sp, #4
 8002ebc:	f00d f8a6 	bl	801000c <f_write>
  SD_WriteBufferIdx[id] = 0;
 8002ec0:	4435      	add	r5, r6
  return 1;
 8002ec2:	fab0 f080 	clz	r0, r0
 8002ec6:	0940      	lsrs	r0, r0, #5
  SD_WriteBufferIdx[id] = 0;
 8002ec8:	2300      	movs	r3, #0
 8002eca:	606b      	str	r3, [r5, #4]
}
 8002ecc:	b003      	add	sp, #12
 8002ece:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret = SDM_WriteBuffer(id, SD_WriteBuffer[id], SD_WriteBufferIdx[id]+1);
 8002ed0:	6852      	ldr	r2, [r2, #4]
  if(f_write(&FileHandler[id], buffer, size, (void *)&byteswritten) != FR_OK)
 8002ed2:	4b0c      	ldr	r3, [pc, #48]	; (8002f04 <SDM_Flush_Buffer+0xac>)
    ret = SDM_WriteBuffer(id, SD_WriteBuffer[id], SD_WriteBufferIdx[id]+1);
 8002ed4:	490a      	ldr	r1, [pc, #40]	; (8002f00 <SDM_Flush_Buffer+0xa8>)
  if(f_write(&FileHandler[id], buffer, size, (void *)&byteswritten) != FR_OK)
 8002ed6:	f44f 700c 	mov.w	r0, #560	; 0x230
 8002eda:	fb00 3004 	mla	r0, r0, r4, r3
 8002ede:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8002ee2:	ab01      	add	r3, sp, #4
 8002ee4:	3201      	adds	r2, #1
 8002ee6:	f00d f891 	bl	801000c <f_write>
  SD_WriteBufferIdx[id] = 0;
 8002eea:	4435      	add	r5, r6
  return 1;
 8002eec:	fab0 f080 	clz	r0, r0
 8002ef0:	0940      	lsrs	r0, r0, #5
  SD_WriteBufferIdx[id] = 0;
 8002ef2:	2300      	movs	r3, #0
 8002ef4:	606b      	str	r3, [r5, #4]
}
 8002ef6:	b003      	add	sp, #12
 8002ef8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002efa:	bf00      	nop
 8002efc:	20001554 	.word	0x20001554
 8002f00:	20017bc0 	.word	0x20017bc0
 8002f04:	2001807c 	.word	0x2001807c

08002f08 <SDM_Fill_Buffer>:

/* Fill SD buffer with new data */
uint8_t SDM_Fill_Buffer(uint8_t id, uint8_t *src, uint16_t srcSize)
{
 8002f08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t dstSize, sdBufSize;
  
  
  sensor_status = COM_GetSensorStatus(id);
  dst = SD_WriteBuffer[id];
  dstP = SD_WriteBufferIdx[id];
 8002f0c:	f8df 8090 	ldr.w	r8, [pc, #144]	; 8002fa0 <SDM_Fill_Buffer+0x98>
{
 8002f10:	4607      	mov	r7, r0
 8002f12:	460d      	mov	r5, r1
 8002f14:	4616      	mov	r6, r2
  sensor_status = COM_GetSensorStatus(id);
 8002f16:	f7fe fd37 	bl	8001988 <COM_GetSensorStatus>
  dst = SD_WriteBuffer[id];
 8002f1a:	4b1f      	ldr	r3, [pc, #124]	; (8002f98 <SDM_Fill_Buffer+0x90>)
  sdBufSize = sensor_status->sdWriteBufferSize;
 8002f1c:	6941      	ldr	r1, [r0, #20]
  dst = SD_WriteBuffer[id];
 8002f1e:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
  dstP = SD_WriteBufferIdx[id];
 8002f22:	eb08 0287 	add.w	r2, r8, r7, lsl #2
 8002f26:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8002f2a:	6854      	ldr	r4, [r2, #4]
  dstSize = sdBufSize*2;
  
  /* byte per byte copy */
  while(srcP < srcSize)
 8002f2c:	b166      	cbz	r6, 8002f48 <SDM_Fill_Buffer+0x40>
 8002f2e:	462b      	mov	r3, r5
 8002f30:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8002f34:	4435      	add	r5, r6
  {
    dst[dstP] = src[srcP];
 8002f36:	f813 2b01 	ldrb.w	r2, [r3], #1
 8002f3a:	5502      	strb	r2, [r0, r4]
    dstP++;
 8002f3c:	3401      	adds	r4, #1
    srcP++;
    if(dstP>=dstSize)
    {
      dstP=0;
 8002f3e:	45a4      	cmp	ip, r4
 8002f40:	bf98      	it	ls
 8002f42:	2400      	movls	r4, #0
  while(srcP < srcSize)
 8002f44:	429d      	cmp	r5, r3
 8002f46:	d1f6      	bne.n	8002f36 <SDM_Fill_Buffer+0x2e>
    }
  }
  
  if(SD_WriteBufferIdx[id]<(dstSize/2) && dstP>=(dstSize/2)) // first half full
 8002f48:	eb08 0209 	add.w	r2, r8, r9
 8002f4c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8002f50:	6852      	ldr	r2, [r2, #4]
 8002f52:	429a      	cmp	r2, r3
 8002f54:	d201      	bcs.n	8002f5a <SDM_Fill_Buffer+0x52>
 8002f56:	42a3      	cmp	r3, r4
 8002f58:	d914      	bls.n	8002f84 <SDM_Fill_Buffer+0x7c>
      _Error_Handler();
    }
    
    // check for buffer consistency
  }
  else if(dstP<SD_WriteBufferIdx[id])  // second half full
 8002f5a:	eb08 0309 	add.w	r3, r8, r9
 8002f5e:	685b      	ldr	r3, [r3, #4]
 8002f60:	42a3      	cmp	r3, r4
 8002f62:	d805      	bhi.n	8002f70 <SDM_Fill_Buffer+0x68>
    if(osMessagePut(sdThreadQueue_id, id|SDM_DATA_READY_MASK|SDM_DATA_SECOND_HALF_MASK, 0) != osOK)
    {
      _Error_Handler();
    }
  }
  SD_WriteBufferIdx[id] = dstP;
 8002f64:	44c8      	add	r8, r9
  return 0;
}
 8002f66:	2000      	movs	r0, #0
  SD_WriteBufferIdx[id] = dstP;
 8002f68:	f8c8 4004 	str.w	r4, [r8, #4]
}
 8002f6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(osMessagePut(sdThreadQueue_id, id|SDM_DATA_READY_MASK|SDM_DATA_SECOND_HALF_MASK, 0) != osOK)
 8002f70:	4b0a      	ldr	r3, [pc, #40]	; (8002f9c <SDM_Fill_Buffer+0x94>)
 8002f72:	f447 4180 	orr.w	r1, r7, #16384	; 0x4000
 8002f76:	6818      	ldr	r0, [r3, #0]
 8002f78:	2200      	movs	r2, #0
 8002f7a:	f00e f849 	bl	8011010 <osMessagePut>
 8002f7e:	2800      	cmp	r0, #0
 8002f80:	d0f0      	beq.n	8002f64 <SDM_Fill_Buffer+0x5c>
* @param  None
* @retval None
*/
static void _Error_Handler( void )
{
  while (1)
 8002f82:	e7fe      	b.n	8002f82 <SDM_Fill_Buffer+0x7a>
    if(osMessagePut(sdThreadQueue_id, id|SDM_DATA_READY_MASK|SDM_DATA_FIRST_HALF_MASK, 0) != osOK)
 8002f84:	4b05      	ldr	r3, [pc, #20]	; (8002f9c <SDM_Fill_Buffer+0x94>)
 8002f86:	f447 41c0 	orr.w	r1, r7, #24576	; 0x6000
 8002f8a:	6818      	ldr	r0, [r3, #0]
 8002f8c:	2200      	movs	r2, #0
 8002f8e:	f00e f83f 	bl	8011010 <osMessagePut>
 8002f92:	2800      	cmp	r0, #0
 8002f94:	d0e6      	beq.n	8002f64 <SDM_Fill_Buffer+0x5c>
  while (1)
 8002f96:	e7fe      	b.n	8002f96 <SDM_Fill_Buffer+0x8e>
 8002f98:	20017bc0 	.word	0x20017bc0
 8002f9c:	20017be8 	.word	0x20017be8
 8002fa0:	20001554 	.word	0x20001554

08002fa4 <SDM_StartSensorThread>:
{
 8002fa4:	b510      	push	{r4, lr}
  if(id == iis3dwb_com_id)
 8002fa6:	4b28      	ldr	r3, [pc, #160]	; (8003048 <SDM_StartSensorThread+0xa4>)
 8002fa8:	781b      	ldrb	r3, [r3, #0]
 8002faa:	4283      	cmp	r3, r0
{
 8002fac:	4604      	mov	r4, r0
  if(id == iis3dwb_com_id)
 8002fae:	d022      	beq.n	8002ff6 <SDM_StartSensorThread+0x52>
  else if(id == hts221_com_id)
 8002fb0:	4b26      	ldr	r3, [pc, #152]	; (800304c <SDM_StartSensorThread+0xa8>)
 8002fb2:	781b      	ldrb	r3, [r3, #0]
 8002fb4:	4283      	cmp	r3, r0
 8002fb6:	d02c      	beq.n	8003012 <SDM_StartSensorThread+0x6e>
  else if(id == iis2dh_com_id)
 8002fb8:	4b25      	ldr	r3, [pc, #148]	; (8003050 <SDM_StartSensorThread+0xac>)
 8002fba:	781b      	ldrb	r3, [r3, #0]
 8002fbc:	4283      	cmp	r3, r0
 8002fbe:	d02f      	beq.n	8003020 <SDM_StartSensorThread+0x7c>
  else if(id == iis2mdc_com_id)
 8002fc0:	4b24      	ldr	r3, [pc, #144]	; (8003054 <SDM_StartSensorThread+0xb0>)
 8002fc2:	781b      	ldrb	r3, [r3, #0]
 8002fc4:	4283      	cmp	r3, r0
 8002fc6:	d01d      	beq.n	8003004 <SDM_StartSensorThread+0x60>
  else if(id == imp34dt05_com_id)
 8002fc8:	4b23      	ldr	r3, [pc, #140]	; (8003058 <SDM_StartSensorThread+0xb4>)
 8002fca:	781b      	ldrb	r3, [r3, #0]
 8002fcc:	4283      	cmp	r3, r0
 8002fce:	d02e      	beq.n	800302e <SDM_StartSensorThread+0x8a>
  else if(id == mp23abs1_com_id)
 8002fd0:	4b22      	ldr	r3, [pc, #136]	; (800305c <SDM_StartSensorThread+0xb8>)
 8002fd2:	781b      	ldrb	r3, [r3, #0]
 8002fd4:	4283      	cmp	r3, r0
 8002fd6:	d02d      	beq.n	8003034 <SDM_StartSensorThread+0x90>
  else if(id == ism330dhcx_com_id)
 8002fd8:	4b21      	ldr	r3, [pc, #132]	; (8003060 <SDM_StartSensorThread+0xbc>)
 8002fda:	781b      	ldrb	r3, [r3, #0]
 8002fdc:	4283      	cmp	r3, r0
 8002fde:	d02c      	beq.n	800303a <SDM_StartSensorThread+0x96>
  else if(id == lps22hh_com_id)
 8002fe0:	4b20      	ldr	r3, [pc, #128]	; (8003064 <SDM_StartSensorThread+0xc0>)
 8002fe2:	781b      	ldrb	r3, [r3, #0]
 8002fe4:	4283      	cmp	r3, r0
 8002fe6:	d02b      	beq.n	8003040 <SDM_StartSensorThread+0x9c>
  else if(id == stts751_com_id)
 8002fe8:	4b1f      	ldr	r3, [pc, #124]	; (8003068 <SDM_StartSensorThread+0xc4>)
 8002fea:	781b      	ldrb	r3, [r3, #0]
 8002fec:	4283      	cmp	r3, r0
 8002fee:	d104      	bne.n	8002ffa <SDM_StartSensorThread+0x56>
    STTS751_Start();
 8002ff0:	f000 ff8c 	bl	8003f0c <STTS751_Start>
 8002ff4:	e001      	b.n	8002ffa <SDM_StartSensorThread+0x56>
    IIS3DWB_Start();
 8002ff6:	f7ff f89b 	bl	8002130 <IIS3DWB_Start>
  sensor_first_dataReady[id] = 1;
 8002ffa:	4b1c      	ldr	r3, [pc, #112]	; (800306c <SDM_StartSensorThread+0xc8>)
 8002ffc:	2201      	movs	r2, #1
 8002ffe:	551a      	strb	r2, [r3, r4]
}
 8003000:	2000      	movs	r0, #0
 8003002:	bd10      	pop	{r4, pc}
    IIS2MDC_Start();
 8003004:	f7fe ffba 	bl	8001f7c <IIS2MDC_Start>
  sensor_first_dataReady[id] = 1;
 8003008:	4b18      	ldr	r3, [pc, #96]	; (800306c <SDM_StartSensorThread+0xc8>)
 800300a:	2201      	movs	r2, #1
 800300c:	551a      	strb	r2, [r3, r4]
}
 800300e:	2000      	movs	r0, #0
 8003010:	bd10      	pop	{r4, pc}
    HTS221_Start();
 8003012:	f7fe ff8f 	bl	8001f34 <HTS221_Start>
  sensor_first_dataReady[id] = 1;
 8003016:	4b15      	ldr	r3, [pc, #84]	; (800306c <SDM_StartSensorThread+0xc8>)
 8003018:	2201      	movs	r2, #1
 800301a:	551a      	strb	r2, [r3, r4]
}
 800301c:	2000      	movs	r0, #0
 800301e:	bd10      	pop	{r4, pc}
    IIS2DH_Start();
 8003020:	f7fe ff9a 	bl	8001f58 <IIS2DH_Start>
  sensor_first_dataReady[id] = 1;
 8003024:	4b11      	ldr	r3, [pc, #68]	; (800306c <SDM_StartSensorThread+0xc8>)
 8003026:	2201      	movs	r2, #1
 8003028:	551a      	strb	r2, [r3, r4]
}
 800302a:	2000      	movs	r0, #0
 800302c:	bd10      	pop	{r4, pc}
    IMP34DT05_Start();
 800302e:	f7ff f9c3 	bl	80023b8 <IMP34DT05_Start>
 8003032:	e7e2      	b.n	8002ffa <SDM_StartSensorThread+0x56>
    MP23ABS1_Start();
 8003034:	f7ff fdd8 	bl	8002be8 <MP23ABS1_Start>
 8003038:	e7df      	b.n	8002ffa <SDM_StartSensorThread+0x56>
    ISM330DHCX_Start();
 800303a:	f7ff f9cf 	bl	80023dc <ISM330DHCX_Start>
 800303e:	e7dc      	b.n	8002ffa <SDM_StartSensorThread+0x56>
    LPS22HH_Start();
 8003040:	f7ff f9de 	bl	8002400 <LPS22HH_Start>
 8003044:	e7d9      	b.n	8002ffa <SDM_StartSensorThread+0x56>
 8003046:	bf00      	nop
 8003048:	20017291 	.word	0x20017291
 800304c:	20016ef8 	.word	0x20016ef8
 8003050:	20016fc0 	.word	0x20016fc0
 8003054:	20016f94 	.word	0x20016f94
 8003058:	20017290 	.word	0x20017290
 800305c:	20016fc1 	.word	0x20016fc1
 8003060:	20016f96 	.word	0x20016f96
 8003064:	20016f08 	.word	0x20016f08
 8003068:	20016f95 	.word	0x20016f95
 800306c:	200000c8 	.word	0x200000c8

08003070 <SDM_InitFiles>:
{
 8003070:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003074:	b0aa      	sub	sp, #168	; 0xa8
  device_descriptor = COM_GetDeviceDescriptor();  
 8003076:	f7fe fc73 	bl	8001960 <COM_GetDeviceDescriptor>
 800307a:	4606      	mov	r6, r0
  dir_n = SDM_GetLastDirNumber();
 800307c:	f7ff fea2 	bl	8002dc4 <SDM_GetLastDirNumber>
  char BatSocFileName [20] = "Battery_SOC";
 8003080:	4f5e      	ldr	r7, [pc, #376]	; (80031fc <SDM_InitFiles+0x18c>)
  sprintf(dir_name, "%s%04ld", LOG_DIR_PREFIX, dir_n);			// SD CARD Test
 8003082:	4a5f      	ldr	r2, [pc, #380]	; (8003200 <SDM_InitFiles+0x190>)
 8003084:	495f      	ldr	r1, [pc, #380]	; (8003204 <SDM_InitFiles+0x194>)
  dir_n++;
 8003086:	1c45      	adds	r5, r0, #1
  sprintf(dir_name, "%s%04ld", LOG_DIR_PREFIX, dir_n);			// SD CARD Test
 8003088:	462b      	mov	r3, r5
 800308a:	a803      	add	r0, sp, #12
 800308c:	f013 fcbc 	bl	8016a08 <siprintf>
  char BatSocFileName [20] = "Battery_SOC";
 8003090:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 8003094:	ac06      	add	r4, sp, #24
 8003096:	2300      	movs	r3, #0
 8003098:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  itoa(dir_n,dir_n_string,10);
 800309c:	220a      	movs	r2, #10
 800309e:	a901      	add	r1, sp, #4
 80030a0:	4628      	mov	r0, r5
  char BatSocFileName [20] = "Battery_SOC";
 80030a2:	930a      	str	r3, [sp, #40]	; 0x28
 80030a4:	9309      	str	r3, [sp, #36]	; 0x24
  itoa(dir_n,dir_n_string,10);
 80030a6:	f012 fed1 	bl	8015e4c <itoa>
  strcat(BatSocFileName,dir_n_string);
 80030aa:	4620      	mov	r0, r4
 80030ac:	f7fd f8b2 	bl	8000214 <strlen>
 80030b0:	a901      	add	r1, sp, #4
 80030b2:	4420      	add	r0, r4
 80030b4:	f013 fd0b 	bl	8016ace <stpcpy>
  strcat(BatSocFileName,".txt");
 80030b8:	4a53      	ldr	r2, [pc, #332]	; (8003208 <SDM_InitFiles+0x198>)
  strcat(BatSocFileName,dir_n_string);
 80030ba:	4603      	mov	r3, r0
  strcat(BatSocFileName,".txt");
 80030bc:	6810      	ldr	r0, [r2, #0]
 80030be:	7912      	ldrb	r2, [r2, #4]
 80030c0:	6018      	str	r0, [r3, #0]
 80030c2:	711a      	strb	r2, [r3, #4]
  if(f_open(&BatteryFileHandler, BatSocFileName, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
 80030c4:	4851      	ldr	r0, [pc, #324]	; (800320c <SDM_InitFiles+0x19c>)
 80030c6:	4621      	mov	r1, r4
 80030c8:	220a      	movs	r2, #10
 80030ca:	f00c fc83 	bl	800f9d4 <f_open>
 80030ce:	b120      	cbz	r0, 80030da <SDM_InitFiles+0x6a>
     return 1;
 80030d0:	2501      	movs	r5, #1
}
 80030d2:	4628      	mov	r0, r5
 80030d4:	b02a      	add	sp, #168	; 0xa8
 80030d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  char buffer [20] = "SOC:";
 80030da:	4605      	mov	r5, r0
 80030dc:	e9d7 0105 	ldrd	r0, r1, [r7, #20]
  itoa(batteryLevel,socString,10);
 80030e0:	4b4b      	ldr	r3, [pc, #300]	; (8003210 <SDM_InitFiles+0x1a0>)
  char buffer [20] = "SOC:";
 80030e2:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
  itoa(batteryLevel,socString,10);
 80030e6:	220a      	movs	r2, #10
  char buffer [20] = "SOC:";
 80030e8:	900b      	str	r0, [sp, #44]	; 0x2c
  itoa(batteryLevel,socString,10);
 80030ea:	4669      	mov	r1, sp
 80030ec:	6818      	ldr	r0, [r3, #0]
  char buffer [20] = "SOC:";
 80030ee:	f8cd 5039 	str.w	r5, [sp, #57]	; 0x39
 80030f2:	f8cd 5031 	str.w	r5, [sp, #49]	; 0x31
 80030f6:	f8cd 5035 	str.w	r5, [sp, #53]	; 0x35
 80030fa:	950f      	str	r5, [sp, #60]	; 0x3c
  itoa(batteryLevel,socString,10);
 80030fc:	f012 fea6 	bl	8015e4c <itoa>
  strcat(buffer,socString);
 8003100:	4669      	mov	r1, sp
 8003102:	a80b      	add	r0, sp, #44	; 0x2c
 8003104:	f013 fcec 	bl	8016ae0 <strcat>
  if(f_write(&BatteryFileHandler, (uint8_t*) buffer, buffSize, (void *)&byteswritten) != FR_OK)
 8003108:	4840      	ldr	r0, [pc, #256]	; (800320c <SDM_InitFiles+0x19c>)
 800310a:	a90b      	add	r1, sp, #44	; 0x2c
 800310c:	ab02      	add	r3, sp, #8
 800310e:	2214      	movs	r2, #20
 8003110:	f00c ff7c 	bl	801000c <f_write>
 8003114:	2800      	cmp	r0, #0
 8003116:	d1dc      	bne.n	80030d2 <SDM_InitFiles+0x62>
  FRESULT test = f_mkdir(dir_name);
 8003118:	a803      	add	r0, sp, #12
 800311a:	f00d fb65 	bl	80107e8 <f_mkdir>
  if(test != FR_OK)
 800311e:	2800      	cmp	r0, #0
 8003120:	d1d6      	bne.n	80030d0 <SDM_InitFiles+0x60>
  for(i=0;i<device_descriptor->nSensor;i++)
 8003122:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8003124:	b383      	cbz	r3, 8003188 <SDM_InitFiles+0x118>
      sprintf(file_name, "%s/%s", dir_name, sensor_descriptor->name);
 8003126:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 8003218 <SDM_InitFiles+0x1a8>
  sprintf(file_name, "%s%s", sensorName, ".dat");
 800312a:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 800321c <SDM_InitFiles+0x1ac>
 800312e:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8003220 <SDM_InitFiles+0x1b0>
  for(i=0;i<device_descriptor->nSensor;i++)
 8003132:	462c      	mov	r4, r5
 8003134:	e003      	b.n	800313e <SDM_InitFiles+0xce>
 8003136:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8003138:	3401      	adds	r4, #1
 800313a:	42a3      	cmp	r3, r4
 800313c:	d924      	bls.n	8003188 <SDM_InitFiles+0x118>
    sensor_status = COM_GetSensorStatus(i);
 800313e:	b2e7      	uxtb	r7, r4
 8003140:	4638      	mov	r0, r7
 8003142:	f7fe fc21 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive)
 8003146:	7b83      	ldrb	r3, [r0, #14]
 8003148:	2b00      	cmp	r3, #0
 800314a:	d0f4      	beq.n	8003136 <SDM_InitFiles+0xc6>
      sensor_descriptor = COM_GetSensorDescriptor(i);
 800314c:	4638      	mov	r0, r7
 800314e:	f7fe fc13 	bl	8001978 <COM_GetSensorDescriptor>
      sprintf(file_name, "%s/%s", dir_name, sensor_descriptor->name);
 8003152:	aa03      	add	r2, sp, #12
 8003154:	1c43      	adds	r3, r0, #1
 8003156:	4651      	mov	r1, sl
 8003158:	a810      	add	r0, sp, #64	; 0x40
 800315a:	f013 fc55 	bl	8016a08 <siprintf>
  sprintf(file_name, "%s%s", sensorName, ".dat");
 800315e:	aa10      	add	r2, sp, #64	; 0x40
 8003160:	464b      	mov	r3, r9
 8003162:	4641      	mov	r1, r8
 8003164:	a81d      	add	r0, sp, #116	; 0x74
 8003166:	f013 fc4f 	bl	8016a08 <siprintf>
  if(f_open(&FileHandler[id], (char const*)file_name, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
 800316a:	4b2a      	ldr	r3, [pc, #168]	; (8003214 <SDM_InitFiles+0x1a4>)
 800316c:	f44f 700c 	mov.w	r0, #560	; 0x230
 8003170:	a91d      	add	r1, sp, #116	; 0x74
 8003172:	fb00 3004 	mla	r0, r0, r4, r3
 8003176:	220a      	movs	r2, #10
 8003178:	f00c fc2c 	bl	800f9d4 <f_open>
 800317c:	2800      	cmp	r0, #0
 800317e:	d1a7      	bne.n	80030d0 <SDM_InitFiles+0x60>
  for(i=0;i<device_descriptor->nSensor;i++)
 8003180:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8003182:	3401      	adds	r4, #1
 8003184:	42a3      	cmp	r3, r4
 8003186:	d8da      	bhi.n	800313e <SDM_InitFiles+0xce>
  device_descriptor = COM_GetDeviceDescriptor();
 8003188:	f7fe fbea 	bl	8001960 <COM_GetDeviceDescriptor>
  for(i=0;i<device_descriptor->nSensor;i++)
 800318c:	6a83      	ldr	r3, [r0, #40]	; 0x28
  device_descriptor = COM_GetDeviceDescriptor();
 800318e:	4607      	mov	r7, r0
  for(i=0;i<device_descriptor->nSensor;i++)
 8003190:	b1c3      	cbz	r3, 80031c4 <SDM_InitFiles+0x154>
 8003192:	f8df 8090 	ldr.w	r8, [pc, #144]	; 8003224 <SDM_InitFiles+0x1b4>
 8003196:	2400      	movs	r4, #0
 8003198:	e005      	b.n	80031a6 <SDM_InitFiles+0x136>
      SD_WriteBuffer[i] = 0;
 800319a:	f848 3024 	str.w	r3, [r8, r4, lsl #2]
  for(i=0;i<device_descriptor->nSensor;i++)
 800319e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80031a0:	3401      	adds	r4, #1
 80031a2:	429c      	cmp	r4, r3
 80031a4:	d20e      	bcs.n	80031c4 <SDM_InitFiles+0x154>
    sensor_status = COM_GetSensorStatus(i);
 80031a6:	b2e0      	uxtb	r0, r4
 80031a8:	f7fe fbee 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive)
 80031ac:	7b83      	ldrb	r3, [r0, #14]
 80031ae:	2b00      	cmp	r3, #0
 80031b0:	d0f3      	beq.n	800319a <SDM_InitFiles+0x12a>
      SD_WriteBuffer[i] = HSD_malloc(sensor_status->sdWriteBufferSize*2);
 80031b2:	6940      	ldr	r0, [r0, #20]
 80031b4:	0040      	lsls	r0, r0, #1
 80031b6:	f012 feb3 	bl	8015f20 <malloc>
 80031ba:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
      if(!SD_WriteBuffer[i])
 80031be:	2800      	cmp	r0, #0
 80031c0:	d1ed      	bne.n	800319e <SDM_InitFiles+0x12e>
  while (1)
 80031c2:	e7fe      	b.n	80031c2 <SDM_InitFiles+0x152>
  for(i=0;i<device_descriptor->nSensor;i++)
 80031c4:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80031c6:	2b00      	cmp	r3, #0
 80031c8:	d083      	beq.n	80030d2 <SDM_InitFiles+0x62>
 80031ca:	2400      	movs	r4, #0
    sensor_status = COM_GetSensorStatus(i);
 80031cc:	b2e0      	uxtb	r0, r4
 80031ce:	f7fe fbdb 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive)
 80031d2:	7b83      	ldrb	r3, [r0, #14]
 80031d4:	b953      	cbnz	r3, 80031ec <SDM_InitFiles+0x17c>
  for(i=0;i<device_descriptor->nSensor;i++)
 80031d6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80031d8:	3401      	adds	r4, #1
 80031da:	42a3      	cmp	r3, r4
 80031dc:	f67f af79 	bls.w	80030d2 <SDM_InitFiles+0x62>
    sensor_status = COM_GetSensorStatus(i);
 80031e0:	b2e0      	uxtb	r0, r4
 80031e2:	f7fe fbd1 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive)
 80031e6:	7b83      	ldrb	r3, [r0, #14]
 80031e8:	2b00      	cmp	r3, #0
 80031ea:	d0f4      	beq.n	80031d6 <SDM_InitFiles+0x166>
      SDM_StartSensorThread(i);
 80031ec:	4620      	mov	r0, r4
 80031ee:	f7ff fed9 	bl	8002fa4 <SDM_StartSensorThread>
  for(i=0;i<device_descriptor->nSensor;i++)
 80031f2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80031f4:	3401      	adds	r4, #1
 80031f6:	429c      	cmp	r4, r3
 80031f8:	d3e8      	bcc.n	80031cc <SDM_InitFiles+0x15c>
 80031fa:	e76a      	b.n	80030d2 <SDM_InitFiles+0x62>
 80031fc:	0801a0ac 	.word	0x0801a0ac
 8003200:	0801aa1c 	.word	0x0801aa1c
 8003204:	0801aa24 	.word	0x0801aa24
 8003208:	0801aa2c 	.word	0x0801aa2c
 800320c:	2001752c 	.word	0x2001752c
 8003210:	200014ac 	.word	0x200014ac
 8003214:	2001807c 	.word	0x2001807c
 8003218:	0801aa34 	.word	0x0801aa34
 800321c:	0801aa0c 	.word	0x0801aa0c
 8003220:	0801aa14 	.word	0x0801aa14
 8003224:	20017bc0 	.word	0x20017bc0

08003228 <SDM_StopSensorThread>:
{
 8003228:	b510      	push	{r4, lr}
  if(id == iis3dwb_com_id)
 800322a:	4b26      	ldr	r3, [pc, #152]	; (80032c4 <SDM_StopSensorThread+0x9c>)
 800322c:	781b      	ldrb	r3, [r3, #0]
 800322e:	4283      	cmp	r3, r0
{
 8003230:	4604      	mov	r4, r0
  if(id == iis3dwb_com_id)
 8003232:	d022      	beq.n	800327a <SDM_StopSensorThread+0x52>
  else if(id == hts221_com_id)
 8003234:	4b24      	ldr	r3, [pc, #144]	; (80032c8 <SDM_StopSensorThread+0xa0>)
 8003236:	781b      	ldrb	r3, [r3, #0]
 8003238:	4283      	cmp	r3, r0
 800323a:	d02a      	beq.n	8003292 <SDM_StopSensorThread+0x6a>
  else if(id == iis2dh_com_id)
 800323c:	4b23      	ldr	r3, [pc, #140]	; (80032cc <SDM_StopSensorThread+0xa4>)
 800323e:	781b      	ldrb	r3, [r3, #0]
 8003240:	4283      	cmp	r3, r0
 8003242:	d02c      	beq.n	800329e <SDM_StopSensorThread+0x76>
  else if(id == iis2mdc_com_id)
 8003244:	4b22      	ldr	r3, [pc, #136]	; (80032d0 <SDM_StopSensorThread+0xa8>)
 8003246:	781b      	ldrb	r3, [r3, #0]
 8003248:	4283      	cmp	r3, r0
 800324a:	d01c      	beq.n	8003286 <SDM_StopSensorThread+0x5e>
  else if(id == imp34dt05_com_id)
 800324c:	4b21      	ldr	r3, [pc, #132]	; (80032d4 <SDM_StopSensorThread+0xac>)
 800324e:	781b      	ldrb	r3, [r3, #0]
 8003250:	4283      	cmp	r3, r0
 8003252:	d02a      	beq.n	80032aa <SDM_StopSensorThread+0x82>
  else if(id == mp23abs1_com_id)
 8003254:	4b20      	ldr	r3, [pc, #128]	; (80032d8 <SDM_StopSensorThread+0xb0>)
 8003256:	781b      	ldrb	r3, [r3, #0]
 8003258:	4283      	cmp	r3, r0
 800325a:	d029      	beq.n	80032b0 <SDM_StopSensorThread+0x88>
  else if(id == ism330dhcx_com_id)
 800325c:	4b1f      	ldr	r3, [pc, #124]	; (80032dc <SDM_StopSensorThread+0xb4>)
 800325e:	781b      	ldrb	r3, [r3, #0]
 8003260:	4283      	cmp	r3, r0
 8003262:	d028      	beq.n	80032b6 <SDM_StopSensorThread+0x8e>
  else if(id == lps22hh_com_id)
 8003264:	4b1e      	ldr	r3, [pc, #120]	; (80032e0 <SDM_StopSensorThread+0xb8>)
 8003266:	781b      	ldrb	r3, [r3, #0]
 8003268:	4283      	cmp	r3, r0
 800326a:	d027      	beq.n	80032bc <SDM_StopSensorThread+0x94>
  else if(id == stts751_com_id)
 800326c:	4b1d      	ldr	r3, [pc, #116]	; (80032e4 <SDM_StopSensorThread+0xbc>)
 800326e:	781b      	ldrb	r3, [r3, #0]
 8003270:	4283      	cmp	r3, r0
 8003272:	d104      	bne.n	800327e <SDM_StopSensorThread+0x56>
    STTS751_Stop();
 8003274:	f000 fe56 	bl	8003f24 <STTS751_Stop>
 8003278:	e001      	b.n	800327e <SDM_StopSensorThread+0x56>
    IIS3DWB_Stop();
 800327a:	f7fe ff65 	bl	8002148 <IIS3DWB_Stop>
  sensor_first_dataReady[id] = 0;
 800327e:	4b1a      	ldr	r3, [pc, #104]	; (80032e8 <SDM_StopSensorThread+0xc0>)
 8003280:	2000      	movs	r0, #0
 8003282:	5518      	strb	r0, [r3, r4]
}
 8003284:	bd10      	pop	{r4, pc}
    IIS2MDC_Stop();
 8003286:	f7fe fe85 	bl	8001f94 <IIS2MDC_Stop>
  sensor_first_dataReady[id] = 0;
 800328a:	4b17      	ldr	r3, [pc, #92]	; (80032e8 <SDM_StopSensorThread+0xc0>)
 800328c:	2000      	movs	r0, #0
 800328e:	5518      	strb	r0, [r3, r4]
}
 8003290:	bd10      	pop	{r4, pc}
    HTS221_Stop();
 8003292:	f7fe fe5b 	bl	8001f4c <HTS221_Stop>
  sensor_first_dataReady[id] = 0;
 8003296:	4b14      	ldr	r3, [pc, #80]	; (80032e8 <SDM_StopSensorThread+0xc0>)
 8003298:	2000      	movs	r0, #0
 800329a:	5518      	strb	r0, [r3, r4]
}
 800329c:	bd10      	pop	{r4, pc}
    IIS2DH_Stop();
 800329e:	f7fe fe67 	bl	8001f70 <IIS2DH_Stop>
  sensor_first_dataReady[id] = 0;
 80032a2:	4b11      	ldr	r3, [pc, #68]	; (80032e8 <SDM_StopSensorThread+0xc0>)
 80032a4:	2000      	movs	r0, #0
 80032a6:	5518      	strb	r0, [r3, r4]
}
 80032a8:	bd10      	pop	{r4, pc}
    IMP34DT05_Stop();
 80032aa:	f7ff f891 	bl	80023d0 <IMP34DT05_Stop>
 80032ae:	e7e6      	b.n	800327e <SDM_StopSensorThread+0x56>
    MP23ABS1_Stop();
 80032b0:	f7ff fca6 	bl	8002c00 <MP23ABS1_Stop>
 80032b4:	e7e3      	b.n	800327e <SDM_StopSensorThread+0x56>
    ISM330DHCX_Stop();
 80032b6:	f7ff f89d 	bl	80023f4 <ISM330DHCX_Stop>
 80032ba:	e7e0      	b.n	800327e <SDM_StopSensorThread+0x56>
    LPS22HH_Stop();
 80032bc:	f7ff f8ac 	bl	8002418 <LPS22HH_Stop>
 80032c0:	e7dd      	b.n	800327e <SDM_StopSensorThread+0x56>
 80032c2:	bf00      	nop
 80032c4:	20017291 	.word	0x20017291
 80032c8:	20016ef8 	.word	0x20016ef8
 80032cc:	20016fc0 	.word	0x20016fc0
 80032d0:	20016f94 	.word	0x20016f94
 80032d4:	20017290 	.word	0x20017290
 80032d8:	20016fc1 	.word	0x20016fc1
 80032dc:	20016f96 	.word	0x20016f96
 80032e0:	20016f08 	.word	0x20016f08
 80032e4:	20016f95 	.word	0x20016f95
 80032e8:	200000c8 	.word	0x200000c8

080032ec <SDM_CloseFiles>:
{
 80032ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80032ee:	b099      	sub	sp, #100	; 0x64
  char* JSON_string = NULL;
 80032f0:	2400      	movs	r4, #0
 80032f2:	9403      	str	r4, [sp, #12]
  device_descriptor = COM_GetDeviceDescriptor();
 80032f4:	f7fe fb34 	bl	8001960 <COM_GetDeviceDescriptor>
  for(id=0;id<device_descriptor->nSensor;id++)
 80032f8:	6a83      	ldr	r3, [r0, #40]	; 0x28
  device_descriptor = COM_GetDeviceDescriptor();
 80032fa:	4605      	mov	r5, r0
  for(id=0;id<device_descriptor->nSensor;id++)
 80032fc:	b36b      	cbz	r3, 800335a <SDM_CloseFiles+0x6e>
    sensor_status = COM_GetSensorStatus(id);
 80032fe:	b2e0      	uxtb	r0, r4
 8003300:	f7fe fb42 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive)
 8003304:	7b83      	ldrb	r3, [r0, #14]
 8003306:	bb03      	cbnz	r3, 800334a <SDM_CloseFiles+0x5e>
  for(id=0;id<device_descriptor->nSensor;id++)
 8003308:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800330a:	3401      	adds	r4, #1
 800330c:	42a3      	cmp	r3, r4
 800330e:	d8f6      	bhi.n	80032fe <SDM_CloseFiles+0x12>
  for(id=0;id<device_descriptor->nSensor;id++)
 8003310:	b31b      	cbz	r3, 800335a <SDM_CloseFiles+0x6e>
  return f_close(&FileHandler[id]);
 8003312:	4f35      	ldr	r7, [pc, #212]	; (80033e8 <SDM_CloseFiles+0xfc>)
  for(id=0;id<device_descriptor->nSensor;id++)
 8003314:	2400      	movs	r4, #0
  return f_close(&FileHandler[id]);
 8003316:	f44f 760c 	mov.w	r6, #560	; 0x230
 800331a:	e003      	b.n	8003324 <SDM_CloseFiles+0x38>
  for(id=0;id<device_descriptor->nSensor;id++)
 800331c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800331e:	3401      	adds	r4, #1
 8003320:	42a3      	cmp	r3, r4
 8003322:	d91a      	bls.n	800335a <SDM_CloseFiles+0x6e>
    sensor_status = COM_GetSensorStatus(id);
 8003324:	b2e0      	uxtb	r0, r4
 8003326:	f7fe fb2f 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive)
 800332a:	7b83      	ldrb	r3, [r0, #14]
 800332c:	2b00      	cmp	r3, #0
 800332e:	d0f5      	beq.n	800331c <SDM_CloseFiles+0x30>
      SDM_Flush_Buffer(id);
 8003330:	4620      	mov	r0, r4
 8003332:	f7ff fd91 	bl	8002e58 <SDM_Flush_Buffer>
  return f_close(&FileHandler[id]);
 8003336:	fb06 7004 	mla	r0, r6, r4, r7
 800333a:	f00c ffc9 	bl	80102d0 <f_close>
      if(SDM_CloseFile(id)!=0)
 800333e:	2800      	cmp	r0, #0
 8003340:	d0ec      	beq.n	800331c <SDM_CloseFiles+0x30>
        return 1;
 8003342:	2401      	movs	r4, #1
}
 8003344:	4620      	mov	r0, r4
 8003346:	b019      	add	sp, #100	; 0x64
 8003348:	bdf0      	pop	{r4, r5, r6, r7, pc}
      SDM_StopSensorThread(id);
 800334a:	4620      	mov	r0, r4
 800334c:	f7ff ff6c 	bl	8003228 <SDM_StopSensorThread>
  for(id=0;id<device_descriptor->nSensor;id++)
 8003350:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8003352:	3401      	adds	r4, #1
 8003354:	429c      	cmp	r4, r3
 8003356:	d3d2      	bcc.n	80032fe <SDM_CloseFiles+0x12>
 8003358:	e7da      	b.n	8003310 <SDM_CloseFiles+0x24>
  f_close(&BatteryFileHandler);
 800335a:	4824      	ldr	r0, [pc, #144]	; (80033ec <SDM_CloseFiles+0x100>)
 800335c:	f00c ffb8 	bl	80102d0 <f_close>
  dir_n = SDM_GetLastDirNumber();
 8003360:	f7ff fd30 	bl	8002dc4 <SDM_GetLastDirNumber>
  sprintf(dir_name, "%s%04ld", LOG_DIR_PREFIX, dir_n);						// SD CARD Test
 8003364:	4a22      	ldr	r2, [pc, #136]	; (80033f0 <SDM_CloseFiles+0x104>)
 8003366:	4923      	ldr	r1, [pc, #140]	; (80033f4 <SDM_CloseFiles+0x108>)
  dir_n = SDM_GetLastDirNumber();
 8003368:	4603      	mov	r3, r0
  sprintf(dir_name, "%s%04ld", LOG_DIR_PREFIX, dir_n);						// SD CARD Test
 800336a:	a804      	add	r0, sp, #16
 800336c:	f013 fb4c 	bl	8016a08 <siprintf>
  sprintf(file_name, "%s/DeviceConfig.json", dir_name);
 8003370:	4921      	ldr	r1, [pc, #132]	; (80033f8 <SDM_CloseFiles+0x10c>)
 8003372:	aa04      	add	r2, sp, #16
 8003374:	a80b      	add	r0, sp, #44	; 0x2c
 8003376:	f013 fb47 	bl	8016a08 <siprintf>
  if(f_open(&FileConfigHandler, (char const*)file_name, FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
 800337a:	4820      	ldr	r0, [pc, #128]	; (80033fc <SDM_CloseFiles+0x110>)
 800337c:	a90b      	add	r1, sp, #44	; 0x2c
 800337e:	220a      	movs	r2, #10
 8003380:	f00c fb28 	bl	800f9d4 <f_open>
 8003384:	2800      	cmp	r0, #0
 8003386:	d1dc      	bne.n	8003342 <SDM_CloseFiles+0x56>
  device = COM_GetDevice();  
 8003388:	f7fe fae6 	bl	8001958 <COM_GetDevice>
  size = HSD_JSON_serialize_Device(device, serialized_string, PRETTY_JSON);
 800338c:	2201      	movs	r2, #1
 800338e:	a903      	add	r1, sp, #12
 8003390:	f7fe fa1a 	bl	80017c8 <HSD_JSON_serialize_Device>
  SDM_WriteConfigBuffer((uint8_t*)JSON_string, strlen(JSON_string));  
 8003394:	9903      	ldr	r1, [sp, #12]
 8003396:	9101      	str	r1, [sp, #4]
 8003398:	4608      	mov	r0, r1
 800339a:	f7fc ff3b 	bl	8000214 <strlen>
  returnWrite = f_write(&FileConfigHandler, buffer, size, (void *)&byteswritten);
 800339e:	ad07      	add	r5, sp, #28
  SDM_WriteConfigBuffer((uint8_t*)JSON_string, strlen(JSON_string));  
 80033a0:	4602      	mov	r2, r0
  returnWrite = f_write(&FileConfigHandler, buffer, size, (void *)&byteswritten);
 80033a2:	9901      	ldr	r1, [sp, #4]
 80033a4:	4815      	ldr	r0, [pc, #84]	; (80033fc <SDM_CloseFiles+0x110>)
 80033a6:	462b      	mov	r3, r5
 80033a8:	f00c fe30 	bl	801000c <f_write>
  if (f_close(&FileConfigHandler)!= FR_OK)
 80033ac:	4813      	ldr	r0, [pc, #76]	; (80033fc <SDM_CloseFiles+0x110>)
 80033ae:	f00c ff8f 	bl	80102d0 <f_close>
 80033b2:	4604      	mov	r4, r0
 80033b4:	2800      	cmp	r0, #0
 80033b6:	d1c4      	bne.n	8003342 <SDM_CloseFiles+0x56>
  HSD_JSON_free(JSON_string);
 80033b8:	9803      	ldr	r0, [sp, #12]
 80033ba:	f7fe f9fd 	bl	80017b8 <HSD_JSON_free>
  char standbyMode [] = {"Standby-Mode!!!"};
 80033be:	4b10      	ldr	r3, [pc, #64]	; (8003400 <SDM_CloseFiles+0x114>)
  JSON_string = NULL;
 80033c0:	9403      	str	r4, [sp, #12]
  char standbyMode [] = {"Standby-Mode!!!"};
 80033c2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80033c4:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  			HAL_UART_Transmit(&huart2, (uint8_t *) standbyMode, sizeof(standbyMode), HAL_MAX_DELAY);
 80033c8:	4629      	mov	r1, r5
 80033ca:	f04f 33ff 	mov.w	r3, #4294967295
 80033ce:	2210      	movs	r2, #16
 80033d0:	480c      	ldr	r0, [pc, #48]	; (8003404 <SDM_CloseFiles+0x118>)
 80033d2:	f007 fcd3 	bl	800ad7c <HAL_UART_Transmit>
  MX_RTC_Init();
 80033d6:	f7ff fc19 	bl	8002c0c <MX_RTC_Init>
  HAL_SuspendTick();
 80033da:	f001 fc19 	bl	8004c10 <HAL_SuspendTick>
  HAL_PWREx_EnterSHUTDOWNMode();
 80033de:	f003 fd07 	bl	8006df0 <HAL_PWREx_EnterSHUTDOWNMode>
}
 80033e2:	4620      	mov	r0, r4
 80033e4:	b019      	add	sp, #100	; 0x64
 80033e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80033e8:	2001807c 	.word	0x2001807c
 80033ec:	2001752c 	.word	0x2001752c
 80033f0:	0801aa1c 	.word	0x0801aa1c
 80033f4:	0801aa24 	.word	0x0801aa24
 80033f8:	0801aa3c 	.word	0x0801aa3c
 80033fc:	2001775c 	.word	0x2001775c
 8003400:	0801aa54 	.word	0x0801aa54
 8003404:	200172a4 	.word	0x200172a4

08003408 <SDM_ReadJSON>:
{  
 8003408:	b570      	push	{r4, r5, r6, lr}
 800340a:	4604      	mov	r4, r0
  local_device = COM_GetDevice();  
 800340c:	f7fe faa4 	bl	8001958 <COM_GetDevice>
  memcpy(&JSON_device, local_device, size);       
 8003410:	4d13      	ldr	r5, [pc, #76]	; (8003460 <SDM_ReadJSON+0x58>)
 8003412:	4601      	mov	r1, r0
 8003414:	2254      	movs	r2, #84	; 0x54
  local_device = COM_GetDevice();  
 8003416:	4606      	mov	r6, r0
  memcpy(&JSON_device, local_device, size);       
 8003418:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 800341c:	f012 fd90 	bl	8015f40 <memcpy>
  HSD_JSON_parse_Device(serialized_string, &JSON_device);      
 8003420:	4620      	mov	r0, r4
 8003422:	f105 012c 	add.w	r1, r5, #44	; 0x2c
 8003426:	f7fe fa39 	bl	800189c <HSD_JSON_parse_Device>
  for (ii = 0; ii < JSON_device.deviceDescriptor.nSensor; ii++)
 800342a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 800342c:	b1a3      	cbz	r3, 8003458 <SDM_ReadJSON+0x50>
 800342e:	2400      	movs	r4, #0
    update_sensorStatus(&local_device->sensors[ii]->sensorStatus, &JSON_device.sensors[ii]->sensorStatus, ii);
 8003430:	f104 030a 	add.w	r3, r4, #10
 8003434:	eb05 0283 	add.w	r2, r5, r3, lsl #2
 8003438:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800343c:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800343e:	6858      	ldr	r0, [r3, #4]
 8003440:	4622      	mov	r2, r4
 8003442:	f501 71d6 	add.w	r1, r1, #428	; 0x1ac
 8003446:	f500 70d6 	add.w	r0, r0, #428	; 0x1ac
 800344a:	f7fe fb95 	bl	8001b78 <update_sensorStatus>
  for (ii = 0; ii < JSON_device.deviceDescriptor.nSensor; ii++)
 800344e:	3401      	adds	r4, #1
 8003450:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8003452:	b2e4      	uxtb	r4, r4
 8003454:	429c      	cmp	r4, r3
 8003456:	d3eb      	bcc.n	8003430 <SDM_ReadJSON+0x28>
  update_sensors_config();  
 8003458:	f7fe fcb2 	bl	8001dc0 <update_sensors_config>
}
 800345c:	2000      	movs	r0, #0
 800345e:	bd70      	pop	{r4, r5, r6, pc}
 8003460:	20001554 	.word	0x20001554

08003464 <SDM_Thread>:
{
 8003464:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003468:	b095      	sub	sp, #84	; 0x54
  if (BSP_SD_IsDetected())
 800346a:	f001 fa93 	bl	8004994 <BSP_SD_IsDetected>
    if (init_SD_peripheral != 1)
 800346e:	4cbb      	ldr	r4, [pc, #748]	; (800375c <SDM_Thread+0x2f8>)
  if (BSP_SD_IsDetected())
 8003470:	2800      	cmp	r0, #0
 8003472:	f040 80ef 	bne.w	8003654 <SDM_Thread+0x1f0>
 8003476:	f10d 080c 	add.w	r8, sp, #12
  vTaskSetApplicationTaskTag( NULL, (TaskHookFunction_t)TASK_SDM_DEBUG_PIN );
 800347a:	2102      	movs	r1, #2
 800347c:	2000      	movs	r0, #0
 800347e:	f00f f9e3 	bl	8012848 <vTaskSetApplicationTaskTag>
 8003482:	4eb7      	ldr	r6, [pc, #732]	; (8003760 <SDM_Thread+0x2fc>)
 8003484:	f8df a300 	ldr.w	sl, [pc, #768]	; 8003788 <SDM_Thread+0x324>
 8003488:	4fb6      	ldr	r7, [pc, #728]	; (8003764 <SDM_Thread+0x300>)
  if(FATFS_UnLinkDriver(SDPath) == 0)
 800348a:	f8df b300 	ldr.w	fp, [pc, #768]	; 800378c <SDM_Thread+0x328>
    BSP_LED_Off(LED1); 
 800348e:	2000      	movs	r0, #0
 8003490:	f000 fff0 	bl	8004474 <BSP_LED_Off>
    if(BatteryLow == 1)
 8003494:	7823      	ldrb	r3, [r4, #0]
 8003496:	2b01      	cmp	r3, #1
 8003498:	d033      	beq.n	8003502 <SDM_Thread+0x9e>
    evt = osMessageGet(sdThreadQueue_id, osWaitForever);  // wait for message      
 800349a:	f8da 1000 	ldr.w	r1, [sl]
 800349e:	f04f 32ff 	mov.w	r2, #4294967295
 80034a2:	4640      	mov	r0, r8
 80034a4:	f00d fde0 	bl	8011068 <osMessageGet>
    if (com_status == HS_DATALOG_IDLE || com_status == HS_DATALOG_SD_STARTED )
 80034a8:	783b      	ldrb	r3, [r7, #0]
 80034aa:	b113      	cbz	r3, 80034b2 <SDM_Thread+0x4e>
 80034ac:	783b      	ldrb	r3, [r7, #0]
 80034ae:	2b02      	cmp	r3, #2
 80034b0:	d1ed      	bne.n	800348e <SDM_Thread+0x2a>
      BSP_LED_On(LED1);
 80034b2:	2000      	movs	r0, #0
    evt = osMessageGet(sdThreadQueue_id, osWaitForever);  // wait for message      
 80034b4:	9d04      	ldr	r5, [sp, #16]
      BSP_LED_On(LED1);
 80034b6:	f000 ffcf 	bl	8004458 <BSP_LED_On>
      if (evt.status == osEventMessage)
 80034ba:	9b03      	ldr	r3, [sp, #12]
 80034bc:	2b10      	cmp	r3, #16
 80034be:	d1e6      	bne.n	800348e <SDM_Thread+0x2a>
        if(evt.value.v == SDM_START_STOP)
 80034c0:	f248 0301 	movw	r3, #32769	; 0x8001
 80034c4:	429d      	cmp	r5, r3
 80034c6:	d044      	beq.n	8003552 <SDM_Thread+0xee>
          if(evt.value.v & SDM_DATA_READY_MASK)
 80034c8:	046b      	lsls	r3, r5, #17
 80034ca:	d5e0      	bpl.n	800348e <SDM_Thread+0x2a>
            sensor_status = COM_GetSensorStatus(sensor_id);
 80034cc:	b2eb      	uxtb	r3, r5
 80034ce:	4618      	mov	r0, r3
 80034d0:	9301      	str	r3, [sp, #4]
 80034d2:	f7fe fa59 	bl	8001988 <COM_GetSensorStatus>
            if(evt.value.v & SDM_DATA_FIRST_HALF_MASK) // Data available on first half of the circular buffer
 80034d6:	f415 5f00 	tst.w	r5, #8192	; 0x2000
            buf_size = sensor_status->sdWriteBufferSize;
 80034da:	6942      	ldr	r2, [r0, #20]
            if(evt.value.v & SDM_DATA_FIRST_HALF_MASK) // Data available on first half of the circular buffer
 80034dc:	9b01      	ldr	r3, [sp, #4]
 80034de:	f000 8097 	beq.w	8003610 <SDM_Thread+0x1ac>
  if(f_write(&FileHandler[id], buffer, size, (void *)&byteswritten) != FR_OK)
 80034e2:	49a1      	ldr	r1, [pc, #644]	; (8003768 <SDM_Thread+0x304>)
 80034e4:	f44f 700c 	mov.w	r0, #560	; 0x230
 80034e8:	fb00 1003 	mla	r0, r0, r3, r1
 80034ec:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
 80034f0:	ab02      	add	r3, sp, #8
 80034f2:	f00c fd8b 	bl	801000c <f_write>
    BSP_LED_Off(LED1); 
 80034f6:	2000      	movs	r0, #0
 80034f8:	f000 ffbc 	bl	8004474 <BSP_LED_Off>
    if(BatteryLow == 1)
 80034fc:	7823      	ldrb	r3, [r4, #0]
 80034fe:	2b01      	cmp	r3, #1
 8003500:	d1cb      	bne.n	800349a <SDM_Thread+0x36>
      SM_TIM_Stop();
 8003502:	f000 fc7b 	bl	8003dfc <SM_TIM_Stop>
      if(SDM_CloseFiles() == 0)
 8003506:	f7ff fef1 	bl	80032ec <SDM_CloseFiles>
 800350a:	b908      	cbnz	r0, 8003510 <SDM_Thread+0xac>
        SD_Logging_Active = 0;
 800350c:	f884 019c 	strb.w	r0, [r4, #412]	; 0x19c
  device_descriptor = COM_GetDeviceDescriptor();
 8003510:	f7fe fa26 	bl	8001960 <COM_GetDeviceDescriptor>
  for(i=0;i<device_descriptor->nSensor;i++)
 8003514:	6a83      	ldr	r3, [r0, #40]	; 0x28
  device_descriptor = COM_GetDeviceDescriptor();
 8003516:	4605      	mov	r5, r0
  for(i=0;i<device_descriptor->nSensor;i++)
 8003518:	b1a3      	cbz	r3, 8003544 <SDM_Thread+0xe0>
 800351a:	f04f 0900 	mov.w	r9, #0
    sensor_status = COM_GetSensorStatus(i);
 800351e:	fa5f f089 	uxtb.w	r0, r9
 8003522:	f7fe fa31 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive && SD_WriteBuffer[i]!=0)
 8003526:	7b82      	ldrb	r2, [r0, #14]
 8003528:	b13a      	cbz	r2, 800353a <SDM_Thread+0xd6>
 800352a:	f856 0029 	ldr.w	r0, [r6, r9, lsl #2]
 800352e:	b120      	cbz	r0, 800353a <SDM_Thread+0xd6>
      HSD_free(SD_WriteBuffer[i]);
 8003530:	f012 fcfe 	bl	8015f30 <free>
      SD_WriteBuffer[i] = NULL;
 8003534:	2300      	movs	r3, #0
 8003536:	f846 3029 	str.w	r3, [r6, r9, lsl #2]
  for(i=0;i<device_descriptor->nSensor;i++)
 800353a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800353c:	f109 0901 	add.w	r9, r9, #1
 8003540:	4591      	cmp	r9, r2
 8003542:	d3ec      	bcc.n	800351e <SDM_Thread+0xba>
      if (init_SD_peripheral != 0)
 8003544:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8003548:	bb53      	cbnz	r3, 80035a0 <SDM_Thread+0x13c>
      BSP_BC_CmdSend(SHIPPING_MODE_ON);
 800354a:	2017      	movs	r0, #23
 800354c:	f000 ffa0 	bl	8004490 <BSP_BC_CmdSend>
 8003550:	e7a3      	b.n	800349a <SDM_Thread+0x36>
          if(SD_Logging_Active == 0)
 8003552:	f894 319c 	ldrb.w	r3, [r4, #412]	; 0x19c
 8003556:	bb73      	cbnz	r3, 80035b6 <SDM_Thread+0x152>
            com_status = HS_DATALOG_SD_STARTED;            
 8003558:	2302      	movs	r3, #2
 800355a:	703b      	strb	r3, [r7, #0]
            SM_TIM_Start();
 800355c:	f000 fc48 	bl	8003df0 <SM_TIM_Start>
            if (BSP_SD_IsDetected())
 8003560:	f001 fa18 	bl	8004994 <BSP_SD_IsDetected>
 8003564:	2800      	cmp	r0, #0
 8003566:	d072      	beq.n	800364e <SDM_Thread+0x1ea>
              if (init_SD_peripheral != 1)
 8003568:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 800356c:	2b01      	cmp	r3, #1
 800356e:	d00a      	beq.n	8003586 <SDM_Thread+0x122>
  if(FATFS_LinkDriver(&SD_Driver, SDPath) == 0)
 8003570:	487e      	ldr	r0, [pc, #504]	; (800376c <SDM_Thread+0x308>)
 8003572:	4659      	mov	r1, fp
 8003574:	f00d fab4 	bl	8010ae0 <FATFS_LinkDriver>
 8003578:	4602      	mov	r2, r0
 800357a:	2800      	cmp	r0, #0
 800357c:	f000 808c 	beq.w	8003698 <SDM_Thread+0x234>
                init_SD_peripheral = 1;
 8003580:	2301      	movs	r3, #1
 8003582:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
              SD_present = 1;
 8003586:	2501      	movs	r5, #1
 8003588:	f884 519d 	strb.w	r5, [r4, #413]	; 0x19d
              if(SDM_InitFiles() == 0)
 800358c:	f7ff fd70 	bl	8003070 <SDM_InitFiles>
 8003590:	2800      	cmp	r0, #0
 8003592:	f000 80bc 	beq.w	800370e <SDM_Thread+0x2aa>
              testTime = HAL_GetTick();
 8003596:	f001 fb23 	bl	8004be0 <HAL_GetTick>
 800359a:	f8c4 01a0 	str.w	r0, [r4, #416]	; 0x1a0
 800359e:	e776      	b.n	800348e <SDM_Thread+0x2a>
  if(FATFS_UnLinkDriver(SDPath) == 0)
 80035a0:	4658      	mov	r0, fp
 80035a2:	f00d fabf 	bl	8010b24 <FATFS_UnLinkDriver>
 80035a6:	4602      	mov	r2, r0
 80035a8:	2800      	cmp	r0, #0
 80035aa:	d03d      	beq.n	8003628 <SDM_Thread+0x1c4>
        init_SD_peripheral = 0;
 80035ac:	f04f 0300 	mov.w	r3, #0
 80035b0:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
 80035b4:	e7c9      	b.n	800354a <SDM_Thread+0xe6>
          else if (SD_Logging_Active == 1)
 80035b6:	2b01      	cmp	r3, #1
 80035b8:	f47f af69 	bne.w	800348e <SDM_Thread+0x2a>
            SM_TIM_Stop();
 80035bc:	f000 fc1e 	bl	8003dfc <SM_TIM_Stop>
            if(SDM_CloseFiles() == 0)
 80035c0:	f7ff fe94 	bl	80032ec <SDM_CloseFiles>
 80035c4:	2800      	cmp	r0, #0
 80035c6:	f000 80a8 	beq.w	800371a <SDM_Thread+0x2b6>
  device_descriptor = COM_GetDeviceDescriptor();
 80035ca:	f7fe f9c9 	bl	8001960 <COM_GetDeviceDescriptor>
  for(i=0;i<device_descriptor->nSensor;i++)
 80035ce:	6a82      	ldr	r2, [r0, #40]	; 0x28
  device_descriptor = COM_GetDeviceDescriptor();
 80035d0:	4603      	mov	r3, r0
  for(i=0;i<device_descriptor->nSensor;i++)
 80035d2:	b1a2      	cbz	r2, 80035fe <SDM_Thread+0x19a>
 80035d4:	2500      	movs	r5, #0
    sensor_status = COM_GetSensorStatus(i);
 80035d6:	b2e8      	uxtb	r0, r5
 80035d8:	9301      	str	r3, [sp, #4]
 80035da:	f7fe f9d5 	bl	8001988 <COM_GetSensorStatus>
    if(sensor_status->isActive && SD_WriteBuffer[i]!=0)
 80035de:	7b82      	ldrb	r2, [r0, #14]
 80035e0:	9b01      	ldr	r3, [sp, #4]
 80035e2:	b142      	cbz	r2, 80035f6 <SDM_Thread+0x192>
 80035e4:	f856 0025 	ldr.w	r0, [r6, r5, lsl #2]
 80035e8:	b128      	cbz	r0, 80035f6 <SDM_Thread+0x192>
      HSD_free(SD_WriteBuffer[i]);
 80035ea:	f012 fca1 	bl	8015f30 <free>
      SD_WriteBuffer[i] = NULL;
 80035ee:	2300      	movs	r3, #0
 80035f0:	f846 3025 	str.w	r3, [r6, r5, lsl #2]
 80035f4:	9b01      	ldr	r3, [sp, #4]
  for(i=0;i<device_descriptor->nSensor;i++)
 80035f6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80035f8:	3501      	adds	r5, #1
 80035fa:	4295      	cmp	r5, r2
 80035fc:	d3eb      	bcc.n	80035d6 <SDM_Thread+0x172>
            if (init_SD_peripheral != 0)
 80035fe:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8003602:	2b00      	cmp	r3, #0
 8003604:	f040 808c 	bne.w	8003720 <SDM_Thread+0x2bc>
            com_status = HS_DATALOG_IDLE;
 8003608:	f04f 0300 	mov.w	r3, #0
 800360c:	703b      	strb	r3, [r7, #0]
 800360e:	e73e      	b.n	800348e <SDM_Thread+0x2a>
              SDM_WriteBuffer(sensor_id, (uint8_t *)(SD_WriteBuffer[sensor_id]+buf_size), buf_size);
 8003610:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
  if(f_write(&FileHandler[id], buffer, size, (void *)&byteswritten) != FR_OK)
 8003614:	4d54      	ldr	r5, [pc, #336]	; (8003768 <SDM_Thread+0x304>)
 8003616:	f44f 700c 	mov.w	r0, #560	; 0x230
 800361a:	fb00 5003 	mla	r0, r0, r3, r5
 800361e:	4411      	add	r1, r2
 8003620:	ab02      	add	r3, sp, #8
 8003622:	f00c fcf3 	bl	801000c <f_write>
 8003626:	e732      	b.n	800348e <SDM_Thread+0x2a>
    if(f_mount(NULL, (TCHAR const*)SDPath, 0) != FR_OK)
 8003628:	4659      	mov	r1, fp
 800362a:	f00c f995 	bl	800f958 <f_mount>
 800362e:	2800      	cmp	r0, #0
 8003630:	d0bc      	beq.n	80035ac <SDM_Thread+0x148>
        BSP_LED_On(LED1);
 8003632:	2000      	movs	r0, #0
 8003634:	f000 ff10 	bl	8004458 <BSP_LED_On>
        HAL_Delay(500);
 8003638:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800363c:	f001 fad6 	bl	8004bec <HAL_Delay>
        BSP_LED_Off(LED1);
 8003640:	2000      	movs	r0, #0
 8003642:	f000 ff17 	bl	8004474 <BSP_LED_Off>
        HAL_Delay(100);
 8003646:	2064      	movs	r0, #100	; 0x64
 8003648:	f001 fad0 	bl	8004bec <HAL_Delay>
      while(1)
 800364c:	e7f1      	b.n	8003632 <SDM_Thread+0x1ce>
              SD_present = 0;
 800364e:	f884 019d 	strb.w	r0, [r4, #413]	; 0x19d
 8003652:	e71c      	b.n	800348e <SDM_Thread+0x2a>
    if (init_SD_peripheral != 1)
 8003654:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8003658:	2b01      	cmp	r3, #1
 800365a:	d152      	bne.n	8003702 <SDM_Thread+0x29e>
    (void)f_opendir(&dir, "/"); /* Open the root directory */
 800365c:	4944      	ldr	r1, [pc, #272]	; (8003770 <SDM_Thread+0x30c>)
      (void)f_readdir(&dir, &fno); /* Read files in root folder */
 800365e:	4d45      	ldr	r5, [pc, #276]	; (8003774 <SDM_Thread+0x310>)
    (void)f_opendir(&dir, "/"); /* Open the root directory */
 8003660:	a806      	add	r0, sp, #24
 8003662:	f00c fecb 	bl	80103fc <f_opendir>
 8003666:	e003      	b.n	8003670 <SDM_Thread+0x20c>
      if (fno.fattrib & AM_ARC) /* It is a file. */
 8003668:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
 800366c:	069a      	lsls	r2, r3, #26
 800366e:	d428      	bmi.n	80036c2 <SDM_Thread+0x25e>
      (void)f_readdir(&dir, &fno); /* Read files in root folder */
 8003670:	4629      	mov	r1, r5
 8003672:	a806      	add	r0, sp, #24
 8003674:	f00c ff80 	bl	8010578 <f_readdir>
      if (fno.fname[0] == 0) break;
 8003678:	f894 309a 	ldrb.w	r3, [r4, #154]	; 0x9a
 800367c:	2b00      	cmp	r3, #0
 800367e:	d1f3      	bne.n	8003668 <SDM_Thread+0x204>
    f_closedir(&dir);
 8003680:	a806      	add	r0, sp, #24
 8003682:	f00c ff41 	bl	8010508 <f_closedir>
  Activate_Sensor(iis3dwb_com_id);
 8003686:	4b3c      	ldr	r3, [pc, #240]	; (8003778 <SDM_Thread+0x314>)
  COM_SensorStatus_t * sensor_status = COM_GetSensorStatus(id);  
 8003688:	7818      	ldrb	r0, [r3, #0]
 800368a:	f7fe f97d 	bl	8001988 <COM_GetSensorStatus>
  sensor_status->isActive = 1;
 800368e:	2301      	movs	r3, #1
 8003690:	7383      	strb	r3, [r0, #14]
 8003692:	f10d 080c 	add.w	r8, sp, #12
}
 8003696:	e029      	b.n	80036ec <SDM_Thread+0x288>
    if(f_mount(&SDFatFs, (TCHAR const*)SDPath, 0) != FR_OK)
 8003698:	4838      	ldr	r0, [pc, #224]	; (800377c <SDM_Thread+0x318>)
 800369a:	4659      	mov	r1, fp
 800369c:	f00c f95c 	bl	800f958 <f_mount>
 80036a0:	2800      	cmp	r0, #0
 80036a2:	f43f af6d 	beq.w	8003580 <SDM_Thread+0x11c>
        BSP_LED_On(LED1);
 80036a6:	2000      	movs	r0, #0
 80036a8:	f000 fed6 	bl	8004458 <BSP_LED_On>
        HAL_Delay(500);
 80036ac:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80036b0:	f001 fa9c 	bl	8004bec <HAL_Delay>
        BSP_LED_Off(LED1);
 80036b4:	2000      	movs	r0, #0
 80036b6:	f000 fedd 	bl	8004474 <BSP_LED_Off>
        HAL_Delay(100);
 80036ba:	2064      	movs	r0, #100	; 0x64
 80036bc:	f001 fa96 	bl	8004bec <HAL_Delay>
      while(1)
 80036c0:	e7f1      	b.n	80036a6 <SDM_Thread+0x242>
        isJSON = strcmp(".json",fno.fname);
 80036c2:	f104 019a 	add.w	r1, r4, #154	; 0x9a
 80036c6:	482e      	ldr	r0, [pc, #184]	; (8003780 <SDM_Thread+0x31c>)
 80036c8:	9101      	str	r1, [sp, #4]
 80036ca:	f7fc fd99 	bl	8000200 <strcmp>
        if (isJSON)
 80036ce:	9901      	ldr	r1, [sp, #4]
 80036d0:	2800      	cmp	r0, #0
 80036d2:	d0d5      	beq.n	8003680 <SDM_Thread+0x21c>
          if(f_open(&FileConfigJSON, fno.fname, FA_OPEN_EXISTING | FA_READ) == FR_OK)
 80036d4:	4e2b      	ldr	r6, [pc, #172]	; (8003784 <SDM_Thread+0x320>)
 80036d6:	2201      	movs	r2, #1
 80036d8:	4630      	mov	r0, r6
 80036da:	f00c f97b 	bl	800f9d4 <f_open>
 80036de:	2800      	cmp	r0, #0
 80036e0:	d056      	beq.n	8003790 <SDM_Thread+0x32c>
 80036e2:	f10d 080c 	add.w	r8, sp, #12
    f_closedir(&dir);
 80036e6:	a806      	add	r0, sp, #24
 80036e8:	f00c ff0e 	bl	8010508 <f_closedir>
    if (init_SD_peripheral != 0)
 80036ec:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 80036f0:	2b00      	cmp	r3, #0
 80036f2:	f43f aec2 	beq.w	800347a <SDM_Thread+0x16>
      SDM_SD_DeInit();
 80036f6:	f7ff fb49 	bl	8002d8c <SDM_SD_DeInit>
      init_SD_peripheral = 0;
 80036fa:	2300      	movs	r3, #0
 80036fc:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
 8003700:	e6bb      	b.n	800347a <SDM_Thread+0x16>
      SDM_SD_Init();
 8003702:	f7ff fb21 	bl	8002d48 <SDM_SD_Init>
      init_SD_peripheral = 1;
 8003706:	2301      	movs	r3, #1
 8003708:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
 800370c:	e7a6      	b.n	800365c <SDM_Thread+0x1f8>
                BSP_LED_Off(LED_ORANGE);
 800370e:	4628      	mov	r0, r5
                SD_Logging_Active = 1;
 8003710:	f884 519c 	strb.w	r5, [r4, #412]	; 0x19c
                BSP_LED_Off(LED_ORANGE);
 8003714:	f000 feae 	bl	8004474 <BSP_LED_Off>
 8003718:	e73d      	b.n	8003596 <SDM_Thread+0x132>
              SD_Logging_Active = 0;
 800371a:	f884 019c 	strb.w	r0, [r4, #412]	; 0x19c
 800371e:	e754      	b.n	80035ca <SDM_Thread+0x166>
  if(FATFS_UnLinkDriver(SDPath) == 0)
 8003720:	4658      	mov	r0, fp
 8003722:	f00d f9ff 	bl	8010b24 <FATFS_UnLinkDriver>
 8003726:	4602      	mov	r2, r0
 8003728:	b120      	cbz	r0, 8003734 <SDM_Thread+0x2d0>
              init_SD_peripheral = 0;
 800372a:	f04f 0300 	mov.w	r3, #0
 800372e:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
 8003732:	e769      	b.n	8003608 <SDM_Thread+0x1a4>
    if(f_mount(NULL, (TCHAR const*)SDPath, 0) != FR_OK)
 8003734:	4659      	mov	r1, fp
 8003736:	f00c f90f 	bl	800f958 <f_mount>
 800373a:	2800      	cmp	r0, #0
 800373c:	d0f5      	beq.n	800372a <SDM_Thread+0x2c6>
        BSP_LED_On(LED1);
 800373e:	2000      	movs	r0, #0
 8003740:	f000 fe8a 	bl	8004458 <BSP_LED_On>
        HAL_Delay(500);
 8003744:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003748:	f001 fa50 	bl	8004bec <HAL_Delay>
        BSP_LED_Off(LED1);
 800374c:	2000      	movs	r0, #0
 800374e:	f000 fe91 	bl	8004474 <BSP_LED_Off>
        HAL_Delay(100);
 8003752:	2064      	movs	r0, #100	; 0x64
 8003754:	f001 fa4a 	bl	8004bec <HAL_Delay>
      while(1)
 8003758:	e7f1      	b.n	800373e <SDM_Thread+0x2da>
 800375a:	bf00      	nop
 800375c:	20001554 	.word	0x20001554
 8003760:	20017bc0 	.word	0x20017bc0
 8003764:	2000038c 	.word	0x2000038c
 8003768:	2001807c 	.word	0x2001807c
 800376c:	0801a230 	.word	0x0801a230
 8003770:	0801aa64 	.word	0x0801aa64
 8003774:	200015d8 	.word	0x200015d8
 8003778:	20017291 	.word	0x20017291
 800377c:	20017bf0 	.word	0x20017bf0
 8003780:	0801aa68 	.word	0x0801aa68
 8003784:	20017990 	.word	0x20017990
 8003788:	20017be8 	.word	0x20017be8
 800378c:	20017bec 	.word	0x20017bec
            sizeFile = f_size(&FileConfigJSON)+1;
 8003790:	68f2      	ldr	r2, [r6, #12]
 8003792:	3201      	adds	r2, #1
            config_JSON_string = HSD_malloc(sizeFile);
 8003794:	4610      	mov	r0, r2
 8003796:	9201      	str	r2, [sp, #4]
 8003798:	f012 fbc2 	bl	8015f20 <malloc>
            f_read (&FileConfigJSON, config_JSON_string, sizeFile, &br);
 800379c:	f10d 080c 	add.w	r8, sp, #12
 80037a0:	4601      	mov	r1, r0
 80037a2:	9a01      	ldr	r2, [sp, #4]
            config_JSON_string = HSD_malloc(sizeFile);
 80037a4:	4605      	mov	r5, r0
            f_read (&FileConfigJSON, config_JSON_string, sizeFile, &br);
 80037a6:	4643      	mov	r3, r8
 80037a8:	4630      	mov	r0, r6
 80037aa:	f00c faf7 	bl	800fd9c <f_read>
            SDM_ReadJSON(config_JSON_string);
 80037ae:	4628      	mov	r0, r5
 80037b0:	f7ff fe2a 	bl	8003408 <SDM_ReadJSON>
            HSD_JSON_free(config_JSON_string);
 80037b4:	4628      	mov	r0, r5
 80037b6:	f7fd ffff 	bl	80017b8 <HSD_JSON_free>
            f_close(&FileConfigJSON);
 80037ba:	4630      	mov	r0, r6
 80037bc:	f00c fd88 	bl	80102d0 <f_close>
 80037c0:	e791      	b.n	80036e6 <SDM_Thread+0x282>
 80037c2:	bf00      	nop

080037c4 <HAL_GPIO_EXTI_Callback>:
  switch(GPIO_Pin)
 80037c4:	2801      	cmp	r0, #1
 80037c6:	d000      	beq.n	80037ca <HAL_GPIO_EXTI_Callback+0x6>
 80037c8:	4770      	bx	lr
{
 80037ca:	b570      	push	{r4, r5, r6, lr}
	if( HAL_GetTick() - t_start > 1000 )
 80037cc:	4e1f      	ldr	r6, [pc, #124]	; (800384c <HAL_GPIO_EXTI_Callback+0x88>)
{
 80037ce:	b086      	sub	sp, #24
	if( HAL_GetTick() - t_start > 1000 )
 80037d0:	f001 fa06 	bl	8004be0 <HAL_GetTick>
 80037d4:	f8d6 31a4 	ldr.w	r3, [r6, #420]	; 0x1a4
 80037d8:	1ac0      	subs	r0, r0, r3
 80037da:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80037de:	d905      	bls.n	80037ec <HAL_GPIO_EXTI_Callback+0x28>
		if (com_status == HS_DATALOG_IDLE || com_status == HS_DATALOG_SD_STARTED )
 80037e0:	4b1b      	ldr	r3, [pc, #108]	; (8003850 <HAL_GPIO_EXTI_Callback+0x8c>)
 80037e2:	781a      	ldrb	r2, [r3, #0]
 80037e4:	b122      	cbz	r2, 80037f0 <HAL_GPIO_EXTI_Callback+0x2c>
 80037e6:	781b      	ldrb	r3, [r3, #0]
 80037e8:	2b02      	cmp	r3, #2
 80037ea:	d001      	beq.n	80037f0 <HAL_GPIO_EXTI_Callback+0x2c>
}
 80037ec:	b006      	add	sp, #24
 80037ee:	bd70      	pop	{r4, r5, r6, pc}
			char startMeasurements [] = {"StartMeasurements!!!"};
 80037f0:	4d18      	ldr	r5, [pc, #96]	; (8003854 <HAL_GPIO_EXTI_Callback+0x90>)
 80037f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80037f4:	466c      	mov	r4, sp
 80037f6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80037f8:	e895 0003 	ldmia.w	r5, {r0, r1}
 80037fc:	f844 0b04 	str.w	r0, [r4], #4
			HAL_UART_Transmit(&huart2, (uint8_t *) startMeasurements, sizeof(startMeasurements), HAL_MAX_DELAY);
 8003800:	f04f 33ff 	mov.w	r3, #4294967295
			char startMeasurements [] = {"StartMeasurements!!!"};
 8003804:	7021      	strb	r1, [r4, #0]
			HAL_UART_Transmit(&huart2, (uint8_t *) startMeasurements, sizeof(startMeasurements), HAL_MAX_DELAY);
 8003806:	2215      	movs	r2, #21
 8003808:	4669      	mov	r1, sp
 800380a:	4813      	ldr	r0, [pc, #76]	; (8003858 <HAL_GPIO_EXTI_Callback+0x94>)
 800380c:	f007 fab6 	bl	800ad7c <HAL_UART_Transmit>
			if(osMessagePut(sdThreadQueue_id, SDM_START_STOP, 0) != osOK)
 8003810:	4b12      	ldr	r3, [pc, #72]	; (800385c <HAL_GPIO_EXTI_Callback+0x98>)
 8003812:	2200      	movs	r2, #0
 8003814:	6818      	ldr	r0, [r3, #0]
 8003816:	f248 0101 	movw	r1, #32769	; 0x8001
 800381a:	f00d fbf9 	bl	8011010 <osMessagePut>
 800381e:	4604      	mov	r4, r0
 8003820:	b100      	cbz	r0, 8003824 <HAL_GPIO_EXTI_Callback+0x60>
  while (1)
 8003822:	e7fe      	b.n	8003822 <HAL_GPIO_EXTI_Callback+0x5e>
			t_start = HAL_GetTick();
 8003824:	f001 f9dc 	bl	8004be0 <HAL_GetTick>
 8003828:	f8c6 01a4 	str.w	r0, [r6, #420]	; 0x1a4
			t_start = SD_Logging_Time_Start = HAL_GetTick();
 800382c:	f001 f9d8 	bl	8004be0 <HAL_GetTick>
			if (SD_Logging_Enabled == 1)
 8003830:	f8d6 31ac 	ldr.w	r3, [r6, #428]	; 0x1ac
 8003834:	2b01      	cmp	r3, #1
				SD_Logging_Enabled = 1;
 8003836:	bf18      	it	ne
 8003838:	2301      	movne	r3, #1
			t_start = SD_Logging_Time_Start = HAL_GetTick();
 800383a:	e9c6 0069 	strd	r0, r0, [r6, #420]	; 0x1a4
				SD_Logging_Enabled = 0;
 800383e:	bf0c      	ite	eq
 8003840:	f8c6 41ac 	streq.w	r4, [r6, #428]	; 0x1ac
				SD_Logging_Enabled = 1;
 8003844:	f8c6 31ac 	strne.w	r3, [r6, #428]	; 0x1ac
}
 8003848:	e7d0      	b.n	80037ec <HAL_GPIO_EXTI_Callback+0x28>
 800384a:	bf00      	nop
 800384c:	20001554 	.word	0x20001554
 8003850:	2000038c 	.word	0x2000038c
 8003854:	0801aa70 	.word	0x0801aa70
 8003858:	200172a4 	.word	0x200172a4
 800385c:	20017be8 	.word	0x20017be8

08003860 <SDM_StartMeasurements>:
{
 8003860:	b570      	push	{r4, r5, r6, lr}
	if( HAL_GetTick() - t_start > 1000 )
 8003862:	4e1f      	ldr	r6, [pc, #124]	; (80038e0 <SDM_StartMeasurements+0x80>)
{
 8003864:	b086      	sub	sp, #24
	if( HAL_GetTick() - t_start > 1000 )
 8003866:	f001 f9bb 	bl	8004be0 <HAL_GetTick>
 800386a:	f8d6 31a4 	ldr.w	r3, [r6, #420]	; 0x1a4
 800386e:	1ac0      	subs	r0, r0, r3
 8003870:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003874:	d905      	bls.n	8003882 <SDM_StartMeasurements+0x22>
		if (com_status == HS_DATALOG_IDLE || com_status == HS_DATALOG_SD_STARTED )
 8003876:	4b1b      	ldr	r3, [pc, #108]	; (80038e4 <SDM_StartMeasurements+0x84>)
 8003878:	781a      	ldrb	r2, [r3, #0]
 800387a:	b122      	cbz	r2, 8003886 <SDM_StartMeasurements+0x26>
 800387c:	781b      	ldrb	r3, [r3, #0]
 800387e:	2b02      	cmp	r3, #2
 8003880:	d001      	beq.n	8003886 <SDM_StartMeasurements+0x26>
}
 8003882:	b006      	add	sp, #24
 8003884:	bd70      	pop	{r4, r5, r6, pc}
			char startMeasurements [] = {"StartMeasurements!!!"};
 8003886:	4d18      	ldr	r5, [pc, #96]	; (80038e8 <SDM_StartMeasurements+0x88>)
 8003888:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800388a:	466c      	mov	r4, sp
 800388c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800388e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8003892:	f844 0b04 	str.w	r0, [r4], #4
			HAL_UART_Transmit(&huart2, (uint8_t *) startMeasurements, sizeof(startMeasurements), HAL_MAX_DELAY);
 8003896:	f04f 33ff 	mov.w	r3, #4294967295
			char startMeasurements [] = {"StartMeasurements!!!"};
 800389a:	7021      	strb	r1, [r4, #0]
			HAL_UART_Transmit(&huart2, (uint8_t *) startMeasurements, sizeof(startMeasurements), HAL_MAX_DELAY);
 800389c:	2215      	movs	r2, #21
 800389e:	4669      	mov	r1, sp
 80038a0:	4812      	ldr	r0, [pc, #72]	; (80038ec <SDM_StartMeasurements+0x8c>)
 80038a2:	f007 fa6b 	bl	800ad7c <HAL_UART_Transmit>
			if(osMessagePut(sdThreadQueue_id, SDM_START_STOP, 0) != osOK)
 80038a6:	4b12      	ldr	r3, [pc, #72]	; (80038f0 <SDM_StartMeasurements+0x90>)
 80038a8:	2200      	movs	r2, #0
 80038aa:	6818      	ldr	r0, [r3, #0]
 80038ac:	f248 0101 	movw	r1, #32769	; 0x8001
 80038b0:	f00d fbae 	bl	8011010 <osMessagePut>
 80038b4:	4604      	mov	r4, r0
 80038b6:	b100      	cbz	r0, 80038ba <SDM_StartMeasurements+0x5a>
  while (1)
 80038b8:	e7fe      	b.n	80038b8 <SDM_StartMeasurements+0x58>
			t_start = HAL_GetTick();
 80038ba:	f001 f991 	bl	8004be0 <HAL_GetTick>
 80038be:	f8c6 01a4 	str.w	r0, [r6, #420]	; 0x1a4
			t_start = SD_Logging_Time_Start = HAL_GetTick();
 80038c2:	f001 f98d 	bl	8004be0 <HAL_GetTick>
			if (SD_Logging_Enabled == 1)
 80038c6:	f8d6 31ac 	ldr.w	r3, [r6, #428]	; 0x1ac
 80038ca:	2b01      	cmp	r3, #1
				SD_Logging_Enabled = 1;
 80038cc:	bf18      	it	ne
 80038ce:	2301      	movne	r3, #1
			t_start = SD_Logging_Time_Start = HAL_GetTick();
 80038d0:	e9c6 0069 	strd	r0, r0, [r6, #420]	; 0x1a4
				SD_Logging_Enabled = 0;
 80038d4:	bf0c      	ite	eq
 80038d6:	f8c6 41ac 	streq.w	r4, [r6, #428]	; 0x1ac
				SD_Logging_Enabled = 1;
 80038da:	f8c6 31ac 	strne.w	r3, [r6, #428]	; 0x1ac
}
 80038de:	e7d0      	b.n	8003882 <SDM_StartMeasurements+0x22>
 80038e0:	20001554 	.word	0x20001554
 80038e4:	2000038c 	.word	0x2000038c
 80038e8:	0801aa70 	.word	0x0801aa70
 80038ec:	200172a4 	.word	0x200172a4
 80038f0:	20017be8 	.word	0x20017be8

080038f4 <SDM_AutosaveFile>:
{
 80038f4:	b538      	push	{r3, r4, r5, lr}
  if (SD_Logging_Active)
 80038f6:	4c17      	ldr	r4, [pc, #92]	; (8003954 <SDM_AutosaveFile+0x60>)
 80038f8:	f894 519c 	ldrb.w	r5, [r4, #412]	; 0x19c
 80038fc:	b14d      	cbz	r5, 8003912 <SDM_AutosaveFile+0x1e>
    if( (HAL_GetTick() - SD_Logging_Time_Start) > HSD_LOGGING_TIME_SECONDS_ACTIVE*1000 )
 80038fe:	f001 f96f 	bl	8004be0 <HAL_GetTick>
 8003902:	f8d4 21a8 	ldr.w	r2, [r4, #424]	; 0x1a8
 8003906:	f64e 2360 	movw	r3, #60000	; 0xea60
 800390a:	1a80      	subs	r0, r0, r2
 800390c:	4298      	cmp	r0, r3
 800390e:	d812      	bhi.n	8003936 <SDM_AutosaveFile+0x42>
}
 8003910:	bd38      	pop	{r3, r4, r5, pc}
    if( (HAL_GetTick() - SD_Logging_Time_Start) > HSD_LOGGING_TIME_SECONDS_IDLE*1000 )
 8003912:	f001 f965 	bl	8004be0 <HAL_GetTick>
 8003916:	f8d4 21a8 	ldr.w	r2, [r4, #424]	; 0x1a8
 800391a:	f242 7310 	movw	r3, #10000	; 0x2710
 800391e:	1a80      	subs	r0, r0, r2
 8003920:	4298      	cmp	r0, r3
 8003922:	d9f5      	bls.n	8003910 <SDM_AutosaveFile+0x1c>
      if(osMessagePut(sdThreadQueue_id, SDM_START_STOP, 0) != osOK)
 8003924:	4b0c      	ldr	r3, [pc, #48]	; (8003958 <SDM_AutosaveFile+0x64>)
 8003926:	462a      	mov	r2, r5
 8003928:	6818      	ldr	r0, [r3, #0]
 800392a:	f248 0101 	movw	r1, #32769	; 0x8001
 800392e:	f00d fb6f 	bl	8011010 <osMessagePut>
 8003932:	b148      	cbz	r0, 8003948 <SDM_AutosaveFile+0x54>
  while (1)
 8003934:	e7fe      	b.n	8003934 <SDM_AutosaveFile+0x40>
      if(osMessagePut(sdThreadQueue_id, SDM_START_STOP, 0) != osOK)
 8003936:	4b08      	ldr	r3, [pc, #32]	; (8003958 <SDM_AutosaveFile+0x64>)
 8003938:	2200      	movs	r2, #0
 800393a:	6818      	ldr	r0, [r3, #0]
 800393c:	f248 0101 	movw	r1, #32769	; 0x8001
 8003940:	f00d fb66 	bl	8011010 <osMessagePut>
 8003944:	b100      	cbz	r0, 8003948 <SDM_AutosaveFile+0x54>
  while (1)
 8003946:	e7fe      	b.n	8003946 <SDM_AutosaveFile+0x52>
      t_start = SD_Logging_Time_Start = HAL_GetTick();
 8003948:	f001 f94a 	bl	8004be0 <HAL_GetTick>
 800394c:	e9c4 0069 	strd	r0, r0, [r4, #420]	; 0x1a4
}
 8003950:	bd38      	pop	{r3, r4, r5, pc}
 8003952:	bf00      	nop
 8003954:	20001554 	.word	0x20001554
 8003958:	20017be8 	.word	0x20017be8

0800395c <spi_Thread>:
*         the thread which made the request at the end of the read.
* @param  argument not used
* @retval None
*/
static void spi_Thread(void const *argument)
{
 800395c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  (void)argument;
  
#if (configUSE_APPLICATION_TASK_TAG == 1 && defined(TASK_SM_SPI_DEBUG_PIN))
  vTaskSetApplicationTaskTag( NULL, (TaskHookFunction_t)TASK_SM_SPI_DEBUG_PIN );
 8003960:	210a      	movs	r1, #10
{
 8003962:	b085      	sub	sp, #20
  vTaskSetApplicationTaskTag( NULL, (TaskHookFunction_t)TASK_SM_SPI_DEBUG_PIN );
 8003964:	2000      	movs	r0, #0
 8003966:	f00e ff6f 	bl	8012848 <vTaskSetApplicationTaskTag>
 800396a:	f8df 9078 	ldr.w	r9, [pc, #120]	; 80039e4 <spi_Thread+0x88>
 800396e:	f8df 8078 	ldr.w	r8, [pc, #120]	; 80039e8 <spi_Thread+0x8c>
 8003972:	4f1a      	ldr	r7, [pc, #104]	; (80039dc <spi_Thread+0x80>)
    evt = osMessageGet(spiReqQueue_id, osWaitForever); 

    SM_Message_t * msg = evt.value.p;

    HAL_GPIO_WritePin(((sensor_handle_t *)msg->sensorHandler)->GPIOx, ((sensor_handle_t *)msg->sensorHandler)->GPIO_Pin , GPIO_PIN_RESET);
    HAL_SPI_Transmit(&hsm_spi, &msg->regAddr, 1, 1000);
 8003974:	4e1a      	ldr	r6, [pc, #104]	; (80039e0 <spi_Thread+0x84>)
    evt = osMessageGet(spiReqQueue_id, osWaitForever); 
 8003976:	f8d9 1000 	ldr.w	r1, [r9]
 800397a:	a801      	add	r0, sp, #4
 800397c:	f04f 32ff 	mov.w	r2, #4294967295
 8003980:	f00d fb72 	bl	8011068 <osMessageGet>
    SM_Message_t * msg = evt.value.p;
 8003984:	9c02      	ldr	r4, [sp, #8]
    HAL_GPIO_WritePin(((sensor_handle_t *)msg->sensorHandler)->GPIOx, ((sensor_handle_t *)msg->sensorHandler)->GPIO_Pin , GPIO_PIN_RESET);
 8003986:	4625      	mov	r5, r4
 8003988:	2200      	movs	r2, #0
 800398a:	f855 3b0c 	ldr.w	r3, [r5], #12
 800398e:	8919      	ldrh	r1, [r3, #8]
 8003990:	6858      	ldr	r0, [r3, #4]
 8003992:	f002 fab3 	bl	8005efc <HAL_GPIO_WritePin>
    HAL_SPI_Transmit(&hsm_spi, &msg->regAddr, 1, 1000);
 8003996:	4629      	mov	r1, r5
 8003998:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800399c:	2201      	movs	r2, #1
 800399e:	4630      	mov	r0, r6
 80039a0:	f005 ff64 	bl	800986c <HAL_SPI_Transmit>
    HAL_SPI_TransmitReceive_DMA(&hsm_spi, msg->dataPtr, msg->dataPtr, msg->readSize);
 80039a4:	68a2      	ldr	r2, [r4, #8]
 80039a6:	89e3      	ldrh	r3, [r4, #14]
 80039a8:	4611      	mov	r1, r2
 80039aa:	4630      	mov	r0, r6
 80039ac:	f006 f87a 	bl	8009aa4 <HAL_SPI_TransmitReceive_DMA>
    
    osSemaphoreWait(spiThreadSem_id, osWaitForever);
 80039b0:	f8d8 0000 	ldr.w	r0, [r8]
 80039b4:	f04f 31ff 	mov.w	r1, #4294967295
 80039b8:	f00d fa38 	bl	8010e2c <osSemaphoreWait>
    
    HAL_GPIO_WritePin(((sensor_handle_t *)msg->sensorHandler)->GPIOx, ((sensor_handle_t *)msg->sensorHandler)->GPIO_Pin , GPIO_PIN_SET); 
 80039bc:	6823      	ldr	r3, [r4, #0]
 80039be:	2201      	movs	r2, #1
 80039c0:	8919      	ldrh	r1, [r3, #8]
 80039c2:	6858      	ldr	r0, [r3, #4]
 80039c4:	f002 fa9a 	bl	8005efc <HAL_GPIO_WritePin>

    osSemaphoreId * sem = ((sensor_handle_t *)msg->sensorHandler)->sem;
 80039c8:	6823      	ldr	r3, [r4, #0]
    osPoolFree(spiPool_id, msg);
 80039ca:	6838      	ldr	r0, [r7, #0]
    osSemaphoreId * sem = ((sensor_handle_t *)msg->sensorHandler)->sem;
 80039cc:	68dd      	ldr	r5, [r3, #12]
    osPoolFree(spiPool_id, msg);
 80039ce:	4621      	mov	r1, r4
 80039d0:	f00d fb02 	bl	8010fd8 <osPoolFree>
    osSemaphoreRelease(*sem);
 80039d4:	6828      	ldr	r0, [r5, #0]
 80039d6:	f00d fa55 	bl	8010e84 <osSemaphoreRelease>
  for (;;)
 80039da:	e7cc      	b.n	8003976 <spi_Thread+0x1a>
 80039dc:	20019850 	.word	0x20019850
 80039e0:	200198bc 	.word	0x200198bc
 80039e4:	200197e8 	.word	0x200197e8
 80039e8:	200197e4 	.word	0x200197e4

080039ec <SM_SPI_TxRxCpltCallback>:
  }
}

static void SM_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
  osSemaphoreRelease(spiThreadSem_id);    
 80039ec:	4b01      	ldr	r3, [pc, #4]	; (80039f4 <SM_SPI_TxRxCpltCallback+0x8>)
 80039ee:	6818      	ldr	r0, [r3, #0]
 80039f0:	f00d ba48 	b.w	8010e84 <osSemaphoreRelease>
 80039f4:	200197e4 	.word	0x200197e4

080039f8 <SM_SPI_MspInit>:
  HAL_NVIC_SetPriority(SM_SPI_TX_DMA_IRQn, 3, 0);
  HAL_NVIC_EnableIRQ(SM_SPI_TX_DMA_IRQn);
}

static void SM_SPI_MspInit(SPI_HandleTypeDef *hspi)
{
 80039f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  
  SM_SPI_CLK_PIN_CLK_ENABLE(); 
 80039fc:	4c38      	ldr	r4, [pc, #224]	; (8003ae0 <SM_SPI_MspInit+0xe8>)
  
  SM_SPIx_CLK_ENABLE();
    
  /* SPI DMA Init */
  /* SPI_RX Init */
  hdma_sm_spi_rx.Instance = SM_SPI_RX_DMA_CHANNEL;
 80039fe:	4d39      	ldr	r5, [pc, #228]	; (8003ae4 <SM_SPI_MspInit+0xec>)
  SM_SPI_CLK_PIN_CLK_ENABLE(); 
 8003a00:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8003a02:	f043 0308 	orr.w	r3, r3, #8
 8003a06:	64e3      	str	r3, [r4, #76]	; 0x4c
 8003a08:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
{
 8003a0a:	b08a      	sub	sp, #40	; 0x28
  SM_SPI_CLK_PIN_CLK_ENABLE(); 
 8003a0c:	f003 0308 	and.w	r3, r3, #8
 8003a10:	9300      	str	r3, [sp, #0]
 8003a12:	9b00      	ldr	r3, [sp, #0]
  SM_SPI_MISO_PIN_CLK_ENABLE(); 
 8003a14:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8003a16:	f043 0308 	orr.w	r3, r3, #8
 8003a1a:	64e3      	str	r3, [r4, #76]	; 0x4c
 8003a1c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8003a1e:	f003 0308 	and.w	r3, r3, #8
 8003a22:	9301      	str	r3, [sp, #4]
 8003a24:	9b01      	ldr	r3, [sp, #4]
  SM_SPI_MOSI_PIN_CLK_ENABLE(); 
 8003a26:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8003a28:	f043 0304 	orr.w	r3, r3, #4
 8003a2c:	64e3      	str	r3, [r4, #76]	; 0x4c
 8003a2e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8003a30:	f003 0304 	and.w	r3, r3, #4
 8003a34:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pin = SM_SPI_CLK_PIN;
 8003a36:	2202      	movs	r2, #2
 8003a38:	2302      	movs	r3, #2
  GPIO_InitStruct.Alternate = SM_SPI_CLK_AF;
 8003a3a:	2705      	movs	r7, #5
  GPIO_InitStruct.Pin = SM_SPI_CLK_PIN;
 8003a3c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  HAL_GPIO_Init(SM_SPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 8003a40:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = SM_SPI_CLK_PIN;
 8003a42:	2200      	movs	r2, #0
 8003a44:	2303      	movs	r3, #3
{
 8003a46:	4606      	mov	r6, r0
  SM_SPI_MOSI_PIN_CLK_ENABLE(); 
 8003a48:	9802      	ldr	r0, [sp, #8]
  HAL_GPIO_Init(SM_SPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 8003a4a:	4827      	ldr	r0, [pc, #156]	; (8003ae8 <SM_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = SM_SPI_CLK_AF;
 8003a4c:	9708      	str	r7, [sp, #32]
  GPIO_InitStruct.Pin = SM_SPI_CLK_PIN;
 8003a4e:	e9cd 2306 	strd	r2, r3, [sp, #24]
  GPIO_InitStruct.Pin = SM_SPI_MISO_PIN;
 8003a52:	f04f 0808 	mov.w	r8, #8
  HAL_GPIO_Init(SM_SPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 8003a56:	f002 f92b 	bl	8005cb0 <HAL_GPIO_Init>
  HAL_GPIO_Init(SM_SPI_MISO_GPIO_PORT, &GPIO_InitStruct);
 8003a5a:	4823      	ldr	r0, [pc, #140]	; (8003ae8 <SM_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = SM_SPI_MISO_AF;
 8003a5c:	9708      	str	r7, [sp, #32]
  HAL_GPIO_Init(SM_SPI_MISO_GPIO_PORT, &GPIO_InitStruct);
 8003a5e:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = SM_SPI_MISO_PIN;
 8003a60:	f8cd 8010 	str.w	r8, [sp, #16]
  HAL_GPIO_Init(SM_SPI_MISO_GPIO_PORT, &GPIO_InitStruct);
 8003a64:	f002 f924 	bl	8005cb0 <HAL_GPIO_Init>
  HAL_GPIO_Init(SM_SPI_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8003a68:	4820      	ldr	r0, [pc, #128]	; (8003aec <SM_SPI_MspInit+0xf4>)
  GPIO_InitStruct.Alternate = SM_SPI_MOSI_AF;
 8003a6a:	9708      	str	r7, [sp, #32]
  HAL_GPIO_Init(SM_SPI_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8003a6c:	a904      	add	r1, sp, #16
  GPIO_InitStruct.Pin = SM_SPI_MOSI_PIN;
 8003a6e:	f8cd 8010 	str.w	r8, [sp, #16]
  HAL_GPIO_Init(SM_SPI_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8003a72:	f002 f91d 	bl	8005cb0 <HAL_GPIO_Init>
  SM_SPIx_CLK_ENABLE();
 8003a76:	6da3      	ldr	r3, [r4, #88]	; 0x58
  hdma_sm_spi_rx.Instance = SM_SPI_RX_DMA_CHANNEL;
 8003a78:	4a1d      	ldr	r2, [pc, #116]	; (8003af0 <SM_SPI_MspInit+0xf8>)
  SM_SPIx_CLK_ENABLE();
 8003a7a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003a7e:	65a3      	str	r3, [r4, #88]	; 0x58
 8003a80:	6da3      	ldr	r3, [r4, #88]	; 0x58
  hdma_sm_spi_rx.Instance = SM_SPI_RX_DMA_CHANNEL;
 8003a82:	602a      	str	r2, [r5, #0]
  SM_SPIx_CLK_ENABLE();
 8003a84:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8003a88:	9303      	str	r3, [sp, #12]
  hdma_sm_spi_rx.Init.Request = SM_SPI_RX_DMA_REQUEST;
 8003a8a:	220c      	movs	r2, #12
  hdma_sm_spi_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8003a8c:	2300      	movs	r3, #0
  hdma_sm_spi_rx.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_sm_spi_rx.Init.MemInc = DMA_MINC_ENABLE;
 8003a8e:	2780      	movs	r7, #128	; 0x80
  hdma_sm_spi_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_sm_spi_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
  hdma_sm_spi_rx.Init.Mode = DMA_NORMAL;
  hdma_sm_spi_rx.Init.Priority = DMA_PRIORITY_LOW;
  if (HAL_DMA_Init(&hdma_sm_spi_rx) != HAL_OK)
 8003a90:	4628      	mov	r0, r5
  hdma_sm_spi_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8003a92:	e9c5 2301 	strd	r2, r3, [r5, #4]
  hdma_sm_spi_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8003a96:	e9c5 3305 	strd	r3, r3, [r5, #20]
  hdma_sm_spi_rx.Init.Priority = DMA_PRIORITY_LOW;
 8003a9a:	e9c5 3307 	strd	r3, r3, [r5, #28]
  SM_SPIx_CLK_ENABLE();
 8003a9e:	9903      	ldr	r1, [sp, #12]
  hdma_sm_spi_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8003aa0:	60eb      	str	r3, [r5, #12]
  hdma_sm_spi_rx.Init.MemInc = DMA_MINC_ENABLE;
 8003aa2:	612f      	str	r7, [r5, #16]
  if (HAL_DMA_Init(&hdma_sm_spi_rx) != HAL_OK)
 8003aa4:	f001 ff6e 	bl	8005984 <HAL_DMA_Init>
 8003aa8:	b100      	cbz	r0, 8003aac <SM_SPI_MspInit+0xb4>
  while (1)
 8003aaa:	e7fe      	b.n	8003aaa <SM_SPI_MspInit+0xb2>
  }
  
  __HAL_LINKDMA(hspi,hdmarx,hdma_sm_spi_rx);
  
  /* SPI_TX Init */
  hdma_sm_spi_tx.Instance = SM_SPI_TX_DMA_CHANNEL;
 8003aac:	4c11      	ldr	r4, [pc, #68]	; (8003af4 <SM_SPI_MspInit+0xfc>)
 8003aae:	f8df c048 	ldr.w	ip, [pc, #72]	; 8003af8 <SM_SPI_MspInit+0x100>
  __HAL_LINKDMA(hspi,hdmarx,hdma_sm_spi_rx);
 8003ab2:	65b5      	str	r5, [r6, #88]	; 0x58
  hdma_sm_spi_tx.Init.Request = SM_SPI_TX_DMA_REQUEST;
  hdma_sm_spi_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
  hdma_sm_spi_tx.Init.PeriphInc = DMA_PINC_DISABLE;
  hdma_sm_spi_tx.Init.MemInc = DMA_MINC_ENABLE;
 8003ab4:	e9c4 0703 	strd	r0, r7, [r4, #12]
  hdma_sm_spi_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_sm_spi_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8003ab8:	e9c4 0005 	strd	r0, r0, [r4, #20]
  hdma_sm_spi_tx.Init.Mode = DMA_NORMAL;
  hdma_sm_spi_tx.Init.Priority = DMA_PRIORITY_LOW;
 8003abc:	e9c4 0007 	strd	r0, r0, [r4, #28]
  hdma_sm_spi_tx.Init.Request = SM_SPI_TX_DMA_REQUEST;
 8003ac0:	210d      	movs	r1, #13
  hdma_sm_spi_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8003ac2:	2210      	movs	r2, #16
  if (HAL_DMA_Init(&hdma_sm_spi_tx) != HAL_OK)
 8003ac4:	4620      	mov	r0, r4
  hdma_sm_spi_tx.Init.Request = SM_SPI_TX_DMA_REQUEST;
 8003ac6:	e9c4 c100 	strd	ip, r1, [r4]
  __HAL_LINKDMA(hspi,hdmarx,hdma_sm_spi_rx);
 8003aca:	62ae      	str	r6, [r5, #40]	; 0x28
  hdma_sm_spi_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8003acc:	60a2      	str	r2, [r4, #8]
  if (HAL_DMA_Init(&hdma_sm_spi_tx) != HAL_OK)
 8003ace:	f001 ff59 	bl	8005984 <HAL_DMA_Init>
 8003ad2:	b100      	cbz	r0, 8003ad6 <SM_SPI_MspInit+0xde>
  while (1)
 8003ad4:	e7fe      	b.n	8003ad4 <SM_SPI_MspInit+0xdc>
  {
    SM_Error_Handler();
  }
  
  __HAL_LINKDMA(hspi,hdmatx,hdma_sm_spi_tx);
 8003ad6:	6574      	str	r4, [r6, #84]	; 0x54
 8003ad8:	62a6      	str	r6, [r4, #40]	; 0x28
}
 8003ada:	b00a      	add	sp, #40	; 0x28
 8003adc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003ae0:	40021000 	.word	0x40021000
 8003ae4:	200196e4 	.word	0x200196e4
 8003ae8:	48000c00 	.word	0x48000c00
 8003aec:	48000800 	.word	0x48000800
 8003af0:	40020008 	.word	0x40020008
 8003af4:	20019854 	.word	0x20019854
 8003af8:	4002001c 	.word	0x4002001c

08003afc <SM_OS_Init>:
{
 8003afc:	b530      	push	{r4, r5, lr}
  spiThreadSem_id = osSemaphoreCreate(osSemaphore(spiThreadSem), 1);
 8003afe:	4c15      	ldr	r4, [pc, #84]	; (8003b54 <SM_OS_Init+0x58>)
{
 8003b00:	b087      	sub	sp, #28
  spiThreadSem_id = osSemaphoreCreate(osSemaphore(spiThreadSem), 1);
 8003b02:	2101      	movs	r1, #1
 8003b04:	4620      	mov	r0, r4
 8003b06:	f00d f97d 	bl	8010e04 <osSemaphoreCreate>
 8003b0a:	4b13      	ldr	r3, [pc, #76]	; (8003b58 <SM_OS_Init+0x5c>)
  osSemaphoreWait(spiThreadSem_id,osWaitForever);
 8003b0c:	f04f 31ff 	mov.w	r1, #4294967295
  spiThreadSem_id = osSemaphoreCreate(osSemaphore(spiThreadSem), 1);
 8003b10:	6018      	str	r0, [r3, #0]
  osSemaphoreWait(spiThreadSem_id,osWaitForever);
 8003b12:	f00d f98b 	bl	8010e2c <osSemaphoreWait>
  spiPool_id = osPoolCreate(osPool(spiPool));
 8003b16:	1d20      	adds	r0, r4, #4
 8003b18:	f00d f9dc 	bl	8010ed4 <osPoolCreate>
 8003b1c:	4b0f      	ldr	r3, [pc, #60]	; (8003b5c <SM_OS_Init+0x60>)
 8003b1e:	4602      	mov	r2, r0
  spiReqQueue_id = osMessageCreate(osMessageQ(spireqqueue), NULL);
 8003b20:	2100      	movs	r1, #0
 8003b22:	f104 0010 	add.w	r0, r4, #16
  spiPool_id = osPoolCreate(osPool(spiPool));
 8003b26:	601a      	str	r2, [r3, #0]
  spiReqQueue_id = osMessageCreate(osMessageQ(spireqqueue), NULL);
 8003b28:	f00d fa6c 	bl	8011004 <osMessageCreate>
 8003b2c:	4b0c      	ldr	r3, [pc, #48]	; (8003b60 <SM_OS_Init+0x64>)
  vQueueAddToRegistry( spiReqQueue_id, "spiReqQueue_id" );
 8003b2e:	490d      	ldr	r1, [pc, #52]	; (8003b64 <SM_OS_Init+0x68>)
  spiReqQueue_id = osMessageCreate(osMessageQ(spireqqueue), NULL);
 8003b30:	6018      	str	r0, [r3, #0]
  osThreadDef(SPI_THREAD, spi_Thread, SPI_RD_THREAD_PRIO, 1, configMINIMAL_STACK_SIZE);
 8003b32:	3418      	adds	r4, #24
  vQueueAddToRegistry( spiReqQueue_id, "spiReqQueue_id" );
 8003b34:	f00e f9d0 	bl	8011ed8 <vQueueAddToRegistry>
  osThreadDef(SPI_THREAD, spi_Thread, SPI_RD_THREAD_PRIO, 1, configMINIMAL_STACK_SIZE);
 8003b38:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8003b3a:	ad01      	add	r5, sp, #4
 8003b3c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003b3e:	6823      	ldr	r3, [r4, #0]
 8003b40:	602b      	str	r3, [r5, #0]
  spiThreadId = osThreadCreate(osThread(SPI_THREAD), NULL);
 8003b42:	2100      	movs	r1, #0
 8003b44:	a801      	add	r0, sp, #4
 8003b46:	f00d f945 	bl	8010dd4 <osThreadCreate>
 8003b4a:	4b07      	ldr	r3, [pc, #28]	; (8003b68 <SM_OS_Init+0x6c>)
 8003b4c:	6018      	str	r0, [r3, #0]
}
 8003b4e:	b007      	add	sp, #28
 8003b50:	bd30      	pop	{r4, r5, pc}
 8003b52:	bf00      	nop
 8003b54:	0801a0d4 	.word	0x0801a0d4
 8003b58:	200197e4 	.word	0x200197e4
 8003b5c:	20019850 	.word	0x20019850
 8003b60:	200197e8 	.word	0x200197e8
 8003b64:	0801aa94 	.word	0x0801aa94
 8003b68:	200198b8 	.word	0x200198b8

08003b6c <SM_SPI_Write>:
{
 8003b6c:	b570      	push	{r4, r5, r6, lr}
 8003b6e:	4604      	mov	r4, r0
 8003b70:	b082      	sub	sp, #8
 8003b72:	461d      	mov	r5, r3
 8003b74:	f88d 1007 	strb.w	r1, [sp, #7]
 8003b78:	4616      	mov	r6, r2
  taskENTER_CRITICAL();
 8003b7a:	f00f fcc3 	bl	8013504 <vPortEnterCritical>
  if (((sensor_handle_t *)handle)->WhoAmI == IIS2DH_ID && len > 1) 
 8003b7e:	7823      	ldrb	r3, [r4, #0]
 8003b80:	2b33      	cmp	r3, #51	; 0x33
 8003b82:	d01d      	beq.n	8003bc0 <SM_SPI_Write+0x54>
  HAL_GPIO_WritePin(((sensor_handle_t *)handle)->GPIOx  , ((sensor_handle_t *)handle)->GPIO_Pin , GPIO_PIN_RESET);
 8003b84:	8921      	ldrh	r1, [r4, #8]
 8003b86:	6860      	ldr	r0, [r4, #4]
 8003b88:	2200      	movs	r2, #0
 8003b8a:	f002 f9b7 	bl	8005efc <HAL_GPIO_WritePin>
  HAL_SPI_Transmit(&hsm_spi, &reg, 1, 1000);
 8003b8e:	f10d 0107 	add.w	r1, sp, #7
 8003b92:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003b96:	2201      	movs	r2, #1
 8003b98:	480e      	ldr	r0, [pc, #56]	; (8003bd4 <SM_SPI_Write+0x68>)
 8003b9a:	f005 fe67 	bl	800986c <HAL_SPI_Transmit>
  HAL_SPI_Transmit(&hsm_spi, data, len, 1000);  
 8003b9e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8003ba2:	462a      	mov	r2, r5
 8003ba4:	4631      	mov	r1, r6
 8003ba6:	480b      	ldr	r0, [pc, #44]	; (8003bd4 <SM_SPI_Write+0x68>)
 8003ba8:	f005 fe60 	bl	800986c <HAL_SPI_Transmit>
  HAL_GPIO_WritePin(((sensor_handle_t *)handle)->GPIOx  , ((sensor_handle_t *)handle)->GPIO_Pin , GPIO_PIN_SET);
 8003bac:	6860      	ldr	r0, [r4, #4]
 8003bae:	8921      	ldrh	r1, [r4, #8]
 8003bb0:	2201      	movs	r2, #1
 8003bb2:	f002 f9a3 	bl	8005efc <HAL_GPIO_WritePin>
  taskEXIT_CRITICAL();
 8003bb6:	f00f fcc7 	bl	8013548 <vPortExitCritical>
}
 8003bba:	2000      	movs	r0, #0
 8003bbc:	b002      	add	sp, #8
 8003bbe:	bd70      	pop	{r4, r5, r6, pc}
  if (((sensor_handle_t *)handle)->WhoAmI == IIS2DH_ID && len > 1) 
 8003bc0:	2d01      	cmp	r5, #1
 8003bc2:	d9df      	bls.n	8003b84 <SM_SPI_Write+0x18>
    reg = reg|0x40;
 8003bc4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003bc8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003bcc:	f88d 3007 	strb.w	r3, [sp, #7]
 8003bd0:	e7d8      	b.n	8003b84 <SM_SPI_Write+0x18>
 8003bd2:	bf00      	nop
 8003bd4:	200198bc 	.word	0x200198bc

08003bd8 <SM_SPI_Read_Os>:
{
 8003bd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  msg = osPoolAlloc(spiPool_id);
 8003bda:	4c12      	ldr	r4, [pc, #72]	; (8003c24 <SM_SPI_Read_Os+0x4c>)
{
 8003bdc:	4605      	mov	r5, r0
  msg = osPoolAlloc(spiPool_id);
 8003bde:	6820      	ldr	r0, [r4, #0]
{
 8003be0:	461e      	mov	r6, r3
 8003be2:	460c      	mov	r4, r1
 8003be4:	4617      	mov	r7, r2
  msg = osPoolAlloc(spiPool_id);
 8003be6:	f00d f9af 	bl	8010f48 <osPoolAlloc>
  if (((sensor_handle_t *)handle)->WhoAmI == IIS2DH_ID && len > 1) 
 8003bea:	782b      	ldrb	r3, [r5, #0]
 8003bec:	2b33      	cmp	r3, #51	; 0x33
  msg = osPoolAlloc(spiPool_id);
 8003bee:	4601      	mov	r1, r0
  if (((sensor_handle_t *)handle)->WhoAmI == IIS2DH_ID && len > 1) 
 8003bf0:	d103      	bne.n	8003bfa <SM_SPI_Read_Os+0x22>
 8003bf2:	2e01      	cmp	r6, #1
 8003bf4:	bf88      	it	hi
 8003bf6:	f044 0440 	orrhi.w	r4, r4, #64	; 0x40
  osMessagePut(spiReqQueue_id, (uint32_t)(msg), osWaitForever);  
 8003bfa:	4b0b      	ldr	r3, [pc, #44]	; (8003c28 <SM_SPI_Read_Os+0x50>)
  msg->sensorHandler = handle;
 8003bfc:	600d      	str	r5, [r1, #0]
  msg->regAddr = reg | 0x80 | autoInc;
 8003bfe:	f064 047f 	orn	r4, r4, #127	; 0x7f
 8003c02:	730c      	strb	r4, [r1, #12]
  msg->readSize = len;
 8003c04:	81ce      	strh	r6, [r1, #14]
  msg->dataPtr = data;
 8003c06:	608f      	str	r7, [r1, #8]
  osMessagePut(spiReqQueue_id, (uint32_t)(msg), osWaitForever);  
 8003c08:	f04f 32ff 	mov.w	r2, #4294967295
 8003c0c:	6818      	ldr	r0, [r3, #0]
 8003c0e:	f00d f9ff 	bl	8011010 <osMessagePut>
  osSemaphoreWait(*(((sensor_handle_t *)handle)->sem), osWaitForever);    
 8003c12:	68eb      	ldr	r3, [r5, #12]
 8003c14:	f04f 31ff 	mov.w	r1, #4294967295
 8003c18:	6818      	ldr	r0, [r3, #0]
 8003c1a:	f00d f907 	bl	8010e2c <osSemaphoreWait>
}
 8003c1e:	2000      	movs	r0, #0
 8003c20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c22:	bf00      	nop
 8003c24:	20019850 	.word	0x20019850
 8003c28:	200197e8 	.word	0x200197e8

08003c2c <SM_SPI_Write_Os>:
{
 8003c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c2e:	4604      	mov	r4, r0
  if (((sensor_handle_t *)handle)->WhoAmI == IIS2DH_ID && len > 1) 
 8003c30:	7800      	ldrb	r0, [r0, #0]
 8003c32:	2833      	cmp	r0, #51	; 0x33
{
 8003c34:	460d      	mov	r5, r1
 8003c36:	4617      	mov	r7, r2
 8003c38:	461e      	mov	r6, r3
  if (((sensor_handle_t *)handle)->WhoAmI == IIS2DH_ID && len > 1) 
 8003c3a:	d103      	bne.n	8003c44 <SM_SPI_Write_Os+0x18>
 8003c3c:	2b01      	cmp	r3, #1
 8003c3e:	bf88      	it	hi
 8003c40:	f041 0540 	orrhi.w	r5, r1, #64	; 0x40
  msg = osPoolAlloc(spiPool_id);
 8003c44:	4b0b      	ldr	r3, [pc, #44]	; (8003c74 <SM_SPI_Write_Os+0x48>)
 8003c46:	6818      	ldr	r0, [r3, #0]
 8003c48:	f00d f97e 	bl	8010f48 <osPoolAlloc>
  osMessagePut(spiReqQueue_id, (uint32_t)(msg), osWaitForever);  
 8003c4c:	4b0a      	ldr	r3, [pc, #40]	; (8003c78 <SM_SPI_Write_Os+0x4c>)
  msg->sensorHandler = handle;
 8003c4e:	6004      	str	r4, [r0, #0]
  msg = osPoolAlloc(spiPool_id);
 8003c50:	4601      	mov	r1, r0
  msg->regAddr = reg|autoInc ;
 8003c52:	7305      	strb	r5, [r0, #12]
  msg->readSize = len;
 8003c54:	81c6      	strh	r6, [r0, #14]
  msg->dataPtr = data;
 8003c56:	6087      	str	r7, [r0, #8]
  osMessagePut(spiReqQueue_id, (uint32_t)(msg), osWaitForever);  
 8003c58:	f04f 32ff 	mov.w	r2, #4294967295
 8003c5c:	6818      	ldr	r0, [r3, #0]
 8003c5e:	f00d f9d7 	bl	8011010 <osMessagePut>
  osSemaphoreWait(*(((sensor_handle_t *)handle)->sem), osWaitForever);    
 8003c62:	68e3      	ldr	r3, [r4, #12]
 8003c64:	f04f 31ff 	mov.w	r1, #4294967295
 8003c68:	6818      	ldr	r0, [r3, #0]
 8003c6a:	f00d f8df 	bl	8010e2c <osSemaphoreWait>
}
 8003c6e:	2000      	movs	r0, #0
 8003c70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c72:	bf00      	nop
 8003c74:	20019850 	.word	0x20019850
 8003c78:	200197e8 	.word	0x200197e8

08003c7c <SM_I2C_Read_Os>:
{
 8003c7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  msg = osPoolAlloc(i2cPool_id);
 8003c7e:	4d0e      	ldr	r5, [pc, #56]	; (8003cb8 <SM_I2C_Read_Os+0x3c>)
{
 8003c80:	4604      	mov	r4, r0
  msg = osPoolAlloc(i2cPool_id);
 8003c82:	6828      	ldr	r0, [r5, #0]
{
 8003c84:	460f      	mov	r7, r1
 8003c86:	4615      	mov	r5, r2
 8003c88:	461e      	mov	r6, r3
  msg = osPoolAlloc(i2cPool_id);
 8003c8a:	f00d f95d 	bl	8010f48 <osPoolAlloc>
  osMessagePut(i2cReqQueue_id, (uint32_t)(msg), osWaitForever); 
 8003c8e:	4b0b      	ldr	r3, [pc, #44]	; (8003cbc <SM_I2C_Read_Os+0x40>)
  msg->regAddr = reg ;
 8003c90:	7307      	strb	r7, [r0, #12]
  msg->isRead = 1;
 8003c92:	2201      	movs	r2, #1
  msg = osPoolAlloc(i2cPool_id);
 8003c94:	4601      	mov	r1, r0
  msg->sensorHandler = handle;
 8003c96:	6004      	str	r4, [r0, #0]
  msg->readSize = len;
 8003c98:	81c6      	strh	r6, [r0, #14]
  msg->dataPtr = data;
 8003c9a:	6085      	str	r5, [r0, #8]
  msg->isRead = 1;
 8003c9c:	7102      	strb	r2, [r0, #4]
  osMessagePut(i2cReqQueue_id, (uint32_t)(msg), osWaitForever); 
 8003c9e:	f04f 32ff 	mov.w	r2, #4294967295
 8003ca2:	6818      	ldr	r0, [r3, #0]
 8003ca4:	f00d f9b4 	bl	8011010 <osMessagePut>
  osSemaphoreWait(*(((sensor_handle_t *)handle)->sem), osWaitForever);  
 8003ca8:	68e3      	ldr	r3, [r4, #12]
 8003caa:	f04f 31ff 	mov.w	r1, #4294967295
 8003cae:	6818      	ldr	r0, [r3, #0]
 8003cb0:	f00d f8bc 	bl	8010e2c <osSemaphoreWait>
}
 8003cb4:	2000      	movs	r0, #0
 8003cb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003cb8:	200198b4 	.word	0x200198b4
 8003cbc:	2001984c 	.word	0x2001984c

08003cc0 <SM_I2C_Write_Os>:
{
 8003cc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  msg = osPoolAlloc(i2cPool_id);
 8003cc2:	4d0e      	ldr	r5, [pc, #56]	; (8003cfc <SM_I2C_Write_Os+0x3c>)
{
 8003cc4:	4604      	mov	r4, r0
  msg = osPoolAlloc(i2cPool_id);
 8003cc6:	6828      	ldr	r0, [r5, #0]
{
 8003cc8:	460f      	mov	r7, r1
 8003cca:	4615      	mov	r5, r2
 8003ccc:	461e      	mov	r6, r3
  msg = osPoolAlloc(i2cPool_id);
 8003cce:	f00d f93b 	bl	8010f48 <osPoolAlloc>
  osMessagePut(i2cReqQueue_id, (uint32_t)(msg), osWaitForever); 
 8003cd2:	4b0b      	ldr	r3, [pc, #44]	; (8003d00 <SM_I2C_Write_Os+0x40>)
  msg->regAddr = reg ;
 8003cd4:	7307      	strb	r7, [r0, #12]
  msg->isRead = 0;
 8003cd6:	2700      	movs	r7, #0
  msg = osPoolAlloc(i2cPool_id);
 8003cd8:	4601      	mov	r1, r0
  msg->sensorHandler = handle;
 8003cda:	6004      	str	r4, [r0, #0]
  msg->readSize = len;
 8003cdc:	81c6      	strh	r6, [r0, #14]
  msg->dataPtr = data;
 8003cde:	6085      	str	r5, [r0, #8]
  msg->isRead = 0;
 8003ce0:	7107      	strb	r7, [r0, #4]
  osMessagePut(i2cReqQueue_id, (uint32_t)(msg), osWaitForever); 
 8003ce2:	f04f 32ff 	mov.w	r2, #4294967295
 8003ce6:	6818      	ldr	r0, [r3, #0]
 8003ce8:	f00d f992 	bl	8011010 <osMessagePut>
  osSemaphoreWait(*(((sensor_handle_t *)handle)->sem), osWaitForever);  
 8003cec:	68e3      	ldr	r3, [r4, #12]
 8003cee:	f04f 31ff 	mov.w	r1, #4294967295
 8003cf2:	6818      	ldr	r0, [r3, #0]
 8003cf4:	f00d f89a 	bl	8010e2c <osSemaphoreWait>
}
 8003cf8:	4638      	mov	r0, r7
 8003cfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003cfc:	200198b4 	.word	0x200198b4
 8003d00:	2001984c 	.word	0x2001984c

08003d04 <SM_Peripheral_Init>:
{
 8003d04:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8003d06:	4d33      	ldr	r5, [pc, #204]	; (8003dd4 <SM_Peripheral_Init+0xd0>)
  hsm_spi.Instance = SM_SPI_x;
 8003d08:	4c33      	ldr	r4, [pc, #204]	; (8003dd8 <SM_Peripheral_Init+0xd4>)
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8003d0a:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8003d0c:	f043 0304 	orr.w	r3, r3, #4
 8003d10:	64ab      	str	r3, [r5, #72]	; 0x48
 8003d12:	6cab      	ldr	r3, [r5, #72]	; 0x48
{
 8003d14:	b085      	sub	sp, #20
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8003d16:	f003 0304 	and.w	r3, r3, #4
 8003d1a:	9302      	str	r3, [sp, #8]
 8003d1c:	9b02      	ldr	r3, [sp, #8]
  SM_SPIx_DMA_CLK_ENABLE();
 8003d1e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8003d20:	f043 0301 	orr.w	r3, r3, #1
 8003d24:	64ab      	str	r3, [r5, #72]	; 0x48
 8003d26:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8003d28:	f003 0301 	and.w	r3, r3, #1
  HAL_NVIC_SetPriority(SM_SPI_RX_DMA_IRQn, 3, 0);
 8003d2c:	2200      	movs	r2, #0
 8003d2e:	2103      	movs	r1, #3
  SM_SPIx_DMA_CLK_ENABLE();
 8003d30:	9303      	str	r3, [sp, #12]
  HAL_NVIC_SetPriority(SM_SPI_RX_DMA_IRQn, 3, 0);
 8003d32:	200b      	movs	r0, #11
  SM_SPIx_DMA_CLK_ENABLE();
 8003d34:	9b03      	ldr	r3, [sp, #12]
  HAL_NVIC_SetPriority(SM_SPI_RX_DMA_IRQn, 3, 0);
 8003d36:	f001 fdc5 	bl	80058c4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SM_SPI_RX_DMA_IRQn);
 8003d3a:	200b      	movs	r0, #11
 8003d3c:	f001 fdfa 	bl	8005934 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(SM_SPI_TX_DMA_IRQn, 3, 0);
 8003d40:	2200      	movs	r2, #0
 8003d42:	2103      	movs	r1, #3
 8003d44:	200c      	movs	r0, #12
 8003d46:	f001 fdbd 	bl	80058c4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SM_SPI_TX_DMA_IRQn);
 8003d4a:	200c      	movs	r0, #12
 8003d4c:	f001 fdf2 	bl	8005934 <HAL_NVIC_EnableIRQ>
  hsm_spi.Instance = SM_SPI_x;
 8003d50:	4b22      	ldr	r3, [pc, #136]	; (8003ddc <SM_Peripheral_Init+0xd8>)
 8003d52:	6023      	str	r3, [r4, #0]
  hsm_spi.Init.Mode = SPI_MODE_MASTER;
 8003d54:	f44f 7082 	mov.w	r0, #260	; 0x104
  hsm_spi.Init.DataSize = SPI_DATASIZE_8BIT;
 8003d58:	f44f 63e0 	mov.w	r3, #1792	; 0x700
  hsm_spi.Init.CLKPhase = SPI_PHASE_2EDGE;
 8003d5c:	2101      	movs	r1, #1
  hsm_spi.Init.Mode = SPI_MODE_MASTER;
 8003d5e:	6060      	str	r0, [r4, #4]
  hsm_spi.Init.DataSize = SPI_DATASIZE_8BIT;
 8003d60:	60e3      	str	r3, [r4, #12]
  hsm_spi.Init.NSS = SPI_NSS_SOFT;
 8003d62:	f44f 7000 	mov.w	r0, #512	; 0x200
  hsm_spi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;
 8003d66:	2320      	movs	r3, #32
  hsm_spi.Init.CLKPhase = SPI_PHASE_2EDGE;
 8003d68:	6161      	str	r1, [r4, #20]
  hsm_spi.Init.CRCPolynomial = 7;
 8003d6a:	2107      	movs	r1, #7
  hsm_spi.Init.NSS = SPI_NSS_SOFT;
 8003d6c:	61a0      	str	r0, [r4, #24]
  hsm_spi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;
 8003d6e:	61e3      	str	r3, [r4, #28]
  hsm_spi.Init.CRCPolynomial = 7;
 8003d70:	62e1      	str	r1, [r4, #44]	; 0x2c
  hsm_spi.Init.Direction = SPI_DIRECTION_2LINES;
 8003d72:	2300      	movs	r3, #0
  HAL_SPI_RegisterCallback(&hsm_spi, HAL_SPI_MSPINIT_CB_ID, SM_SPI_MspInit);
 8003d74:	4a1a      	ldr	r2, [pc, #104]	; (8003de0 <SM_Peripheral_Init+0xdc>)
  hsm_spi.Init.Direction = SPI_DIRECTION_2LINES;
 8003d76:	60a3      	str	r3, [r4, #8]
  hsm_spi.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8003d78:	2702      	movs	r7, #2
  HAL_SPI_RegisterCallback(&hsm_spi, HAL_SPI_MSPINIT_CB_ID, SM_SPI_MspInit);
 8003d7a:	4620      	mov	r0, r4
 8003d7c:	2108      	movs	r1, #8
  hsm_spi.Init.TIMode = SPI_TIMODE_DISABLE;
 8003d7e:	e9c4 3308 	strd	r3, r3, [r4, #32]
  hsm_spi.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 8003d82:	e9c4 330c 	strd	r3, r3, [r4, #48]	; 0x30
  hsm_spi.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8003d86:	62a3      	str	r3, [r4, #40]	; 0x28
  hsm_spi.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8003d88:	6127      	str	r7, [r4, #16]
  HAL_SPI_RegisterCallback(&hsm_spi, HAL_SPI_MSPINIT_CB_ID, SM_SPI_MspInit);
 8003d8a:	f005 fd0b 	bl	80097a4 <HAL_SPI_RegisterCallback>
  if (HAL_SPI_Init(&hsm_spi) != HAL_OK)
 8003d8e:	4620      	mov	r0, r4
 8003d90:	f005 fc72 	bl	8009678 <HAL_SPI_Init>
 8003d94:	b100      	cbz	r0, 8003d98 <SM_Peripheral_Init+0x94>
  while (1)
 8003d96:	e7fe      	b.n	8003d96 <SM_Peripheral_Init+0x92>
 8003d98:	4606      	mov	r6, r0
  HAL_SPI_RegisterCallback(&hsm_spi, HAL_SPI_TX_RX_COMPLETE_CB_ID, SM_SPI_TxRxCpltCallback);
 8003d9a:	4a12      	ldr	r2, [pc, #72]	; (8003de4 <SM_Peripheral_Init+0xe0>)
 8003d9c:	4639      	mov	r1, r7
 8003d9e:	4620      	mov	r0, r4
 8003da0:	f005 fd00 	bl	80097a4 <HAL_SPI_RegisterCallback>
  HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);  
}

void SM_TIM_Init(void)
{
  SM_TIMx_CLK_ENABLE();
 8003da4:	6dab      	ldr	r3, [r5, #88]	; 0x58
  /* Set TIMx instance */
  hsm_tim.Instance = SM_TIMx;
 8003da6:	4810      	ldr	r0, [pc, #64]	; (8003de8 <SM_Peripheral_Init+0xe4>)
 8003da8:	4a10      	ldr	r2, [pc, #64]	; (8003dec <SM_Peripheral_Init+0xe8>)
       + Prescaler = (SystemCoreClock/10000) - 1
       + ClockDivision = 0
       + Counter direction = Up
  */
  hsm_tim.Init.Period            = 0xFFFFFFFF;
  hsm_tim.Init.Prescaler         = 0;
 8003daa:	6046      	str	r6, [r0, #4]
  SM_TIMx_CLK_ENABLE();
 8003dac:	f043 0308 	orr.w	r3, r3, #8
 8003db0:	65ab      	str	r3, [r5, #88]	; 0x58
 8003db2:	6dab      	ldr	r3, [r5, #88]	; 0x58
  hsm_tim.Init.ClockDivision     = 0;
 8003db4:	6106      	str	r6, [r0, #16]
  SM_TIMx_CLK_ENABLE();
 8003db6:	f003 0308 	and.w	r3, r3, #8
 8003dba:	9301      	str	r3, [sp, #4]
 8003dbc:	9b01      	ldr	r3, [sp, #4]
  hsm_tim.Init.CounterMode       = TIM_COUNTERMODE_UP;
 8003dbe:	6086      	str	r6, [r0, #8]
  hsm_tim.Init.Period            = 0xFFFFFFFF;
 8003dc0:	f04f 33ff 	mov.w	r3, #4294967295
  hsm_tim.Init.RepetitionCounter = 0;
 8003dc4:	6146      	str	r6, [r0, #20]
  hsm_tim.Instance = SM_TIMx;
 8003dc6:	6002      	str	r2, [r0, #0]
  hsm_tim.Init.Period            = 0xFFFFFFFF;
 8003dc8:	60c3      	str	r3, [r0, #12]
}
 8003dca:	b005      	add	sp, #20
 8003dcc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}

  if (HAL_TIM_Base_Init(&hsm_tim) != HAL_OK)
 8003dd0:	f005 bf42 	b.w	8009c58 <HAL_TIM_Base_Init>
 8003dd4:	40021000 	.word	0x40021000
 8003dd8:	200198bc 	.word	0x200198bc
 8003ddc:	40003800 	.word	0x40003800
 8003de0:	080039f9 	.word	0x080039f9
 8003de4:	080039ed 	.word	0x080039ed
 8003de8:	200197a4 	.word	0x200197a4
 8003dec:	40000c00 	.word	0x40000c00

08003df0 <SM_TIM_Start>:
}

void SM_TIM_Start(void)
{
  /*##-2- Start the TIM Base generation ####################*/
  if (HAL_TIM_Base_Start(&hsm_tim) != HAL_OK)
 8003df0:	4801      	ldr	r0, [pc, #4]	; (8003df8 <SM_TIM_Start+0x8>)
 8003df2:	f005 bfa3 	b.w	8009d3c <HAL_TIM_Base_Start>
 8003df6:	bf00      	nop
 8003df8:	200197a4 	.word	0x200197a4

08003dfc <SM_TIM_Stop>:
//    Error_Handler();
  }
}

void SM_TIM_Stop(void)
{
 8003dfc:	b510      	push	{r4, lr}
  /*##-2- Start the TIM Base generation ####################*/
  if (HAL_TIM_Base_Stop(&hsm_tim) != HAL_OK)
 8003dfe:	4c04      	ldr	r4, [pc, #16]	; (8003e10 <SM_TIM_Stop+0x14>)
 8003e00:	4620      	mov	r0, r4
 8003e02:	f005 ffb3 	bl	8009d6c <HAL_TIM_Base_Stop>
  {
    /* Starting Error */
//    Error_Handler();
  }
  hsm_tim.Instance->CNT = 0;
 8003e06:	6823      	ldr	r3, [r4, #0]
 8003e08:	2200      	movs	r2, #0
 8003e0a:	625a      	str	r2, [r3, #36]	; 0x24
}
 8003e0c:	bd10      	pop	{r4, pc}
 8003e0e:	bf00      	nop
 8003e10:	200197a4 	.word	0x200197a4

08003e14 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8003e14:	4770      	bx	lr
 8003e16:	bf00      	nop

08003e18 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8003e18:	e7fe      	b.n	8003e18 <HardFault_Handler>
 8003e1a:	bf00      	nop

08003e1c <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8003e1c:	e7fe      	b.n	8003e1c <MemManage_Handler>
 8003e1e:	bf00      	nop

08003e20 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8003e20:	e7fe      	b.n	8003e20 <BusFault_Handler>
 8003e22:	bf00      	nop

08003e24 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8003e24:	e7fe      	b.n	8003e24 <UsageFault_Handler>
 8003e26:	bf00      	nop

08003e28 <DebugMon_Handler>:
 8003e28:	4770      	bx	lr
 8003e2a:	bf00      	nop

08003e2c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8003e2c:	b508      	push	{r3, lr}
 HAL_IncTick();
 8003e2e:	f000 fecb 	bl	8004bc8 <HAL_IncTick>
 osSystickHandler();
}
 8003e32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 osSystickHandler();
 8003e36:	f00d b95b 	b.w	80110f0 <osSystickHandler>
 8003e3a:	bf00      	nop

08003e3c <PVD_PVM_IRQHandler>:
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32l4xx.s).                    */
/******************************************************************************/
void PVD_PVM_IRQHandler(void)
{
  HAL_PWREx_PVD_PVM_IRQHandler();
 8003e3c:	f002 bff2 	b.w	8006e24 <HAL_PWREx_PVD_PVM_IRQHandler>

08003e40 <DMA1_Channel1_IRQHandler>:
/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_sm_spi_rx);
 8003e40:	4801      	ldr	r0, [pc, #4]	; (8003e48 <DMA1_Channel1_IRQHandler+0x8>)
 8003e42:	f001 bec3 	b.w	8005bcc <HAL_DMA_IRQHandler>
 8003e46:	bf00      	nop
 8003e48:	200196e4 	.word	0x200196e4

08003e4c <DMA1_Channel2_IRQHandler>:
/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_sm_spi_tx);
 8003e4c:	4801      	ldr	r0, [pc, #4]	; (8003e54 <DMA1_Channel2_IRQHandler+0x8>)
 8003e4e:	f001 bebd 	b.w	8005bcc <HAL_DMA_IRQHandler>
 8003e52:	bf00      	nop
 8003e54:	20019854 	.word	0x20019854

08003e58 <DMA1_Channel3_IRQHandler>:
/**
  * @brief This function handles DMA1 channel3 global interrupt.
  */
void DMA1_Channel3_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_sm_i2c_rx);
 8003e58:	4801      	ldr	r0, [pc, #4]	; (8003e60 <DMA1_Channel3_IRQHandler+0x8>)
 8003e5a:	f001 beb7 	b.w	8005bcc <HAL_DMA_IRQHandler>
 8003e5e:	bf00      	nop
 8003e60:	200197ec 	.word	0x200197ec

08003e64 <DMA1_Channel4_IRQHandler>:
/**
  * @brief This function handles DMA1 channel3 global interrupt.
  */
void DMA1_Channel4_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_sm_i2c_tx);
 8003e64:	4801      	ldr	r0, [pc, #4]	; (8003e6c <DMA1_Channel4_IRQHandler+0x8>)
 8003e66:	f001 beb1 	b.w	8005bcc <HAL_DMA_IRQHandler>
 8003e6a:	bf00      	nop
 8003e6c:	20019744 	.word	0x20019744

08003e70 <DMA1_Channel5_IRQHandler>:
/**
  * @brief This function handles DMA1 channel5 global interrupt.
  */
void DMA1_Channel5_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_dfsdm1_flt0);
 8003e70:	4801      	ldr	r0, [pc, #4]	; (8003e78 <DMA1_Channel5_IRQHandler+0x8>)
 8003e72:	f001 beab 	b.w	8005bcc <HAL_DMA_IRQHandler>
 8003e76:	bf00      	nop
 8003e78:	200134f0 	.word	0x200134f0

08003e7c <DMA1_Channel6_IRQHandler>:
/**
  * @brief This function handles DMA1 channel6 global interrupt.
  */
void DMA1_Channel6_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_dfsdm1_flt1);
 8003e7c:	4801      	ldr	r0, [pc, #4]	; (8003e84 <DMA1_Channel6_IRQHandler+0x8>)
 8003e7e:	f001 bea5 	b.w	8005bcc <HAL_DMA_IRQHandler>
 8003e82:	bf00      	nop
 8003e84:	200173cc 	.word	0x200173cc

08003e88 <EXTI0_IRQHandler>:
/**
  * @brief This function handles EXTI line[0] interrupts.
  */
void EXTI0_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 8003e88:	2001      	movs	r0, #1
 8003e8a:	f002 b843 	b.w	8005f14 <HAL_GPIO_EXTI_IRQHandler>
 8003e8e:	bf00      	nop

08003e90 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 8003e90:	b508      	push	{r3, lr}
   HAL_EXTI_IRQHandler(&hts221_exti);  
 8003e92:	4807      	ldr	r0, [pc, #28]	; (8003eb0 <EXTI9_5_IRQHandler+0x20>)
 8003e94:	f001 fef4 	bl	8005c80 <HAL_EXTI_IRQHandler>
   HAL_EXTI_IRQHandler(&ism330dhcx_exti);  
 8003e98:	4806      	ldr	r0, [pc, #24]	; (8003eb4 <EXTI9_5_IRQHandler+0x24>)
 8003e9a:	f001 fef1 	bl	8005c80 <HAL_EXTI_IRQHandler>
   HAL_EXTI_IRQHandler(&iis2mdc_exti);
 8003e9e:	4806      	ldr	r0, [pc, #24]	; (8003eb8 <EXTI9_5_IRQHandler+0x28>)
 8003ea0:	f001 feee 	bl	8005c80 <HAL_EXTI_IRQHandler>
   HAL_EXTI_IRQHandler(&iis3dwb_exti);
}
 8003ea4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   HAL_EXTI_IRQHandler(&iis3dwb_exti);
 8003ea8:	4804      	ldr	r0, [pc, #16]	; (8003ebc <EXTI9_5_IRQHandler+0x2c>)
 8003eaa:	f001 bee9 	b.w	8005c80 <HAL_EXTI_IRQHandler>
 8003eae:	bf00      	nop
 8003eb0:	20010dcc 	.word	0x20010dcc
 8003eb4:	20016dac 	.word	0x20016dac
 8003eb8:	20010e34 	.word	0x20010e34
 8003ebc:	20010e54 	.word	0x20010e54

08003ec0 <I2C2_EV_IRQHandler>:
/**
  * @brief This function handles I2C2 event interrupt.
  */
void I2C2_EV_IRQHandler(void)
{
  HAL_I2C_EV_IRQHandler(&hsm_i2c);
 8003ec0:	4801      	ldr	r0, [pc, #4]	; (8003ec8 <I2C2_EV_IRQHandler+0x8>)
 8003ec2:	f002 baad 	b.w	8006420 <HAL_I2C_EV_IRQHandler>
 8003ec6:	bf00      	nop
 8003ec8:	20019660 	.word	0x20019660

08003ecc <I2C2_ER_IRQHandler>:
/**
  * @brief This function handles I2C2 error interrupt.
  */
void I2C2_ER_IRQHandler(void)
{
  HAL_I2C_ER_IRQHandler(&hsm_i2c);
 8003ecc:	4801      	ldr	r0, [pc, #4]	; (8003ed4 <I2C2_ER_IRQHandler+0x8>)
 8003ece:	f002 baaf 	b.w	8006430 <HAL_I2C_ER_IRQHandler>
 8003ed2:	bf00      	nop
 8003ed4:	20019660 	.word	0x20019660

08003ed8 <EXTI15_10_IRQHandler>:
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
  //HAL_EXTI_IRQHandler(&iis3dwb_exti);
  HAL_EXTI_IRQHandler(&BC_exti);
 8003ed8:	4801      	ldr	r0, [pc, #4]	; (8003ee0 <EXTI15_10_IRQHandler+0x8>)
 8003eda:	f001 bed1 	b.w	8005c80 <HAL_EXTI_IRQHandler>
 8003ede:	bf00      	nop
 8003ee0:	20017298 	.word	0x20017298

08003ee4 <EXTI2_IRQHandler>:
/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI2_IRQHandler(void)
{
  HAL_EXTI_IRQHandler(&iis2dh_exti);
 8003ee4:	4801      	ldr	r0, [pc, #4]	; (8003eec <EXTI2_IRQHandler+0x8>)
 8003ee6:	f001 becb 	b.w	8005c80 <HAL_EXTI_IRQHandler>
 8003eea:	bf00      	nop
 8003eec:	20010de0 	.word	0x20010de0

08003ef0 <DMA2_Channel1_IRQHandler>:
 8003ef0:	4770      	bx	lr
 8003ef2:	bf00      	nop

08003ef4 <OTG_FS_IRQHandler>:
/**
  * @brief This function handles USB OTG FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8003ef4:	4801      	ldr	r0, [pc, #4]	; (8003efc <OTG_FS_IRQHandler+0x8>)
 8003ef6:	f002 bad9 	b.w	80064ac <HAL_PCD_IRQHandler>
 8003efa:	bf00      	nop
 8003efc:	2001996c 	.word	0x2001996c

08003f00 <SDMMC1_IRQHandler>:
}

void SDMMC1_IRQHandler(void)
{
  HAL_SD_IRQHandler(&hsd1);
 8003f00:	4801      	ldr	r0, [pc, #4]	; (8003f08 <SDMMC1_IRQHandler+0x8>)
 8003f02:	f004 bc9b 	b.w	800883c <HAL_SD_IRQHandler>
 8003f06:	bf00      	nop
 8003f08:	20016f0c 	.word	0x20016f0c

08003f0c <STTS751_Start>:
}

void STTS751_Start(void)
{
  STTS751_Set_State(SM_SENSOR_STATE_INITIALIZING);
  osThreadResume(STTS751_Thread_Id);
 8003f0c:	4a03      	ldr	r2, [pc, #12]	; (8003f1c <STTS751_Start+0x10>)
  STTS751_Sensor_State = newState;
 8003f0e:	4b04      	ldr	r3, [pc, #16]	; (8003f20 <STTS751_Start+0x14>)
  osThreadResume(STTS751_Thread_Id);
 8003f10:	6810      	ldr	r0, [r2, #0]
  STTS751_Sensor_State = newState;
 8003f12:	2203      	movs	r2, #3
 8003f14:	701a      	strb	r2, [r3, #0]
  osThreadResume(STTS751_Thread_Id);
 8003f16:	f00d b8fb 	b.w	8011110 <osThreadResume>
 8003f1a:	bf00      	nop
 8003f1c:	20019968 	.word	0x20019968
 8003f20:	200000d4 	.word	0x200000d4

08003f24 <STTS751_Stop>:
  STTS751_Sensor_State = newState;
 8003f24:	4b01      	ldr	r3, [pc, #4]	; (8003f2c <STTS751_Stop+0x8>)
 8003f26:	2201      	movs	r2, #1
 8003f28:	701a      	strb	r2, [r3, #0]
}

void STTS751_Stop(void)
{
  STTS751_Set_State(SM_SENSOR_STATE_SUSPENDING);
}
 8003f2a:	4770      	bx	lr
 8003f2c:	200000d4 	.word	0x200000d4

08003f30 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8003f30:	f500 7171 	add.w	r1, r0, #964	; 0x3c4
 8003f34:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f38:	f008 beaa 	b.w	800cc90 <USBD_LL_SetupStage>

08003f3c <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8003f3c:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003f40:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003f44:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f48:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 8003f4c:	f008 bed0 	b.w	800ccf0 <USBD_LL_DataOutStage>

08003f50 <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8003f50:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8003f54:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8003f58:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f5c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8003f5e:	f008 bf05 	b.w	800cd6c <USBD_LL_DataInStage>
 8003f62:	bf00      	nop

08003f64 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8003f64:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f68:	f008 bfa2 	b.w	800ceb0 <USBD_LL_SOF>

08003f6c <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{   
 8003f6c:	b510      	push	{r4, lr}
 8003f6e:	4604      	mov	r4, r0
  /* Reset Device */
  USBD_LL_Reset(hpcd->pData);
 8003f70:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f74:	f008 ff5c 	bl	800ce30 <USBD_LL_Reset>
  
  /* Set USB Current Speed */ 
  USBD_LL_SetSpeed(hpcd->pData, USBD_SPEED_FULL);
 8003f78:	f8d4 0404 	ldr.w	r0, [r4, #1028]	; 0x404
 8003f7c:	2101      	movs	r1, #1
}
 8003f7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_SetSpeed(hpcd->pData, USBD_SPEED_FULL);
 8003f82:	f008 bf7d 	b.w	800ce80 <USBD_LL_SetSpeed>
 8003f86:	bf00      	nop

08003f88 <HAL_PCD_SuspendCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{ 
  USBD_LL_Suspend(hpcd->pData);
 8003f88:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f8c:	f008 bf7c 	b.w	800ce88 <USBD_LL_Suspend>

08003f90 <HAL_PCD_ResumeCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_Resume(hpcd->pData);
 8003f90:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f94:	f008 bf82 	b.w	800ce9c <USBD_LL_Resume>

08003f98 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 8003f98:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003f9c:	f008 bf98 	b.w	800ced0 <USBD_LL_IsoOUTIncomplete>

08003fa0 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8003fa0:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003fa4:	f008 bf92 	b.w	800cecc <USBD_LL_IsoINIncomplete>

08003fa8 <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 8003fa8:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003fac:	f008 bf92 	b.w	800ced4 <USBD_LL_DevConnected>

08003fb0 <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 8003fb0:	f8d0 0404 	ldr.w	r0, [r0, #1028]	; 0x404
 8003fb4:	f008 bf90 	b.w	800ced8 <USBD_LL_DevDisconnected>

08003fb8 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev,
                                  uint8_t ep_addr,
                                  uint8_t ep_type,
                                  uint16_t ep_mps)
{
 8003fb8:	b510      	push	{r4, lr}
 8003fba:	4614      	mov	r4, r2
  HAL_PCD_EP_Open(pdev->pData,
 8003fbc:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
{
 8003fc0:	461a      	mov	r2, r3
  HAL_PCD_EP_Open(pdev->pData,
 8003fc2:	4623      	mov	r3, r4
 8003fc4:	f002 fd42 	bl	8006a4c <HAL_PCD_EP_Open>
                  ep_addr,
                  ep_mps,
                  ep_type);
  
  return USBD_OK;
}
 8003fc8:	2000      	movs	r0, #0
 8003fca:	bd10      	pop	{r4, pc}

08003fcc <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003fcc:	b508      	push	{r3, lr}
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8003fce:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8003fd2:	f002 fdb1 	bl	8006b38 <HAL_PCD_EP_SetStall>
  return USBD_OK;
}
 8003fd6:	2000      	movs	r0, #0
 8003fd8:	bd08      	pop	{r3, pc}
 8003fda:	bf00      	nop

08003fdc <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8003fdc:	b508      	push	{r3, lr}
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8003fde:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8003fe2:	f002 fdeb 	bl	8006bbc <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
}
 8003fe6:	2000      	movs	r0, #0
 8003fe8:	bd08      	pop	{r3, pc}
 8003fea:	bf00      	nop

08003fec <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = pdev->pData;
  
  if((ep_addr & 0x80) == 0x80)
 8003fec:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = pdev->pData;
 8003fee:	f8d0 32c0 	ldr.w	r3, [r0, #704]	; 0x2c0
  if((ep_addr & 0x80) == 0x80)
 8003ff2:	d406      	bmi.n	8004002 <USBD_LL_IsStallEP+0x16>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8003ff4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8003ff8:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8003ffc:	f891 01fe 	ldrb.w	r0, [r1, #510]	; 0x1fe
  }
}
 8004000:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8004002:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8004006:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 800400a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800400e:	f891 003e 	ldrb.w	r0, [r1, #62]	; 0x3e
 8004012:	4770      	bx	lr

08004014 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8004014:	b508      	push	{r3, lr}
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8004016:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800401a:	f002 fd03 	bl	8006a24 <HAL_PCD_SetAddress>
  return USBD_OK; 
}
 800401e:	2000      	movs	r0, #0
 8004020:	bd08      	pop	{r3, pc}
 8004022:	bf00      	nop

08004024 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, 
                                    uint8_t ep_addr,
                                    uint8_t *pbuf,
                                    uint16_t size)
{
 8004024:	b508      	push	{r3, lr}
  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8004026:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800402a:	f002 fd67 	bl	8006afc <HAL_PCD_EP_Transmit>
  return USBD_OK;
}
 800402e:	2000      	movs	r0, #0
 8004030:	bd08      	pop	{r3, pc}
 8004032:	bf00      	nop

08004034 <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                          uint8_t ep_addr,
                                          uint8_t *pbuf,
                                          uint16_t size)
{
 8004034:	b508      	push	{r3, lr}
  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8004036:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 800403a:	f002 fd3d 	bl	8006ab8 <HAL_PCD_EP_Receive>
  return USBD_OK;
}
 800403e:	2000      	movs	r0, #0
 8004040:	bd08      	pop	{r3, pc}
 8004042:	bf00      	nop

08004044 <iis3dwb_read_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t iis3dwb_read_reg(stmdev_ctx_t* ctx, uint8_t reg, uint8_t* data,
                           uint16_t len)
{
 8004044:	b410      	push	{r4}
  int32_t ret;
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8004046:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
 800404a:	46a4      	mov	ip, r4
  return ret;
}
 800404c:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8004050:	4760      	bx	ip
 8004052:	bf00      	nop

08004054 <iis3dwb_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t iis3dwb_write_reg(stmdev_ctx_t* ctx, uint8_t reg, uint8_t* data,
                            uint16_t len)
{
 8004054:	b410      	push	{r4}
  int32_t ret;
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004056:	6804      	ldr	r4, [r0, #0]
 8004058:	6880      	ldr	r0, [r0, #8]
 800405a:	46a4      	mov	ip, r4
  return ret;
}
 800405c:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004060:	4760      	bx	ip
 8004062:	bf00      	nop

08004064 <iis3dwb_xl_full_scale_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_xl_full_scale_set(stmdev_ctx_t *ctx,
                                    iis3dwb_fs_xl_t val)
{
 8004064:	b570      	push	{r4, r5, r6, lr}
 8004066:	b082      	sub	sp, #8
 8004068:	4604      	mov	r4, r0
 800406a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800406c:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 8004070:	aa01      	add	r2, sp, #4
 8004072:	2301      	movs	r3, #1
 8004074:	2110      	movs	r1, #16
 8004076:	47b0      	blx	r6
  iis3dwb_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  if(ret == 0){
 8004078:	b958      	cbnz	r0, 8004092 <iis3dwb_xl_full_scale_set+0x2e>
    ctrl1_xl.fs_xl = (uint8_t)val;
 800407a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800407e:	6826      	ldr	r6, [r4, #0]
 8004080:	68a0      	ldr	r0, [r4, #8]
    ctrl1_xl.fs_xl = (uint8_t)val;
 8004082:	f365 0383 	bfi	r3, r5, #2, #2
 8004086:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800408a:	aa01      	add	r2, sp, #4
 800408c:	2301      	movs	r3, #1
 800408e:	2110      	movs	r1, #16
 8004090:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_CTRL1_XL,
                              (uint8_t*)&ctrl1_xl, 1);
  }
  return ret;
}
 8004092:	b002      	add	sp, #8
 8004094:	bd70      	pop	{r4, r5, r6, pc}
 8004096:	bf00      	nop

08004098 <iis3dwb_data_ready_mode_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_data_ready_mode_set(stmdev_ctx_t *ctx,
                                      iis3dwb_dataready_pulsed_t val)
{
 8004098:	b570      	push	{r4, r5, r6, lr}
 800409a:	b082      	sub	sp, #8
 800409c:	4604      	mov	r4, r0
 800409e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80040a0:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 80040a4:	aa01      	add	r2, sp, #4
 80040a6:	2301      	movs	r3, #1
 80040a8:	210b      	movs	r1, #11
 80040aa:	47b0      	blx	r6
  iis3dwb_counter_bdr_reg1_t counter_bdr_reg1;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_COUNTER_BDR_REG1,
                           (uint8_t*)&counter_bdr_reg1, 1);
  if(ret == 0){
 80040ac:	b958      	cbnz	r0, 80040c6 <iis3dwb_data_ready_mode_set+0x2e>
    counter_bdr_reg1.dataready_pulsed= (uint8_t)val;
 80040ae:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80040b2:	6826      	ldr	r6, [r4, #0]
 80040b4:	68a0      	ldr	r0, [r4, #8]
    counter_bdr_reg1.dataready_pulsed= (uint8_t)val;
 80040b6:	f365 13c7 	bfi	r3, r5, #7, #1
 80040ba:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80040be:	aa01      	add	r2, sp, #4
 80040c0:	2301      	movs	r3, #1
 80040c2:	210b      	movs	r1, #11
 80040c4:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_COUNTER_BDR_REG1,
                              (uint8_t*)&counter_bdr_reg1, 1);
  }
  return ret;
}
 80040c6:	b002      	add	sp, #8
 80040c8:	bd70      	pop	{r4, r5, r6, pc}
 80040ca:	bf00      	nop

080040cc <iis3dwb_device_id_get>:
  * @param  buff   Buffer that stores data read
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_device_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
 80040cc:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80040ce:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
{
 80040d2:	460a      	mov	r2, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80040d4:	46a4      	mov	ip, r4
 80040d6:	2301      	movs	r3, #1
  int32_t ret;
  ret = iis3dwb_read_reg(ctx, IIS3DWB_WHO_AM_I, buff, 1);
  return ret;
}
 80040d8:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80040dc:	210f      	movs	r1, #15
 80040de:	4760      	bx	ip

080040e0 <iis3dwb_reset_set>:
  * @param  val    Change the values of sw_reset in reg CTRL3_C
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_reset_set(stmdev_ctx_t *ctx, uint8_t val)
{
 80040e0:	b570      	push	{r4, r5, r6, lr}
 80040e2:	b082      	sub	sp, #8
 80040e4:	4604      	mov	r4, r0
 80040e6:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80040e8:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 80040ec:	aa01      	add	r2, sp, #4
 80040ee:	2301      	movs	r3, #1
 80040f0:	2112      	movs	r1, #18
 80040f2:	47b0      	blx	r6
  iis3dwb_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  if(ret == 0){
 80040f4:	b958      	cbnz	r0, 800410e <iis3dwb_reset_set+0x2e>
    ctrl3_c.sw_reset= (uint8_t)val;
 80040f6:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80040fa:	6826      	ldr	r6, [r4, #0]
 80040fc:	68a0      	ldr	r0, [r4, #8]
    ctrl3_c.sw_reset= (uint8_t)val;
 80040fe:	f365 0300 	bfi	r3, r5, #0, #1
 8004102:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004106:	aa01      	add	r2, sp, #4
 8004108:	2301      	movs	r3, #1
 800410a:	2112      	movs	r1, #18
 800410c:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_CTRL3_C, (uint8_t*)&ctrl3_c, 1);
  }
  return ret;
}
 800410e:	b002      	add	sp, #8
 8004110:	bd70      	pop	{r4, r5, r6, pc}
 8004112:	bf00      	nop

08004114 <iis3dwb_xl_hp_path_on_out_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_xl_hp_path_on_out_set(stmdev_ctx_t *ctx,
                                        iis3dwb_hp_slope_xl_en_t val)
{
 8004114:	b570      	push	{r4, r5, r6, lr}
 8004116:	b082      	sub	sp, #8
 8004118:	4604      	mov	r4, r0
 800411a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800411c:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 8004120:	466a      	mov	r2, sp
 8004122:	2301      	movs	r3, #1
 8004124:	2110      	movs	r1, #16
 8004126:	47b0      	blx	r6
  iis3dwb_ctrl1_xl_t ctrl1_xl;
  iis3dwb_ctrl8_xl_t ctrl8_xl;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  if(ret == 0){
 8004128:	bb50      	cbnz	r0, 8004180 <iis3dwb_xl_hp_path_on_out_set+0x6c>
    ctrl1_xl.lpf2_xl_en = ((uint8_t)val & 0x80U) >> 7;
 800412a:	f89d 3000 	ldrb.w	r3, [sp]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800412e:	6826      	ldr	r6, [r4, #0]
 8004130:	68a0      	ldr	r0, [r4, #8]
    ctrl1_xl.lpf2_xl_en = ((uint8_t)val & 0x80U) >> 7;
 8004132:	09ea      	lsrs	r2, r5, #7
 8004134:	f362 0341 	bfi	r3, r2, #1, #1
 8004138:	f88d 3000 	strb.w	r3, [sp]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800413c:	466a      	mov	r2, sp
 800413e:	2301      	movs	r3, #1
 8004140:	2110      	movs	r1, #16
 8004142:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_CTRL1_XL, (uint8_t*)&ctrl1_xl, 1);
  }
  if(ret == 0){
 8004144:	b9e0      	cbnz	r0, 8004180 <iis3dwb_xl_hp_path_on_out_set+0x6c>
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8004146:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
 800414a:	aa01      	add	r2, sp, #4
 800414c:	2301      	movs	r3, #1
 800414e:	2117      	movs	r1, #23
 8004150:	47b0      	blx	r6
    ret = iis3dwb_read_reg(ctx, IIS3DWB_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
  }
  if(ret == 0){
 8004152:	b9a8      	cbnz	r0, 8004180 <iis3dwb_xl_hp_path_on_out_set+0x6c>
    ctrl8_xl.fds = ((uint8_t)val & 0x10U) >> 4;
 8004154:	f3c5 1300 	ubfx	r3, r5, #4, #1
 8004158:	f89d 2004 	ldrb.w	r2, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800415c:	68a0      	ldr	r0, [r4, #8]
    ctrl8_xl.fds = ((uint8_t)val & 0x10U) >> 4;
 800415e:	f3c5 1140 	ubfx	r1, r5, #5, #1
 8004162:	009b      	lsls	r3, r3, #2
 8004164:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8004168:	ea43 1145 	orr.w	r1, r3, r5, lsl #5
 800416c:	f002 030b 	and.w	r3, r2, #11
 8004170:	4319      	orrs	r1, r3
 8004172:	f88d 1004 	strb.w	r1, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004176:	6825      	ldr	r5, [r4, #0]
 8004178:	aa01      	add	r2, sp, #4
 800417a:	2301      	movs	r3, #1
 800417c:	2117      	movs	r1, #23
 800417e:	47a8      	blx	r5
    ctrl8_xl.hp_ref_mode_xl = ((uint8_t)val & 0x20U) >> 5;
    ctrl8_xl.hpcf_xl = (uint8_t)val & 0x07U;
    ret = iis3dwb_write_reg(ctx, IIS3DWB_CTRL8_XL, (uint8_t*)&ctrl8_xl, 1);
  }
  return ret;
}
 8004180:	b002      	add	sp, #8
 8004182:	bd70      	pop	{r4, r5, r6, pc}

08004184 <iis3dwb_i2c_interface_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_i2c_interface_set(stmdev_ctx_t *ctx,
                                    iis3dwb_i2c_disable_t val)
{
 8004184:	b570      	push	{r4, r5, r6, lr}
 8004186:	b082      	sub	sp, #8
 8004188:	4604      	mov	r4, r0
 800418a:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800418c:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 8004190:	aa01      	add	r2, sp, #4
 8004192:	2301      	movs	r3, #1
 8004194:	2113      	movs	r1, #19
 8004196:	47b0      	blx	r6
  iis3dwb_ctrl4_c_t ctrl4_c;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
  if(ret == 0){
 8004198:	b958      	cbnz	r0, 80041b2 <iis3dwb_i2c_interface_set+0x2e>
    ctrl4_c.i2c_disable= (uint8_t)val;
 800419a:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800419e:	6826      	ldr	r6, [r4, #0]
 80041a0:	68a0      	ldr	r0, [r4, #8]
    ctrl4_c.i2c_disable= (uint8_t)val;
 80041a2:	f365 0382 	bfi	r3, r5, #2, #1
 80041a6:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041aa:	aa01      	add	r2, sp, #4
 80041ac:	2301      	movs	r3, #1
 80041ae:	2113      	movs	r1, #19
 80041b0:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_CTRL4_C, (uint8_t*)&ctrl4_c, 1);
  }
  return ret;
}
 80041b2:	b002      	add	sp, #8
 80041b4:	bd70      	pop	{r4, r5, r6, pc}
 80041b6:	bf00      	nop

080041b8 <iis3dwb_pin_int1_route_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_pin_int1_route_set(stmdev_ctx_t *ctx,
                                     iis3dwb_pin_int1_route_t *val)
{
 80041b8:	b570      	push	{r4, r5, r6, lr}
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041ba:	460a      	mov	r2, r1
 80041bc:	6806      	ldr	r6, [r0, #0]
{
 80041be:	4604      	mov	r4, r0
 80041c0:	460d      	mov	r5, r1
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041c2:	6880      	ldr	r0, [r0, #8]
 80041c4:	2301      	movs	r3, #1
 80041c6:	210d      	movs	r1, #13
 80041c8:	47b0      	blx	r6
  int32_t ret;
  
  ret = iis3dwb_write_reg(ctx, IIS3DWB_INT1_CTRL,
                            (uint8_t*)&val->int1_ctrl, 1);
  if(ret == 0){
 80041ca:	b940      	cbnz	r0, 80041de <iis3dwb_pin_int1_route_set+0x26>
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041cc:	1c6a      	adds	r2, r5, #1
 80041ce:	6825      	ldr	r5, [r4, #0]
 80041d0:	68a0      	ldr	r0, [r4, #8]
 80041d2:	46ac      	mov	ip, r5
 80041d4:	2301      	movs	r3, #1
    ret = iis3dwb_write_reg(ctx, IIS3DWB_MD1_CFG,
                              (uint8_t*)&val->md1_cfg, 1);
  }
  return ret;
}
 80041d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041da:	215e      	movs	r1, #94	; 0x5e
 80041dc:	4760      	bx	ip
}
 80041de:	bd70      	pop	{r4, r5, r6, pc}

080041e0 <iis3dwb_fifo_watermark_set>:
  * @param  val    Change the values of wtm in reg FIFO_CTRL1
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_fifo_watermark_set(stmdev_ctx_t *ctx, uint16_t val)
{
 80041e0:	b570      	push	{r4, r5, r6, lr}
 80041e2:	b082      	sub	sp, #8
 80041e4:	4604      	mov	r4, r0
 80041e6:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80041e8:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 80041ec:	aa01      	add	r2, sp, #4
 80041ee:	2301      	movs	r3, #1
 80041f0:	2108      	movs	r1, #8
 80041f2:	47b0      	blx	r6
  iis3dwb_fifo_ctrl2_t fifo_ctrl2;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_FIFO_CTRL2,
                           (uint8_t*)&fifo_ctrl2, 1);
  if(ret == 0){
 80041f4:	b9a8      	cbnz	r0, 8004222 <iis3dwb_fifo_watermark_set+0x42>
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041f6:	6826      	ldr	r6, [r4, #0]
 80041f8:	68a0      	ldr	r0, [r4, #8]
    fifo_ctrl1.wtm = (uint8_t)(0x00FFU & val);
 80041fa:	f88d 5000 	strb.w	r5, [sp]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80041fe:	2301      	movs	r3, #1
 8004200:	466a      	mov	r2, sp
 8004202:	2107      	movs	r1, #7
 8004204:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_FIFO_CTRL1,
                              (uint8_t*)&fifo_ctrl1, 1);
  }
  if(ret == 0){
 8004206:	b960      	cbnz	r0, 8004222 <iis3dwb_fifo_watermark_set+0x42>
    fifo_ctrl2.wtm = (uint8_t)(( 0x0100U & val ) >> 8);
 8004208:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800420c:	6826      	ldr	r6, [r4, #0]
 800420e:	68a0      	ldr	r0, [r4, #8]
    fifo_ctrl2.wtm = (uint8_t)(( 0x0100U & val ) >> 8);
 8004210:	0a2d      	lsrs	r5, r5, #8
 8004212:	f365 0300 	bfi	r3, r5, #0, #1
 8004216:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800421a:	aa01      	add	r2, sp, #4
 800421c:	2301      	movs	r3, #1
 800421e:	2108      	movs	r1, #8
 8004220:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_FIFO_CTRL2,
                              (uint8_t*)&fifo_ctrl2, 1);
  }
  return ret;
}
 8004222:	b002      	add	sp, #8
 8004224:	bd70      	pop	{r4, r5, r6, pc}
 8004226:	bf00      	nop

08004228 <iis3dwb_fifo_xl_batch_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_fifo_xl_batch_set(stmdev_ctx_t *ctx,
                                    iis3dwb_bdr_xl_t val)
{
 8004228:	b570      	push	{r4, r5, r6, lr}
 800422a:	b082      	sub	sp, #8
 800422c:	4604      	mov	r4, r0
 800422e:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8004230:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 8004234:	aa01      	add	r2, sp, #4
 8004236:	2301      	movs	r3, #1
 8004238:	2109      	movs	r1, #9
 800423a:	47b0      	blx	r6
  iis3dwb_fifo_ctrl3_t fifo_ctrl3;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_FIFO_CTRL3,
                           (uint8_t*)&fifo_ctrl3, 1);
  if(ret == 0){
 800423c:	b958      	cbnz	r0, 8004256 <iis3dwb_fifo_xl_batch_set+0x2e>
    fifo_ctrl3.bdr_xl= (uint8_t)val;
 800423e:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004242:	6826      	ldr	r6, [r4, #0]
 8004244:	68a0      	ldr	r0, [r4, #8]
    fifo_ctrl3.bdr_xl= (uint8_t)val;
 8004246:	f365 0303 	bfi	r3, r5, #0, #4
 800424a:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800424e:	aa01      	add	r2, sp, #4
 8004250:	2301      	movs	r3, #1
 8004252:	2109      	movs	r1, #9
 8004254:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_FIFO_CTRL3,
                              (uint8_t*)&fifo_ctrl3, 1);
  }
  return ret;
}
 8004256:	b002      	add	sp, #8
 8004258:	bd70      	pop	{r4, r5, r6, pc}
 800425a:	bf00      	nop

0800425c <iis3dwb_fifo_mode_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t iis3dwb_fifo_mode_set(stmdev_ctx_t *ctx,
                                iis3dwb_fifo_mode_t val)
{
 800425c:	b570      	push	{r4, r5, r6, lr}
 800425e:	b082      	sub	sp, #8
 8004260:	4604      	mov	r4, r0
 8004262:	460d      	mov	r5, r1
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8004264:	e9d0 6001 	ldrd	r6, r0, [r0, #4]
 8004268:	aa01      	add	r2, sp, #4
 800426a:	2301      	movs	r3, #1
 800426c:	210a      	movs	r1, #10
 800426e:	47b0      	blx	r6
  iis3dwb_fifo_ctrl4_t fifo_ctrl4;
  int32_t ret;

  ret = iis3dwb_read_reg(ctx, IIS3DWB_FIFO_CTRL4,
                           (uint8_t*)&fifo_ctrl4, 1);
  if(ret == 0){
 8004270:	b958      	cbnz	r0, 800428a <iis3dwb_fifo_mode_set+0x2e>
    fifo_ctrl4.fifo_mode= (uint8_t)val;
 8004272:	f89d 3004 	ldrb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004276:	6826      	ldr	r6, [r4, #0]
 8004278:	68a0      	ldr	r0, [r4, #8]
    fifo_ctrl4.fifo_mode= (uint8_t)val;
 800427a:	f365 0302 	bfi	r3, r5, #0, #3
 800427e:	f88d 3004 	strb.w	r3, [sp, #4]
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8004282:	aa01      	add	r2, sp, #4
 8004284:	2301      	movs	r3, #1
 8004286:	210a      	movs	r1, #10
 8004288:	47b0      	blx	r6
    ret = iis3dwb_write_reg(ctx, IIS3DWB_FIFO_CTRL4,
                              (uint8_t*)&fifo_ctrl4, 1);
  }
  return ret;
}
 800428a:	b002      	add	sp, #8
 800428c:	bd70      	pop	{r4, r5, r6, pc}
 800428e:	bf00      	nop

08004290 <BSP_ADC1_Initialization>:
* @param  ADC_InitFor who wants to Init the ADC: Audio or Battery Charger
* @retval BSP_ERROR_NONE in case of success
* @retval BSP_ERROR_PERIPH_FAILURE in case of failures
*/
int32_t BSP_ADC1_Initialization(ADC_InitUsedDef ADC_InitFor)
{
 8004290:	b570      	push	{r4, r5, r6, lr}
  /* If the ADC is not yet initialized */
  if(ADC_UsedFor == ADC1_NOT_USED){
 8004292:	4e1a      	ldr	r6, [pc, #104]	; (80042fc <BSP_ADC1_Initialization+0x6c>)
 8004294:	7833      	ldrb	r3, [r6, #0]
{
 8004296:	4605      	mov	r5, r0
  if(ADC_UsedFor == ADC1_NOT_USED){
 8004298:	b123      	cbz	r3, 80042a4 <BSP_ADC1_Initialization+0x14>
      return BSP_ERROR_PERIPH_FAILURE;
    } 
  }

  /* Set that we had Initiliazed the ADC for Audio or For Battery Charger */
  ADC_UsedFor |= ADC_InitFor;
 800429a:	ea45 0003 	orr.w	r0, r5, r3
 800429e:	7030      	strb	r0, [r6, #0]

  return BSP_ERROR_NONE;
 80042a0:	2000      	movs	r0, #0
}
 80042a2:	bd70      	pop	{r4, r5, r6, pc}
    ADC1_Handle.Instance = ADC1;
 80042a4:	4c16      	ldr	r4, [pc, #88]	; (8004300 <BSP_ADC1_Initialization+0x70>)
 80042a6:	4917      	ldr	r1, [pc, #92]	; (8004304 <BSP_ADC1_Initialization+0x74>)
    ADC1_Handle.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 80042a8:	6063      	str	r3, [r4, #4]
    ADC1_Handle.Init.LowPowerAutoWait = DISABLE;
 80042aa:	f44f 7280 	mov.w	r2, #256	; 0x100
    ADC1_Handle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80042ae:	e9c4 3302 	strd	r3, r3, [r4, #8]
    ADC1_Handle.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 80042b2:	e9c4 330a 	strd	r3, r3, [r4, #40]	; 0x28
    ADC1_Handle.Init.Oversampling.TriggeredMode         = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;         /* Specifies whether or not a trigger is needed for each sample */
 80042b6:	e9c4 3310 	strd	r3, r3, [r4, #64]	; 0x40
    ADC1_Handle.Init.ScanConvMode = (uint32_t)DISABLE;
 80042ba:	6123      	str	r3, [r4, #16]
    ADC1_Handle.Init.DiscontinuousConvMode = DISABLE;
 80042bc:	f884 3020 	strb.w	r3, [r4, #32]
    ADC1_Handle.Init.DMAContinuousRequests = DISABLE;
 80042c0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    ADC1_Handle.Init.OversamplingMode = DISABLE;
 80042c4:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    ADC1_Handle.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
 80042c8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    ADC1_Handle.Init.LowPowerAutoWait = DISABLE;
 80042cc:	8322      	strh	r2, [r4, #24]
    ADC1_Handle.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
 80042ce:	6363      	str	r3, [r4, #52]	; 0x34
    ADC1_Handle.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 80042d0:	2204      	movs	r2, #4
    ADC1_Handle.Init.NbrOfConversion = 1; 
 80042d2:	2301      	movs	r3, #1
    if(HAL_ADC_Init(&ADC1_Handle) != HAL_OK)
 80042d4:	4620      	mov	r0, r4
    ADC1_Handle.Instance = ADC1;
 80042d6:	6021      	str	r1, [r4, #0]
    ADC1_Handle.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 80042d8:	6162      	str	r2, [r4, #20]
    ADC1_Handle.Init.DFSDMConfig = ADC_DFSDM_MODE_ENABLE;
 80042da:	64e2      	str	r2, [r4, #76]	; 0x4c
    ADC1_Handle.Init.NbrOfConversion = 1; 
 80042dc:	61e3      	str	r3, [r4, #28]
    ADC1_Handle.Init.NbrOfDiscConversion      = 1;
 80042de:	6263      	str	r3, [r4, #36]	; 0x24
    ADC1_Handle.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE; /* Specifies whether or not the oversampling buffer is maintained during injection sequence */    
 80042e0:	64a3      	str	r3, [r4, #72]	; 0x48
    if(HAL_ADC_Init(&ADC1_Handle) != HAL_OK)
 80042e2:	f000 fca5 	bl	8004c30 <HAL_ADC_Init>
 80042e6:	b930      	cbnz	r0, 80042f6 <BSP_ADC1_Initialization+0x66>
    if (HAL_ADCEx_Calibration_Start(&ADC1_Handle, ADC_SINGLE_ENDED) != HAL_OK)
 80042e8:	4620      	mov	r0, r4
 80042ea:	217f      	movs	r1, #127	; 0x7f
 80042ec:	f000 ff08 	bl	8005100 <HAL_ADCEx_Calibration_Start>
 80042f0:	b908      	cbnz	r0, 80042f6 <BSP_ADC1_Initialization+0x66>
 80042f2:	7833      	ldrb	r3, [r6, #0]
 80042f4:	e7d1      	b.n	800429a <BSP_ADC1_Initialization+0xa>
      return BSP_ERROR_PERIPH_FAILURE;
 80042f6:	f06f 0003 	mvn.w	r0, #3
}
 80042fa:	bd70      	pop	{r4, r5, r6, pc}
 80042fc:	20001780 	.word	0x20001780
 8004300:	20019d74 	.word	0x20019d74
 8004304:	50040000 	.word	0x50040000

08004308 <HAL_ADC_MspInit>:
void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{ 
  UNUSED(hadc);
  /*##-1- Enable peripherals  ################################################*/
  /* ADC Periph clock enable */
  __HAL_RCC_ADC_CLK_ENABLE();
 8004308:	4b0a      	ldr	r3, [pc, #40]	; (8004334 <HAL_ADC_MspInit+0x2c>)
 800430a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800430c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8004310:	64da      	str	r2, [r3, #76]	; 0x4c
 8004312:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{ 
 8004314:	b082      	sub	sp, #8
  __HAL_RCC_ADC_CLK_ENABLE();
 8004316:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 800431a:	9201      	str	r2, [sp, #4]
 800431c:	9a01      	ldr	r2, [sp, #4]
  /* ADC Periph interface clock configuration */
  __HAL_RCC_ADC_CONFIG(RCC_ADCCLKSOURCE_PLLSAI1);
 800431e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8004322:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8004326:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800432a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
}
 800432e:	b002      	add	sp, #8
 8004330:	4770      	bx	lr
 8004332:	bf00      	nop
 8004334:	40021000 	.word	0x40021000

08004338 <BSP_PB_PWR_Init>:
*/
void BSP_PB_PWR_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  
  POWER_BUTTON_GPIO_CLK_ENABLE();
 8004338:	4b11      	ldr	r3, [pc, #68]	; (8004380 <BSP_PB_PWR_Init+0x48>)
  GPIO_InitStruct.Pin = POWER_BUTTON_PIN;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  
  HAL_GPIO_Init(POWER_BUTTON_GPIO_PORT, &GPIO_InitStruct);
 800433a:	4812      	ldr	r0, [pc, #72]	; (8004384 <BSP_PB_PWR_Init+0x4c>)
  POWER_BUTTON_GPIO_CLK_ENABLE();
 800433c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 800433e:	b570      	push	{r4, r5, r6, lr}
  POWER_BUTTON_GPIO_CLK_ENABLE();
 8004340:	f042 0208 	orr.w	r2, r2, #8
 8004344:	64da      	str	r2, [r3, #76]	; 0x4c
 8004346:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIO_InitStruct.Pin = POWER_BUTTON_PIN;
 8004348:	4d0f      	ldr	r5, [pc, #60]	; (8004388 <BSP_PB_PWR_Init+0x50>)
{
 800434a:	b088      	sub	sp, #32
  POWER_BUTTON_GPIO_CLK_ENABLE();
 800434c:	f003 0308 	and.w	r3, r3, #8
 8004350:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pin = POWER_BUTTON_PIN;
 8004352:	2202      	movs	r2, #2
 8004354:	2302      	movs	r3, #2
  HAL_GPIO_Init(POWER_BUTTON_GPIO_PORT, &GPIO_InitStruct);
 8004356:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = POWER_BUTTON_PIN;
 8004358:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800435c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8004360:	e9cd 4502 	strd	r4, r5, [sp, #8]
  POWER_BUTTON_GPIO_CLK_ENABLE();
 8004364:	9e01      	ldr	r6, [sp, #4]
  HAL_GPIO_Init(POWER_BUTTON_GPIO_PORT, &GPIO_InitStruct);
 8004366:	f001 fca3 	bl	8005cb0 <HAL_GPIO_Init>
  
  /* Enable and set Button EXTI Interrupt to the lowest priority */
  HAL_NVIC_SetPriority((IRQn_Type) POWER_BUTTON_EXTI_IRQn, 0x0F, 0x00);
 800436a:	2200      	movs	r2, #0
 800436c:	210f      	movs	r1, #15
 800436e:	2028      	movs	r0, #40	; 0x28
 8004370:	f001 faa8 	bl	80058c4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ((IRQn_Type) POWER_BUTTON_EXTI_IRQn);
 8004374:	2028      	movs	r0, #40	; 0x28
 8004376:	f001 fadd 	bl	8005934 <HAL_NVIC_EnableIRQ>
  
}
 800437a:	b008      	add	sp, #32
 800437c:	bd70      	pop	{r4, r5, r6, pc}
 800437e:	bf00      	nop
 8004380:	40021000 	.word	0x40021000
 8004384:	48000c00 	.word	0x48000c00
 8004388:	10110000 	.word	0x10110000

0800438c <BSP_PB_Init>:
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800438c:	4b18      	ldr	r3, [pc, #96]	; (80043f0 <BSP_PB_Init+0x64>)
{
 800438e:	b530      	push	{r4, r5, lr}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 8004390:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004392:	f042 0210 	orr.w	r2, r2, #16
 8004396:	64da      	str	r2, [r3, #76]	; 0x4c
 8004398:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 800439a:	b089      	sub	sp, #36	; 0x24
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800439c:	f003 0310 	and.w	r3, r3, #16
 80043a0:	9301      	str	r3, [sp, #4]
 80043a2:	9b01      	ldr	r3, [sp, #4]

  if (ButtonMode == BUTTON_MODE_GPIO)
 80043a4:	b971      	cbnz	r1, 80043c4 <BSP_PB_Init+0x38>
  {
    /* Configure Button pin as input */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80043a6:	2202      	movs	r2, #2
 80043a8:	2302      	movs	r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80043aa:	4812      	ldr	r0, [pc, #72]	; (80043f4 <BSP_PB_Init+0x68>)
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80043ac:	2401      	movs	r4, #1
 80043ae:	2500      	movs	r5, #0
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80043b0:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80043b2:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80043b6:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80043ba:	f001 fc79 	bl	8005cb0 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;  
}
 80043be:	2000      	movs	r0, #0
 80043c0:	b009      	add	sp, #36	; 0x24
 80043c2:	bd30      	pop	{r4, r5, pc}
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80043c4:	4b0c      	ldr	r3, [pc, #48]	; (80043f8 <BSP_PB_Init+0x6c>)
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80043c6:	480b      	ldr	r0, [pc, #44]	; (80043f4 <BSP_PB_Init+0x68>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80043c8:	2400      	movs	r4, #0
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80043ca:	2201      	movs	r2, #1
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80043cc:	a902      	add	r1, sp, #8
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80043ce:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80043d2:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80043d4:	f001 fc6c 	bl	8005cb0 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 80043d8:	4622      	mov	r2, r4
 80043da:	210f      	movs	r1, #15
 80043dc:	2006      	movs	r0, #6
 80043de:	f001 fa71 	bl	80058c4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 80043e2:	2006      	movs	r0, #6
 80043e4:	f001 faa6 	bl	8005934 <HAL_NVIC_EnableIRQ>
}
 80043e8:	2000      	movs	r0, #0
 80043ea:	b009      	add	sp, #36	; 0x24
 80043ec:	bd30      	pop	{r4, r5, pc}
 80043ee:	bf00      	nop
 80043f0:	40021000 	.word	0x40021000
 80043f4:	48001000 	.word	0x48001000
 80043f8:	10210000 	.word	0x10210000

080043fc <BSP_LED_Init>:
*          This parameter can be one of the following values:
*            @arg  LED1
* @retval None
*/
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 80043fc:	b510      	push	{r4, lr}
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* Enable the GPIO_LED clock */
  LEDx_GPIO_CLK_ENABLE((int8_t)Led);
 80043fe:	4b14      	ldr	r3, [pc, #80]	; (8004450 <BSP_LED_Init+0x54>)
{
 8004400:	b088      	sub	sp, #32
  LEDx_GPIO_CLK_ENABLE((int8_t)Led);
 8004402:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004404:	b9d0      	cbnz	r0, 800443c <BSP_LED_Init+0x40>
 8004406:	f042 0210 	orr.w	r2, r2, #16
 800440a:	64da      	str	r2, [r3, #76]	; 0x4c
 800440c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800440e:	f003 0310 	and.w	r3, r3, #16
 8004412:	9301      	str	r3, [sp, #4]
 8004414:	9b01      	ldr	r3, [sp, #4]
  
  /* Configure the GPIO_LED pin */
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 8004416:	4b0f      	ldr	r3, [pc, #60]	; (8004454 <BSP_LED_Init+0x58>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
  
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8004418:	eb03 0280 	add.w	r2, r3, r0, lsl #2
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 800441c:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
 8004420:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8004422:	6850      	ldr	r0, [r2, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004424:	2400      	movs	r4, #0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8004426:	2201      	movs	r2, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8004428:	2302      	movs	r3, #2
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 800442a:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800442c:	e9cd 2404 	strd	r2, r4, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8004430:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8004432:	f001 fc3d 	bl	8005cb0 <HAL_GPIO_Init>
  
  return BSP_ERROR_NONE;    
}
 8004436:	4620      	mov	r0, r4
 8004438:	b008      	add	sp, #32
 800443a:	bd10      	pop	{r4, pc}
  LEDx_GPIO_CLK_ENABLE((int8_t)Led);
 800443c:	f042 0208 	orr.w	r2, r2, #8
 8004440:	64da      	str	r2, [r3, #76]	; 0x4c
 8004442:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004444:	f003 0308 	and.w	r3, r3, #8
 8004448:	9302      	str	r3, [sp, #8]
 800444a:	9b02      	ldr	r3, [sp, #8]
 800444c:	e7e3      	b.n	8004416 <BSP_LED_Init+0x1a>
 800444e:	bf00      	nop
 8004450:	40021000 	.word	0x40021000
 8004454:	0801a118 	.word	0x0801a118

08004458 <BSP_LED_On>:
*            @arg  LED1
*            @arg  LED2
* @retval None
*/
int32_t BSP_LED_On(Led_TypeDef Led)
{
 8004458:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET);
 800445a:	4b05      	ldr	r3, [pc, #20]	; (8004470 <BSP_LED_On+0x18>)
 800445c:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8004460:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8004464:	6850      	ldr	r0, [r2, #4]
 8004466:	2201      	movs	r2, #1
 8004468:	f001 fd48 	bl	8005efc <HAL_GPIO_WritePin>
  return BSP_ERROR_NONE;    
}
 800446c:	2000      	movs	r0, #0
 800446e:	bd08      	pop	{r3, pc}
 8004470:	0801a118 	.word	0x0801a118

08004474 <BSP_LED_Off>:
*            @arg  LED1
*            @arg  LED2
* @retval None
*/
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 8004474:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET);
 8004476:	4b05      	ldr	r3, [pc, #20]	; (800448c <BSP_LED_Off+0x18>)
 8004478:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800447c:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8004480:	6850      	ldr	r0, [r2, #4]
 8004482:	2200      	movs	r2, #0
 8004484:	f001 fd3a 	bl	8005efc <HAL_GPIO_WritePin>
  return BSP_ERROR_NONE;    
}
 8004488:	2000      	movs	r0, #0
 800448a:	bd08      	pop	{r3, pc}
 800448c:	0801a118 	.word	0x0801a118

08004490 <BSP_BC_CmdSend>:
  * @param stbc02_SwCmd The command to be sent
  * @retval 0 in case of success
  * @retval 1 in case of failure
  */
int32_t BSP_BC_CmdSend(stbc02_SwCmd_TypeDef stbc02_SwCmd)
{
 8004490:	b570      	push	{r4, r5, r6, lr}
 8004492:	4604      	mov	r4, r0
  uint32_t tk = STBC02_GetTick();
 8004494:	f000 fba4 	bl	8004be0 <HAL_GetTick>
  
  stbc02_SwCmdSel = stbc02_SwCmd;
 8004498:	4d0d      	ldr	r5, [pc, #52]	; (80044d0 <BSP_BC_CmdSend+0x40>)
  uint32_t tk = STBC02_GetTick();
 800449a:	4606      	mov	r6, r0
  stbc02_SwState = start;
 800449c:	2301      	movs	r3, #1
  
  /* Start the time base */
  (void)HAL_TIM_Base_Start_IT(&hstbc02_UsedTim);
 800449e:	480d      	ldr	r0, [pc, #52]	; (80044d4 <BSP_BC_CmdSend+0x44>)
  stbc02_SwCmdSel = stbc02_SwCmd;
 80044a0:	f885 4040 	strb.w	r4, [r5, #64]	; 0x40
  stbc02_SwState = start;
 80044a4:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
  (void)HAL_TIM_Base_Start_IT(&hstbc02_UsedTim);
 80044a8:	f005 fc78 	bl	8009d9c <HAL_TIM_Base_Start_IT>
    
  while(stbc02_SwState != idle)
 80044ac:	e004      	b.n	80044b8 <BSP_BC_CmdSend+0x28>
  {
    if ( (STBC02_GetTick() - tk) > 10U )
 80044ae:	f000 fb97 	bl	8004be0 <HAL_GetTick>
 80044b2:	1b80      	subs	r0, r0, r6
 80044b4:	280a      	cmp	r0, #10
 80044b6:	d808      	bhi.n	80044ca <BSP_BC_CmdSend+0x3a>
  while(stbc02_SwState != idle)
 80044b8:	f895 4041 	ldrb.w	r4, [r5, #65]	; 0x41
 80044bc:	2c00      	cmp	r4, #0
 80044be:	d1f6      	bne.n	80044ae <BSP_BC_CmdSend+0x1e>
    {
      return 1;
    }
  }
    /* Stop the time base */
  (void)HAL_TIM_Base_Stop_IT(&hstbc02_UsedTim);
 80044c0:	4804      	ldr	r0, [pc, #16]	; (80044d4 <BSP_BC_CmdSend+0x44>)
 80044c2:	f005 fc81 	bl	8009dc8 <HAL_TIM_Base_Stop_IT>
  
  return 0;
 80044c6:	4620      	mov	r0, r4
}
 80044c8:	bd70      	pop	{r4, r5, r6, pc}
      return 1;
 80044ca:	2001      	movs	r0, #1
}
 80044cc:	bd70      	pop	{r4, r5, r6, pc}
 80044ce:	bf00      	nop
 80044d0:	20001814 	.word	0x20001814
 80044d4:	20019e08 	.word	0x20019e08

080044d8 <BSP_BC_BatMS_Init>:
* @param  None
* @retval BSP_ERROR_NONE in case of success
* @retval BSP_ERROR_COMPONENT_FAILURE in case of failures
*/
int32_t BSP_BC_BatMS_Init(void)
{
 80044d8:	b530      	push	{r4, r5, lr}
   /* Enable ADC1 if it's necessary */
  (void)BSP_ADC1_Initialization(ADC1_FOR_BC);
 80044da:	2002      	movs	r0, #2
{
 80044dc:	b097      	sub	sp, #92	; 0x5c
  (void)BSP_ADC1_Initialization(ADC1_FOR_BC);
 80044de:	f7ff fed7 	bl	8004290 <BSP_ADC1_Initialization>
  * @retval 0 in case of success
  * @retval 1 in case of failure
*/
static int32_t Channel_ADC1_Init(void)
{
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 80044e2:	2234      	movs	r2, #52	; 0x34
 80044e4:	2100      	movs	r1, #0
 80044e6:	a808      	add	r0, sp, #32
 80044e8:	f011 fd52 	bl	8015f90 <memset>
  static uint8_t ADC_stopped=0;
  uint32_t ADC_Status;
  
  
  ADC_Status= HAL_ADC_GetState(&ADC1_Handle);
 80044ec:	4827      	ldr	r0, [pc, #156]	; (800458c <BSP_BC_BatMS_Init+0xb4>)
 80044ee:	f000 fcad 	bl	8004e4c <HAL_ADC_GetState>
  if ((ADC_Status & HAL_ADC_STATE_REG_BUSY) == HAL_ADC_STATE_REG_BUSY)
 80044f2:	05c3      	lsls	r3, r0, #23
 80044f4:	d43c      	bmi.n	8004570 <BSP_BC_BatMS_Init+0x98>
 80044f6:	4c26      	ldr	r4, [pc, #152]	; (8004590 <BSP_BC_BatMS_Init+0xb8>)
    ADC_stopped=1;
  }

    
  /* Configure ADC injected channel */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_13;
 80044f8:	4826      	ldr	r0, [pc, #152]	; (8004594 <BSP_BC_BatMS_Init+0xbc>)
 80044fa:	2108      	movs	r1, #8
 80044fc:	2207      	movs	r2, #7
 80044fe:	237f      	movs	r3, #127	; 0x7f
 8004500:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8004504:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 8004508:	2004      	movs	r0, #4
 800450a:	2100      	movs	r1, #0
  sConfigInjected.InjectedOffset = 0;
  sConfigInjected.InjectedNbrOfConversion = 1;
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
  sConfigInjected.AutoInjectedConv = DISABLE;
  sConfigInjected.QueueInjectedContext = DISABLE;
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 800450c:	2200      	movs	r2, #0
 800450e:	2300      	movs	r3, #0
  sConfigInjected.InjectedChannel = ADC_CHANNEL_13;
 8004510:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 8004514:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
  STBC02_BATMS_GPIO_CLK_ENABLE();
 8004518:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 800451c:	2300      	movs	r3, #0
  STBC02_BATMS_GPIO_CLK_ENABLE();
 800451e:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
  sConfigInjected.InjectedNbrOfConversion = 1;
 8004522:	2101      	movs	r1, #1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004524:	9306      	str	r3, [sp, #24]
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 8004526:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
  sConfigInjected.QueueInjectedContext = DISABLE;
 800452a:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_NONE;
  sConfigInjected.InjecOversamplingMode = DISABLE; 
 800452e:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004532:	9305      	str	r3, [sp, #20]
  sConfigInjected.InjectedNbrOfConversion = 1;
 8004534:	910e      	str	r1, [sp, #56]	; 0x38
  STBC02_BATMS_GPIO_CLK_ENABLE();
 8004536:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
  HAL_GPIO_Init(STBC02_BATMS_GPIO_PORT, &GPIO_InitStruct);
 8004538:	4817      	ldr	r0, [pc, #92]	; (8004598 <BSP_BC_BatMS_Init+0xc0>)
  STBC02_BATMS_GPIO_CLK_ENABLE();
 800453a:	f041 0104 	orr.w	r1, r1, #4
 800453e:	64d1      	str	r1, [r2, #76]	; 0x4c
 8004540:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004542:	9304      	str	r3, [sp, #16]
  STBC02_BATMS_GPIO_CLK_ENABLE();
 8004544:	f002 0204 	and.w	r2, r2, #4
  GPIO_InitStruct.Pin = STBC02_BATMS_PIN;
 8004548:	230b      	movs	r3, #11
  STBC02_BATMS_GPIO_CLK_ENABLE();
 800454a:	9201      	str	r2, [sp, #4]
  HAL_GPIO_Init(STBC02_BATMS_GPIO_PORT, &GPIO_InitStruct);
 800454c:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = STBC02_BATMS_PIN;
 800454e:	2210      	movs	r2, #16
 8004550:	e9cd 2302 	strd	r2, r3, [sp, #8]
  STBC02_BATMS_GPIO_CLK_ENABLE();
 8004554:	9d01      	ldr	r5, [sp, #4]
  HAL_GPIO_Init(STBC02_BATMS_GPIO_PORT, &GPIO_InitStruct);
 8004556:	f001 fbab 	bl	8005cb0 <HAL_GPIO_Init>
  
  HAL_ADC_BC_MspInit();
  
  
  (void)HAL_ADCEx_InjectedConfigChannel(&ADC1_Handle, &sConfigInjected);
 800455a:	480c      	ldr	r0, [pc, #48]	; (800458c <BSP_BC_BatMS_Init+0xb4>)
 800455c:	a908      	add	r1, sp, #32
 800455e:	f000 fee9 	bl	8005334 <HAL_ADCEx_InjectedConfigChannel>
    
  if (ADC_stopped == 1U)
 8004562:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
 8004566:	2b01      	cmp	r3, #1
 8004568:	d00a      	beq.n	8004580 <BSP_BC_BatMS_Init+0xa8>
}
 800456a:	2000      	movs	r0, #0
 800456c:	b017      	add	sp, #92	; 0x5c
 800456e:	bd30      	pop	{r4, r5, pc}
    (void)HAL_ADC_Stop(&ADC1_Handle);
 8004570:	4806      	ldr	r0, [pc, #24]	; (800458c <BSP_BC_BatMS_Init+0xb4>)
    ADC_stopped=1;
 8004572:	4c07      	ldr	r4, [pc, #28]	; (8004590 <BSP_BC_BatMS_Init+0xb8>)
    (void)HAL_ADC_Stop(&ADC1_Handle);
 8004574:	f000 fda0 	bl	80050b8 <HAL_ADC_Stop>
    ADC_stopped=1;
 8004578:	2301      	movs	r3, #1
 800457a:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
 800457e:	e7bb      	b.n	80044f8 <BSP_BC_BatMS_Init+0x20>
  {
    (void)HAL_ADC_Start(&ADC1_Handle);
 8004580:	4802      	ldr	r0, [pc, #8]	; (800458c <BSP_BC_BatMS_Init+0xb4>)
 8004582:	f000 fd25 	bl	8004fd0 <HAL_ADC_Start>
}
 8004586:	2000      	movs	r0, #0
 8004588:	b017      	add	sp, #92	; 0x5c
 800458a:	bd30      	pop	{r4, r5, pc}
 800458c:	20019d74 	.word	0x20019d74
 8004590:	20001814 	.word	0x20001814
 8004594:	36902000 	.word	0x36902000
 8004598:	48000800 	.word	0x48000800

0800459c <BSP_BC_GetVoltageAndLevel>:
{
 800459c:	b538      	push	{r3, r4, r5, lr}
 800459e:	4604      	mov	r4, r0
  if (HAL_ADCEx_InjectedStart(&ADC1_Handle) != HAL_OK)
 80045a0:	4842      	ldr	r0, [pc, #264]	; (80046ac <BSP_BC_GetVoltageAndLevel+0x110>)
{
 80045a2:	460d      	mov	r5, r1
  if (HAL_ADCEx_InjectedStart(&ADC1_Handle) != HAL_OK)
 80045a4:	f000 fdf8 	bl	8005198 <HAL_ADCEx_InjectedStart>
 80045a8:	2800      	cmp	r0, #0
 80045aa:	d17c      	bne.n	80046a6 <BSP_BC_GetVoltageAndLevel+0x10a>
  if (HAL_ADCEx_InjectedPollForConversion(&ADC1_Handle, 10) != HAL_OK)
 80045ac:	483f      	ldr	r0, [pc, #252]	; (80046ac <BSP_BC_GetVoltageAndLevel+0x110>)
 80045ae:	210a      	movs	r1, #10
 80045b0:	f000 fe38 	bl	8005224 <HAL_ADCEx_InjectedPollForConversion>
 80045b4:	2800      	cmp	r0, #0
 80045b6:	d176      	bne.n	80046a6 <BSP_BC_GetVoltageAndLevel+0x10a>
  if ((HAL_ADC_GetState(&ADC1_Handle) & HAL_ADC_STATE_INJ_EOC) == HAL_ADC_STATE_INJ_EOC)
 80045b8:	483c      	ldr	r0, [pc, #240]	; (80046ac <BSP_BC_GetVoltageAndLevel+0x110>)
 80045ba:	f000 fc47 	bl	8004e4c <HAL_ADC_GetState>
 80045be:	0483      	lsls	r3, r0, #18
 80045c0:	d467      	bmi.n	8004692 <BSP_BC_GetVoltageAndLevel+0xf6>
 80045c2:	4a3b      	ldr	r2, [pc, #236]	; (80046b0 <BSP_BC_GetVoltageAndLevel+0x114>)
  Voltage = (2700U * (uint32_t)uhADCxConvertedValue) / (4095U);  // [0-2.7V]
 80045c4:	6d90      	ldr	r0, [r2, #88]	; 0x58
 80045c6:	4b3b      	ldr	r3, [pc, #236]	; (80046b4 <BSP_BC_GetVoltageAndLevel+0x118>)
 80045c8:	f640 218c 	movw	r1, #2700	; 0xa8c
 80045cc:	fb01 f100 	mul.w	r1, r1, r0
 80045d0:	fba3 0301 	umull	r0, r3, r3, r1
 80045d4:	1ac9      	subs	r1, r1, r3
 80045d6:	eb03 0351 	add.w	r3, r3, r1, lsr #1
 80045da:	0ad9      	lsrs	r1, r3, #11
  Voltage = ((56U+100U)*Voltage)/100U;   // [0-4.2V]
 80045dc:	4836      	ldr	r0, [pc, #216]	; (80046b8 <BSP_BC_GetVoltageAndLevel+0x11c>)
 80045de:	239c      	movs	r3, #156	; 0x9c
 80045e0:	fb03 f301 	mul.w	r3, r3, r1
 80045e4:	fba0 1303 	umull	r1, r3, r0, r3
 80045e8:	095b      	lsrs	r3, r3, #5
  WindowVoltage[WindowPostion]= Voltage;
 80045ea:	6dd1      	ldr	r1, [r2, #92]	; 0x5c
 80045ec:	eb02 0081 	add.w	r0, r2, r1, lsl #2
  WindowPostion++;  
 80045f0:	3101      	adds	r1, #1
  if(WindowPostion==WINDOW_VOLTAGE_DIM)
 80045f2:	2910      	cmp	r1, #16
  WindowPostion++;  
 80045f4:	65d1      	str	r1, [r2, #92]	; 0x5c
  WindowVoltage[WindowPostion]= Voltage;
 80045f6:	6603      	str	r3, [r0, #96]	; 0x60
    if(VoltageWindowInit==0)
 80045f8:	f8d2 10a0 	ldr.w	r1, [r2, #160]	; 0xa0
  if(WindowPostion==WINDOW_VOLTAGE_DIM)
 80045fc:	d01d      	beq.n	800463a <BSP_BC_GetVoltageAndLevel+0x9e>
  if(VoltageWindowInit == 1)
 80045fe:	2901      	cmp	r1, #1
 8004600:	d020      	beq.n	8004644 <BSP_BC_GetVoltageAndLevel+0xa8>
  if(Voltage > (uint32_t)MAX_VOLTAGE) 
 8004602:	f640 42b2 	movw	r2, #3250	; 0xcb2
 8004606:	4293      	cmp	r3, r2
 8004608:	bf38      	it	cc
 800460a:	4613      	movcc	r3, r2
 800460c:	f241 0281 	movw	r2, #4225	; 0x1081
 8004610:	4293      	cmp	r3, r2
 8004612:	bf28      	it	cs
 8004614:	4613      	movcs	r3, r2
  *BatteryLevel= (((Voltage - (uint32_t)MIN_VOLTAGE) * 100U)/(uint32_t)(MAX_VOLTAGE - MIN_VOLTAGE));
 8004616:	2264      	movs	r2, #100	; 0x64
 8004618:	fb02 f203 	mul.w	r2, r2, r3
 800461c:	4927      	ldr	r1, [pc, #156]	; (80046bc <BSP_BC_GetVoltageAndLevel+0x120>)
 800461e:	f5a2 229e 	sub.w	r2, r2, #323584	; 0x4f000
 8004622:	f5a2 62b1 	sub.w	r2, r2, #1416	; 0x588
 8004626:	fba1 0102 	umull	r0, r1, r1, r2
 800462a:	1a52      	subs	r2, r2, r1
 800462c:	eb01 0252 	add.w	r2, r1, r2, lsr #1
 8004630:	0a52      	lsrs	r2, r2, #9
 8004632:	602a      	str	r2, [r5, #0]
}
 8004634:	2000      	movs	r0, #0
  *mV = Voltage;
 8004636:	6023      	str	r3, [r4, #0]
}
 8004638:	bd38      	pop	{r3, r4, r5, pc}
    if(VoltageWindowInit==0)
 800463a:	bb89      	cbnz	r1, 80046a0 <BSP_BC_GetVoltageAndLevel+0x104>
      VoltageWindowInit =1;
 800463c:	2301      	movs	r3, #1
    WindowPostion     =0;
 800463e:	65d1      	str	r1, [r2, #92]	; 0x5c
      VoltageWindowInit =1;
 8004640:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
      Voltage+=WindowVoltage[Counter];
 8004644:	e9d2 0318 	ldrd	r0, r3, [r2, #96]	; 0x60
 8004648:	6e91      	ldr	r1, [r2, #104]	; 0x68
 800464a:	4403      	add	r3, r0
 800464c:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800464e:	440b      	add	r3, r1
 8004650:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8004652:	4403      	add	r3, r0
 8004654:	6f50      	ldr	r0, [r2, #116]	; 0x74
 8004656:	440b      	add	r3, r1
 8004658:	6f91      	ldr	r1, [r2, #120]	; 0x78
 800465a:	4403      	add	r3, r0
 800465c:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 800465e:	440b      	add	r3, r1
 8004660:	f8d2 1080 	ldr.w	r1, [r2, #128]	; 0x80
 8004664:	4403      	add	r3, r0
 8004666:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
 800466a:	440b      	add	r3, r1
 800466c:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 8004670:	4403      	add	r3, r0
 8004672:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
 8004676:	440b      	add	r3, r1
 8004678:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 800467c:	4403      	add	r3, r0
 800467e:	440b      	add	r3, r1
 8004680:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
 8004684:	e9d2 1226 	ldrd	r1, r2, [r2, #152]	; 0x98
 8004688:	4403      	add	r3, r0
 800468a:	440b      	add	r3, r1
 800468c:	4413      	add	r3, r2
    Voltage>>=4;    
 800468e:	091b      	lsrs	r3, r3, #4
 8004690:	e7b7      	b.n	8004602 <BSP_BC_GetVoltageAndLevel+0x66>
    uhADCxConvertedValue = HAL_ADCEx_InjectedGetValue(&ADC1_Handle,ADC_INJECTED_RANK_1);
 8004692:	4806      	ldr	r0, [pc, #24]	; (80046ac <BSP_BC_GetVoltageAndLevel+0x110>)
 8004694:	2108      	movs	r1, #8
 8004696:	f000 fe29 	bl	80052ec <HAL_ADCEx_InjectedGetValue>
 800469a:	4a05      	ldr	r2, [pc, #20]	; (80046b0 <BSP_BC_GetVoltageAndLevel+0x114>)
 800469c:	6590      	str	r0, [r2, #88]	; 0x58
 800469e:	e791      	b.n	80045c4 <BSP_BC_GetVoltageAndLevel+0x28>
    WindowPostion     =0;
 80046a0:	2000      	movs	r0, #0
 80046a2:	65d0      	str	r0, [r2, #92]	; 0x5c
 80046a4:	e7ab      	b.n	80045fe <BSP_BC_GetVoltageAndLevel+0x62>
 80046a6:	4a02      	ldr	r2, [pc, #8]	; (80046b0 <BSP_BC_GetVoltageAndLevel+0x114>)
  uint32_t Voltage = 0;
 80046a8:	2300      	movs	r3, #0
 80046aa:	e79e      	b.n	80045ea <BSP_BC_GetVoltageAndLevel+0x4e>
 80046ac:	20019d74 	.word	0x20019d74
 80046b0:	20001814 	.word	0x20001814
 80046b4:	00100101 	.word	0x00100101
 80046b8:	51eb851f 	.word	0x51eb851f
 80046bc:	0cdd9aa7 	.word	0x0cdd9aa7

080046c0 <BC_TIMx_Init>:
{
 80046c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80046c4:	b084      	sub	sp, #16
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80046c6:	2300      	movs	r3, #0
 80046c8:	e9cd 3301 	strd	r3, r3, [sp, #4]
 80046cc:	9303      	str	r3, [sp, #12]
  uint32_t freq = STBC02_USED_TIM_CLKFreq;
 80046ce:	f003 f8a3 	bl	8007818 <HAL_RCC_GetPCLK1Freq>
 80046d2:	4b23      	ldr	r3, [pc, #140]	; (8004760 <BC_TIMx_Init+0xa0>)
 80046d4:	689b      	ldr	r3, [r3, #8]
    period = (uint32_t)(freq/(prescaler) * STBC02_USED_TIM_PERIOD);
 80046d6:	a720      	add	r7, pc, #128	; (adr r7, 8004758 <BC_TIMx_Init+0x98>)
 80046d8:	e9d7 6700 	ldrd	r6, r7, [r7]
  uint32_t freq = STBC02_USED_TIM_CLKFreq;
 80046dc:	055b      	lsls	r3, r3, #21
 80046de:	4605      	mov	r5, r0
  uint32_t prescaler = 0;
 80046e0:	f04f 0400 	mov.w	r4, #0
 80046e4:	bf48      	it	mi
 80046e6:	0045      	lslmi	r5, r0, #1
    prescaler++;
 80046e8:	46a0      	mov	r8, r4
 80046ea:	3401      	adds	r4, #1
    period = (uint32_t)(freq/(prescaler) * STBC02_USED_TIM_PERIOD);
 80046ec:	fbb5 f0f4 	udiv	r0, r5, r4
 80046f0:	f7fb ff30 	bl	8000554 <__aeabi_ui2d>
 80046f4:	4632      	mov	r2, r6
 80046f6:	463b      	mov	r3, r7
 80046f8:	f7fb ffa6 	bl	8000648 <__aeabi_dmul>
 80046fc:	f7fc fa7c 	bl	8000bf8 <__aeabi_d2uiz>
  } while (period > 65535U);
 8004700:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8004704:	d2f0      	bcs.n	80046e8 <BC_TIMx_Init+0x28>
  hstbc02_UsedTim.Instance = STBC02_USED_TIM;
 8004706:	4c17      	ldr	r4, [pc, #92]	; (8004764 <BC_TIMx_Init+0xa4>)
    STBC02_USED_TIM_CLK_ENABLE();
 8004708:	4b15      	ldr	r3, [pc, #84]	; (8004760 <BC_TIMx_Init+0xa0>)
  hstbc02_UsedTim.Instance = STBC02_USED_TIM;
 800470a:	4a17      	ldr	r2, [pc, #92]	; (8004768 <BC_TIMx_Init+0xa8>)
 800470c:	6022      	str	r2, [r4, #0]
    STBC02_USED_TIM_CLK_ENABLE();
 800470e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  hstbc02_UsedTim.Init.Prescaler = (prescaler-1U);
 8004710:	f8c4 8004 	str.w	r8, [r4, #4]
    STBC02_USED_TIM_CLK_ENABLE();
 8004714:	f042 0220 	orr.w	r2, r2, #32
 8004718:	659a      	str	r2, [r3, #88]	; 0x58
 800471a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  hstbc02_UsedTim.Init.Period = period;
 800471c:	60e0      	str	r0, [r4, #12]
  hstbc02_UsedTim.Init.CounterMode = TIM_COUNTERMODE_UP;
 800471e:	2500      	movs	r5, #0
    STBC02_USED_TIM_CLK_ENABLE();
 8004720:	f003 0320 	and.w	r3, r3, #32
    HAL_NVIC_SetPriority(STBC02_USED_TIM_IRQn, STBC02_USED_TIM_IRQ_PP, STBC02_USED_TIM_IRQ_SP);
 8004724:	462a      	mov	r2, r5
 8004726:	2103      	movs	r1, #3
    STBC02_USED_TIM_CLK_ENABLE();
 8004728:	9300      	str	r3, [sp, #0]
    HAL_NVIC_SetPriority(STBC02_USED_TIM_IRQn, STBC02_USED_TIM_IRQ_PP, STBC02_USED_TIM_IRQ_SP);
 800472a:	2037      	movs	r0, #55	; 0x37
    STBC02_USED_TIM_CLK_ENABLE();
 800472c:	9b00      	ldr	r3, [sp, #0]
  hstbc02_UsedTim.Init.CounterMode = TIM_COUNTERMODE_UP;
 800472e:	60a5      	str	r5, [r4, #8]
    HAL_NVIC_SetPriority(STBC02_USED_TIM_IRQn, STBC02_USED_TIM_IRQ_PP, STBC02_USED_TIM_IRQ_SP);
 8004730:	f001 f8c8 	bl	80058c4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(STBC02_USED_TIM_IRQn);
 8004734:	2037      	movs	r0, #55	; 0x37
 8004736:	f001 f8fd 	bl	8005934 <HAL_NVIC_EnableIRQ>
  (void)HAL_TIM_Base_Init(&hstbc02_UsedTim);
 800473a:	4620      	mov	r0, r4
 800473c:	f005 fa8c 	bl	8009c58 <HAL_TIM_Base_Init>
  (void)HAL_TIMEx_MasterConfigSynchronization(&hstbc02_UsedTim, &sMasterConfig);
 8004740:	4620      	mov	r0, r4
 8004742:	a901      	add	r1, sp, #4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8004744:	9501      	str	r5, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8004746:	9503      	str	r5, [sp, #12]
  (void)HAL_TIMEx_MasterConfigSynchronization(&hstbc02_UsedTim, &sMasterConfig);
 8004748:	f005 fc12 	bl	8009f70 <HAL_TIMEx_MasterConfigSynchronization>
}
 800474c:	b004      	add	sp, #16
 800474e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004752:	bf00      	nop
 8004754:	f3af 8000 	nop.w
 8004758:	88e368f1 	.word	0x88e368f1
 800475c:	3ed4f8b5 	.word	0x3ed4f8b5
 8004760:	40021000 	.word	0x40021000
 8004764:	20019e08 	.word	0x20019e08
 8004768:	40001400 	.word	0x40001400

0800476c <BSP_BC_Init>:
{
 800476c:	b530      	push	{r4, r5, lr}
 800476e:	b089      	sub	sp, #36	; 0x24
  BC_TIMx_Init();
 8004770:	f7ff ffa6 	bl	80046c0 <BC_TIMx_Init>
  STBC02_SW_SEL_GPIO_CLK_ENABLE();
 8004774:	4b0e      	ldr	r3, [pc, #56]	; (80047b0 <BSP_BC_Init+0x44>)
  HAL_GPIO_WritePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN, GPIO_PIN_RESET);
 8004776:	480f      	ldr	r0, [pc, #60]	; (80047b4 <BSP_BC_Init+0x48>)
  STBC02_SW_SEL_GPIO_CLK_ENABLE();
 8004778:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800477a:	f042 0220 	orr.w	r2, r2, #32
 800477e:	64da      	str	r2, [r3, #76]	; 0x4c
 8004780:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIO_InitStruct.Pin = STBC02_SW_SEL_PIN;
 8004782:	2440      	movs	r4, #64	; 0x40
  STBC02_SW_SEL_GPIO_CLK_ENABLE();
 8004784:	f003 0320 	and.w	r3, r3, #32
  GPIO_InitStruct.Pin = STBC02_SW_SEL_PIN;
 8004788:	2501      	movs	r5, #1
 800478a:	e9cd 4502 	strd	r4, r5, [sp, #8]
  STBC02_SW_SEL_GPIO_CLK_ENABLE();
 800478e:	9301      	str	r3, [sp, #4]
  HAL_GPIO_WritePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN, GPIO_PIN_RESET);
 8004790:	2200      	movs	r2, #0
 8004792:	2140      	movs	r1, #64	; 0x40
  GPIO_InitStruct.Pin = STBC02_SW_SEL_PIN;
 8004794:	2400      	movs	r4, #0
 8004796:	2502      	movs	r5, #2
  STBC02_SW_SEL_GPIO_CLK_ENABLE();
 8004798:	9b01      	ldr	r3, [sp, #4]
  GPIO_InitStruct.Pin = STBC02_SW_SEL_PIN;
 800479a:	e9cd 4504 	strd	r4, r5, [sp, #16]
  HAL_GPIO_WritePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN, GPIO_PIN_RESET);
 800479e:	f001 fbad 	bl	8005efc <HAL_GPIO_WritePin>
  HAL_GPIO_Init(STBC02_SW_SEL_GPIO_PORT, &GPIO_InitStruct);
 80047a2:	4804      	ldr	r0, [pc, #16]	; (80047b4 <BSP_BC_Init+0x48>)
 80047a4:	a902      	add	r1, sp, #8
 80047a6:	f001 fa83 	bl	8005cb0 <HAL_GPIO_Init>
}
 80047aa:	b009      	add	sp, #36	; 0x24
 80047ac:	bd30      	pop	{r4, r5, pc}
 80047ae:	bf00      	nop
 80047b0:	40021000 	.word	0x40021000
 80047b4:	48001400 	.word	0x48001400

080047b8 <HAL_TIM_PeriodElapsedCallback>:
  * @param  htim TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == STBC02_USED_TIM)
 80047b8:	4b3b      	ldr	r3, [pc, #236]	; (80048a8 <HAL_TIM_PeriodElapsedCallback+0xf0>)
 80047ba:	6802      	ldr	r2, [r0, #0]
 80047bc:	429a      	cmp	r2, r3
 80047be:	d000      	beq.n	80047c2 <HAL_TIM_PeriodElapsedCallback+0xa>
 80047c0:	4770      	bx	lr
{
 80047c2:	b510      	push	{r4, lr}
  TIMx_Pulse++;
 80047c4:	4c39      	ldr	r4, [pc, #228]	; (80048ac <HAL_TIM_PeriodElapsedCallback+0xf4>)
 80047c6:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
 80047ca:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80047ce:	3301      	adds	r3, #1
 80047d0:	b29b      	uxth	r3, r3
 80047d2:	3a01      	subs	r2, #1
 80047d4:	f8a4 30a4 	strh.w	r3, [r4, #164]	; 0xa4
  switch (stbc02_SwState)
 80047d8:	2a05      	cmp	r2, #5
 80047da:	d814      	bhi.n	8004806 <HAL_TIM_PeriodElapsedCallback+0x4e>
 80047dc:	e8df f002 	tbb	[pc, r2]
 80047e0:	03030335 	.word	0x03030335
 80047e4:	1424      	.short	0x1424
    HAL_GPIO_TogglePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN);
 80047e6:	4832      	ldr	r0, [pc, #200]	; (80048b0 <HAL_TIM_PeriodElapsedCallback+0xf8>)
 80047e8:	2140      	movs	r1, #64	; 0x40
 80047ea:	f001 fb8d 	bl	8005f08 <HAL_GPIO_TogglePin>
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(100/5);
 80047ee:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
    stbc02_sw_state_prv = stbc02_SwState;
 80047f2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80047f6:	f884 20a8 	strb.w	r2, [r4, #168]	; 0xa8
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(100/5);
 80047fa:	3314      	adds	r3, #20
    stbc02_SwState = wait;
 80047fc:	2206      	movs	r2, #6
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(100/5);
 80047fe:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
    stbc02_SwState = wait;
 8004802:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
  {
    BC_CmdMng();
  }
}
 8004806:	bd10      	pop	{r4, pc}
    if ( TIMx_Pulse > TIMx_PulseTCS )
 8004808:	f8b4 20a6 	ldrh.w	r2, [r4, #166]	; 0xa6
 800480c:	429a      	cmp	r2, r3
 800480e:	d2fa      	bcs.n	8004806 <HAL_TIM_PeriodElapsedCallback+0x4e>
      if ( stbc02_sw_state_prv == stop_h )
 8004810:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
 8004814:	2b05      	cmp	r3, #5
 8004816:	d038      	beq.n	800488a <HAL_TIM_PeriodElapsedCallback+0xd2>
        if ( stbc02_sw_state_prv == pulse_h )
 8004818:	2b03      	cmp	r3, #3
 800481a:	d027      	beq.n	800486c <HAL_TIM_PeriodElapsedCallback+0xb4>
 800481c:	3301      	adds	r3, #1
 800481e:	b2db      	uxtb	r3, r3
        stbc02_SwState = (stbc02_SwState_TypeDef)(stbc02_sw_state_prv + 1);
 8004820:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        __NOP();
 8004824:	bf00      	nop
}
 8004826:	bd10      	pop	{r4, pc}
    HAL_GPIO_TogglePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN);
 8004828:	4821      	ldr	r0, [pc, #132]	; (80048b0 <HAL_TIM_PeriodElapsedCallback+0xf8>)
 800482a:	2140      	movs	r1, #64	; 0x40
 800482c:	f001 fb6c 	bl	8005f08 <HAL_GPIO_TogglePin>
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(500/5);
 8004830:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
    stbc02_sw_state_prv = stbc02_SwState;
 8004834:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8004838:	f884 20a8 	strb.w	r2, [r4, #168]	; 0xa8
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(500/5);
 800483c:	3364      	adds	r3, #100	; 0x64
    stbc02_SwState = wait;
 800483e:	2206      	movs	r2, #6
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(500/5);
 8004840:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
    stbc02_SwState = wait;
 8004844:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
}
 8004848:	bd10      	pop	{r4, pc}
    HAL_GPIO_TogglePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN);
 800484a:	4819      	ldr	r0, [pc, #100]	; (80048b0 <HAL_TIM_PeriodElapsedCallback+0xf8>)
 800484c:	2140      	movs	r1, #64	; 0x40
 800484e:	f001 fb5b 	bl	8005f08 <HAL_GPIO_TogglePin>
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(350/5);
 8004852:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	; 0xa4
    stbc02_sw_state_prv = stbc02_SwState;
 8004856:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 800485a:	f884 20a8 	strb.w	r2, [r4, #168]	; 0xa8
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(350/5);
 800485e:	3346      	adds	r3, #70	; 0x46
    stbc02_SwState = wait;
 8004860:	2206      	movs	r2, #6
    TIMx_PulseTCS = TIMx_Pulse + (uint16_t)(350/5);
 8004862:	f8a4 30a6 	strh.w	r3, [r4, #166]	; 0xa6
    stbc02_SwState = wait;
 8004866:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
}
 800486a:	bd10      	pop	{r4, pc}
          CmdPulse++;
 800486c:	f894 30a9 	ldrb.w	r3, [r4, #169]	; 0xa9
          if ( CmdPulse < (uint8_t)stbc02_SwCmdSel )
 8004870:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
          CmdPulse++;
 8004874:	3301      	adds	r3, #1
 8004876:	b2db      	uxtb	r3, r3
          if ( CmdPulse < (uint8_t)stbc02_SwCmdSel )
 8004878:	429a      	cmp	r2, r3
          CmdPulse++;
 800487a:	f884 30a9 	strb.w	r3, [r4, #169]	; 0xa9
          if ( CmdPulse < (uint8_t)stbc02_SwCmdSel )
 800487e:	d90f      	bls.n	80048a0 <HAL_TIM_PeriodElapsedCallback+0xe8>
            stbc02_sw_state_prv = start;
 8004880:	2301      	movs	r3, #1
 8004882:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
 8004886:	2302      	movs	r3, #2
 8004888:	e7ca      	b.n	8004820 <HAL_TIM_PeriodElapsedCallback+0x68>
        CmdPulse = 0;
 800488a:	2200      	movs	r2, #0
 800488c:	f884 20a9 	strb.w	r2, [r4, #169]	; 0xa9
        stbc02_SwState = idle;
 8004890:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        HAL_GPIO_WritePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN, GPIO_PIN_RESET);
 8004894:	4806      	ldr	r0, [pc, #24]	; (80048b0 <HAL_TIM_PeriodElapsedCallback+0xf8>)
}
 8004896:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        HAL_GPIO_WritePin(STBC02_SW_SEL_GPIO_PORT, STBC02_SW_SEL_PIN, GPIO_PIN_RESET);
 800489a:	2140      	movs	r1, #64	; 0x40
 800489c:	f001 bb2e 	b.w	8005efc <HAL_GPIO_WritePin>
            __NOP();
 80048a0:	bf00      	nop
 80048a2:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
 80048a6:	e7b9      	b.n	800481c <HAL_TIM_PeriodElapsedCallback+0x64>
 80048a8:	40001400 	.word	0x40001400
 80048ac:	20001814 	.word	0x20001814
 80048b0:	48001400 	.word	0x48001400

080048b4 <HAL_TIM_IC_CaptureCallback>:
  * @param  htim : hadc handle
  * @retval None
  */
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3)
 80048b4:	7f03      	ldrb	r3, [r0, #28]
 80048b6:	2b04      	cmp	r3, #4
 80048b8:	d000      	beq.n	80048bc <HAL_TIM_IC_CaptureCallback+0x8>
 80048ba:	4770      	bx	lr
{
 80048bc:	b510      	push	{r4, lr}
  if(uhCaptureIndex == 0U)
 80048be:	4c10      	ldr	r4, [pc, #64]	; (8004900 <HAL_TIM_IC_CaptureCallback+0x4c>)
 80048c0:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 80048c4:	b12b      	cbz	r3, 80048d2 <HAL_TIM_IC_CaptureCallback+0x1e>
   if(uhCaptureIndex == 1U)
 80048c6:	2b01      	cmp	r3, #1
 80048c8:	d009      	beq.n	80048de <HAL_TIM_IC_CaptureCallback+0x2a>
  stbc02_ChgPinToggledTime = STBC02_GetTick();
 80048ca:	f000 f989 	bl	8004be0 <HAL_GetTick>
 80048ce:	6520      	str	r0, [r4, #80]	; 0x50
  {
    BSP_BC_ChgPinHasToggled();
  }
}
 80048d0:	bd10      	pop	{r4, pc}
    uwIC2Value1 = HAL_GetTick();
 80048d2:	f000 f985 	bl	8004be0 <HAL_GetTick>
    uhCaptureIndex = 1;
 80048d6:	2301      	movs	r3, #1
    uwIC2Value1 = HAL_GetTick();
 80048d8:	6460      	str	r0, [r4, #68]	; 0x44
    uhCaptureIndex = 1;
 80048da:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
    uwIC2Value2 = HAL_GetTick();
 80048de:	f000 f97f 	bl	8004be0 <HAL_GetTick>
      uwDiffCapture = ((0xFFFFFFFF - uwIC2Value1) + uwIC2Value2) + 1U;
 80048e2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80048e4:	1ac0      	subs	r0, r0, r3
 80048e6:	64a0      	str	r0, [r4, #72]	; 0x48
    if (uwDiffCapture != 0U)
 80048e8:	2800      	cmp	r0, #0
 80048ea:	d0ee      	beq.n	80048ca <HAL_TIM_IC_CaptureCallback+0x16>
      uhCaptureIndex = 0U;
 80048ec:	2200      	movs	r2, #0
      uwFrequency = 10000U / uwDiffCapture;
 80048ee:	f242 7310 	movw	r3, #10000	; 0x2710
      uhCaptureIndex = 0U;
 80048f2:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
      uwFrequency = 10000U / uwDiffCapture;
 80048f6:	fbb3 f0f0 	udiv	r0, r3, r0
 80048fa:	64e0      	str	r0, [r4, #76]	; 0x4c
      uhCaptureIndex = 0U;
 80048fc:	e7e5      	b.n	80048ca <HAL_TIM_IC_CaptureCallback+0x16>
 80048fe:	bf00      	nop
 8004900:	20001814 	.word	0x20001814

08004904 <TIM7_IRQHandler>:
/**
* @brief This function handles STBC02_USED_TIM global interrupt.
*/
void STBC02_USED_TIM_IRQHandler(void)
{
  HAL_TIM_IRQHandler(&hstbc02_UsedTim);
 8004904:	4801      	ldr	r0, [pc, #4]	; (800490c <TIM7_IRQHandler+0x8>)
 8004906:	f005 ba7b 	b.w	8009e00 <HAL_TIM_IRQHandler>
 800490a:	bf00      	nop
 800490c:	20019e08 	.word	0x20019e08

08004910 <TIM3_IRQHandler>:
  * @param  None
  * @retval None
  */
void TIM3_IRQHandler(void)
{
  HAL_TIM_IRQHandler(&TimBCHandle);
 8004910:	4801      	ldr	r0, [pc, #4]	; (8004918 <TIM3_IRQHandler+0x8>)
 8004912:	f005 ba75 	b.w	8009e00 <HAL_TIM_IRQHandler>
 8004916:	bf00      	nop
 8004918:	20001814 	.word	0x20001814

0800491c <BSP_DEBUG_PIN_On>:
  DEBUG_PINx_GPIO_CLK_DISABLE(Pin);
}

void BSP_DEBUG_PIN_On(Debug_Pin_TypeDef Pin)
{
  HAL_GPIO_WritePin(DEBUG_PIN_PORT[Pin], DEBUG_PIN[Pin], GPIO_PIN_SET);
 800491c:	4a04      	ldr	r2, [pc, #16]	; (8004930 <BSP_DEBUG_PIN_On+0x14>)
 800491e:	4b05      	ldr	r3, [pc, #20]	; (8004934 <BSP_DEBUG_PIN_On+0x18>)
 8004920:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
 8004924:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8004928:	2201      	movs	r2, #1
 800492a:	f001 bae7 	b.w	8005efc <HAL_GPIO_WritePin>
 800492e:	bf00      	nop
 8004930:	0801a124 	.word	0x0801a124
 8004934:	200000f4 	.word	0x200000f4

08004938 <BSP_DEBUG_PIN_Off>:
}

void BSP_DEBUG_PIN_Off(Debug_Pin_TypeDef Pin)
{
  HAL_GPIO_WritePin(DEBUG_PIN_PORT[Pin], DEBUG_PIN[Pin], GPIO_PIN_RESET);
 8004938:	4a04      	ldr	r2, [pc, #16]	; (800494c <BSP_DEBUG_PIN_Off+0x14>)
 800493a:	4b05      	ldr	r3, [pc, #20]	; (8004950 <BSP_DEBUG_PIN_Off+0x18>)
 800493c:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
 8004940:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8004944:	2200      	movs	r2, #0
 8004946:	f001 bad9 	b.w	8005efc <HAL_GPIO_WritePin>
 800494a:	bf00      	nop
 800494c:	0801a124 	.word	0x0801a124
 8004950:	200000f4 	.word	0x200000f4

08004954 <BSP_SD_Detect_Init>:
 */
void BSP_SD_Detect_Init(void)
{
  GPIO_InitTypeDef gpio_init_structure;
  
  SD_DETECT_GPIO_CLK_ENABLE();
 8004954:	4b0d      	ldr	r3, [pc, #52]	; (800498c <BSP_SD_Detect_Init+0x38>)
  /* Configure MFX Interrupt GPIO */
  gpio_init_structure.Pin   = SD_DETECT_GPIO_PIN;
  gpio_init_structure.Pull  = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_LOW;
  gpio_init_structure.Mode  = GPIO_MODE_INPUT;
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8004956:	480e      	ldr	r0, [pc, #56]	; (8004990 <BSP_SD_Detect_Init+0x3c>)
  SD_DETECT_GPIO_CLK_ENABLE();
 8004958:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 800495a:	b570      	push	{r4, r5, r6, lr}
  SD_DETECT_GPIO_CLK_ENABLE();
 800495c:	f042 0202 	orr.w	r2, r2, #2
 8004960:	64da      	str	r2, [r3, #76]	; 0x4c
 8004962:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 8004964:	b088      	sub	sp, #32
  SD_DETECT_GPIO_CLK_ENABLE();
 8004966:	f003 0302 	and.w	r3, r3, #2
 800496a:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pin   = SD_DETECT_GPIO_PIN;
 800496c:	2201      	movs	r2, #1
 800496e:	2300      	movs	r3, #0
 8004970:	f44f 5480 	mov.w	r4, #4096	; 0x1000
 8004974:	2500      	movs	r5, #0
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8004976:	a902      	add	r1, sp, #8
  gpio_init_structure.Pin   = SD_DETECT_GPIO_PIN;
 8004978:	e9cd 4502 	strd	r4, r5, [sp, #8]
 800497c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  SD_DETECT_GPIO_CLK_ENABLE();
 8004980:	9e01      	ldr	r6, [sp, #4]
  HAL_GPIO_Init(SD_DETECT_GPIO_PORT, &gpio_init_structure);
 8004982:	f001 f995 	bl	8005cb0 <HAL_GPIO_Init>
}
 8004986:	b008      	add	sp, #32
 8004988:	bd70      	pop	{r4, r5, r6, pc}
 800498a:	bf00      	nop
 800498c:	40021000 	.word	0x40021000
 8004990:	48000400 	.word	0x48000400

08004994 <BSP_SD_IsDetected>:
/**
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @retval Return 1 if SD is detected, 0 if not
 */
uint8_t BSP_SD_IsDetected(void)
{
 8004994:	b508      	push	{r3, lr}
  /* Check SD card detect pin */
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_GPIO_PIN) == GPIO_PIN_RESET)
 8004996:	4807      	ldr	r0, [pc, #28]	; (80049b4 <BSP_SD_IsDetected+0x20>)
 8004998:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800499c:	f001 faa8 	bl	8005ef0 <HAL_GPIO_ReadPin>
  {
    SD_Status = SD_NOT_PRESENT;
 80049a0:	4b05      	ldr	r3, [pc, #20]	; (80049b8 <BSP_SD_IsDetected+0x24>)
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_GPIO_PIN) == GPIO_PIN_RESET)
 80049a2:	b910      	cbnz	r0, 80049aa <BSP_SD_IsDetected+0x16>
    SD_Status = SD_NOT_PRESENT;
 80049a4:	7018      	strb	r0, [r3, #0]
  else
  {
    SD_Status = SD_PRESENT;
  }
  
  return SD_Status;
 80049a6:	7818      	ldrb	r0, [r3, #0]
}
 80049a8:	bd08      	pop	{r3, pc}
    SD_Status = SD_PRESENT;
 80049aa:	2201      	movs	r2, #1
 80049ac:	701a      	strb	r2, [r3, #0]
  return SD_Status;
 80049ae:	7818      	ldrb	r0, [r3, #0]
}
 80049b0:	bd08      	pop	{r3, pc}
 80049b2:	bf00      	nop
 80049b4:	48000400 	.word	0x48000400
 80049b8:	200018be 	.word	0x200018be

080049bc <BSP_SD_ReadBlocks_DMA>:
  * @param  ReadAddr: Address from where data is to be read
  * @param  NumOfBlocks: Number of SD blocks to read 
  * @retval SD status
  */
uint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)
{
 80049bc:	b510      	push	{r4, lr}
 80049be:	460c      	mov	r4, r1
 80049c0:	4613      	mov	r3, r2
  uint8_t sd_state = MSD_OK;
  
  /* Read block(s) in DMA transfer mode */
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
 80049c2:	4601      	mov	r1, r0
 80049c4:	4622      	mov	r2, r4
 80049c6:	4803      	ldr	r0, [pc, #12]	; (80049d4 <BSP_SD_ReadBlocks_DMA+0x18>)
 80049c8:	f003 fe3c 	bl	8008644 <HAL_SD_ReadBlocks_DMA>
  {
    sd_state = MSD_ERROR;
  }
  
  return sd_state; 
}
 80049cc:	3800      	subs	r0, #0
 80049ce:	bf18      	it	ne
 80049d0:	2001      	movne	r0, #1
 80049d2:	bd10      	pop	{r4, pc}
 80049d4:	20016f0c 	.word	0x20016f0c

080049d8 <BSP_SD_WriteBlocks_DMA>:
  * @param  WriteAddr: Address from where data is to be written
  * @param  NumOfBlocks: Number of SD blocks to write 
  * @retval SD status
  */
uint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)
{
 80049d8:	b510      	push	{r4, lr}
 80049da:	460c      	mov	r4, r1
 80049dc:	4613      	mov	r3, r2
  uint8_t sd_state = MSD_OK;
  
  /* Write block(s) in DMA transfer mode */
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
 80049de:	4601      	mov	r1, r0
 80049e0:	4622      	mov	r2, r4
 80049e2:	4803      	ldr	r0, [pc, #12]	; (80049f0 <BSP_SD_WriteBlocks_DMA+0x18>)
 80049e4:	f003 feac 	bl	8008740 <HAL_SD_WriteBlocks_DMA>
  {
    sd_state = MSD_ERROR;
  }
  
  return sd_state; 
}
 80049e8:	3800      	subs	r0, #0
 80049ea:	bf18      	it	ne
 80049ec:	2001      	movne	r0, #1
 80049ee:	bd10      	pop	{r4, pc}
 80049f0:	20016f0c 	.word	0x20016f0c

080049f4 <BSP_SD_MspInit>:
{
  UNUSED(hsd);
  GPIO_InitTypeDef gpioinitstruct = {0};
  
  /* Enable SDMMC1 clock */
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 80049f4:	4b1e      	ldr	r3, [pc, #120]	; (8004a70 <BSP_SD_MspInit+0x7c>)
  gpioinitstruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  gpioinitstruct.Alternate = GPIO_AF12_SDMMC1;

  /* GPIOC configuration */
  gpioinitstruct.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
  HAL_GPIO_Init(GPIOC, &gpioinitstruct);
 80049f6:	481f      	ldr	r0, [pc, #124]	; (8004a74 <BSP_SD_MspInit+0x80>)
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 80049f8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 80049fa:	b530      	push	{r4, r5, lr}
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 80049fc:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8004a00:	64da      	str	r2, [r3, #76]	; 0x4c
 8004a02:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 8004a04:	b08b      	sub	sp, #44	; 0x2c
  __HAL_RCC_SDMMC1_CLK_ENABLE();
 8004a06:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 8004a0a:	9201      	str	r2, [sp, #4]
 8004a0c:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8004a0e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004a10:	f042 0204 	orr.w	r2, r2, #4
 8004a14:	64da      	str	r2, [r3, #76]	; 0x4c
 8004a16:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004a18:	f002 0204 	and.w	r2, r2, #4
 8004a1c:	9202      	str	r2, [sp, #8]
 8004a1e:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8004a20:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004a22:	f042 0208 	orr.w	r2, r2, #8
 8004a26:	64da      	str	r2, [r3, #76]	; 0x4c
 8004a28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004a2a:	f003 0308 	and.w	r3, r3, #8
 8004a2e:	9303      	str	r3, [sp, #12]
  gpioinitstruct.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8004a30:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
 8004a34:	2302      	movs	r3, #2
 8004a36:	e9cd 2304 	strd	r2, r3, [sp, #16]
  HAL_GPIO_Init(GPIOC, &gpioinitstruct);
 8004a3a:	a904      	add	r1, sp, #16
  gpioinitstruct.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8004a3c:	2201      	movs	r2, #1
 8004a3e:	2303      	movs	r3, #3
  gpioinitstruct.Alternate = GPIO_AF12_SDMMC1;
 8004a40:	240c      	movs	r4, #12
  gpioinitstruct.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8004a42:	e9cd 2306 	strd	r2, r3, [sp, #24]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8004a46:	9d03      	ldr	r5, [sp, #12]
  gpioinitstruct.Alternate = GPIO_AF12_SDMMC1;
 8004a48:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOC, &gpioinitstruct);
 8004a4a:	f001 f931 	bl	8005cb0 <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpioinitstruct.Pin = GPIO_PIN_2;
 8004a4e:	2304      	movs	r3, #4
  HAL_GPIO_Init(GPIOD, &gpioinitstruct);
 8004a50:	a904      	add	r1, sp, #16
 8004a52:	4809      	ldr	r0, [pc, #36]	; (8004a78 <BSP_SD_MspInit+0x84>)
  gpioinitstruct.Pin = GPIO_PIN_2;
 8004a54:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIOD, &gpioinitstruct);
 8004a56:	f001 f92b 	bl	8005cb0 <HAL_GPIO_Init>

  /* NVIC configuration for SDMMC1 interrupts */
  HAL_NVIC_SetPriority(SDMMCx_IRQn, 5, 0);
 8004a5a:	2200      	movs	r2, #0
 8004a5c:	2105      	movs	r1, #5
 8004a5e:	2031      	movs	r0, #49	; 0x31
 8004a60:	f000 ff30 	bl	80058c4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDMMCx_IRQn);
 8004a64:	2031      	movs	r0, #49	; 0x31
 8004a66:	f000 ff65 	bl	8005934 <HAL_NVIC_EnableIRQ>


}
 8004a6a:	b00b      	add	sp, #44	; 0x2c
 8004a6c:	bd30      	pop	{r4, r5, pc}
 8004a6e:	bf00      	nop
 8004a70:	40021000 	.word	0x40021000
 8004a74:	48000800 	.word	0x48000800
 8004a78:	48000c00 	.word	0x48000c00

08004a7c <BSP_SD_Init>:
  hsd1.Instance = SDMMC1;
 8004a7c:	4813      	ldr	r0, [pc, #76]	; (8004acc <BSP_SD_Init+0x50>)
 8004a7e:	4b14      	ldr	r3, [pc, #80]	; (8004ad0 <BSP_SD_Init+0x54>)
{
 8004a80:	b510      	push	{r4, lr}
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 8004a82:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
 8004a86:	6003      	str	r3, [r0, #0]
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;
 8004a88:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 8004a8c:	2300      	movs	r3, #0
  hsd1.Init.ClockDiv = 1;
 8004a8e:	2401      	movs	r4, #1
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;
 8004a90:	e9c0 1203 	strd	r1, r2, [r0, #12]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 8004a94:	e9c0 3301 	strd	r3, r3, [r0, #4]
  hsd1.Init.ClockDiv = 1;
 8004a98:	e9c0 4305 	strd	r4, r3, [r0, #20]
  BSP_SD_MspInit(&hsd1);
 8004a9c:	f7ff ffaa 	bl	80049f4 <BSP_SD_MspInit>
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_GPIO_PIN) == GPIO_PIN_RESET)
 8004aa0:	480c      	ldr	r0, [pc, #48]	; (8004ad4 <BSP_SD_Init+0x58>)
 8004aa2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004aa6:	f001 fa23 	bl	8005ef0 <HAL_GPIO_ReadPin>
    SD_Status = SD_NOT_PRESENT;
 8004aaa:	4b0b      	ldr	r3, [pc, #44]	; (8004ad8 <BSP_SD_Init+0x5c>)
  if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_GPIO_PIN) == GPIO_PIN_RESET)
 8004aac:	b928      	cbnz	r0, 8004aba <BSP_SD_Init+0x3e>
    SD_Status = SD_NOT_PRESENT;
 8004aae:	7018      	strb	r0, [r3, #0]
  return SD_Status;
 8004ab0:	781b      	ldrb	r3, [r3, #0]
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8004ab2:	2b01      	cmp	r3, #1
 8004ab4:	d005      	beq.n	8004ac2 <BSP_SD_Init+0x46>
}
 8004ab6:	2002      	movs	r0, #2
 8004ab8:	bd10      	pop	{r4, pc}
    SD_Status = SD_PRESENT;
 8004aba:	701c      	strb	r4, [r3, #0]
  return SD_Status;
 8004abc:	781b      	ldrb	r3, [r3, #0]
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8004abe:	2b01      	cmp	r3, #1
 8004ac0:	d1f9      	bne.n	8004ab6 <BSP_SD_Init+0x3a>
}
 8004ac2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  sd_state = (uint8_t)HAL_SD_Init(&hsd1);
 8004ac6:	4801      	ldr	r0, [pc, #4]	; (8004acc <BSP_SD_Init+0x50>)
 8004ac8:	f004 bbac 	b.w	8009224 <HAL_SD_Init>
 8004acc:	20016f0c 	.word	0x20016f0c
 8004ad0:	50062400 	.word	0x50062400
 8004ad4:	48000400 	.word	0x48000400
 8004ad8:	200018be 	.word	0x200018be

08004adc <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
uint8_t BSP_SD_GetCardState(void)
{
 8004adc:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 8004ade:	4803      	ldr	r0, [pc, #12]	; (8004aec <BSP_SD_GetCardState+0x10>)
 8004ae0:	f004 fc04 	bl	80092ec <HAL_SD_GetCardState>
}
 8004ae4:	3804      	subs	r0, #4
 8004ae6:	bf18      	it	ne
 8004ae8:	2001      	movne	r0, #1
 8004aea:	bd08      	pop	{r3, pc}
 8004aec:	20016f0c 	.word	0x20016f0c

08004af0 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None 
  */
void BSP_SD_GetCardInfo(BSP_SD_CardInfo *CardInfo)
{
 8004af0:	4601      	mov	r1, r0
  /* Get SD card Information */
  (void)HAL_SD_GetCardInfo(&hsd1, CardInfo);
 8004af2:	4801      	ldr	r0, [pc, #4]	; (8004af8 <BSP_SD_GetCardInfo+0x8>)
 8004af4:	f004 badc 	b.w	80090b0 <HAL_SD_GetCardInfo>
 8004af8:	20016f0c 	.word	0x20016f0c

08004afc <HAL_SD_TxCpltCallback>:
  * @brief Tx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
{
 8004afc:	b508      	push	{r3, lr}
  UNUSED(hsd);
  BSP_SD_WriteCpltCallback();
 8004afe:	f00c f8e1 	bl	8010cc4 <BSP_SD_WriteCpltCallback>
}
 8004b02:	bd08      	pop	{r3, pc}

08004b04 <HAL_SD_RxCpltCallback>:
  * @brief Rx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
 8004b04:	b508      	push	{r3, lr}
  UNUSED(hsd);
  BSP_SD_ReadCpltCallback();
 8004b06:	f00c f8e9 	bl	8010cdc <BSP_SD_ReadCpltCallback>
}
 8004b0a:	bd08      	pop	{r3, pc}

08004b0c <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8004b0c:	4911      	ldr	r1, [pc, #68]	; (8004b54 <SystemInit+0x48>)
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8004b0e:	4b12      	ldr	r3, [pc, #72]	; (8004b58 <SystemInit+0x4c>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8004b10:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8004b14:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 8004b18:	b410      	push	{r4}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8004b1a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= RCC_CR_MSION;
 8004b1e:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8004b20:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 8004b22:	f042 0201 	orr.w	r2, r2, #1
 8004b26:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8004b28:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8004b2a:	681a      	ldr	r2, [r3, #0]
 8004b2c:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8004b30:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000;
 8004b34:	f44f 5480 	mov.w	r4, #4096	; 0x1000
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8004b38:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x00001000;
 8004b3a:	60dc      	str	r4, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8004b3c:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8004b3e:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8004b42:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004b46:	601a      	str	r2, [r3, #0]
  RCC->CIER = 0x00000000;
 8004b48:	6198      	str	r0, [r3, #24]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8004b4a:	608c      	str	r4, [r1, #8]
#endif
}
 8004b4c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004b50:	4770      	bx	lr
 8004b52:	bf00      	nop
 8004b54:	e000ed00 	.word	0xe000ed00
 8004b58:	40021000 	.word	0x40021000

08004b5c <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8004b5c:	4770      	bx	lr
 8004b5e:	bf00      	nop

08004b60 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8004b60:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 8004b62:	4e0f      	ldr	r6, [pc, #60]	; (8004ba0 <HAL_InitTick+0x40>)
 8004b64:	6833      	ldr	r3, [r6, #0]
 8004b66:	b90b      	cbnz	r3, 8004b6c <HAL_InitTick+0xc>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 8004b68:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8004b6a:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 8004b6c:	490d      	ldr	r1, [pc, #52]	; (8004ba4 <HAL_InitTick+0x44>)
 8004b6e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8004b72:	4605      	mov	r5, r0
 8004b74:	fbb2 f3f3 	udiv	r3, r2, r3
 8004b78:	6808      	ldr	r0, [r1, #0]
 8004b7a:	fbb0 f0f3 	udiv	r0, r0, r3
 8004b7e:	f000 fee7 	bl	8005950 <HAL_SYSTICK_Config>
 8004b82:	4604      	mov	r4, r0
 8004b84:	2800      	cmp	r0, #0
 8004b86:	d1ef      	bne.n	8004b68 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8004b88:	2d0f      	cmp	r5, #15
 8004b8a:	d8ed      	bhi.n	8004b68 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8004b8c:	4602      	mov	r2, r0
 8004b8e:	4629      	mov	r1, r5
 8004b90:	f04f 30ff 	mov.w	r0, #4294967295
 8004b94:	f000 fe96 	bl	80058c4 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8004b98:	6075      	str	r5, [r6, #4]
 8004b9a:	4620      	mov	r0, r4
}
 8004b9c:	bd70      	pop	{r4, r5, r6, pc}
 8004b9e:	bf00      	nop
 8004ba0:	20000128 	.word	0x20000128
 8004ba4:	20000124 	.word	0x20000124

08004ba8 <HAL_Init>:
{
 8004ba8:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8004baa:	2003      	movs	r0, #3
 8004bac:	f000 fe76 	bl	800589c <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8004bb0:	2000      	movs	r0, #0
 8004bb2:	f7ff ffd5 	bl	8004b60 <HAL_InitTick>
 8004bb6:	b110      	cbz	r0, 8004bbe <HAL_Init+0x16>
    status = HAL_ERROR;
 8004bb8:	2401      	movs	r4, #1
}
 8004bba:	4620      	mov	r0, r4
 8004bbc:	bd10      	pop	{r4, pc}
 8004bbe:	4604      	mov	r4, r0
    HAL_MspInit();
 8004bc0:	f7ff ffcc 	bl	8004b5c <HAL_MspInit>
}
 8004bc4:	4620      	mov	r0, r4
 8004bc6:	bd10      	pop	{r4, pc}

08004bc8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8004bc8:	4a03      	ldr	r2, [pc, #12]	; (8004bd8 <HAL_IncTick+0x10>)
 8004bca:	4904      	ldr	r1, [pc, #16]	; (8004bdc <HAL_IncTick+0x14>)
 8004bcc:	6813      	ldr	r3, [r2, #0]
 8004bce:	6809      	ldr	r1, [r1, #0]
 8004bd0:	440b      	add	r3, r1
 8004bd2:	6013      	str	r3, [r2, #0]
}
 8004bd4:	4770      	bx	lr
 8004bd6:	bf00      	nop
 8004bd8:	20019e48 	.word	0x20019e48
 8004bdc:	20000128 	.word	0x20000128

08004be0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8004be0:	4b01      	ldr	r3, [pc, #4]	; (8004be8 <HAL_GetTick+0x8>)
 8004be2:	6818      	ldr	r0, [r3, #0]
}
 8004be4:	4770      	bx	lr
 8004be6:	bf00      	nop
 8004be8:	20019e48 	.word	0x20019e48

08004bec <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8004bec:	b538      	push	{r3, r4, r5, lr}
 8004bee:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8004bf0:	f7ff fff6 	bl	8004be0 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8004bf4:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8004bf6:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 8004bf8:	d002      	beq.n	8004c00 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8004bfa:	4b04      	ldr	r3, [pc, #16]	; (8004c0c <HAL_Delay+0x20>)
 8004bfc:	681b      	ldr	r3, [r3, #0]
 8004bfe:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 8004c00:	f7ff ffee 	bl	8004be0 <HAL_GetTick>
 8004c04:	1b43      	subs	r3, r0, r5
 8004c06:	42a3      	cmp	r3, r4
 8004c08:	d3fa      	bcc.n	8004c00 <HAL_Delay+0x14>
  {
  }
}
 8004c0a:	bd38      	pop	{r3, r4, r5, pc}
 8004c0c:	20000128 	.word	0x20000128

08004c10 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
 8004c10:	4a02      	ldr	r2, [pc, #8]	; (8004c1c <HAL_SuspendTick+0xc>)
 8004c12:	6813      	ldr	r3, [r2, #0]
 8004c14:	f023 0302 	bic.w	r3, r3, #2
 8004c18:	6013      	str	r3, [r2, #0]
}
 8004c1a:	4770      	bx	lr
 8004c1c:	e000e010 	.word	0xe000e010

08004c20 <HAL_ADC_ErrorCallback>:
 8004c20:	4770      	bx	lr
 8004c22:	bf00      	nop

08004c24 <HAL_ADC_ConvCpltCallback>:
 8004c24:	4770      	bx	lr
 8004c26:	bf00      	nop

08004c28 <HAL_ADC_ConvHalfCpltCallback>:
 8004c28:	4770      	bx	lr
 8004c2a:	bf00      	nop

08004c2c <HAL_ADC_LevelOutOfWindowCallback>:
 8004c2c:	4770      	bx	lr
 8004c2e:	bf00      	nop

08004c30 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8004c30:	b570      	push	{r4, r5, r6, lr}
 8004c32:	b082      	sub	sp, #8
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8004c34:	2300      	movs	r3, #0
 8004c36:	9301      	str	r3, [sp, #4]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8004c38:	2800      	cmp	r0, #0
 8004c3a:	f000 80c8 	beq.w	8004dce <HAL_ADC_Init+0x19e>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8004c3e:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8004c40:	4604      	mov	r4, r0
 8004c42:	b9e3      	cbnz	r3, 8004c7e <HAL_ADC_Init+0x4e>
  {
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    /* Init the ADC Callback settings */
    hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
 8004c44:	4a72      	ldr	r2, [pc, #456]	; (8004e10 <HAL_ADC_Init+0x1e0>)
    hadc->InjectedQueueOverflowCallback = HAL_ADCEx_InjectedQueueOverflowCallback;  /* Legacy weak callback */
    hadc->LevelOutOfWindow2Callback     = HAL_ADCEx_LevelOutOfWindow2Callback;      /* Legacy weak callback */
    hadc->LevelOutOfWindow3Callback     = HAL_ADCEx_LevelOutOfWindow3Callback;      /* Legacy weak callback */
    hadc->EndOfSamplingCallback         = HAL_ADCEx_EndOfSamplingCallback;          /* Legacy weak callback */

    if (hadc->MspInitCallback == NULL)
 8004c46:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
    hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
 8004c4a:	4d72      	ldr	r5, [pc, #456]	; (8004e14 <HAL_ADC_Init+0x1e4>)
    hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
 8004c4c:	4872      	ldr	r0, [pc, #456]	; (8004e18 <HAL_ADC_Init+0x1e8>)
    hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
 8004c4e:	4973      	ldr	r1, [pc, #460]	; (8004e1c <HAL_ADC_Init+0x1ec>)
    hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
 8004c50:	66a2      	str	r2, [r4, #104]	; 0x68
    hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
 8004c52:	4a73      	ldr	r2, [pc, #460]	; (8004e20 <HAL_ADC_Init+0x1f0>)
    hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
 8004c54:	66e5      	str	r5, [r4, #108]	; 0x6c
    hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
 8004c56:	6720      	str	r0, [r4, #112]	; 0x70
    hadc->InjectedQueueOverflowCallback = HAL_ADCEx_InjectedQueueOverflowCallback;  /* Legacy weak callback */
 8004c58:	4d72      	ldr	r5, [pc, #456]	; (8004e24 <HAL_ADC_Init+0x1f4>)
    hadc->LevelOutOfWindow2Callback     = HAL_ADCEx_LevelOutOfWindow2Callback;      /* Legacy weak callback */
 8004c5a:	4873      	ldr	r0, [pc, #460]	; (8004e28 <HAL_ADC_Init+0x1f8>)
    hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
 8004c5c:	6761      	str	r1, [r4, #116]	; 0x74
    hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
 8004c5e:	67a2      	str	r2, [r4, #120]	; 0x78
    hadc->LevelOutOfWindow3Callback     = HAL_ADCEx_LevelOutOfWindow3Callback;      /* Legacy weak callback */
 8004c60:	4972      	ldr	r1, [pc, #456]	; (8004e2c <HAL_ADC_Init+0x1fc>)
    hadc->EndOfSamplingCallback         = HAL_ADCEx_EndOfSamplingCallback;          /* Legacy weak callback */
 8004c62:	4a73      	ldr	r2, [pc, #460]	; (8004e30 <HAL_ADC_Init+0x200>)
    hadc->LevelOutOfWindow2Callback     = HAL_ADCEx_LevelOutOfWindow2Callback;      /* Legacy weak callback */
 8004c64:	e9c4 501f 	strd	r5, r0, [r4, #124]	; 0x7c
    hadc->EndOfSamplingCallback         = HAL_ADCEx_EndOfSamplingCallback;          /* Legacy weak callback */
 8004c68:	e9c4 1221 	strd	r1, r2, [r4, #132]	; 0x84
    if (hadc->MspInitCallback == NULL)
 8004c6c:	2b00      	cmp	r3, #0
 8004c6e:	f000 80b1 	beq.w	8004dd4 <HAL_ADC_Init+0x1a4>
    {
      hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
    }

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
 8004c72:	4620      	mov	r0, r4
 8004c74:	4798      	blx	r3
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8004c76:	2300      	movs	r3, #0
 8004c78:	65e3      	str	r3, [r4, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8004c7a:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8004c7e:	6822      	ldr	r2, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8004c80:	6893      	ldr	r3, [r2, #8]
 8004c82:	009d      	lsls	r5, r3, #2
 8004c84:	d505      	bpl.n	8004c92 <HAL_ADC_Init+0x62>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8004c86:	6893      	ldr	r3, [r2, #8]
 8004c88:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8004c8c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8004c90:	6093      	str	r3, [r2, #8]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8004c92:	6893      	ldr	r3, [r2, #8]
 8004c94:	00d8      	lsls	r0, r3, #3
 8004c96:	d417      	bmi.n	8004cc8 <HAL_ADC_Init+0x98>
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8004c98:	4b66      	ldr	r3, [pc, #408]	; (8004e34 <HAL_ADC_Init+0x204>)
  MODIFY_REG(ADCx->CR,
 8004c9a:	6891      	ldr	r1, [r2, #8]
 8004c9c:	681b      	ldr	r3, [r3, #0]
 8004c9e:	4866      	ldr	r0, [pc, #408]	; (8004e38 <HAL_ADC_Init+0x208>)
 8004ca0:	099b      	lsrs	r3, r3, #6
 8004ca2:	f021 4110 	bic.w	r1, r1, #2415919104	; 0x90000000
 8004ca6:	fba0 0303 	umull	r0, r3, r0, r3
 8004caa:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 8004cae:	099b      	lsrs	r3, r3, #6
 8004cb0:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8004cb4:	6091      	str	r1, [r2, #8]
 8004cb6:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8004cb8:	9b01      	ldr	r3, [sp, #4]
 8004cba:	b12b      	cbz	r3, 8004cc8 <HAL_ADC_Init+0x98>
    {
      wait_loop_index--;
 8004cbc:	9b01      	ldr	r3, [sp, #4]
 8004cbe:	3b01      	subs	r3, #1
 8004cc0:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8004cc2:	9b01      	ldr	r3, [sp, #4]
 8004cc4:	2b00      	cmp	r3, #0
 8004cc6:	d1f9      	bne.n	8004cbc <HAL_ADC_Init+0x8c>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8004cc8:	6893      	ldr	r3, [r2, #8]
 8004cca:	00d9      	lsls	r1, r3, #3
 8004ccc:	d451      	bmi.n	8004d72 <HAL_ADC_Init+0x142>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004cce:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004cd0:	f043 0310 	orr.w	r3, r3, #16
 8004cd4:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004cd6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8004cd8:	f043 0301 	orr.w	r3, r3, #1
 8004cdc:	65e3      	str	r3, [r4, #92]	; 0x5c
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004cde:	6893      	ldr	r3, [r2, #8]
 8004ce0:	f013 0f04 	tst.w	r3, #4

    tmp_hal_status = HAL_ERROR;
 8004ce4:	f04f 0001 	mov.w	r0, #1
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8004ce8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004cea:	d149      	bne.n	8004d80 <HAL_ADC_Init+0x150>
 8004cec:	06db      	lsls	r3, r3, #27
 8004cee:	d447      	bmi.n	8004d80 <HAL_ADC_Init+0x150>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8004cf0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004cf2:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8004cf6:	f043 0302 	orr.w	r3, r3, #2
 8004cfa:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004cfc:	6893      	ldr	r3, [r2, #8]
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8004cfe:	07de      	lsls	r6, r3, #31
 8004d00:	d40a      	bmi.n	8004d18 <HAL_ADC_Init+0xe8>
 8004d02:	4b4e      	ldr	r3, [pc, #312]	; (8004e3c <HAL_ADC_Init+0x20c>)
 8004d04:	689b      	ldr	r3, [r3, #8]
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8004d06:	07dd      	lsls	r5, r3, #31
 8004d08:	d406      	bmi.n	8004d18 <HAL_ADC_Init+0xe8>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8004d0a:	494d      	ldr	r1, [pc, #308]	; (8004e40 <HAL_ADC_Init+0x210>)
 8004d0c:	6865      	ldr	r5, [r4, #4]
 8004d0e:	688b      	ldr	r3, [r1, #8]
 8004d10:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8004d14:	432b      	orrs	r3, r5
 8004d16:	608b      	str	r3, [r1, #8]
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
                hadc->Init.Overrun                                                     |
                hadc->Init.DataAlign                                                   |
 8004d18:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
 8004d1c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004d1e:	432b      	orrs	r3, r5
 8004d20:	430b      	orrs	r3, r1
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8004d22:	7e65      	ldrb	r5, [r4, #25]
                hadc->Init.Resolution                                                  |
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8004d24:	f894 1020 	ldrb.w	r1, [r4, #32]
                hadc->Init.DataAlign                                                   |
 8004d28:	ea43 3345 	orr.w	r3, r3, r5, lsl #13

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004d2c:	2901      	cmp	r1, #1
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8004d2e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8004d32:	d047      	beq.n	8004dc4 <HAL_ADC_Init+0x194>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8004d34:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004d36:	b121      	cbz	r1, 8004d42 <HAL_ADC_Init+0x112>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                  | hadc->Init.ExternalTrigConvEdge
 8004d38:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8004d3a:	f401 7170 	and.w	r1, r1, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 8004d3e:	4329      	orrs	r1, r5
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8004d40:	430b      	orrs	r3, r1
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8004d42:	68d5      	ldr	r5, [r2, #12]
 8004d44:	493f      	ldr	r1, [pc, #252]	; (8004e44 <HAL_ADC_Init+0x214>)
 8004d46:	4029      	ands	r1, r5
 8004d48:	430b      	orrs	r3, r1
 8004d4a:	60d3      	str	r3, [r2, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004d4c:	6893      	ldr	r3, [r2, #8]
 8004d4e:	0759      	lsls	r1, r3, #29
 8004d50:	d51d      	bpl.n	8004d8e <HAL_ADC_Init+0x15e>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004d52:	6893      	ldr	r3, [r2, #8]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8004d54:	6923      	ldr	r3, [r4, #16]
 8004d56:	2b01      	cmp	r3, #1
 8004d58:	d040      	beq.n	8004ddc <HAL_ADC_Init+0x1ac>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8004d5a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004d5c:	f023 030f 	bic.w	r3, r3, #15
 8004d60:	6313      	str	r3, [r2, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8004d62:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004d64:	f023 0303 	bic.w	r3, r3, #3
 8004d68:	f043 0301 	orr.w	r3, r3, #1
 8004d6c:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
  }

  /* Return function status */
  return tmp_hal_status;
}
 8004d6e:	b002      	add	sp, #8
 8004d70:	bd70      	pop	{r4, r5, r6, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004d72:	6893      	ldr	r3, [r2, #8]
 8004d74:	f013 0f04 	tst.w	r3, #4
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8004d78:	f04f 0000 	mov.w	r0, #0
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8004d7c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004d7e:	d0b5      	beq.n	8004cec <HAL_ADC_Init+0xbc>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004d80:	6da3      	ldr	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 8004d82:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004d84:	f043 0310 	orr.w	r3, r3, #16
 8004d88:	65a3      	str	r3, [r4, #88]	; 0x58
}
 8004d8a:	b002      	add	sp, #8
 8004d8c:	bd70      	pop	{r4, r5, r6, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004d8e:	6893      	ldr	r3, [r2, #8]
 8004d90:	071b      	lsls	r3, r3, #28
 8004d92:	d4df      	bmi.n	8004d54 <HAL_ADC_Init+0x124>
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8004d94:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8004d98:	7e26      	ldrb	r6, [r4, #24]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8004d9a:	68d1      	ldr	r1, [r2, #12]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8004d9c:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8004d9e:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8004da0:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8004da4:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8004da8:	432b      	orrs	r3, r5
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8004daa:	f021 0106 	bic.w	r1, r1, #6
 8004dae:	430b      	orrs	r3, r1
 8004db0:	60d3      	str	r3, [r2, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
 8004db2:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8004db6:	2b01      	cmp	r3, #1
 8004db8:	d018      	beq.n	8004dec <HAL_ADC_Init+0x1bc>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8004dba:	6913      	ldr	r3, [r2, #16]
 8004dbc:	f023 0301 	bic.w	r3, r3, #1
 8004dc0:	6113      	str	r3, [r2, #16]
 8004dc2:	e7c7      	b.n	8004d54 <HAL_ADC_Init+0x124>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8004dc4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8004dc6:	3901      	subs	r1, #1
 8004dc8:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
 8004dcc:	e7b2      	b.n	8004d34 <HAL_ADC_Init+0x104>
    return HAL_ERROR;
 8004dce:	2001      	movs	r0, #1
}
 8004dd0:	b002      	add	sp, #8
 8004dd2:	bd70      	pop	{r4, r5, r6, pc}
      hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
 8004dd4:	4b1c      	ldr	r3, [pc, #112]	; (8004e48 <HAL_ADC_Init+0x218>)
 8004dd6:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 8004dda:	e74a      	b.n	8004c72 <HAL_ADC_Init+0x42>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8004ddc:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004dde:	69e3      	ldr	r3, [r4, #28]
 8004de0:	f021 010f 	bic.w	r1, r1, #15
 8004de4:	3b01      	subs	r3, #1
 8004de6:	430b      	orrs	r3, r1
 8004de8:	6313      	str	r3, [r2, #48]	; 0x30
 8004dea:	e7ba      	b.n	8004d62 <HAL_ADC_Init+0x132>
        MODIFY_REG(hadc->Instance->CFGR2,
 8004dec:	e9d4 360f 	ldrd	r3, r6, [r4, #60]	; 0x3c
 8004df0:	6911      	ldr	r1, [r2, #16]
 8004df2:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8004df4:	f421 61ff 	bic.w	r1, r1, #2040	; 0x7f8
 8004df8:	f021 0104 	bic.w	r1, r1, #4
 8004dfc:	4333      	orrs	r3, r6
 8004dfe:	430b      	orrs	r3, r1
 8004e00:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8004e02:	432b      	orrs	r3, r5
 8004e04:	430b      	orrs	r3, r1
 8004e06:	f043 0301 	orr.w	r3, r3, #1
 8004e0a:	6113      	str	r3, [r2, #16]
 8004e0c:	e7a2      	b.n	8004d54 <HAL_ADC_Init+0x124>
 8004e0e:	bf00      	nop
 8004e10:	08004c25 	.word	0x08004c25
 8004e14:	08004c29 	.word	0x08004c29
 8004e18:	08004c2d 	.word	0x08004c2d
 8004e1c:	08004c21 	.word	0x08004c21
 8004e20:	08005321 	.word	0x08005321
 8004e24:	08005325 	.word	0x08005325
 8004e28:	08005329 	.word	0x08005329
 8004e2c:	0800532d 	.word	0x0800532d
 8004e30:	08005331 	.word	0x08005331
 8004e34:	20000124 	.word	0x20000124
 8004e38:	053e2d63 	.word	0x053e2d63
 8004e3c:	50040000 	.word	0x50040000
 8004e40:	50040300 	.word	0x50040300
 8004e44:	fff0c007 	.word	0xfff0c007
 8004e48:	08004309 	.word	0x08004309

08004e4c <HAL_ADC_GetState>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Return ADC handle state */
  return hadc->State;
 8004e4c:	6d80      	ldr	r0, [r0, #88]	; 0x58
}
 8004e4e:	4770      	bx	lr

08004e50 <ADC_ConversionStop>:
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));

  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8004e50:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004e52:	689a      	ldr	r2, [r3, #8]
 8004e54:	0752      	lsls	r2, r2, #29
{
 8004e56:	b570      	push	{r4, r5, r6, lr}
 8004e58:	4604      	mov	r4, r0
 8004e5a:	d51a      	bpl.n	8004e92 <ADC_ConversionStop+0x42>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004e5c:	689a      	ldr	r2, [r3, #8]
    /* auto-delay mode.                                                       */
    /* In auto-injection mode, regular group stop ADC_CR_ADSTP is used (not   */
    /* injected group stop ADC_CR_JADSTP).                                    */
    /* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */
    /* (see reference manual).                                                */
    if (((hadc->Instance->CFGR & ADC_CFGR_JAUTO) != 0UL)
 8004e5e:	68da      	ldr	r2, [r3, #12]
 8004e60:	0195      	lsls	r5, r2, #6
 8004e62:	d504      	bpl.n	8004e6e <ADC_ConversionStop+0x1e>
        && (hadc->Init.ContinuousConvMode == ENABLE)
        && (hadc->Init.LowPowerAutoWait == ENABLE)
 8004e64:	8b20      	ldrh	r0, [r4, #24]
 8004e66:	f240 1201 	movw	r2, #257	; 0x101
 8004e6a:	4290      	cmp	r0, r2
 8004e6c:	d031      	beq.n	8004ed2 <ADC_ConversionStop+0x82>
      /* Clear JEOS */
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
    }

    /* Stop potential conversion on going on ADC group regular */
    if (conversion_group_reassigned != ADC_INJECTED_GROUP)
 8004e6e:	2902      	cmp	r1, #2
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004e70:	689a      	ldr	r2, [r3, #8]
 8004e72:	d013      	beq.n	8004e9c <ADC_ConversionStop+0x4c>
 8004e74:	0755      	lsls	r5, r2, #29
 8004e76:	d502      	bpl.n	8004e7e <ADC_ConversionStop+0x2e>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8004e78:	689a      	ldr	r2, [r3, #8]
 8004e7a:	0790      	lsls	r0, r2, #30
 8004e7c:	d55d      	bpl.n	8004f3a <ADC_ConversionStop+0xea>
        }
      }
    }

    /* Stop potential conversion on going on ADC group injected */
    if (conversion_group_reassigned != ADC_REGULAR_GROUP)
 8004e7e:	2901      	cmp	r1, #1
 8004e80:	d041      	beq.n	8004f06 <ADC_ConversionStop+0xb6>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8004e82:	689a      	ldr	r2, [r3, #8]
 8004e84:	0712      	lsls	r2, r2, #28
 8004e86:	d440      	bmi.n	8004f0a <ADC_ConversionStop+0xba>

    /* Selection of start and stop bits with respect to the regular or injected group */
    switch (conversion_group_reassigned)
    {
      case ADC_REGULAR_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
 8004e88:	2903      	cmp	r1, #3
 8004e8a:	bf14      	ite	ne
 8004e8c:	2604      	movne	r6, #4
 8004e8e:	260c      	moveq	r6, #12
 8004e90:	e007      	b.n	8004ea2 <ADC_ConversionStop+0x52>
 8004e92:	689a      	ldr	r2, [r3, #8]
 8004e94:	0715      	lsls	r5, r2, #28
 8004e96:	d4e2      	bmi.n	8004e5e <ADC_ConversionStop+0xe>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 8004e98:	2000      	movs	r0, #0
}
 8004e9a:	bd70      	pop	{r4, r5, r6, pc}
 8004e9c:	0710      	lsls	r0, r2, #28
 8004e9e:	d440      	bmi.n	8004f22 <ADC_ConversionStop+0xd2>
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
 8004ea0:	2608      	movs	r6, #8
    tickstart = HAL_GetTick();
 8004ea2:	f7ff fe9d 	bl	8004be0 <HAL_GetTick>
 8004ea6:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
 8004ea8:	e004      	b.n	8004eb4 <ADC_ConversionStop+0x64>
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 8004eaa:	f7ff fe99 	bl	8004be0 <HAL_GetTick>
 8004eae:	1b43      	subs	r3, r0, r5
 8004eb0:	2b05      	cmp	r3, #5
 8004eb2:	d804      	bhi.n	8004ebe <ADC_ConversionStop+0x6e>
    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
 8004eb4:	6823      	ldr	r3, [r4, #0]
 8004eb6:	689b      	ldr	r3, [r3, #8]
 8004eb8:	4233      	tst	r3, r6
 8004eba:	d1f6      	bne.n	8004eaa <ADC_ConversionStop+0x5a>
 8004ebc:	e7ec      	b.n	8004e98 <ADC_ConversionStop+0x48>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004ebe:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004ec0:	f043 0310 	orr.w	r3, r3, #16
 8004ec4:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004ec6:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8004ec8:	f043 0301 	orr.w	r3, r3, #1
 8004ecc:	65e3      	str	r3, [r4, #92]	; 0x5c
        return HAL_ERROR;
 8004ece:	2001      	movs	r0, #1
}
 8004ed0:	bd70      	pop	{r4, r5, r6, pc}
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
 8004ed2:	681a      	ldr	r2, [r3, #0]
 8004ed4:	0650      	lsls	r0, r2, #25
 8004ed6:	d406      	bmi.n	8004ee6 <ADC_ConversionStop+0x96>
 8004ed8:	4a1c      	ldr	r2, [pc, #112]	; (8004f4c <ADC_ConversionStop+0xfc>)
 8004eda:	e001      	b.n	8004ee0 <ADC_ConversionStop+0x90>
        if (Conversion_Timeout_CPU_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES * 4UL))
 8004edc:	3a01      	subs	r2, #1
 8004ede:	d0ee      	beq.n	8004ebe <ADC_ConversionStop+0x6e>
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
 8004ee0:	6819      	ldr	r1, [r3, #0]
 8004ee2:	0649      	lsls	r1, r1, #25
 8004ee4:	d5fa      	bpl.n	8004edc <ADC_ConversionStop+0x8c>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
 8004ee6:	2240      	movs	r2, #64	; 0x40
 8004ee8:	601a      	str	r2, [r3, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004eea:	689a      	ldr	r2, [r3, #8]
 8004eec:	0756      	lsls	r6, r2, #29
 8004eee:	d50a      	bpl.n	8004f06 <ADC_ConversionStop+0xb6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8004ef0:	689a      	ldr	r2, [r3, #8]
 8004ef2:	0796      	lsls	r6, r2, #30
 8004ef4:	d407      	bmi.n	8004f06 <ADC_ConversionStop+0xb6>
  MODIFY_REG(ADCx->CR,
 8004ef6:	689a      	ldr	r2, [r3, #8]
 8004ef8:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8004efc:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8004f00:	f042 0210 	orr.w	r2, r2, #16
 8004f04:	609a      	str	r2, [r3, #8]
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
 8004f06:	2604      	movs	r6, #4
 8004f08:	e7cb      	b.n	8004ea2 <ADC_ConversionStop+0x52>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8004f0a:	689a      	ldr	r2, [r3, #8]
 8004f0c:	0792      	lsls	r2, r2, #30
 8004f0e:	d4bb      	bmi.n	8004e88 <ADC_ConversionStop+0x38>
  MODIFY_REG(ADCx->CR,
 8004f10:	689a      	ldr	r2, [r3, #8]
 8004f12:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8004f16:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8004f1a:	f042 0220 	orr.w	r2, r2, #32
 8004f1e:	609a      	str	r2, [r3, #8]
    switch (conversion_group_reassigned)
 8004f20:	e7b2      	b.n	8004e88 <ADC_ConversionStop+0x38>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8004f22:	689a      	ldr	r2, [r3, #8]
 8004f24:	0791      	lsls	r1, r2, #30
 8004f26:	d4bb      	bmi.n	8004ea0 <ADC_ConversionStop+0x50>
  MODIFY_REG(ADCx->CR,
 8004f28:	689a      	ldr	r2, [r3, #8]
 8004f2a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8004f2e:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8004f32:	f042 0220 	orr.w	r2, r2, #32
 8004f36:	609a      	str	r2, [r3, #8]
 8004f38:	e7b2      	b.n	8004ea0 <ADC_ConversionStop+0x50>
  MODIFY_REG(ADCx->CR,
 8004f3a:	689a      	ldr	r2, [r3, #8]
 8004f3c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8004f40:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8004f44:	f042 0210 	orr.w	r2, r2, #16
 8004f48:	609a      	str	r2, [r3, #8]
}
 8004f4a:	e798      	b.n	8004e7e <ADC_ConversionStop+0x2e>
 8004f4c:	a3400000 	.word	0xa3400000

08004f50 <ADC_Enable>:

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8004f50:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004f52:	689a      	ldr	r2, [r3, #8]
 8004f54:	07d2      	lsls	r2, r2, #31
 8004f56:	d501      	bpl.n	8004f5c <ADC_Enable+0xc>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8004f58:	2000      	movs	r0, #0
}
 8004f5a:	4770      	bx	lr
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 8004f5c:	6899      	ldr	r1, [r3, #8]
 8004f5e:	4a1a      	ldr	r2, [pc, #104]	; (8004fc8 <ADC_Enable+0x78>)
 8004f60:	4211      	tst	r1, r2
{
 8004f62:	b570      	push	{r4, r5, r6, lr}
 8004f64:	4604      	mov	r4, r0
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 8004f66:	d119      	bne.n	8004f9c <ADC_Enable+0x4c>
  MODIFY_REG(ADCx->CR,
 8004f68:	689a      	ldr	r2, [r3, #8]
 8004f6a:	4e18      	ldr	r6, [pc, #96]	; (8004fcc <ADC_Enable+0x7c>)
 8004f6c:	4032      	ands	r2, r6
 8004f6e:	f042 0201 	orr.w	r2, r2, #1
 8004f72:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
 8004f74:	f7ff fe34 	bl	8004be0 <HAL_GetTick>
 8004f78:	4605      	mov	r5, r0
    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8004f7a:	6823      	ldr	r3, [r4, #0]
 8004f7c:	681a      	ldr	r2, [r3, #0]
 8004f7e:	07d2      	lsls	r2, r2, #31
 8004f80:	d41f      	bmi.n	8004fc2 <ADC_Enable+0x72>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8004f82:	689a      	ldr	r2, [r3, #8]
      if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8004f84:	07d1      	lsls	r1, r2, #31
 8004f86:	d413      	bmi.n	8004fb0 <ADC_Enable+0x60>
  MODIFY_REG(ADCx->CR,
 8004f88:	689a      	ldr	r2, [r3, #8]
 8004f8a:	4032      	ands	r2, r6
 8004f8c:	f042 0201 	orr.w	r2, r2, #1
 8004f90:	609a      	str	r2, [r3, #8]
      if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8004f92:	f7ff fe25 	bl	8004be0 <HAL_GetTick>
 8004f96:	1b40      	subs	r0, r0, r5
 8004f98:	2802      	cmp	r0, #2
 8004f9a:	d9ee      	bls.n	8004f7a <ADC_Enable+0x2a>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8004f9c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004f9e:	f043 0310 	orr.w	r3, r3, #16
 8004fa2:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8004fa4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8004fa6:	f043 0301 	orr.w	r3, r3, #1
 8004faa:	65e3      	str	r3, [r4, #92]	; 0x5c
        return HAL_ERROR;
 8004fac:	2001      	movs	r0, #1
}
 8004fae:	bd70      	pop	{r4, r5, r6, pc}
      if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8004fb0:	f7ff fe16 	bl	8004be0 <HAL_GetTick>
 8004fb4:	1b40      	subs	r0, r0, r5
 8004fb6:	2802      	cmp	r0, #2
 8004fb8:	d8f0      	bhi.n	8004f9c <ADC_Enable+0x4c>
    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8004fba:	6823      	ldr	r3, [r4, #0]
 8004fbc:	681a      	ldr	r2, [r3, #0]
 8004fbe:	07d2      	lsls	r2, r2, #31
 8004fc0:	d5df      	bpl.n	8004f82 <ADC_Enable+0x32>
  return HAL_OK;
 8004fc2:	2000      	movs	r0, #0
}
 8004fc4:	bd70      	pop	{r4, r5, r6, pc}
 8004fc6:	bf00      	nop
 8004fc8:	8000003f 	.word	0x8000003f
 8004fcc:	7fffffc0 	.word	0x7fffffc0

08004fd0 <HAL_ADC_Start>:
{
 8004fd0:	b538      	push	{r3, r4, r5, lr}
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8004fd2:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8004fd4:	689d      	ldr	r5, [r3, #8]
 8004fd6:	f015 0504 	ands.w	r5, r5, #4
 8004fda:	d133      	bne.n	8005044 <HAL_ADC_Start+0x74>
    __HAL_LOCK(hadc);
 8004fdc:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 8004fe0:	2b01      	cmp	r3, #1
 8004fe2:	4604      	mov	r4, r0
 8004fe4:	d02e      	beq.n	8005044 <HAL_ADC_Start+0x74>
 8004fe6:	2301      	movs	r3, #1
 8004fe8:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
    tmp_hal_status = ADC_Enable(hadc);
 8004fec:	f7ff ffb0 	bl	8004f50 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 8004ff0:	bb50      	cbnz	r0, 8005048 <HAL_ADC_Start+0x78>
      ADC_STATE_CLR_SET(hadc->State,
 8004ff2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8004ff4:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8004ff8:	f023 0301 	bic.w	r3, r3, #1
 8004ffc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005000:	65a3      	str	r3, [r4, #88]	; 0x58
      if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8005002:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8005004:	04da      	lsls	r2, r3, #19
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 8005006:	bf48      	it	mi
 8005008:	6de3      	ldrmi	r3, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800500a:	6822      	ldr	r2, [r4, #0]
        ADC_CLEAR_ERRORCODE(hadc);
 800500c:	bf52      	itee	pl
 800500e:	65e0      	strpl	r0, [r4, #92]	; 0x5c
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 8005010:	f023 0306 	bicmi.w	r3, r3, #6
 8005014:	65e3      	strmi	r3, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8005016:	211c      	movs	r1, #28
      __HAL_UNLOCK(hadc);
 8005018:	2300      	movs	r3, #0
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800501a:	6011      	str	r1, [r2, #0]
      __HAL_UNLOCK(hadc);
 800501c:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != 0UL)
 8005020:	68d3      	ldr	r3, [r2, #12]
 8005022:	019b      	lsls	r3, r3, #6
 8005024:	d505      	bpl.n	8005032 <HAL_ADC_Start+0x62>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 8005026:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8005028:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800502c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8005030:	65a3      	str	r3, [r4, #88]	; 0x58
  MODIFY_REG(ADCx->CR,
 8005032:	6893      	ldr	r3, [r2, #8]
 8005034:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8005038:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800503c:	f043 0304 	orr.w	r3, r3, #4
 8005040:	6093      	str	r3, [r2, #8]
}
 8005042:	bd38      	pop	{r3, r4, r5, pc}
    tmp_hal_status = HAL_BUSY;
 8005044:	2002      	movs	r0, #2
}
 8005046:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 8005048:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
}
 800504c:	bd38      	pop	{r3, r4, r5, pc}
 800504e:	bf00      	nop

08005050 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
 8005050:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 8005052:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8005054:	689a      	ldr	r2, [r3, #8]
 8005056:	0791      	lsls	r1, r2, #30
 8005058:	d502      	bpl.n	8005060 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800505a:	689b      	ldr	r3, [r3, #8]
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 800505c:	2000      	movs	r0, #0
}
 800505e:	bd38      	pop	{r3, r4, r5, pc}
 8005060:	689a      	ldr	r2, [r3, #8]
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8005062:	07d2      	lsls	r2, r2, #31
 8005064:	d526      	bpl.n	80050b4 <ADC_Disable+0x64>
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8005066:	689a      	ldr	r2, [r3, #8]
 8005068:	f002 020d 	and.w	r2, r2, #13
 800506c:	2a01      	cmp	r2, #1
 800506e:	4604      	mov	r4, r0
 8005070:	d009      	beq.n	8005086 <ADC_Disable+0x36>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8005072:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8005074:	f043 0310 	orr.w	r3, r3, #16
 8005078:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800507a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800507c:	f043 0301 	orr.w	r3, r3, #1
 8005080:	65e3      	str	r3, [r4, #92]	; 0x5c
        return HAL_ERROR;
 8005082:	2001      	movs	r0, #1
}
 8005084:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 8005086:	689a      	ldr	r2, [r3, #8]
 8005088:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800508c:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8005090:	f042 0202 	orr.w	r2, r2, #2
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8005094:	2103      	movs	r1, #3
 8005096:	609a      	str	r2, [r3, #8]
 8005098:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
 800509a:	f7ff fda1 	bl	8004be0 <HAL_GetTick>
 800509e:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 80050a0:	e004      	b.n	80050ac <ADC_Disable+0x5c>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 80050a2:	f7ff fd9d 	bl	8004be0 <HAL_GetTick>
 80050a6:	1b40      	subs	r0, r0, r5
 80050a8:	2802      	cmp	r0, #2
 80050aa:	d8e2      	bhi.n	8005072 <ADC_Disable+0x22>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 80050ac:	6823      	ldr	r3, [r4, #0]
 80050ae:	689b      	ldr	r3, [r3, #8]
 80050b0:	07db      	lsls	r3, r3, #31
 80050b2:	d4f6      	bmi.n	80050a2 <ADC_Disable+0x52>
  return HAL_OK;
 80050b4:	2000      	movs	r0, #0
}
 80050b6:	bd38      	pop	{r3, r4, r5, pc}

080050b8 <HAL_ADC_Stop>:
  __HAL_LOCK(hadc);
 80050b8:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 80050bc:	2b01      	cmp	r3, #1
 80050be:	d01d      	beq.n	80050fc <HAL_ADC_Stop+0x44>
 80050c0:	2301      	movs	r3, #1
{
 80050c2:	b510      	push	{r4, lr}
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 80050c4:	2103      	movs	r1, #3
  __HAL_LOCK(hadc);
 80050c6:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 80050ca:	4604      	mov	r4, r0
 80050cc:	f7ff fec0 	bl	8004e50 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 80050d0:	b118      	cbz	r0, 80050da <HAL_ADC_Stop+0x22>
  __HAL_UNLOCK(hadc);
 80050d2:	2300      	movs	r3, #0
 80050d4:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 80050d8:	bd10      	pop	{r4, pc}
    tmp_hal_status = ADC_Disable(hadc);
 80050da:	4620      	mov	r0, r4
 80050dc:	f7ff ffb8 	bl	8005050 <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 80050e0:	2800      	cmp	r0, #0
 80050e2:	d1f6      	bne.n	80050d2 <HAL_ADC_Stop+0x1a>
      ADC_STATE_CLR_SET(hadc->State,
 80050e4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80050e6:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 80050ea:	f023 0301 	bic.w	r3, r3, #1
 80050ee:	f043 0301 	orr.w	r3, r3, #1
 80050f2:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 80050f4:	2300      	movs	r3, #0
 80050f6:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 80050fa:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 80050fc:	2002      	movs	r0, #2
}
 80050fe:	4770      	bx	lr

08005100 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t SingleDiff)
{
 8005100:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));

  /* Process locked */
  __HAL_LOCK(hadc);
 8005102:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
{
 8005106:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
 8005108:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 800510a:	2b01      	cmp	r3, #1
  __IO uint32_t wait_loop_index = 0UL;
 800510c:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 800510e:	d03f      	beq.n	8005190 <HAL_ADCEx_Calibration_Start+0x90>
 8005110:	2301      	movs	r3, #1
 8005112:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 8005116:	4604      	mov	r4, r0
 8005118:	460d      	mov	r5, r1
 800511a:	f7ff ff99 	bl	8005050 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800511e:	6da3      	ldr	r3, [r4, #88]	; 0x58
  if (tmp_hal_status == HAL_OK)
 8005120:	b9e0      	cbnz	r0, 800515c <HAL_ADCEx_Calibration_Start+0x5c>
    ADC_STATE_CLR_SET(hadc->State,
 8005122:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8005126:	f023 0302 	bic.w	r3, r3, #2
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance, SingleDiff);
 800512a:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 800512c:	f043 0302 	orr.w	r3, r3, #2
 8005130:	65a3      	str	r3, [r4, #88]	; 0x58
  MODIFY_REG(ADCx->CR,
 8005132:	6893      	ldr	r3, [r2, #8]
 8005134:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8005138:	f005 4580 	and.w	r5, r5, #1073741824	; 0x40000000
 800513c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8005140:	432b      	orrs	r3, r5
 8005142:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005146:	6093      	str	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8005148:	6893      	ldr	r3, [r2, #8]
 800514a:	2b00      	cmp	r3, #0
 800514c:	db0e      	blt.n	800516c <HAL_ADCEx_Calibration_Start+0x6c>
        return HAL_ERROR;
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800514e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8005150:	f023 0303 	bic.w	r3, r3, #3
 8005154:	f043 0301 	orr.w	r3, r3, #1
 8005158:	65a3      	str	r3, [r4, #88]	; 0x58
 800515a:	e002      	b.n	8005162 <HAL_ADCEx_Calibration_Start+0x62>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800515c:	f043 0310 	orr.w	r3, r3, #16
 8005160:	65a3      	str	r3, [r4, #88]	; 0x58
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8005162:	2300      	movs	r3, #0
 8005164:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
}
 8005168:	b003      	add	sp, #12
 800516a:	bd30      	pop	{r4, r5, pc}
      wait_loop_index++;
 800516c:	9b01      	ldr	r3, [sp, #4]
 800516e:	3301      	adds	r3, #1
 8005170:	9301      	str	r3, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8005172:	9b01      	ldr	r3, [sp, #4]
 8005174:	f5b3 2f91 	cmp.w	r3, #296960	; 0x48800
 8005178:	d3e6      	bcc.n	8005148 <HAL_ADCEx_Calibration_Start+0x48>
        ADC_STATE_CLR_SET(hadc->State,
 800517a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800517c:	f023 0312 	bic.w	r3, r3, #18
 8005180:	f043 0310 	orr.w	r3, r3, #16
        __HAL_UNLOCK(hadc);
 8005184:	2200      	movs	r2, #0
        ADC_STATE_CLR_SET(hadc->State,
 8005186:	65a3      	str	r3, [r4, #88]	; 0x58
        __HAL_UNLOCK(hadc);
 8005188:	f884 2054 	strb.w	r2, [r4, #84]	; 0x54
        return HAL_ERROR;
 800518c:	2001      	movs	r0, #1
 800518e:	e7eb      	b.n	8005168 <HAL_ADCEx_Calibration_Start+0x68>
  __HAL_LOCK(hadc);
 8005190:	2002      	movs	r0, #2
}
 8005192:	b003      	add	sp, #12
 8005194:	bd30      	pop	{r4, r5, pc}
 8005196:	bf00      	nop

08005198 <HAL_ADCEx_InjectedStart>:
  *         For ADC master, ADC is enabled and multimode conversion is started.
  * @param hadc ADC handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef *hadc)
{
 8005198:	b538      	push	{r3, r4, r5, lr}
#endif

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
 800519a:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800519c:	689a      	ldr	r2, [r3, #8]
 800519e:	0711      	lsls	r1, r2, #28
 80051a0:	d432      	bmi.n	8005208 <HAL_ADCEx_InjectedStart+0x70>
       If JQDIS is not set at that point, returns an error
       - since software trigger detection is disabled. User needs to
       resort to HAL_ADCEx_DisableInjectedQueue() API to set JQDIS.
       - or (if JQDIS is intentionally reset) since JEXTEN = 0 which means
         the queue is empty */
    tmp_config_injected_queue = READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);
 80051a2:	68da      	ldr	r2, [r3, #12]

    if ((READ_BIT(hadc->Instance->JSQR, ADC_JSQR_JEXTEN) == 0UL)
 80051a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80051a6:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 80051aa:	4604      	mov	r4, r0
 80051ac:	d02e      	beq.n	800520c <HAL_ADCEx_InjectedStart+0x74>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
      return HAL_ERROR;
    }

    /* Process locked */
    __HAL_LOCK(hadc);
 80051ae:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 80051b2:	2b01      	cmp	r3, #1
 80051b4:	d028      	beq.n	8005208 <HAL_ADCEx_InjectedStart+0x70>
 80051b6:	2301      	movs	r3, #1
 80051b8:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

    /* Enable the ADC peripheral */
    tmp_hal_status = ADC_Enable(hadc);
 80051bc:	4620      	mov	r0, r4
 80051be:	f7ff fec7 	bl	8004f50 <ADC_Enable>

    /* Start conversion if ADC is effectively enabled */
    if (tmp_hal_status == HAL_OK)
 80051c2:	bb58      	cbnz	r0, 800521c <HAL_ADCEx_InjectedStart+0x84>
    {
      /* Check if a regular conversion is ongoing */
      if ((hadc->State & HAL_ADC_STATE_REG_BUSY) != 0UL)
 80051c4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80051c6:	05da      	lsls	r2, r3, #23
      {
        /* Reset ADC error code field related to injected conversions only */
        CLEAR_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 80051c8:	bf49      	itett	mi
 80051ca:	6de3      	ldrmi	r3, [r4, #92]	; 0x5c
      }
      else
      {
        /* Set ADC error code to none */
        ADC_CLEAR_ERRORCODE(hadc);
 80051cc:	65e0      	strpl	r0, [r4, #92]	; 0x5c
        CLEAR_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 80051ce:	f023 0308 	bicmi.w	r3, r3, #8
 80051d2:	65e3      	strmi	r3, [r4, #92]	; 0x5c
      }

      /* Set ADC state                                                        */
      /* - Clear state bitfield related to injected group conversion results  */
      /* - Set state bitfield related to injected operation                   */
      ADC_STATE_CLR_SET(hadc->State,
 80051d4:	6da3      	ldr	r3, [r4, #88]	; 0x58
      }
#endif

      /* Clear ADC group injected group conversion flag */
      /* (To ensure of no unknown state from potential previous ADC operations) */
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
 80051d6:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 80051d8:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80051dc:	f023 0301 	bic.w	r3, r3, #1
 80051e0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
 80051e4:	2560      	movs	r5, #96	; 0x60

      /* Process unlocked */
      /* Unlock before starting ADC conversions: in case of potential         */
      /* interruption, to let the process to ADC IRQ Handler.                 */
      __HAL_UNLOCK(hadc);
 80051e6:	2100      	movs	r1, #0
      ADC_STATE_CLR_SET(hadc->State,
 80051e8:	65a3      	str	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
 80051ea:	6015      	str	r5, [r2, #0]
      __HAL_UNLOCK(hadc);
 80051ec:	f884 1054 	strb.w	r1, [r4, #84]	; 0x54
  return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_JAUTO));
 80051f0:	68d3      	ldr	r3, [r2, #12]
      {
        /* ADC instance is not a multimode slave instance with multimode injected conversions enabled */
        SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
      }
#else
      if (LL_ADC_INJ_GetTrigAuto(hadc->Instance) == LL_ADC_INJ_TRIG_INDEPENDENT)
 80051f2:	019b      	lsls	r3, r3, #6
 80051f4:	d407      	bmi.n	8005206 <HAL_ADCEx_InjectedStart+0x6e>
  MODIFY_REG(ADCx->CR,
 80051f6:	6893      	ldr	r3, [r2, #8]
 80051f8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80051fc:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8005200:	f043 0308 	orr.w	r3, r3, #8
 8005204:	6093      	str	r3, [r2, #8]
    }

    /* Return function status */
    return tmp_hal_status;
  }
}
 8005206:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
 8005208:	2002      	movs	r0, #2
}
 800520a:	bd38      	pop	{r3, r4, r5, pc}
        && (tmp_config_injected_queue == 0UL)
 800520c:	2a00      	cmp	r2, #0
 800520e:	dbce      	blt.n	80051ae <HAL_ADCEx_InjectedStart+0x16>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8005210:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8005212:	f043 0320 	orr.w	r3, r3, #32
 8005216:	6583      	str	r3, [r0, #88]	; 0x58
      return HAL_ERROR;
 8005218:	2001      	movs	r0, #1
}
 800521a:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 800521c:	2300      	movs	r3, #0
 800521e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 8005222:	bd38      	pop	{r3, r4, r5, pc}

08005224 <HAL_ADCEx_InjectedPollForConversion>:
  * @note   Depending on hadc->Init.EOCSelection, JEOS or JEOC is
  *         checked and cleared depending on AUTDLY bit status.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 8005224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of sequence selected */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8005226:	6943      	ldr	r3, [r0, #20]
  {
    tmp_Flag_End = ADC_FLAG_JEOS;
  }
  else /* end of conversion selected */
  {
    tmp_Flag_End = ADC_FLAG_JEOC;
 8005228:	2b08      	cmp	r3, #8
{
 800522a:	4605      	mov	r5, r0
 800522c:	460e      	mov	r6, r1
    tmp_Flag_End = ADC_FLAG_JEOC;
 800522e:	bf0c      	ite	eq
 8005230:	2440      	moveq	r4, #64	; 0x40
 8005232:	2420      	movne	r4, #32
  }

  /* Get timeout */
  tickstart = HAL_GetTick();
 8005234:	f7ff fcd4 	bl	8004be0 <HAL_GetTick>
 8005238:	4607      	mov	r7, r0

  /* Wait until End of Conversion or Sequence flag is raised */
  while ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
 800523a:	1c73      	adds	r3, r6, #1
 800523c:	682a      	ldr	r2, [r5, #0]
 800523e:	d122      	bne.n	8005286 <HAL_ADCEx_InjectedPollForConversion+0x62>
 8005240:	6813      	ldr	r3, [r2, #0]
 8005242:	4223      	tst	r3, r4
 8005244:	d0fc      	beq.n	8005240 <HAL_ADCEx_InjectedPollForConversion+0x1c>
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 8005246:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8005248:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 800524c:	d12e      	bne.n	80052ac <HAL_ADCEx_InjectedPollForConversion+0x88>
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 800524e:	68d3      	ldr	r3, [r2, #12]
  {
    tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
    tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
  }
#else
  tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8005250:	68d3      	ldr	r3, [r2, #12]
#endif

  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8005252:	6da9      	ldr	r1, [r5, #88]	; 0x58
 8005254:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8005258:	65a9      	str	r1, [r5, #88]	; 0x58
      ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL)      &&
       ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
        (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) == 0UL))))
  {
    /* Check whether end of sequence is reached */
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
 800525a:	6811      	ldr	r1, [r2, #0]
 800525c:	064e      	lsls	r6, r1, #25
 800525e:	d50c      	bpl.n	800527a <HAL_ADCEx_InjectedPollForConversion+0x56>
      /* when the last context has been fully processed, JSQR is reset      */
      /* by the hardware. Even if no injected conversion is planned to come */
      /* (queue empty, triggers are ignored), it can start again            */
      /* immediately after setting a new context (JADSTART is still set).   */
      /* Therefore, state of HAL ADC injected group is kept to busy.        */
      if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
 8005260:	0298      	lsls	r0, r3, #10
 8005262:	d40a      	bmi.n	800527a <HAL_ADCEx_InjectedPollForConversion+0x56>
      {
        /* Set ADC state */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 8005264:	6da9      	ldr	r1, [r5, #88]	; 0x58
 8005266:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
 800526a:	65a9      	str	r1, [r5, #88]	; 0x58

        if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
 800526c:	6da9      	ldr	r1, [r5, #88]	; 0x58
 800526e:	05c9      	lsls	r1, r1, #23
 8005270:	d403      	bmi.n	800527a <HAL_ADCEx_InjectedPollForConversion+0x56>
        {
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8005272:	6da9      	ldr	r1, [r5, #88]	; 0x58
 8005274:	f041 0101 	orr.w	r1, r1, #1
 8005278:	65a9      	str	r1, [r5, #88]	; 0x58
      }
    }
  }

  /* Clear polled flag */
  if (tmp_Flag_End == ADC_FLAG_JEOS)
 800527a:	2c40      	cmp	r4, #64	; 0x40
 800527c:	d025      	beq.n	80052ca <HAL_ADCEx_InjectedPollForConversion+0xa6>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
    }
  }
  else
  {
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
 800527e:	2320      	movs	r3, #32
 8005280:	6013      	str	r3, [r2, #0]
  }

  /* Return API HAL status */
  return HAL_OK;
 8005282:	2000      	movs	r0, #0
}
 8005284:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
 8005286:	6813      	ldr	r3, [r2, #0]
 8005288:	4223      	tst	r3, r4
 800528a:	d1dc      	bne.n	8005246 <HAL_ADCEx_InjectedPollForConversion+0x22>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 800528c:	f7ff fca8 	bl	8004be0 <HAL_GetTick>
 8005290:	1bc0      	subs	r0, r0, r7
 8005292:	42b0      	cmp	r0, r6
 8005294:	d801      	bhi.n	800529a <HAL_ADCEx_InjectedPollForConversion+0x76>
 8005296:	2e00      	cmp	r6, #0
 8005298:	d1cf      	bne.n	800523a <HAL_ADCEx_InjectedPollForConversion+0x16>
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 800529a:	6dab      	ldr	r3, [r5, #88]	; 0x58
        __HAL_UNLOCK(hadc);
 800529c:	2200      	movs	r2, #0
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 800529e:	f043 0304 	orr.w	r3, r3, #4
        __HAL_UNLOCK(hadc);
 80052a2:	f885 2054 	strb.w	r2, [r5, #84]	; 0x54
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80052a6:	65ab      	str	r3, [r5, #88]	; 0x58
        return HAL_TIMEOUT;
 80052a8:	2003      	movs	r0, #3
}
 80052aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80052ac:	68d3      	ldr	r3, [r2, #12]
 80052ae:	f413 6f40 	tst.w	r3, #3072	; 0xc00
 80052b2:	d110      	bne.n	80052d6 <HAL_ADCEx_InjectedPollForConversion+0xb2>
  tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 80052b4:	68d3      	ldr	r3, [r2, #12]
       ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
 80052b6:	490c      	ldr	r1, [pc, #48]	; (80052e8 <HAL_ADCEx_InjectedPollForConversion+0xc4>)
  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80052b8:	6da8      	ldr	r0, [r5, #88]	; 0x58
       ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
 80052ba:	4019      	ands	r1, r3
  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80052bc:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
 80052c0:	65a8      	str	r0, [r5, #88]	; 0x58
       ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
 80052c2:	2900      	cmp	r1, #0
 80052c4:	d0c9      	beq.n	800525a <HAL_ADCEx_InjectedPollForConversion+0x36>
  if (tmp_Flag_End == ADC_FLAG_JEOS)
 80052c6:	2c40      	cmp	r4, #64	; 0x40
 80052c8:	d1d9      	bne.n	800527e <HAL_ADCEx_InjectedPollForConversion+0x5a>
    if (READ_BIT(tmp_cfgr, ADC_CFGR_AUTDLY) == 0UL)
 80052ca:	f413 4080 	ands.w	r0, r3, #16384	; 0x4000
 80052ce:	d108      	bne.n	80052e2 <HAL_ADCEx_InjectedPollForConversion+0xbe>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JEOC | ADC_FLAG_JEOS));
 80052d0:	2360      	movs	r3, #96	; 0x60
 80052d2:	6013      	str	r3, [r2, #0]
}
 80052d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 80052d6:	68d3      	ldr	r3, [r2, #12]
  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80052d8:	6da9      	ldr	r1, [r5, #88]	; 0x58
 80052da:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 80052de:	65a9      	str	r1, [r5, #88]	; 0x58
  if ((tmp_adc_inj_is_trigger_source_sw_start != 0UL)            ||
 80052e0:	e7cb      	b.n	800527a <HAL_ADCEx_InjectedPollForConversion+0x56>
  return HAL_OK;
 80052e2:	2000      	movs	r0, #0
}
 80052e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80052e6:	bf00      	nop
 80052e8:	02002000 	.word	0x02002000

080052ec <HAL_ADCEx_InjectedGetValue>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_INJECTED_RANK(InjectedRank));

  /* Get ADC converted value */
  switch (InjectedRank)
 80052ec:	f5b1 7f05 	cmp.w	r1, #532	; 0x214
 80052f0:	d00a      	beq.n	8005308 <HAL_ADCEx_InjectedGetValue+0x1c>
 80052f2:	f240 331a 	movw	r3, #794	; 0x31a
 80052f6:	4299      	cmp	r1, r3
 80052f8:	d00e      	beq.n	8005318 <HAL_ADCEx_InjectedGetValue+0x2c>
 80052fa:	f5b1 7f87 	cmp.w	r1, #270	; 0x10e
 80052fe:	d007      	beq.n	8005310 <HAL_ADCEx_InjectedGetValue+0x24>
    case ADC_INJECTED_RANK_2:
      tmp_jdr = hadc->Instance->JDR2;
      break;
    case ADC_INJECTED_RANK_1:
    default:
      tmp_jdr = hadc->Instance->JDR1;
 8005300:	6803      	ldr	r3, [r0, #0]
 8005302:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
      break;
  }

  /* Return ADC converted value */
  return tmp_jdr;
}
 8005306:	4770      	bx	lr
      tmp_jdr = hadc->Instance->JDR3;
 8005308:	6803      	ldr	r3, [r0, #0]
 800530a:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
      break;
 800530e:	4770      	bx	lr
      tmp_jdr = hadc->Instance->JDR2;
 8005310:	6803      	ldr	r3, [r0, #0]
 8005312:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
      break;
 8005316:	4770      	bx	lr
      tmp_jdr = hadc->Instance->JDR4;
 8005318:	6803      	ldr	r3, [r0, #0]
 800531a:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
      break;
 800531e:	4770      	bx	lr

08005320 <HAL_ADCEx_InjectedConvCpltCallback>:
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
 8005320:	4770      	bx	lr
 8005322:	bf00      	nop

08005324 <HAL_ADCEx_InjectedQueueOverflowCallback>:
 8005324:	4770      	bx	lr
 8005326:	bf00      	nop

08005328 <HAL_ADCEx_LevelOutOfWindow2Callback>:
 8005328:	4770      	bx	lr
 800532a:	bf00      	nop

0800532c <HAL_ADCEx_LevelOutOfWindow3Callback>:
 800532c:	4770      	bx	lr
 800532e:	bf00      	nop

08005330 <HAL_ADCEx_EndOfSamplingCallback>:
 8005330:	4770      	bx	lr
 8005332:	bf00      	nop

08005334 <HAL_ADCEx_InjectedConfigChannel>:
  * @param sConfigInjected Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc, ADC_InjectionConfTypeDef *sConfigInjected)
{
 8005334:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfigInjected->InjectedChannel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8005336:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 800533a:	6904      	ldr	r4, [r0, #16]
{
 800533c:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0;
 800533e:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 8005340:	2b01      	cmp	r3, #1
  __IO uint32_t wait_loop_index = 0;
 8005342:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 8005344:	f000 8152 	beq.w	80055ec <HAL_ADCEx_InjectedConfigChannel+0x2b8>
 8005348:	2301      	movs	r3, #1
 800534a:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  /*      injected channel rank. It is entered into queue only when all       */
  /*      injected ranks have been set.                                       */
  /*   Note: Scan mode is not present by hardware on this device, but used    */
  /*   by software for alignment over all STM32 devices.                      */

  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 800534e:	b1e4      	cbz	r4, 800538a <HAL_ADCEx_InjectedConfigChannel+0x56>
      (sConfigInjected->InjectedNbrOfConversion == 1U))
 8005350:	698b      	ldr	r3, [r1, #24]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 8005352:	2b01      	cmp	r3, #1
 8005354:	d019      	beq.n	800538a <HAL_ADCEx_InjectedConfigChannel+0x56>
    /* 1. Start new context and set parameters related to all injected        */
    /*    channels: injected sequence length and trigger.                     */

    /* if hadc->InjectionConfig.ChannelCount is equal to 0, this is the first */
    /*   call of the context under setting                                    */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005356:	6e44      	ldr	r4, [r0, #100]	; 0x64
 8005358:	2c00      	cmp	r4, #0
 800535a:	f040 80db 	bne.w	8005514 <HAL_ADCEx_InjectedConfigChannel+0x1e0>
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 800535e:	6a0a      	ldr	r2, [r1, #32]
 8005360:	2a00      	cmp	r2, #0
 8005362:	f000 8204 	beq.w	800576e <HAL_ADCEx_InjectedConfigChannel+0x43a>
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8005366:	1e5c      	subs	r4, r3, #1
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 8005368:	f002 023c 	and.w	r2, r2, #60	; 0x3c
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 800536c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 800536e:	4322      	orrs	r2, r4
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 8005370:	4313      	orrs	r3, r2
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, sConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005372:	e9d1 2500 	ldrd	r2, r5, [r1]

    /* Decrease channel count  */
    hadc->InjectionConfig.ChannelCount--;
 8005376:	6644      	str	r4, [r0, #100]	; 0x64
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005378:	f005 051f 	and.w	r5, r5, #31
 800537c:	f3c2 6484 	ubfx	r4, r2, #26, #5
 8005380:	40ac      	lsls	r4, r5

    /* 3. tmp_JSQR_ContextQueueBeingBuilt is fully built for this HAL_ADCEx_InjectedConfigChannel()
          call, aggregate the setting to those already built during the previous
          HAL_ADCEx_InjectedConfigChannel() calls (for the same context of course)  */
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005382:	4323      	orrs	r3, r4
 8005384:	6603      	str	r3, [r0, #96]	; 0x60

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 8005386:	6803      	ldr	r3, [r0, #0]
 8005388:	e005      	b.n	8005396 <HAL_ADCEx_InjectedConfigChannel+0x62>
    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 800538a:	684b      	ldr	r3, [r1, #4]
 800538c:	2b08      	cmp	r3, #8
 800538e:	f000 80ad 	beq.w	80054ec <HAL_ADCEx_InjectedConfigChannel+0x1b8>
 8005392:	680a      	ldr	r2, [r1, #0]
 8005394:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005396:	689c      	ldr	r4, [r3, #8]
 8005398:	0724      	lsls	r4, r4, #28
 800539a:	d40d      	bmi.n	80053b8 <HAL_ADCEx_InjectedConfigChannel+0x84>
  /*  - Injected discontinuous mode: can be enabled only if auto-injected     */
  /*    mode is disabled.                                                     */
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* If auto-injected mode is disabled: no constraint                       */
    if (sConfigInjected->AutoInjectedConv == DISABLE)
 800539c:	7f4c      	ldrb	r4, [r1, #29]
 800539e:	2c00      	cmp	r4, #0
 80053a0:	f040 809c 	bne.w	80054dc <HAL_ADCEx_InjectedConfigChannel+0x1a8>
    {
      MODIFY_REG(hadc->Instance->CFGR,
 80053a4:	7f0c      	ldrb	r4, [r1, #28]
 80053a6:	7f8e      	ldrb	r6, [r1, #30]
 80053a8:	68dd      	ldr	r5, [r3, #12]
 80053aa:	0524      	lsls	r4, r4, #20
 80053ac:	ea44 5446 	orr.w	r4, r4, r6, lsl #21
 80053b0:	f425 1540 	bic.w	r5, r5, #3145728	; 0x300000
 80053b4:	432c      	orrs	r4, r5
 80053b6:	60dc      	str	r4, [r3, #12]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80053b8:	689c      	ldr	r4, [r3, #8]
 80053ba:	f014 0404 	ands.w	r4, r4, #4
 80053be:	d037      	beq.n	8005430 <HAL_ADCEx_InjectedConfigChannel+0xfc>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80053c0:	689c      	ldr	r4, [r3, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80053c2:	2400      	movs	r4, #0
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80053c4:	689d      	ldr	r5, [r3, #8]
  }

  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated only when ADC is disabled:                */
  /*  - Single or differential mode                                           */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80053c6:	07ef      	lsls	r7, r5, #31
 80053c8:	d414      	bmi.n	80053f4 <HAL_ADCEx_InjectedConfigChannel+0xc0>
  {
    /* Set mode single-ended or differential input of the selected ADC channel */
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 80053ca:	68cf      	ldr	r7, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 80053cc:	4dab      	ldr	r5, [pc, #684]	; (800567c <HAL_ADCEx_InjectedConfigChannel+0x348>)
 80053ce:	f8d3 60b0 	ldr.w	r6, [r3, #176]	; 0xb0

    /* Configuration of differential mode */
    /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
    if (sConfigInjected->InjectedSingleDiff == ADC_DIFFERENTIAL_ENDED)
 80053d2:	f8df e2d0 	ldr.w	lr, [pc, #720]	; 80056a4 <HAL_ADCEx_InjectedConfigChannel+0x370>
 80053d6:	f007 0c18 	and.w	ip, r7, #24
 80053da:	fa25 f50c 	lsr.w	r5, r5, ip
 80053de:	f3c2 0c12 	ubfx	ip, r2, #0, #19
 80053e2:	4015      	ands	r5, r2
 80053e4:	ea26 060c 	bic.w	r6, r6, ip
 80053e8:	4335      	orrs	r5, r6
 80053ea:	4577      	cmp	r7, lr
 80053ec:	f8c3 50b0 	str.w	r5, [r3, #176]	; 0xb0
 80053f0:	f000 80c3 	beq.w	800557a <HAL_ADCEx_InjectedConfigChannel+0x246>
  /* internal measurement paths enable: If internal channel selected,       */
  /* enable dedicated internal buffers and path.                            */
  /* Note: these internal measurement paths can be disabled using           */
  /* HAL_ADC_DeInit().                                                      */

  if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 80053f4:	49a2      	ldr	r1, [pc, #648]	; (8005680 <HAL_ADCEx_InjectedConfigChannel+0x34c>)
 80053f6:	420a      	tst	r2, r1
 80053f8:	d014      	beq.n	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80053fa:	4da2      	ldr	r5, [pc, #648]	; (8005684 <HAL_ADCEx_InjectedConfigChannel+0x350>)
  {
    tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

    /* If the requested internal measurement path has already been enabled,   */
    /* bypass the configuration processing.                                   */
    if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR)
 80053fc:	4ea2      	ldr	r6, [pc, #648]	; (8005688 <HAL_ADCEx_InjectedConfigChannel+0x354>)
 80053fe:	68a9      	ldr	r1, [r5, #8]
 8005400:	42b2      	cmp	r2, r6
 8005402:	f001 77e0 	and.w	r7, r1, #29360128	; 0x1c00000
 8005406:	f000 80cd 	beq.w	80055a4 <HAL_ADCEx_InjectedConfigChannel+0x270>
        {
          wait_loop_index--;
        }
      }
    }
    else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT)
 800540a:	4ea0      	ldr	r6, [pc, #640]	; (800568c <HAL_ADCEx_InjectedConfigChannel+0x358>)
 800540c:	42b2      	cmp	r2, r6
 800540e:	f000 8097 	beq.w	8005540 <HAL_ADCEx_InjectedConfigChannel+0x20c>
      {
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
                                       LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
      }
    }
    else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)
 8005412:	4e9f      	ldr	r6, [pc, #636]	; (8005690 <HAL_ADCEx_InjectedConfigChannel+0x35c>)
 8005414:	42b2      	cmp	r2, r6
 8005416:	d105      	bne.n	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8005418:	024a      	lsls	r2, r1, #9
 800541a:	d403      	bmi.n	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
    {
      if (ADC_VREFINT_INSTANCE(hadc))
 800541c:	4a9d      	ldr	r2, [pc, #628]	; (8005694 <HAL_ADCEx_InjectedConfigChannel+0x360>)
 800541e:	4293      	cmp	r3, r2
 8005420:	f000 81f6 	beq.w	8005810 <HAL_ADCEx_InjectedConfigChannel+0x4dc>
      /* nothing to do */
    }
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8005424:	2300      	movs	r3, #0
 8005426:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
}
 800542a:	4620      	mov	r0, r4
 800542c:	b003      	add	sp, #12
 800542e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8005430:	689d      	ldr	r5, [r3, #8]
 8005432:	f015 0508 	ands.w	r5, r5, #8
 8005436:	d1c5      	bne.n	80053c4 <HAL_ADCEx_InjectedConfigChannel+0x90>
    if ((sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 8005438:	6a0c      	ldr	r4, [r1, #32]
 800543a:	2c00      	cmp	r4, #0
 800543c:	f040 808f 	bne.w	800555e <HAL_ADCEx_InjectedConfigChannel+0x22a>
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8005440:	7f4c      	ldrb	r4, [r1, #29]
 8005442:	2c01      	cmp	r4, #1
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005444:	68dc      	ldr	r4, [r3, #12]
 8005446:	bf0c      	ite	eq
 8005448:	f044 7400 	orreq.w	r4, r4, #33554432	; 0x2000000
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 800544c:	f024 7400 	bicne.w	r4, r4, #33554432	; 0x2000000
 8005450:	60dc      	str	r4, [r3, #12]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005452:	2400      	movs	r4, #0
    if (sConfigInjected->InjecOversamplingMode == ENABLE)
 8005454:	f891 5028 	ldrb.w	r5, [r1, #40]	; 0x28
 8005458:	2d01      	cmp	r5, #1
 800545a:	f000 817d 	beq.w	8005758 <HAL_ADCEx_InjectedConfigChannel+0x424>
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 800545e:	691d      	ldr	r5, [r3, #16]
 8005460:	f025 0502 	bic.w	r5, r5, #2
 8005464:	611d      	str	r5, [r3, #16]
    if (sConfigInjected->InjectedSamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8005466:	688d      	ldr	r5, [r1, #8]
 8005468:	f1b5 4f00 	cmp.w	r5, #2147483648	; 0x80000000
 800546c:	f000 8161 	beq.w	8005732 <HAL_ADCEx_InjectedConfigChannel+0x3fe>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005470:	ea4f 5cd2 	mov.w	ip, r2, lsr #23
 8005474:	f00c 0c04 	and.w	ip, ip, #4
 8005478:	f103 0714 	add.w	r7, r3, #20
  MODIFY_REG(*preg,
 800547c:	f3c2 5204 	ubfx	r2, r2, #20, #5
 8005480:	f85c 6007 	ldr.w	r6, [ip, r7]
 8005484:	f04f 0e07 	mov.w	lr, #7
 8005488:	fa0e fe02 	lsl.w	lr, lr, r2
 800548c:	4095      	lsls	r5, r2
 800548e:	ea26 020e 	bic.w	r2, r6, lr
 8005492:	4315      	orrs	r5, r2
 8005494:	f84c 5007 	str.w	r5, [ip, r7]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8005498:	695a      	ldr	r2, [r3, #20]
 800549a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800549e:	615a      	str	r2, [r3, #20]
    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 80054a0:	690f      	ldr	r7, [r1, #16]
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 80054a2:	68dd      	ldr	r5, [r3, #12]
    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 80054a4:	2f04      	cmp	r7, #4
 80054a6:	f000 80a9 	beq.w	80055fc <HAL_ADCEx_InjectedConfigChannel+0x2c8>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80054aa:	f103 0c60 	add.w	ip, r3, #96	; 0x60
  MODIFY_REG(*preg,
 80054ae:	f8df e1f8 	ldr.w	lr, [pc, #504]	; 80056a8 <HAL_ADCEx_InjectedConfigChannel+0x374>
 80054b2:	f85c 2027 	ldr.w	r2, [ip, r7, lsl #2]
 80054b6:	680e      	ldr	r6, [r1, #0]
 80054b8:	ea02 0e0e 	and.w	lr, r2, lr
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 80054bc:	f3c5 05c1 	ubfx	r5, r5, #3, #2
 80054c0:	694a      	ldr	r2, [r1, #20]
 80054c2:	006d      	lsls	r5, r5, #1
 80054c4:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 80054c8:	40aa      	lsls	r2, r5
 80054ca:	ea46 060e 	orr.w	r6, r6, lr
 80054ce:	4332      	orrs	r2, r6
 80054d0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80054d4:	f84c 2027 	str.w	r2, [ip, r7, lsl #2]
 80054d8:	680a      	ldr	r2, [r1, #0]
}
 80054da:	e773      	b.n	80053c4 <HAL_ADCEx_InjectedConfigChannel+0x90>
      MODIFY_REG(hadc->Instance->CFGR,
 80054dc:	68dc      	ldr	r4, [r3, #12]
 80054de:	7f8d      	ldrb	r5, [r1, #30]
 80054e0:	f424 1440 	bic.w	r4, r4, #3145728	; 0x300000
 80054e4:	ea44 5445 	orr.w	r4, r4, r5, lsl #21
 80054e8:	60dc      	str	r4, [r3, #12]
 80054ea:	e765      	b.n	80053b8 <HAL_ADCEx_InjectedConfigChannel+0x84>
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 80054ec:	6a0b      	ldr	r3, [r1, #32]
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 80054ee:	680a      	ldr	r2, [r1, #0]
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 80054f0:	2b00      	cmp	r3, #0
 80054f2:	d07f      	beq.n	80055f4 <HAL_ADCEx_InjectedConfigChannel+0x2c0>
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 80054f4:	6a4c      	ldr	r4, [r1, #36]	; 0x24
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 80054f6:	f003 033c 	and.w	r3, r3, #60	; 0x3c
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 80054fa:	0c95      	lsrs	r5, r2, #18
 80054fc:	4323      	orrs	r3, r4
 80054fe:	f405 55f8 	and.w	r5, r5, #7936	; 0x1f00
 8005502:	431d      	orrs	r5, r3
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_JSQR_ContextQueueBeingBuilt);
 8005504:	6803      	ldr	r3, [r0, #0]
 8005506:	4e64      	ldr	r6, [pc, #400]	; (8005698 <HAL_ADCEx_InjectedConfigChannel+0x364>)
 8005508:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 800550a:	4034      	ands	r4, r6
 800550c:	432c      	orrs	r4, r5
 800550e:	64dc      	str	r4, [r3, #76]	; 0x4c
      hadc->InjectionConfig.ContextQueue = tmp_JSQR_ContextQueueBeingBuilt;
 8005510:	6605      	str	r5, [r0, #96]	; 0x60
 8005512:	e740      	b.n	8005396 <HAL_ADCEx_InjectedConfigChannel+0x62>
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 8005514:	e9d1 2600 	ldrd	r2, r6, [r1]
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005518:	6e03      	ldr	r3, [r0, #96]	; 0x60
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 800551a:	f3c2 6584 	ubfx	r5, r2, #26, #5
 800551e:	f006 061f 	and.w	r6, r6, #31
 8005522:	40b5      	lsls	r5, r6
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005524:	431d      	orrs	r5, r3
    hadc->InjectionConfig.ChannelCount--;
 8005526:	3c01      	subs	r4, #1
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 8005528:	e9c0 5418 	strd	r5, r4, [r0, #96]	; 0x60
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 800552c:	6803      	ldr	r3, [r0, #0]
    if (hadc->InjectionConfig.ChannelCount == 0U)
 800552e:	2c00      	cmp	r4, #0
 8005530:	f47f af31 	bne.w	8005396 <HAL_ADCEx_InjectedConfigChannel+0x62>
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 8005534:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 8005536:	4e58      	ldr	r6, [pc, #352]	; (8005698 <HAL_ADCEx_InjectedConfigChannel+0x364>)
 8005538:	4034      	ands	r4, r6
 800553a:	4325      	orrs	r5, r4
 800553c:	64dd      	str	r5, [r3, #76]	; 0x4c
 800553e:	e72a      	b.n	8005396 <HAL_ADCEx_InjectedConfigChannel+0x62>
             && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8005540:	01c9      	lsls	r1, r1, #7
 8005542:	f53f af6f 	bmi.w	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
      if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8005546:	4a53      	ldr	r2, [pc, #332]	; (8005694 <HAL_ADCEx_InjectedConfigChannel+0x360>)
 8005548:	4293      	cmp	r3, r2
 800554a:	f47f af6b 	bne.w	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800554e:	68ab      	ldr	r3, [r5, #8]
 8005550:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8005554:	431f      	orrs	r7, r3
 8005556:	f047 7780 	orr.w	r7, r7, #16777216	; 0x1000000
 800555a:	60af      	str	r7, [r5, #8]
}
 800555c:	e762      	b.n	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
        || (sConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 800555e:	6a4c      	ldr	r4, [r1, #36]	; 0x24
 8005560:	2c00      	cmp	r4, #0
 8005562:	f43f af6d 	beq.w	8005440 <HAL_ADCEx_InjectedConfigChannel+0x10c>
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 8005566:	7f4c      	ldrb	r4, [r1, #29]
 8005568:	2c01      	cmp	r4, #1
 800556a:	f000 814c 	beq.w	8005806 <HAL_ADCEx_InjectedConfigChannel+0x4d2>
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 800556e:	68de      	ldr	r6, [r3, #12]
 8005570:	f026 7600 	bic.w	r6, r6, #33554432	; 0x2000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8005574:	462c      	mov	r4, r5
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 8005576:	60de      	str	r6, [r3, #12]
 8005578:	e76c      	b.n	8005454 <HAL_ADCEx_InjectedConfigChannel+0x120>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel) + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
 800557a:	f1bc 0f00 	cmp.w	ip, #0
 800557e:	f040 8095 	bne.w	80056ac <HAL_ADCEx_InjectedConfigChannel+0x378>
 8005582:	0e92      	lsrs	r2, r2, #26
 8005584:	1c55      	adds	r5, r2, #1
 8005586:	f005 071f 	and.w	r7, r5, #31
 800558a:	2f09      	cmp	r7, #9
 800558c:	f200 812d 	bhi.w	80057ea <HAL_ADCEx_InjectedConfigChannel+0x4b6>
 8005590:	06ad      	lsls	r5, r5, #26
 8005592:	2601      	movs	r6, #1
 8005594:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
 8005598:	40be      	lsls	r6, r7
 800559a:	eb07 0247 	add.w	r2, r7, r7, lsl #1
 800559e:	4335      	orrs	r5, r6
 80055a0:	0512      	lsls	r2, r2, #20
 80055a2:	e104      	b.n	80057ae <HAL_ADCEx_InjectedConfigChannel+0x47a>
        && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80055a4:	020e      	lsls	r6, r1, #8
 80055a6:	f53f af3d 	bmi.w	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
      if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80055aa:	4a3a      	ldr	r2, [pc, #232]	; (8005694 <HAL_ADCEx_InjectedConfigChannel+0x360>)
 80055ac:	4293      	cmp	r3, r2
 80055ae:	f47f af39 	bne.w	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80055b2:	68ab      	ldr	r3, [r5, #8]
        wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80055b4:	4a39      	ldr	r2, [pc, #228]	; (800569c <HAL_ADCEx_InjectedConfigChannel+0x368>)
 80055b6:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 80055ba:	431f      	orrs	r7, r3
 80055bc:	f447 0700 	orr.w	r7, r7, #8388608	; 0x800000
 80055c0:	60af      	str	r7, [r5, #8]
 80055c2:	6813      	ldr	r3, [r2, #0]
 80055c4:	4a36      	ldr	r2, [pc, #216]	; (80056a0 <HAL_ADCEx_InjectedConfigChannel+0x36c>)
 80055c6:	099b      	lsrs	r3, r3, #6
 80055c8:	fba2 2303 	umull	r2, r3, r2, r3
 80055cc:	099b      	lsrs	r3, r3, #6
 80055ce:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80055d2:	009b      	lsls	r3, r3, #2
 80055d4:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 80055d6:	9b01      	ldr	r3, [sp, #4]
 80055d8:	2b00      	cmp	r3, #0
 80055da:	f43f af23 	beq.w	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
          wait_loop_index--;
 80055de:	9b01      	ldr	r3, [sp, #4]
 80055e0:	3b01      	subs	r3, #1
 80055e2:	9301      	str	r3, [sp, #4]
        while (wait_loop_index != 0UL)
 80055e4:	9b01      	ldr	r3, [sp, #4]
 80055e6:	2b00      	cmp	r3, #0
 80055e8:	d1f9      	bne.n	80055de <HAL_ADCEx_InjectedConfigChannel+0x2aa>
 80055ea:	e71b      	b.n	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
  __HAL_LOCK(hadc);
 80055ec:	2402      	movs	r4, #2
}
 80055ee:	4620      	mov	r0, r4
 80055f0:	b003      	add	sp, #12
 80055f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1));
 80055f4:	0c95      	lsrs	r5, r2, #18
 80055f6:	f405 55f8 	and.w	r5, r5, #7936	; 0x1f00
 80055fa:	e783      	b.n	8005504 <HAL_ADCEx_InjectedConfigChannel+0x1d0>
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80055fc:	680a      	ldr	r2, [r1, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80055fe:	6e1d      	ldr	r5, [r3, #96]	; 0x60
 8005600:	6e1d      	ldr	r5, [r3, #96]	; 0x60
 8005602:	f3c2 0612 	ubfx	r6, r2, #0, #19
 8005606:	f3c5 6584 	ubfx	r5, r5, #26, #5
 800560a:	2e00      	cmp	r6, #0
 800560c:	f000 80d1 	beq.w	80057b2 <HAL_ADCEx_InjectedConfigChannel+0x47e>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8005610:	fa92 f6a2 	rbit	r6, r2
 8005614:	fab6 f686 	clz	r6, r6
 8005618:	42b5      	cmp	r5, r6
 800561a:	f000 812a 	beq.w	8005872 <HAL_ADCEx_InjectedConfigChannel+0x53e>
 800561e:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 8005620:	6e5f      	ldr	r7, [r3, #100]	; 0x64
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005622:	f103 0560 	add.w	r5, r3, #96	; 0x60
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005626:	f3c7 6784 	ubfx	r7, r7, #26, #5
 800562a:	f103 0c64 	add.w	ip, r3, #100	; 0x64
 800562e:	fa92 f6a2 	rbit	r6, r2
 8005632:	fab6 f686 	clz	r6, r6
 8005636:	42be      	cmp	r6, r7
 8005638:	f000 8106 	beq.w	8005848 <HAL_ADCEx_InjectedConfigChannel+0x514>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800563c:	68ae      	ldr	r6, [r5, #8]
 800563e:	68af      	ldr	r7, [r5, #8]
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005640:	f105 0c08 	add.w	ip, r5, #8
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005644:	f3c7 6784 	ubfx	r7, r7, #26, #5
 8005648:	fa92 f6a2 	rbit	r6, r2
 800564c:	fab6 f686 	clz	r6, r6
 8005650:	42be      	cmp	r6, r7
 8005652:	f000 80e5 	beq.w	8005820 <HAL_ADCEx_InjectedConfigChannel+0x4ec>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005656:	68ee      	ldr	r6, [r5, #12]
 8005658:	68ef      	ldr	r7, [r5, #12]
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800565a:	350c      	adds	r5, #12
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800565c:	f3c7 6784 	ubfx	r7, r7, #26, #5
 8005660:	fa92 f6a2 	rbit	r6, r2
 8005664:	fab6 f686 	clz	r6, r6
 8005668:	42be      	cmp	r6, r7
 800566a:	f47f aeab 	bne.w	80053c4 <HAL_ADCEx_InjectedConfigChannel+0x90>
  MODIFY_REG(*preg,
 800566e:	682a      	ldr	r2, [r5, #0]
 8005670:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8005674:	602a      	str	r2, [r5, #0]
 8005676:	680a      	ldr	r2, [r1, #0]
}
 8005678:	e6a4      	b.n	80053c4 <HAL_ADCEx_InjectedConfigChannel+0x90>
 800567a:	bf00      	nop
 800567c:	0007ffff 	.word	0x0007ffff
 8005680:	80080000 	.word	0x80080000
 8005684:	50040300 	.word	0x50040300
 8005688:	c7520000 	.word	0xc7520000
 800568c:	cb840000 	.word	0xcb840000
 8005690:	80000001 	.word	0x80000001
 8005694:	50040000 	.word	0x50040000
 8005698:	82082000 	.word	0x82082000
 800569c:	20000124 	.word	0x20000124
 80056a0:	053e2d63 	.word	0x053e2d63
 80056a4:	407f0000 	.word	0x407f0000
 80056a8:	03fff000 	.word	0x03fff000
 80056ac:	fa92 f5a2 	rbit	r5, r2
      LL_ADC_SetChannelSamplingTime(hadc->Instance, (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel) + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
 80056b0:	fab5 f585 	clz	r5, r5
 80056b4:	3501      	adds	r5, #1
 80056b6:	f005 051f 	and.w	r5, r5, #31
 80056ba:	2d09      	cmp	r5, #9
 80056bc:	d95a      	bls.n	8005774 <HAL_ADCEx_InjectedConfigChannel+0x440>
 80056be:	fa92 f6a2 	rbit	r6, r2
 80056c2:	fab6 f686 	clz	r6, r6
 80056c6:	fa92 f5a2 	rbit	r5, r2
 80056ca:	fab5 f585 	clz	r5, r5
 80056ce:	3501      	adds	r5, #1
 80056d0:	3601      	adds	r6, #1
 80056d2:	2701      	movs	r7, #1
 80056d4:	f005 051f 	and.w	r5, r5, #31
 80056d8:	06b6      	lsls	r6, r6, #26
 80056da:	fa07 f505 	lsl.w	r5, r7, r5
 80056de:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 80056e2:	432e      	orrs	r6, r5
 80056e4:	fa92 f5a2 	rbit	r5, r2
 80056e8:	fab5 f585 	clz	r5, r5
 80056ec:	443d      	add	r5, r7
 80056ee:	f005 051f 	and.w	r5, r5, #31
 80056f2:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80056f6:	f1a5 021e 	sub.w	r2, r5, #30
 80056fa:	0512      	lsls	r2, r2, #20
 80056fc:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8005700:	4332      	orrs	r2, r6
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005702:	ea4f 5cd2 	mov.w	ip, r2, lsr #23
 8005706:	f00c 0c04 	and.w	ip, ip, #4
 800570a:	f103 0714 	add.w	r7, r3, #20
  MODIFY_REG(*preg,
 800570e:	688e      	ldr	r6, [r1, #8]
 8005710:	f85c 5007 	ldr.w	r5, [ip, r7]
 8005714:	f3c2 5204 	ubfx	r2, r2, #20, #5
 8005718:	f04f 0e07 	mov.w	lr, #7
 800571c:	fa0e fe02 	lsl.w	lr, lr, r2
 8005720:	ea25 050e 	bic.w	r5, r5, lr
 8005724:	fa06 f202 	lsl.w	r2, r6, r2
 8005728:	432a      	orrs	r2, r5
 800572a:	f84c 2007 	str.w	r2, [ip, r7]
 800572e:	680a      	ldr	r2, [r1, #0]
}
 8005730:	e660      	b.n	80053f4 <HAL_ADCEx_InjectedConfigChannel+0xc0>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8005732:	0dd6      	lsrs	r6, r2, #23
 8005734:	f006 0604 	and.w	r6, r6, #4
 8005738:	f103 0514 	add.w	r5, r3, #20
  MODIFY_REG(*preg,
 800573c:	f3c2 5c04 	ubfx	ip, r2, #20, #5
 8005740:	5977      	ldr	r7, [r6, r5]
 8005742:	2207      	movs	r2, #7
 8005744:	fa02 f20c 	lsl.w	r2, r2, ip
 8005748:	ea27 0202 	bic.w	r2, r7, r2
 800574c:	5172      	str	r2, [r6, r5]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 800574e:	695a      	ldr	r2, [r3, #20]
 8005750:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8005754:	615a      	str	r2, [r3, #20]
}
 8005756:	e6a3      	b.n	80054a0 <HAL_ADCEx_InjectedConfigChannel+0x16c>
      MODIFY_REG(hadc->Instance->CFGR2,
 8005758:	e9d1 570b 	ldrd	r5, r7, [r1, #44]	; 0x2c
 800575c:	691e      	ldr	r6, [r3, #16]
 800575e:	433d      	orrs	r5, r7
 8005760:	f426 76ff 	bic.w	r6, r6, #510	; 0x1fe
 8005764:	4335      	orrs	r5, r6
 8005766:	f045 0502 	orr.w	r5, r5, #2
 800576a:	611d      	str	r5, [r3, #16]
 800576c:	e67b      	b.n	8005466 <HAL_ADCEx_InjectedConfigChannel+0x132>
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U));
 800576e:	3b01      	subs	r3, #1
 8005770:	461c      	mov	r4, r3
 8005772:	e5fe      	b.n	8005372 <HAL_ADCEx_InjectedConfigChannel+0x3e>
 8005774:	fa92 f5a2 	rbit	r5, r2
      LL_ADC_SetChannelSamplingTime(hadc->Instance, (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel) + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
 8005778:	fab5 f585 	clz	r5, r5
 800577c:	fa92 f6a2 	rbit	r6, r2
 8005780:	fab6 f686 	clz	r6, r6
 8005784:	3601      	adds	r6, #1
 8005786:	3501      	adds	r5, #1
 8005788:	2701      	movs	r7, #1
 800578a:	f006 061f 	and.w	r6, r6, #31
 800578e:	06ad      	lsls	r5, r5, #26
 8005790:	fa07 f606 	lsl.w	r6, r7, r6
 8005794:	f005 45f8 	and.w	r5, r5, #2080374784	; 0x7c000000
 8005798:	4335      	orrs	r5, r6
 800579a:	fa92 f2a2 	rbit	r2, r2
 800579e:	fab2 f282 	clz	r2, r2
 80057a2:	443a      	add	r2, r7
 80057a4:	f002 021f 	and.w	r2, r2, #31
 80057a8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80057ac:	0512      	lsls	r2, r2, #20
 80057ae:	432a      	orrs	r2, r5
 80057b0:	e7a7      	b.n	8005702 <HAL_ADCEx_InjectedConfigChannel+0x3ce>
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80057b2:	f3c2 6684 	ubfx	r6, r2, #26, #5
 80057b6:	42b5      	cmp	r5, r6
 80057b8:	d05b      	beq.n	8005872 <HAL_ADCEx_InjectedConfigChannel+0x53e>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80057ba:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 80057bc:	6e5f      	ldr	r7, [r3, #100]	; 0x64
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80057be:	f103 0560 	add.w	r5, r3, #96	; 0x60
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80057c2:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80057c6:	f103 0c64 	add.w	ip, r3, #100	; 0x64
 80057ca:	42b7      	cmp	r7, r6
 80057cc:	d03c      	beq.n	8005848 <HAL_ADCEx_InjectedConfigChannel+0x514>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80057ce:	68af      	ldr	r7, [r5, #8]
 80057d0:	68af      	ldr	r7, [r5, #8]
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80057d2:	f105 0c08 	add.w	ip, r5, #8
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80057d6:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80057da:	42b7      	cmp	r7, r6
 80057dc:	d020      	beq.n	8005820 <HAL_ADCEx_InjectedConfigChannel+0x4ec>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80057de:	68ef      	ldr	r7, [r5, #12]
 80057e0:	68ef      	ldr	r7, [r5, #12]
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80057e2:	350c      	adds	r5, #12
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 80057e4:	f3c7 6784 	ubfx	r7, r7, #26, #5
 80057e8:	e73e      	b.n	8005668 <HAL_ADCEx_InjectedConfigChannel+0x334>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel) + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
 80057ea:	eb07 0247 	add.w	r2, r7, r7, lsl #1
 80057ee:	06ae      	lsls	r6, r5, #26
 80057f0:	3a1e      	subs	r2, #30
 80057f2:	2501      	movs	r5, #1
 80057f4:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 80057f8:	fa05 f707 	lsl.w	r7, r5, r7
 80057fc:	0512      	lsls	r2, r2, #20
 80057fe:	433e      	orrs	r6, r7
 8005800:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8005804:	e77c      	b.n	8005700 <HAL_ADCEx_InjectedConfigChannel+0x3cc>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8005806:	6d85      	ldr	r5, [r0, #88]	; 0x58
 8005808:	f045 0520 	orr.w	r5, r5, #32
 800580c:	6585      	str	r5, [r0, #88]	; 0x58
        tmp_hal_status = HAL_ERROR;
 800580e:	e621      	b.n	8005454 <HAL_ADCEx_InjectedConfigChannel+0x120>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8005810:	68ab      	ldr	r3, [r5, #8]
 8005812:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8005816:	433b      	orrs	r3, r7
 8005818:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800581c:	60ab      	str	r3, [r5, #8]
}
 800581e:	e601      	b.n	8005424 <HAL_ADCEx_InjectedConfigChannel+0xf0>
  MODIFY_REG(*preg,
 8005820:	f8dc 2000 	ldr.w	r2, [ip]
 8005824:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8005828:	f8cc 2000 	str.w	r2, [ip]
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800582c:	680a      	ldr	r2, [r1, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800582e:	68ee      	ldr	r6, [r5, #12]
 8005830:	68ef      	ldr	r7, [r5, #12]
 8005832:	f3c2 0612 	ubfx	r6, r2, #0, #19
 8005836:	f3c7 6784 	ubfx	r7, r7, #26, #5
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800583a:	350c      	adds	r5, #12
 800583c:	2e00      	cmp	r6, #0
 800583e:	f47f af0f 	bne.w	8005660 <HAL_ADCEx_InjectedConfigChannel+0x32c>
 8005842:	f3c2 6684 	ubfx	r6, r2, #26, #5
 8005846:	e70f      	b.n	8005668 <HAL_ADCEx_InjectedConfigChannel+0x334>
  MODIFY_REG(*preg,
 8005848:	f8dc 2000 	ldr.w	r2, [ip]
 800584c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8005850:	f8cc 2000 	str.w	r2, [ip]
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 8005854:	680a      	ldr	r2, [r1, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005856:	68ae      	ldr	r6, [r5, #8]
 8005858:	68af      	ldr	r7, [r5, #8]
 800585a:	f3c2 0612 	ubfx	r6, r2, #0, #19
 800585e:	f3c7 6784 	ubfx	r7, r7, #26, #5
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8005862:	f105 0c08 	add.w	ip, r5, #8
 8005866:	2e00      	cmp	r6, #0
 8005868:	f47f aeee 	bne.w	8005648 <HAL_ADCEx_InjectedConfigChannel+0x314>
 800586c:	f3c2 6684 	ubfx	r6, r2, #26, #5
 8005870:	e7b3      	b.n	80057da <HAL_ADCEx_InjectedConfigChannel+0x4a6>
  MODIFY_REG(*preg,
 8005872:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8005874:	461d      	mov	r5, r3
 8005876:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800587a:	f845 2f60 	str.w	r2, [r5, #96]!
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800587e:	680a      	ldr	r2, [r1, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8005880:	6e5e      	ldr	r6, [r3, #100]	; 0x64
 8005882:	6e5f      	ldr	r7, [r3, #100]	; 0x64
 8005884:	f3c2 0612 	ubfx	r6, r2, #0, #19
 8005888:	f3c7 6784 	ubfx	r7, r7, #26, #5
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800588c:	f103 0c64 	add.w	ip, r3, #100	; 0x64
 8005890:	2e00      	cmp	r6, #0
 8005892:	f47f aecc 	bne.w	800562e <HAL_ADCEx_InjectedConfigChannel+0x2fa>
 8005896:	f3c2 6684 	ubfx	r6, r2, #26, #5
 800589a:	e796      	b.n	80057ca <HAL_ADCEx_InjectedConfigChannel+0x496>

0800589c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800589c:	4908      	ldr	r1, [pc, #32]	; (80058c0 <HAL_NVIC_SetPriorityGrouping+0x24>)
 800589e:	68ca      	ldr	r2, [r1, #12]
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80058a0:	b410      	push	{r4}
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80058a2:	0200      	lsls	r0, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80058a4:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 80058a8:	4022      	ands	r2, r4
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80058aa:	f400 63e0 	and.w	r3, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80058ae:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80058b0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80058b4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80058b8:	f85d 4b04 	ldr.w	r4, [sp], #4
  SCB->AIRCR =  reg_value;
 80058bc:	60cb      	str	r3, [r1, #12]
 80058be:	4770      	bx	lr
 80058c0:	e000ed00 	.word	0xe000ed00

080058c4 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80058c4:	4b19      	ldr	r3, [pc, #100]	; (800592c <HAL_NVIC_SetPriority+0x68>)
 80058c6:	68db      	ldr	r3, [r3, #12]
 80058c8:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80058cc:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80058ce:	f1c3 0507 	rsb	r5, r3, #7
 80058d2:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80058d4:	f103 0404 	add.w	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80058d8:	bf28      	it	cs
 80058da:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80058dc:	2c06      	cmp	r4, #6
 80058de:	d919      	bls.n	8005914 <HAL_NVIC_SetPriority+0x50>
 80058e0:	3b03      	subs	r3, #3
 80058e2:	f04f 34ff 	mov.w	r4, #4294967295
 80058e6:	409c      	lsls	r4, r3
 80058e8:	ea22 0204 	bic.w	r2, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80058ec:	f04f 34ff 	mov.w	r4, #4294967295
 80058f0:	40ac      	lsls	r4, r5
 80058f2:	ea21 0104 	bic.w	r1, r1, r4
 80058f6:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) >= 0)
 80058f8:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80058fa:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 80058fe:	db0c      	blt.n	800591a <HAL_NVIC_SetPriority+0x56>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005900:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8005904:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8005908:	0109      	lsls	r1, r1, #4
 800590a:	b2c9      	uxtb	r1, r1
 800590c:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8005910:	bc30      	pop	{r4, r5}
 8005912:	4770      	bx	lr
 8005914:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8005916:	4613      	mov	r3, r2
 8005918:	e7e8      	b.n	80058ec <HAL_NVIC_SetPriority+0x28>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800591a:	4b05      	ldr	r3, [pc, #20]	; (8005930 <HAL_NVIC_SetPriority+0x6c>)
 800591c:	f000 000f 	and.w	r0, r0, #15
 8005920:	0109      	lsls	r1, r1, #4
 8005922:	4403      	add	r3, r0
 8005924:	b2c9      	uxtb	r1, r1
 8005926:	7619      	strb	r1, [r3, #24]
 8005928:	bc30      	pop	{r4, r5}
 800592a:	4770      	bx	lr
 800592c:	e000ed00 	.word	0xe000ed00
 8005930:	e000ecfc 	.word	0xe000ecfc

08005934 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8005934:	2800      	cmp	r0, #0
 8005936:	db07      	blt.n	8005948 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8005938:	f000 011f 	and.w	r1, r0, #31
 800593c:	4a03      	ldr	r2, [pc, #12]	; (800594c <HAL_NVIC_EnableIRQ+0x18>)
 800593e:	0940      	lsrs	r0, r0, #5
 8005940:	2301      	movs	r3, #1
 8005942:	408b      	lsls	r3, r1
 8005944:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8005948:	4770      	bx	lr
 800594a:	bf00      	nop
 800594c:	e000e100 	.word	0xe000e100

08005950 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8005950:	3801      	subs	r0, #1
 8005952:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8005956:	d20e      	bcs.n	8005976 <HAL_SYSTICK_Config+0x26>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8005958:	4b08      	ldr	r3, [pc, #32]	; (800597c <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800595a:	b410      	push	{r4}
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800595c:	4c08      	ldr	r4, [pc, #32]	; (8005980 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800595e:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005960:	20f0      	movs	r0, #240	; 0xf0
 8005962:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8005966:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8005968:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800596a:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800596c:	609a      	str	r2, [r3, #8]
   return SysTick_Config(TicksNumb);
}
 800596e:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8005972:	6019      	str	r1, [r3, #0]
 8005974:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8005976:	2001      	movs	r0, #1
 8005978:	4770      	bx	lr
 800597a:	bf00      	nop
 800597c:	e000e010 	.word	0xe000e010
 8005980:	e000ed00 	.word	0xe000ed00

08005984 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8005984:	2800      	cmp	r0, #0
 8005986:	d076      	beq.n	8005a76 <HAL_DMA_Init+0xf2>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8005988:	6802      	ldr	r2, [r0, #0]
 800598a:	493c      	ldr	r1, [pc, #240]	; (8005a7c <HAL_DMA_Init+0xf8>)
 800598c:	428a      	cmp	r2, r1
{
 800598e:	b4f0      	push	{r4, r5, r6, r7}
 8005990:	4603      	mov	r3, r0
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8005992:	d95e      	bls.n	8005a52 <HAL_DMA_Init+0xce>
    hdma->DmaBaseAddress = DMA1;
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8005994:	4c3a      	ldr	r4, [pc, #232]	; (8005a80 <HAL_DMA_Init+0xfc>)
 8005996:	493b      	ldr	r1, [pc, #236]	; (8005a84 <HAL_DMA_Init+0x100>)
    hdma->DmaBaseAddress = DMA2;
 8005998:	4d3b      	ldr	r5, [pc, #236]	; (8005a88 <HAL_DMA_Init+0x104>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 800599a:	4414      	add	r4, r2
 800599c:	fba1 1404 	umull	r1, r4, r1, r4
 80059a0:	0924      	lsrs	r4, r4, #4
 80059a2:	00a4      	lsls	r4, r4, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 80059a4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80059a8:	691e      	ldr	r6, [r3, #16]
 80059aa:	641d      	str	r5, [r3, #64]	; 0x40
  tmp |=  hdma->Init.Direction        |
 80059ac:	4301      	orrs	r1, r0
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80059ae:	695d      	ldr	r5, [r3, #20]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80059b0:	699f      	ldr	r7, [r3, #24]
 80059b2:	645c      	str	r4, [r3, #68]	; 0x44
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80059b4:	4331      	orrs	r1, r6
  hdma->State = HAL_DMA_STATE_BUSY;
 80059b6:	2602      	movs	r6, #2
 80059b8:	f883 6025 	strb.w	r6, [r3, #37]	; 0x25
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80059bc:	4329      	orrs	r1, r5
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80059be:	69de      	ldr	r6, [r3, #28]
  tmp = hdma->Instance->CCR;
 80059c0:	6815      	ldr	r5, [r2, #0]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80059c2:	4339      	orrs	r1, r7
 80059c4:	4331      	orrs	r1, r6
          hdma->Init.Mode                | hdma->Init.Priority;
 80059c6:	6a1e      	ldr	r6, [r3, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80059c8:	f425 45ff 	bic.w	r5, r5, #32640	; 0x7f80
          hdma->Init.Mode                | hdma->Init.Priority;
 80059cc:	4331      	orrs	r1, r6
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80059ce:	4e2b      	ldr	r6, [pc, #172]	; (8005a7c <HAL_DMA_Init+0xf8>)
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80059d0:	f025 0570 	bic.w	r5, r5, #112	; 0x70
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80059d4:	42b2      	cmp	r2, r6
  tmp |=  hdma->Init.Direction        |
 80059d6:	ea41 0105 	orr.w	r1, r1, r5
  hdma->Instance->CCR = tmp;
 80059da:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
  }
  else
  {
    /* DMA2 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 80059dc:	bf88      	it	hi
 80059de:	492b      	ldrhi	r1, [pc, #172]	; (8005a8c <HAL_DMA_Init+0x108>)
  }

  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80059e0:	4e2b      	ldr	r6, [pc, #172]	; (8005a90 <HAL_DMA_Init+0x10c>)
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 80059e2:	bf94      	ite	ls
 80059e4:	f104 4180 	addls.w	r1, r4, #1073741824	; 0x40000000
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 80059e8:	1909      	addhi	r1, r1, r4
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 80059ea:	b2d2      	uxtb	r2, r2
 80059ec:	4c25      	ldr	r4, [pc, #148]	; (8005a84 <HAL_DMA_Init+0x100>)
 80059ee:	f1a2 0208 	sub.w	r2, r2, #8
 80059f2:	fba4 4202 	umull	r4, r2, r4, r2
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80059f6:	f3c2 1204 	ubfx	r2, r2, #4, #5
 80059fa:	f04f 0401 	mov.w	r4, #1
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 80059fe:	bf98      	it	ls
 8005a00:	f501 3102 	addls.w	r1, r1, #133120	; 0x20800
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 8005a04:	fa04 f202 	lsl.w	r2, r4, r2
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8005a08:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8005a0c:	e9c3 6213 	strd	r6, r2, [r3, #76]	; 0x4c
 8005a10:	6499      	str	r1, [r3, #72]	; 0x48
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8005a12:	d027      	beq.n	8005a64 <HAL_DMA_Init+0xe0>
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8005a14:	685d      	ldr	r5, [r3, #4]
 8005a16:	b2e8      	uxtb	r0, r5
  if(((hdma->Init.Request > 0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8005a18:	3d01      	subs	r5, #1
 8005a1a:	2d03      	cmp	r5, #3
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8005a1c:	6008      	str	r0, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005a1e:	6072      	str	r2, [r6, #4]
  if(((hdma->Init.Request > 0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8005a20:	d824      	bhi.n	8005a6c <HAL_DMA_Init+0xe8>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005a22:	4a1c      	ldr	r2, [pc, #112]	; (8005a94 <HAL_DMA_Init+0x110>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8005a24:	491c      	ldr	r1, [pc, #112]	; (8005a98 <HAL_DMA_Init+0x114>)
 8005a26:	6599      	str	r1, [r3, #88]	; 0x58
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005a28:	4402      	add	r2, r0

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 8005a2a:	3801      	subs	r0, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005a2c:	0092      	lsls	r2, r2, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 8005a2e:	f000 0003 	and.w	r0, r0, #3
 8005a32:	fa04 f000 	lsl.w	r0, r4, r0
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8005a36:	2400      	movs	r4, #0
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005a38:	655a      	str	r2, [r3, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 8005a3a:	65d8      	str	r0, [r3, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8005a3c:	6014      	str	r4, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005a3e:	6048      	str	r0, [r1, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8005a40:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8005a42:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8005a44:	63d8      	str	r0, [r3, #60]	; 0x3c
  hdma->Lock = HAL_UNLOCKED;
 8005a46:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 8005a4a:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
}
 8005a4e:	bcf0      	pop	{r4, r5, r6, r7}
 8005a50:	4770      	bx	lr
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8005a52:	4c12      	ldr	r4, [pc, #72]	; (8005a9c <HAL_DMA_Init+0x118>)
 8005a54:	490b      	ldr	r1, [pc, #44]	; (8005a84 <HAL_DMA_Init+0x100>)
    hdma->DmaBaseAddress = DMA1;
 8005a56:	4d12      	ldr	r5, [pc, #72]	; (8005aa0 <HAL_DMA_Init+0x11c>)
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8005a58:	4414      	add	r4, r2
 8005a5a:	fba1 1404 	umull	r1, r4, r1, r4
 8005a5e:	0924      	lsrs	r4, r4, #4
 8005a60:	00a4      	lsls	r4, r4, #2
    hdma->DmaBaseAddress = DMA1;
 8005a62:	e79f      	b.n	80059a4 <HAL_DMA_Init+0x20>
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8005a64:	2000      	movs	r0, #0
 8005a66:	6058      	str	r0, [r3, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8005a68:	6008      	str	r0, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005a6a:	6072      	str	r2, [r6, #4]
    hdma->DMAmuxRequestGen = 0U;
 8005a6c:	2200      	movs	r2, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 8005a6e:	e9c3 2215 	strd	r2, r2, [r3, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 8005a72:	65da      	str	r2, [r3, #92]	; 0x5c
 8005a74:	e7e4      	b.n	8005a40 <HAL_DMA_Init+0xbc>
    return HAL_ERROR;
 8005a76:	2001      	movs	r0, #1
}
 8005a78:	4770      	bx	lr
 8005a7a:	bf00      	nop
 8005a7c:	40020407 	.word	0x40020407
 8005a80:	bffdfbf8 	.word	0xbffdfbf8
 8005a84:	cccccccd 	.word	0xcccccccd
 8005a88:	40020400 	.word	0x40020400
 8005a8c:	4002081c 	.word	0x4002081c
 8005a90:	40020880 	.word	0x40020880
 8005a94:	1000823f 	.word	0x1000823f
 8005a98:	40020940 	.word	0x40020940
 8005a9c:	bffdfff8 	.word	0xbffdfff8
 8005aa0:	40020000 	.word	0x40020000

08005aa4 <HAL_DMA_Start_IT>:
{
 8005aa4:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(hdma);
 8005aa6:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
 8005aaa:	2c01      	cmp	r4, #1
 8005aac:	d053      	beq.n	8005b56 <HAL_DMA_Start_IT+0xb2>
  if(HAL_DMA_STATE_READY == hdma->State)
 8005aae:	f890 4025 	ldrb.w	r4, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 8005ab2:	2501      	movs	r5, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8005ab4:	42ac      	cmp	r4, r5
  __HAL_LOCK(hdma);
 8005ab6:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
  if(HAL_DMA_STATE_READY == hdma->State)
 8005aba:	d005      	beq.n	8005ac8 <HAL_DMA_Start_IT+0x24>
    __HAL_UNLOCK(hdma);
 8005abc:	2300      	movs	r3, #0
 8005abe:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
}
 8005ac2:	bcf0      	pop	{r4, r5, r6, r7}
    status = HAL_BUSY;
 8005ac4:	2002      	movs	r0, #2
}
 8005ac6:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 8005ac8:	6804      	ldr	r4, [r0, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005aca:	6cc7      	ldr	r7, [r0, #76]	; 0x4c
    hdma->State = HAL_DMA_STATE_BUSY;
 8005acc:	2602      	movs	r6, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8005ace:	2500      	movs	r5, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 8005ad0:	f880 6025 	strb.w	r6, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8005ad4:	63c5      	str	r5, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 8005ad6:	6826      	ldr	r6, [r4, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005ad8:	e9d0 c514 	ldrd	ip, r5, [r0, #80]	; 0x50
    __HAL_DMA_DISABLE(hdma);
 8005adc:	f026 0601 	bic.w	r6, r6, #1
 8005ae0:	6026      	str	r6, [r4, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005ae2:	f8c7 c004 	str.w	ip, [r7, #4]
  if(hdma->DMAmuxRequestGen != 0U)
 8005ae6:	b115      	cbz	r5, 8005aee <HAL_DMA_Start_IT+0x4a>
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005ae8:	e9d0 6716 	ldrd	r6, r7, [r0, #88]	; 0x58
 8005aec:	6077      	str	r7, [r6, #4]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005aee:	6c46      	ldr	r6, [r0, #68]	; 0x44
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8005af0:	6887      	ldr	r7, [r0, #8]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005af2:	f006 0c1c 	and.w	ip, r6, #28
 8005af6:	2601      	movs	r6, #1
 8005af8:	fa06 fc0c 	lsl.w	ip, r6, ip
 8005afc:	6c06      	ldr	r6, [r0, #64]	; 0x40
 8005afe:	f8c6 c004 	str.w	ip, [r6, #4]
  hdma->Instance->CNDTR = DataLength;
 8005b02:	6063      	str	r3, [r4, #4]
    if(NULL != hdma->XferHalfCpltCallback )
 8005b04:	6b03      	ldr	r3, [r0, #48]	; 0x30
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8005b06:	2f10      	cmp	r7, #16
    hdma->Instance->CPAR = DstAddress;
 8005b08:	bf0b      	itete	eq
 8005b0a:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->CPAR = SrcAddress;
 8005b0c:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8005b0e:	60e1      	streq	r1, [r4, #12]
    hdma->Instance->CMAR = DstAddress;
 8005b10:	60e2      	strne	r2, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8005b12:	b1bb      	cbz	r3, 8005b44 <HAL_DMA_Start_IT+0xa0>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005b14:	6823      	ldr	r3, [r4, #0]
 8005b16:	f043 030e 	orr.w	r3, r3, #14
 8005b1a:	6023      	str	r3, [r4, #0]
    if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8005b1c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8005b1e:	681a      	ldr	r2, [r3, #0]
 8005b20:	03d2      	lsls	r2, r2, #15
 8005b22:	d503      	bpl.n	8005b2c <HAL_DMA_Start_IT+0x88>
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8005b24:	681a      	ldr	r2, [r3, #0]
 8005b26:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005b2a:	601a      	str	r2, [r3, #0]
    if(hdma->DMAmuxRequestGen != 0U)
 8005b2c:	b11d      	cbz	r5, 8005b36 <HAL_DMA_Start_IT+0x92>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 8005b2e:	682b      	ldr	r3, [r5, #0]
 8005b30:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005b34:	602b      	str	r3, [r5, #0]
    __HAL_DMA_ENABLE(hdma);
 8005b36:	6823      	ldr	r3, [r4, #0]
 8005b38:	f043 0301 	orr.w	r3, r3, #1
 8005b3c:	6023      	str	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8005b3e:	2000      	movs	r0, #0
}
 8005b40:	bcf0      	pop	{r4, r5, r6, r7}
 8005b42:	4770      	bx	lr
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8005b44:	6823      	ldr	r3, [r4, #0]
 8005b46:	f023 0304 	bic.w	r3, r3, #4
 8005b4a:	6023      	str	r3, [r4, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8005b4c:	6823      	ldr	r3, [r4, #0]
 8005b4e:	f043 030a 	orr.w	r3, r3, #10
 8005b52:	6023      	str	r3, [r4, #0]
 8005b54:	e7e2      	b.n	8005b1c <HAL_DMA_Start_IT+0x78>
  __HAL_LOCK(hdma);
 8005b56:	2002      	movs	r0, #2
}
 8005b58:	bcf0      	pop	{r4, r5, r6, r7}
 8005b5a:	4770      	bx	lr

08005b5c <HAL_DMA_Abort_IT>:
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8005b5c:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 8005b60:	2b02      	cmp	r3, #2
 8005b62:	d003      	beq.n	8005b6c <HAL_DMA_Abort_IT+0x10>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8005b64:	2304      	movs	r3, #4
 8005b66:	63c3      	str	r3, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 8005b68:	2001      	movs	r0, #1
}
 8005b6a:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005b6c:	6803      	ldr	r3, [r0, #0]
 8005b6e:	6819      	ldr	r1, [r3, #0]
 8005b70:	f021 010e 	bic.w	r1, r1, #14
{
 8005b74:	b570      	push	{r4, r5, r6, lr}
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005b76:	e9d0 4210 	ldrd	r4, r2, [r0, #64]	; 0x40
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005b7a:	6c85      	ldr	r5, [r0, #72]	; 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005b7c:	6019      	str	r1, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 8005b7e:	6819      	ldr	r1, [r3, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005b80:	6cc6      	ldr	r6, [r0, #76]	; 0x4c
    __HAL_DMA_DISABLE(hdma);
 8005b82:	f021 0101 	bic.w	r1, r1, #1
 8005b86:	6019      	str	r1, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005b88:	682b      	ldr	r3, [r5, #0]
    if(hdma->DMAmuxRequestGen != 0U)
 8005b8a:	6d41      	ldr	r1, [r0, #84]	; 0x54
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8005b8c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005b90:	602b      	str	r3, [r5, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005b92:	f002 021c 	and.w	r2, r2, #28
 8005b96:	2301      	movs	r3, #1
 8005b98:	4093      	lsls	r3, r2
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005b9a:	6d02      	ldr	r2, [r0, #80]	; 0x50
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005b9c:	6063      	str	r3, [r4, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005b9e:	6072      	str	r2, [r6, #4]
    if(hdma->DMAmuxRequestGen != 0U)
 8005ba0:	b131      	cbz	r1, 8005bb0 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005ba2:	680b      	ldr	r3, [r1, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005ba4:	e9d0 2416 	ldrd	r2, r4, [r0, #88]	; 0x58
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005ba8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005bac:	600b      	str	r3, [r1, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005bae:	6054      	str	r4, [r2, #4]
    if(hdma->XferAbortCallback != NULL)
 8005bb0:	6b83      	ldr	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;
 8005bb2:	2201      	movs	r2, #1
    __HAL_UNLOCK(hdma);
 8005bb4:	2400      	movs	r4, #0
    hdma->State = HAL_DMA_STATE_READY;
 8005bb6:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 8005bba:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if(hdma->XferAbortCallback != NULL)
 8005bbe:	b113      	cbz	r3, 8005bc6 <HAL_DMA_Abort_IT+0x6a>
      hdma->XferAbortCallback(hdma);
 8005bc0:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 8005bc2:	4620      	mov	r0, r4
}
 8005bc4:	bd70      	pop	{r4, r5, r6, pc}
  HAL_StatusTypeDef status = HAL_OK;
 8005bc6:	4618      	mov	r0, r3
}
 8005bc8:	bd70      	pop	{r4, r5, r6, pc}
 8005bca:	bf00      	nop

08005bcc <HAL_DMA_IRQHandler>:
{
 8005bcc:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8005bce:	e9d0 6310 	ldrd	r6, r3, [r0, #64]	; 0x40
 8005bd2:	2204      	movs	r2, #4
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8005bd4:	6831      	ldr	r1, [r6, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8005bd6:	6805      	ldr	r5, [r0, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8005bd8:	f003 031c 	and.w	r3, r3, #28
 8005bdc:	409a      	lsls	r2, r3
 8005bde:	420a      	tst	r2, r1
  uint32_t source_it = hdma->Instance->CCR;
 8005be0:	682c      	ldr	r4, [r5, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8005be2:	d00e      	beq.n	8005c02 <HAL_DMA_IRQHandler+0x36>
 8005be4:	f014 0f04 	tst.w	r4, #4
 8005be8:	d00b      	beq.n	8005c02 <HAL_DMA_IRQHandler+0x36>
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8005bea:	682b      	ldr	r3, [r5, #0]
 8005bec:	069b      	lsls	r3, r3, #26
 8005bee:	d403      	bmi.n	8005bf8 <HAL_DMA_IRQHandler+0x2c>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8005bf0:	682b      	ldr	r3, [r5, #0]
 8005bf2:	f023 0304 	bic.w	r3, r3, #4
 8005bf6:	602b      	str	r3, [r5, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 8005bf8:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 8005bfa:	6072      	str	r2, [r6, #4]
      if(hdma->XferHalfCpltCallback != NULL)
 8005bfc:	b1cb      	cbz	r3, 8005c32 <HAL_DMA_IRQHandler+0x66>
}
 8005bfe:	bc70      	pop	{r4, r5, r6}
      hdma->XferCpltCallback(hdma);
 8005c00:	4718      	bx	r3
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 8005c02:	2202      	movs	r2, #2
 8005c04:	409a      	lsls	r2, r3
 8005c06:	420a      	tst	r2, r1
 8005c08:	d015      	beq.n	8005c36 <HAL_DMA_IRQHandler+0x6a>
 8005c0a:	f014 0f02 	tst.w	r4, #2
 8005c0e:	d012      	beq.n	8005c36 <HAL_DMA_IRQHandler+0x6a>
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8005c10:	682b      	ldr	r3, [r5, #0]
 8005c12:	0699      	lsls	r1, r3, #26
 8005c14:	d406      	bmi.n	8005c24 <HAL_DMA_IRQHandler+0x58>
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8005c16:	682b      	ldr	r3, [r5, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8005c18:	2101      	movs	r1, #1
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8005c1a:	f023 030a 	bic.w	r3, r3, #10
 8005c1e:	602b      	str	r3, [r5, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8005c20:	f880 1025 	strb.w	r1, [r0, #37]	; 0x25
    if(hdma->XferCpltCallback != NULL)
 8005c24:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1CU));
 8005c26:	6072      	str	r2, [r6, #4]
    __HAL_UNLOCK(hdma);
 8005c28:	2200      	movs	r2, #0
 8005c2a:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    if(hdma->XferCpltCallback != NULL)
 8005c2e:	2b00      	cmp	r3, #0
 8005c30:	d1e5      	bne.n	8005bfe <HAL_DMA_IRQHandler+0x32>
}
 8005c32:	bc70      	pop	{r4, r5, r6}
 8005c34:	4770      	bx	lr
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) !=  0U))
 8005c36:	2208      	movs	r2, #8
 8005c38:	409a      	lsls	r2, r3
 8005c3a:	420a      	tst	r2, r1
 8005c3c:	d0f9      	beq.n	8005c32 <HAL_DMA_IRQHandler+0x66>
 8005c3e:	0722      	lsls	r2, r4, #28
 8005c40:	d5f7      	bpl.n	8005c32 <HAL_DMA_IRQHandler+0x66>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005c42:	682a      	ldr	r2, [r5, #0]
    if (hdma->XferErrorCallback != NULL)
 8005c44:	6b41      	ldr	r1, [r0, #52]	; 0x34
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005c46:	f022 020e 	bic.w	r2, r2, #14
 8005c4a:	602a      	str	r2, [r5, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005c4c:	2201      	movs	r2, #1
 8005c4e:	fa02 f303 	lsl.w	r3, r2, r3
    __HAL_UNLOCK(hdma);
 8005c52:	2400      	movs	r4, #0
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8005c54:	6073      	str	r3, [r6, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8005c56:	63c2      	str	r2, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 8005c58:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    hdma->State = HAL_DMA_STATE_READY;
 8005c5c:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
    if (hdma->XferErrorCallback != NULL)
 8005c60:	2900      	cmp	r1, #0
 8005c62:	d0e6      	beq.n	8005c32 <HAL_DMA_IRQHandler+0x66>
}
 8005c64:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 8005c66:	4708      	bx	r1

08005c68 <HAL_EXTI_RegisterCallback>:
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 8005c68:	b911      	cbnz	r1, 8005c70 <HAL_EXTI_RegisterCallback+0x8>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 8005c6a:	6042      	str	r2, [r0, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8005c6c:	4608      	mov	r0, r1
      break;
 8005c6e:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 8005c70:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 8005c72:	4770      	bx	lr

08005c74 <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 8005c74:	b110      	cbz	r0, 8005c7c <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 8005c76:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 8005c78:	2000      	movs	r0, #0
 8005c7a:	4770      	bx	lr
    return HAL_ERROR;
 8005c7c:	2001      	movs	r0, #1
  }
}
 8005c7e:	4770      	bx	lr

08005c80 <HAL_EXTI_IRQHandler>:
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 8005c80:	6803      	ldr	r3, [r0, #0]
 8005c82:	f3c3 4200 	ubfx	r2, r3, #16, #1
{
 8005c86:	b430      	push	{r4, r5}
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));

  /* Get pending bit  */
  regaddr = (&EXTI->PR1 + (EXTI_CONFIG_OFFSET * offset));
 8005c88:	0152      	lsls	r2, r2, #5
 8005c8a:	4c08      	ldr	r4, [pc, #32]	; (8005cac <HAL_EXTI_IRQHandler+0x2c>)
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
 8005c8c:	f003 031f 	and.w	r3, r3, #31
  regval = (*regaddr & maskline);
 8005c90:	5915      	ldr	r5, [r2, r4]
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
 8005c92:	2101      	movs	r1, #1
 8005c94:	fa01 f303 	lsl.w	r3, r1, r3

  if (regval != 0x00u)
 8005c98:	421d      	tst	r5, r3
 8005c9a:	d004      	beq.n	8005ca6 <HAL_EXTI_IRQHandler+0x26>
  {
    /* Clear pending bit */
    *regaddr = maskline;

    /* Call callback */
    if (hexti->PendingCallback != NULL)
 8005c9c:	6841      	ldr	r1, [r0, #4]
    *regaddr = maskline;
 8005c9e:	5113      	str	r3, [r2, r4]
    if (hexti->PendingCallback != NULL)
 8005ca0:	b109      	cbz	r1, 8005ca6 <HAL_EXTI_IRQHandler+0x26>
    {
      hexti->PendingCallback();
    }
  }
}
 8005ca2:	bc30      	pop	{r4, r5}
      hexti->PendingCallback();
 8005ca4:	4708      	bx	r1
}
 8005ca6:	bc30      	pop	{r4, r5}
 8005ca8:	4770      	bx	lr
 8005caa:	bf00      	nop
 8005cac:	40010414 	.word	0x40010414

08005cb0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8005cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8005cb4:	680e      	ldr	r6, [r1, #0]
{
 8005cb6:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8005cb8:	2e00      	cmp	r6, #0
 8005cba:	f000 80a0 	beq.w	8005dfe <HAL_GPIO_Init+0x14e>
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005cbe:	f8df 8228 	ldr.w	r8, [pc, #552]	; 8005ee8 <HAL_GPIO_Init+0x238>
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
        SYSCFG->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8005cc2:	f8df c228 	ldr.w	ip, [pc, #552]	; 8005eec <HAL_GPIO_Init+0x23c>
  uint32_t position = 0x00u;
 8005cc6:	2300      	movs	r3, #0
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8005cc8:	2201      	movs	r2, #1
 8005cca:	409a      	lsls	r2, r3
    if (iocurrent != 0x00u)
 8005ccc:	ea12 0e06 	ands.w	lr, r2, r6
 8005cd0:	f000 8090 	beq.w	8005df4 <HAL_GPIO_Init+0x144>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8005cd4:	684d      	ldr	r5, [r1, #4]
 8005cd6:	f025 0a10 	bic.w	sl, r5, #16
 8005cda:	f1ba 0f02 	cmp.w	sl, #2
 8005cde:	f000 8091 	beq.w	8005e04 <HAL_GPIO_Init+0x154>
      temp = GPIOx->MODER;
 8005ce2:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8005ce6:	ea4f 0943 	mov.w	r9, r3, lsl #1
 8005cea:	2403      	movs	r4, #3
 8005cec:	fa04 f409 	lsl.w	r4, r4, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8005cf0:	f005 0703 	and.w	r7, r5, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8005cf4:	ea2b 0b04 	bic.w	fp, fp, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8005cf8:	fa07 f709 	lsl.w	r7, r7, r9
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8005cfc:	f10a 3aff 	add.w	sl, sl, #4294967295
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8005d00:	ea47 070b 	orr.w	r7, r7, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8005d04:	f1ba 0f01 	cmp.w	sl, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8005d08:	ea6f 0404 	mvn.w	r4, r4
      GPIOx->MODER = temp;
 8005d0c:	6007      	str	r7, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8005d0e:	f240 809f 	bls.w	8005e50 <HAL_GPIO_Init+0x1a0>
      temp = GPIOx->PUPDR;
 8005d12:	68c7      	ldr	r7, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8005d14:	688a      	ldr	r2, [r1, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8005d16:	403c      	ands	r4, r7
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8005d18:	fa02 f209 	lsl.w	r2, r2, r9
 8005d1c:	4322      	orrs	r2, r4
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8005d1e:	00ef      	lsls	r7, r5, #3
      GPIOx->PUPDR = temp;
 8005d20:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8005d22:	d567      	bpl.n	8005df4 <HAL_GPIO_Init+0x144>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005d24:	f8d8 2060 	ldr.w	r2, [r8, #96]	; 0x60
 8005d28:	f042 0201 	orr.w	r2, r2, #1
 8005d2c:	f8c8 2060 	str.w	r2, [r8, #96]	; 0x60
 8005d30:	f8d8 2060 	ldr.w	r2, [r8, #96]	; 0x60
 8005d34:	f023 0403 	bic.w	r4, r3, #3
 8005d38:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8005d3c:	f002 0201 	and.w	r2, r2, #1
 8005d40:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 8005d44:	9201      	str	r2, [sp, #4]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8005d46:	f003 0703 	and.w	r7, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005d4a:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2u];
 8005d4c:	f8d4 9008 	ldr.w	r9, [r4, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8005d50:	00bf      	lsls	r7, r7, #2
 8005d52:	220f      	movs	r2, #15
 8005d54:	40ba      	lsls	r2, r7
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8005d56:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8005d5a:	ea29 0a02 	bic.w	sl, r9, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8005d5e:	d021      	beq.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005d60:	4a5a      	ldr	r2, [pc, #360]	; (8005ecc <HAL_GPIO_Init+0x21c>)
 8005d62:	4290      	cmp	r0, r2
 8005d64:	f000 808e 	beq.w	8005e84 <HAL_GPIO_Init+0x1d4>
 8005d68:	4a59      	ldr	r2, [pc, #356]	; (8005ed0 <HAL_GPIO_Init+0x220>)
 8005d6a:	4290      	cmp	r0, r2
 8005d6c:	f000 8091 	beq.w	8005e92 <HAL_GPIO_Init+0x1e2>
 8005d70:	4a58      	ldr	r2, [pc, #352]	; (8005ed4 <HAL_GPIO_Init+0x224>)
 8005d72:	4290      	cmp	r0, r2
 8005d74:	d07f      	beq.n	8005e76 <HAL_GPIO_Init+0x1c6>
 8005d76:	4a58      	ldr	r2, [pc, #352]	; (8005ed8 <HAL_GPIO_Init+0x228>)
 8005d78:	4290      	cmp	r0, r2
 8005d7a:	f000 8098 	beq.w	8005eae <HAL_GPIO_Init+0x1fe>
 8005d7e:	4a57      	ldr	r2, [pc, #348]	; (8005edc <HAL_GPIO_Init+0x22c>)
 8005d80:	4290      	cmp	r0, r2
 8005d82:	f000 809b 	beq.w	8005ebc <HAL_GPIO_Init+0x20c>
 8005d86:	4a56      	ldr	r2, [pc, #344]	; (8005ee0 <HAL_GPIO_Init+0x230>)
 8005d88:	4290      	cmp	r0, r2
 8005d8a:	f000 8089 	beq.w	8005ea0 <HAL_GPIO_Init+0x1f0>
 8005d8e:	4a55      	ldr	r2, [pc, #340]	; (8005ee4 <HAL_GPIO_Init+0x234>)
 8005d90:	4290      	cmp	r0, r2
 8005d92:	bf0c      	ite	eq
 8005d94:	f04f 0907 	moveq.w	r9, #7
 8005d98:	f04f 0908 	movne.w	r9, #8
 8005d9c:	fa09 f707 	lsl.w	r7, r9, r7
 8005da0:	ea4a 0a07 	orr.w	sl, sl, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 8005da4:	f8c4 a008 	str.w	sl, [r4, #8]
        temp = EXTI->IMR1;
 8005da8:	f8dc 2000 	ldr.w	r2, [ip]
        temp &= ~(iocurrent);
 8005dac:	ea6f 070e 	mvn.w	r7, lr
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8005db0:	03ec      	lsls	r4, r5, #15
        temp &= ~(iocurrent);
 8005db2:	bf54      	ite	pl
 8005db4:	403a      	andpl	r2, r7
        {
          temp |= iocurrent;
 8005db6:	ea4e 0202 	orrmi.w	r2, lr, r2
        }
        EXTI->IMR1 = temp;
 8005dba:	f8cc 2000 	str.w	r2, [ip]

        temp = EXTI->EMR1;
 8005dbe:	f8dc 4004 	ldr.w	r4, [ip, #4]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8005dc2:	03aa      	lsls	r2, r5, #14
        temp &= ~(iocurrent);
 8005dc4:	bf54      	ite	pl
 8005dc6:	403c      	andpl	r4, r7
        {
          temp |= iocurrent;
 8005dc8:	ea4e 0404 	orrmi.w	r4, lr, r4
        }
        EXTI->EMR1 = temp;
 8005dcc:	f8cc 4004 	str.w	r4, [ip, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8005dd0:	f8dc 4008 	ldr.w	r4, [ip, #8]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8005dd4:	02ea      	lsls	r2, r5, #11
        temp &= ~(iocurrent);
 8005dd6:	bf54      	ite	pl
 8005dd8:	403c      	andpl	r4, r7
        {
          temp |= iocurrent;
 8005dda:	ea4e 0404 	orrmi.w	r4, lr, r4
        }
        EXTI->RTSR1 = temp;
 8005dde:	f8cc 4008 	str.w	r4, [ip, #8]

        temp = EXTI->FTSR1;
 8005de2:	f8dc 200c 	ldr.w	r2, [ip, #12]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8005de6:	02ac      	lsls	r4, r5, #10
        temp &= ~(iocurrent);
 8005de8:	bf54      	ite	pl
 8005dea:	403a      	andpl	r2, r7
        {
          temp |= iocurrent;
 8005dec:	ea4e 0202 	orrmi.w	r2, lr, r2
        }
        EXTI->FTSR1 = temp;
 8005df0:	f8cc 200c 	str.w	r2, [ip, #12]
      }
    }

    position++;
 8005df4:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8005df6:	fa36 f203 	lsrs.w	r2, r6, r3
 8005dfa:	f47f af65 	bne.w	8005cc8 <HAL_GPIO_Init+0x18>
  }
}
 8005dfe:	b003      	add	sp, #12
 8005e00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->AFR[position >> 3u];
 8005e04:	ea4f 09d3 	mov.w	r9, r3, lsr #3
 8005e08:	eb00 0989 	add.w	r9, r0, r9, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8005e0c:	f003 0707 	and.w	r7, r3, #7
        temp = GPIOx->AFR[position >> 3u];
 8005e10:	f8d9 4020 	ldr.w	r4, [r9, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8005e14:	00bf      	lsls	r7, r7, #2
 8005e16:	f04f 0b0f 	mov.w	fp, #15
 8005e1a:	fa0b fb07 	lsl.w	fp, fp, r7
 8005e1e:	ea24 0a0b 	bic.w	sl, r4, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8005e22:	690c      	ldr	r4, [r1, #16]
 8005e24:	40bc      	lsls	r4, r7
 8005e26:	ea44 040a 	orr.w	r4, r4, sl
        GPIOx->AFR[position >> 3u] = temp;
 8005e2a:	f8c9 4020 	str.w	r4, [r9, #32]
      temp = GPIOx->MODER;
 8005e2e:	f8d0 a000 	ldr.w	sl, [r0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8005e32:	ea4f 0943 	mov.w	r9, r3, lsl #1
 8005e36:	2403      	movs	r4, #3
 8005e38:	fa04 f409 	lsl.w	r4, r4, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8005e3c:	f005 0703 	and.w	r7, r5, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8005e40:	ea2a 0a04 	bic.w	sl, sl, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8005e44:	fa07 f709 	lsl.w	r7, r7, r9
 8005e48:	ea47 070a 	orr.w	r7, r7, sl
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 8005e4c:	43e4      	mvns	r4, r4
      GPIOx->MODER = temp;
 8005e4e:	6007      	str	r7, [r0, #0]
        temp = GPIOx->OSPEEDR;
 8005e50:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8005e52:	ea04 0a07 	and.w	sl, r4, r7
        temp |= (GPIO_Init->Speed << (position * 2u));
 8005e56:	68cf      	ldr	r7, [r1, #12]
 8005e58:	fa07 f709 	lsl.w	r7, r7, r9
 8005e5c:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 8005e60:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8005e62:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8005e66:	f3c5 1700 	ubfx	r7, r5, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8005e6a:	ea2a 0202 	bic.w	r2, sl, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8005e6e:	409f      	lsls	r7, r3
 8005e70:	4317      	orrs	r7, r2
        GPIOx->OTYPER = temp;
 8005e72:	6047      	str	r7, [r0, #4]
 8005e74:	e74d      	b.n	8005d12 <HAL_GPIO_Init+0x62>
 8005e76:	f04f 0903 	mov.w	r9, #3
 8005e7a:	fa09 f707 	lsl.w	r7, r9, r7
 8005e7e:	ea4a 0a07 	orr.w	sl, sl, r7
 8005e82:	e78f      	b.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005e84:	f04f 0901 	mov.w	r9, #1
 8005e88:	fa09 f707 	lsl.w	r7, r9, r7
 8005e8c:	ea4a 0a07 	orr.w	sl, sl, r7
 8005e90:	e788      	b.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005e92:	f04f 0902 	mov.w	r9, #2
 8005e96:	fa09 f707 	lsl.w	r7, r9, r7
 8005e9a:	ea4a 0a07 	orr.w	sl, sl, r7
 8005e9e:	e781      	b.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005ea0:	f04f 0906 	mov.w	r9, #6
 8005ea4:	fa09 f707 	lsl.w	r7, r9, r7
 8005ea8:	ea4a 0a07 	orr.w	sl, sl, r7
 8005eac:	e77a      	b.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005eae:	f04f 0904 	mov.w	r9, #4
 8005eb2:	fa09 f707 	lsl.w	r7, r9, r7
 8005eb6:	ea4a 0a07 	orr.w	sl, sl, r7
 8005eba:	e773      	b.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005ebc:	f04f 0905 	mov.w	r9, #5
 8005ec0:	fa09 f707 	lsl.w	r7, r9, r7
 8005ec4:	ea4a 0a07 	orr.w	sl, sl, r7
 8005ec8:	e76c      	b.n	8005da4 <HAL_GPIO_Init+0xf4>
 8005eca:	bf00      	nop
 8005ecc:	48000400 	.word	0x48000400
 8005ed0:	48000800 	.word	0x48000800
 8005ed4:	48000c00 	.word	0x48000c00
 8005ed8:	48001000 	.word	0x48001000
 8005edc:	48001400 	.word	0x48001400
 8005ee0:	48001800 	.word	0x48001800
 8005ee4:	48001c00 	.word	0x48001c00
 8005ee8:	40021000 	.word	0x40021000
 8005eec:	40010400 	.word	0x40010400

08005ef0 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 8005ef0:	6903      	ldr	r3, [r0, #16]
 8005ef2:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8005ef4:	bf14      	ite	ne
 8005ef6:	2001      	movne	r0, #1
 8005ef8:	2000      	moveq	r0, #0
 8005efa:	4770      	bx	lr

08005efc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8005efc:	b10a      	cbz	r2, 8005f02 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8005efe:	6181      	str	r1, [r0, #24]
 8005f00:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8005f02:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8005f04:	4770      	bx	lr
 8005f06:	bf00      	nop

08005f08 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != 0x00u)
 8005f08:	6943      	ldr	r3, [r0, #20]
 8005f0a:	420b      	tst	r3, r1
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8005f0c:	bf14      	ite	ne
 8005f0e:	6281      	strne	r1, [r0, #40]	; 0x28
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8005f10:	6181      	streq	r1, [r0, #24]
  }
}
 8005f12:	4770      	bx	lr

08005f14 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8005f14:	4a04      	ldr	r2, [pc, #16]	; (8005f28 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 8005f16:	6951      	ldr	r1, [r2, #20]
 8005f18:	4201      	tst	r1, r0
 8005f1a:	d100      	bne.n	8005f1e <HAL_GPIO_EXTI_IRQHandler+0xa>
 8005f1c:	4770      	bx	lr
{
 8005f1e:	b508      	push	{r3, lr}
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8005f20:	6150      	str	r0, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8005f22:	f7fd fc4f 	bl	80037c4 <HAL_GPIO_EXTI_Callback>
  }
}
 8005f26:	bd08      	pop	{r3, pc}
 8005f28:	40010400 	.word	0x40010400

08005f2c <I2C_DMAAbort>:
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8005f2c:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* Reset AbortCpltCallback */
  hi2c->hdmatx->XferAbortCallback = NULL;
  hi2c->hdmarx->XferAbortCallback = NULL;
 8005f2e:	e9d0 120e 	ldrd	r1, r2, [r0, #56]	; 0x38
  hi2c->hdmatx->XferAbortCallback = NULL;
 8005f32:	2300      	movs	r3, #0
 8005f34:	638b      	str	r3, [r1, #56]	; 0x38
  hi2c->hdmarx->XferAbortCallback = NULL;
 8005f36:	6393      	str	r3, [r2, #56]	; 0x38

  /* Check if come from abort from user */
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8005f38:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8005f3c:	2b60      	cmp	r3, #96	; 0x60
 8005f3e:	d001      	beq.n	8005f44 <I2C_DMAAbort+0x18>
  }
  else
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ErrorCallback(hi2c);
 8005f40:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8005f42:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
 8005f44:	2320      	movs	r3, #32
 8005f46:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    hi2c->AbortCpltCallback(hi2c);
 8005f4a:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8005f4c:	4718      	bx	r3
 8005f4e:	bf00      	nop

08005f50 <I2C_ITError>:
{
 8005f50:	b570      	push	{r4, r5, r6, lr}
 8005f52:	4604      	mov	r4, r0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8005f54:	4a40      	ldr	r2, [pc, #256]	; (8006058 <I2C_ITError+0x108>)
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8005f56:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8005f5a:	2000      	movs	r0, #0
 8005f5c:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8005f60:	62e2      	str	r2, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8005f62:	8560      	strh	r0, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8005f64:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8005f66:	3b28      	subs	r3, #40	; 0x28
  hi2c->ErrorCode |= ErrorCode;
 8005f68:	4311      	orrs	r1, r2
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8005f6a:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
 8005f6c:	6461      	str	r1, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8005f6e:	d83d      	bhi.n	8005fec <I2C_ITError+0x9c>
  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f70:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f74:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8005f78:	6823      	ldr	r3, [r4, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8005f7a:	4d38      	ldr	r5, [pc, #224]	; (800605c <I2C_ITError+0x10c>)
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f7c:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8005f80:	2928      	cmp	r1, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f82:	f002 0228 	and.w	r2, r2, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f86:	bf14      	ite	ne
 8005f88:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
 8005f8c:	f06f 0146 	mvneq.w	r1, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f90:	2a28      	cmp	r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8005f92:	681a      	ldr	r2, [r3, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005f94:	bf18      	it	ne
 8005f96:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8005f9a:	400a      	ands	r2, r1
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8005f9c:	2128      	movs	r1, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8005f9e:	601a      	str	r2, [r3, #0]
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8005fa0:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8005fa4:	6365      	str	r5, [r4, #52]	; 0x34
    hi2c->PreviousState = I2C_STATE_NONE;
 8005fa6:	6320      	str	r0, [r4, #48]	; 0x30
  if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8005fa8:	681a      	ldr	r2, [r3, #0]
 8005faa:	f412 4280 	ands.w	r2, r2, #16384	; 0x4000
 8005fae:	d012      	beq.n	8005fd6 <I2C_ITError+0x86>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8005fb0:	681a      	ldr	r2, [r3, #0]
    if (hi2c->hdmatx != NULL)
 8005fb2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8005fb4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8005fb8:	601a      	str	r2, [r3, #0]
    if (hi2c->hdmatx != NULL)
 8005fba:	b1b0      	cbz	r0, 8005fea <I2C_ITError+0x9a>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8005fbc:	4b28      	ldr	r3, [pc, #160]	; (8006060 <I2C_ITError+0x110>)
 8005fbe:	6383      	str	r3, [r0, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8005fc0:	2300      	movs	r3, #0
 8005fc2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8005fc6:	f7ff fdc9 	bl	8005b5c <HAL_DMA_Abort_IT>
 8005fca:	b170      	cbz	r0, 8005fea <I2C_ITError+0x9a>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8005fcc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 8005fce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8005fd2:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8005fd4:	4718      	bx	r3
  else if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8005fd6:	6819      	ldr	r1, [r3, #0]
 8005fd8:	f411 4100 	ands.w	r1, r1, #32768	; 0x8000
 8005fdc:	d01a      	beq.n	8006014 <I2C_ITError+0xc4>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8005fde:	6819      	ldr	r1, [r3, #0]
    if (hi2c->hdmarx != NULL)
 8005fe0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8005fe2:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8005fe6:	6019      	str	r1, [r3, #0]
    if (hi2c->hdmarx != NULL)
 8005fe8:	b9f8      	cbnz	r0, 800602a <I2C_ITError+0xda>
}
 8005fea:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8005fec:	6823      	ldr	r3, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005fee:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8005ff2:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8005ff6:	681a      	ldr	r2, [r3, #0]
 8005ff8:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
 8005ffc:	601a      	str	r2, [r3, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8005ffe:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8006002:	2a60      	cmp	r2, #96	; 0x60
      hi2c->State         = HAL_I2C_STATE_READY;
 8006004:	bf1c      	itt	ne
 8006006:	2220      	movne	r2, #32
 8006008:	f884 2041 	strbne.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 800600c:	2200      	movs	r2, #0
 800600e:	6322      	str	r2, [r4, #48]	; 0x30
    hi2c->XferISR       = NULL;
 8006010:	6362      	str	r2, [r4, #52]	; 0x34
 8006012:	e7c9      	b.n	8005fa8 <I2C_ITError+0x58>
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 8006014:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006018:	2b60      	cmp	r3, #96	; 0x60
 800601a:	d013      	beq.n	8006044 <I2C_ITError+0xf4>
    __HAL_UNLOCK(hi2c);
 800601c:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCallback(hi2c);
 8006020:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8006022:	4620      	mov	r0, r4
}
 8006024:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hi2c->ErrorCallback(hi2c);
 8006028:	4718      	bx	r3
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800602a:	4b0d      	ldr	r3, [pc, #52]	; (8006060 <I2C_ITError+0x110>)
 800602c:	6383      	str	r3, [r0, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 800602e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8006032:	f7ff fd93 	bl	8005b5c <HAL_DMA_Abort_IT>
 8006036:	2800      	cmp	r0, #0
 8006038:	d0d7      	beq.n	8005fea <I2C_ITError+0x9a>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800603a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 800603c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8006040:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8006042:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
 8006044:	2320      	movs	r3, #32
 8006046:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800604a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->AbortCpltCallback(hi2c);
 800604e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8006050:	4620      	mov	r0, r4
}
 8006052:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hi2c->AbortCpltCallback(hi2c);
 8006056:	4718      	bx	r3
 8006058:	ffff0000 	.word	0xffff0000
 800605c:	080062dd 	.word	0x080062dd
 8006060:	08005f2d 	.word	0x08005f2d

08006064 <I2C_ITListenCplt>:
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8006064:	4b18      	ldr	r3, [pc, #96]	; (80060c8 <I2C_ITListenCplt+0x64>)
 8006066:	62c3      	str	r3, [r0, #44]	; 0x2c
  hi2c->State = HAL_I2C_STATE_READY;
 8006068:	2220      	movs	r2, #32
  hi2c->PreviousState = I2C_STATE_NONE;
 800606a:	2300      	movs	r3, #0
 800606c:	6303      	str	r3, [r0, #48]	; 0x30
  hi2c->XferISR = NULL;
 800606e:	6343      	str	r3, [r0, #52]	; 0x34
  hi2c->State = HAL_I2C_STATE_READY;
 8006070:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006074:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8006078:	074b      	lsls	r3, r1, #29
{
 800607a:	b430      	push	{r4, r5}
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 800607c:	d512      	bpl.n	80060a4 <I2C_ITListenCplt+0x40>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800607e:	6802      	ldr	r2, [r0, #0]
 8006080:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8006082:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8006084:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8006086:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006088:	8d02      	ldrh	r2, [r0, #40]	; 0x28
    hi2c->pBuffPtr++;
 800608a:	3301      	adds	r3, #1
 800608c:	6243      	str	r3, [r0, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 800608e:	b14a      	cbz	r2, 80060a4 <I2C_ITListenCplt+0x40>
      hi2c->XferCount--;
 8006090:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8006092:	3b01      	subs	r3, #1
 8006094:	b29b      	uxth	r3, r3
 8006096:	8543      	strh	r3, [r0, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006098:	6c43      	ldr	r3, [r0, #68]	; 0x44
      hi2c->XferSize--;
 800609a:	3a01      	subs	r2, #1
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800609c:	f043 0304 	orr.w	r3, r3, #4
      hi2c->XferSize--;
 80060a0:	8502      	strh	r2, [r0, #40]	; 0x28
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80060a2:	6443      	str	r3, [r0, #68]	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80060a4:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80060a6:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80060aa:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80060ae:	681a      	ldr	r2, [r3, #0]
  hi2c->ListenCpltCallback(hi2c);
 80060b0:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80060b2:	2510      	movs	r5, #16
  __HAL_UNLOCK(hi2c);
 80060b4:	2400      	movs	r4, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80060b6:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
 80060ba:	601a      	str	r2, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80060bc:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 80060be:	f880 4040 	strb.w	r4, [r0, #64]	; 0x40
}
 80060c2:	bc30      	pop	{r4, r5}
  hi2c->ListenCpltCallback(hi2c);
 80060c4:	4708      	bx	r1
 80060c6:	bf00      	nop
 80060c8:	ffff0000 	.word	0xffff0000

080060cc <I2C_ITAddrCplt.isra.0.part.0>:
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
 80060cc:	b4f0      	push	{r4, r5, r6, r7}
    transferdirection = I2C_GET_DIR(hi2c);
 80060ce:	6805      	ldr	r5, [r0, #0]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80060d0:	68c3      	ldr	r3, [r0, #12]
    transferdirection = I2C_GET_DIR(hi2c);
 80060d2:	69a9      	ldr	r1, [r5, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80060d4:	69aa      	ldr	r2, [r5, #24]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80060d6:	68ae      	ldr	r6, [r5, #8]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 80060d8:	68ef      	ldr	r7, [r5, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80060da:	0c12      	lsrs	r2, r2, #16
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80060dc:	2b02      	cmp	r3, #2
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
 80060de:	4604      	mov	r4, r0
    transferdirection = I2C_GET_DIR(hi2c);
 80060e0:	f3c1 4100 	ubfx	r1, r1, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80060e4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80060e8:	d10e      	bne.n	8006108 <I2C_ITAddrCplt.isra.0.part.0+0x3c>
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
 80060ea:	ea82 13d6 	eor.w	r3, r2, r6, lsr #7
 80060ee:	f013 0306 	ands.w	r3, r3, #6
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80060f2:	f3c6 0209 	ubfx	r2, r6, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
 80060f6:	d112      	bne.n	800611e <I2C_ITAddrCplt.isra.0.part.0+0x52>
        hi2c->AddrEventCount++;
 80060f8:	6c86      	ldr	r6, [r0, #72]	; 0x48
 80060fa:	3601      	adds	r6, #1
 80060fc:	6486      	str	r6, [r0, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
 80060fe:	6c86      	ldr	r6, [r0, #72]	; 0x48
 8006100:	2e02      	cmp	r6, #2
 8006102:	d013      	beq.n	800612c <I2C_ITAddrCplt.isra.0.part.0+0x60>
}
 8006104:	bcf0      	pop	{r4, r5, r6, r7}
 8006106:	4770      	bx	lr
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006108:	682b      	ldr	r3, [r5, #0]
      hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 800610a:	6f06      	ldr	r6, [r0, #112]	; 0x70
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800610c:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
 8006110:	602b      	str	r3, [r5, #0]
      __HAL_UNLOCK(hi2c);
 8006112:	2300      	movs	r3, #0
 8006114:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006118:	4633      	mov	r3, r6
}
 800611a:	bcf0      	pop	{r4, r5, r6, r7}
      hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 800611c:	4718      	bx	r3
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800611e:	682b      	ldr	r3, [r5, #0]
        hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006120:	6f06      	ldr	r6, [r0, #112]	; 0x70
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006122:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
        hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006126:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
 800612a:	e7f1      	b.n	8006110 <I2C_ITAddrCplt.isra.0.part.0+0x44>
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 800612c:	2608      	movs	r6, #8
          hi2c->AddrEventCount = 0U;
 800612e:	6483      	str	r3, [r0, #72]	; 0x48
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8006130:	61ee      	str	r6, [r5, #28]
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006132:	6f05      	ldr	r5, [r0, #112]	; 0x70
          __HAL_UNLOCK(hi2c);
 8006134:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8006138:	462b      	mov	r3, r5
}
 800613a:	bcf0      	pop	{r4, r5, r6, r7}
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
 800613c:	4718      	bx	r3
 800613e:	bf00      	nop

08006140 <I2C_ITSlaveSeqCplt>:
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006140:	2100      	movs	r1, #0
 8006142:	f880 1042 	strb.w	r1, [r0, #66]	; 0x42
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8006146:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 800614a:	2a29      	cmp	r2, #41	; 0x29
{
 800614c:	b4f0      	push	{r4, r5, r6, r7}
 800614e:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8006150:	d005      	beq.n	800615e <I2C_ITSlaveSeqCplt+0x1e>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8006152:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8006156:	2a2a      	cmp	r2, #42	; 0x2a
 8006158:	d01a      	beq.n	8006190 <I2C_ITSlaveSeqCplt+0x50>
}
 800615a:	bcf0      	pop	{r4, r5, r6, r7}
 800615c:	4770      	bx	lr
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800615e:	2428      	movs	r4, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8006160:	2221      	movs	r2, #33	; 0x21
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006162:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8006166:	6302      	str	r2, [r0, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006168:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800616c:	6805      	ldr	r5, [r0, #0]
    hi2c->SlaveTxCpltCallback(hi2c);
 800616e:	6d46      	ldr	r6, [r0, #84]	; 0x54
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006170:	682a      	ldr	r2, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8006172:	f004 0428 	and.w	r4, r4, #40	; 0x28
 8006176:	2c28      	cmp	r4, #40	; 0x28
 8006178:	bf0c      	ite	eq
 800617a:	f06f 0442 	mvneq.w	r4, #66	; 0x42
 800617e:	f06f 04f2 	mvnne.w	r4, #242	; 0xf2
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8006182:	4022      	ands	r2, r4
 8006184:	602a      	str	r2, [r5, #0]
    __HAL_UNLOCK(hi2c);
 8006186:	f883 1040 	strb.w	r1, [r3, #64]	; 0x40
    hi2c->SlaveRxCpltCallback(hi2c);
 800618a:	4633      	mov	r3, r6
}
 800618c:	bcf0      	pop	{r4, r5, r6, r7}
    hi2c->SlaveRxCpltCallback(hi2c);
 800618e:	4718      	bx	r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8006190:	2222      	movs	r2, #34	; 0x22
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8006192:	2428      	movs	r4, #40	; 0x28
 8006194:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8006198:	6302      	str	r2, [r0, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800619a:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800619e:	6805      	ldr	r5, [r0, #0]
    hi2c->SlaveRxCpltCallback(hi2c);
 80061a0:	6d86      	ldr	r6, [r0, #88]	; 0x58
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80061a2:	682f      	ldr	r7, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80061a4:	f004 0428 	and.w	r4, r4, #40	; 0x28
 80061a8:	2c28      	cmp	r4, #40	; 0x28
 80061aa:	bf0c      	ite	eq
 80061ac:	f06f 0244 	mvneq.w	r2, #68	; 0x44
 80061b0:	f06f 02f4 	mvnne.w	r2, #244	; 0xf4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80061b4:	403a      	ands	r2, r7
 80061b6:	602a      	str	r2, [r5, #0]
    __HAL_UNLOCK(hi2c);
 80061b8:	f883 1040 	strb.w	r1, [r3, #64]	; 0x40
    hi2c->SlaveRxCpltCallback(hi2c);
 80061bc:	4633      	mov	r3, r6
}
 80061be:	bcf0      	pop	{r4, r5, r6, r7}
    hi2c->SlaveRxCpltCallback(hi2c);
 80061c0:	4718      	bx	r3
 80061c2:	bf00      	nop

080061c4 <I2C_ITSlaveCplt>:
{
 80061c4:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 80061c6:	6803      	ldr	r3, [r0, #0]
  I2C_RESET_CR2(hi2c);
 80061c8:	4d42      	ldr	r5, [pc, #264]	; (80062d4 <I2C_ITSlaveCplt+0x110>)
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 80061ca:	681e      	ldr	r6, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80061cc:	2220      	movs	r2, #32
 80061ce:	61da      	str	r2, [r3, #28]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80061d0:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80061d4:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
{
 80061d8:	4604      	mov	r4, r0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80061da:	6818      	ldr	r0, [r3, #0]
 80061dc:	f020 00fe 	bic.w	r0, r0, #254	; 0xfe
 80061e0:	6018      	str	r0, [r3, #0]
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80061e2:	6858      	ldr	r0, [r3, #4]
 80061e4:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 80061e8:	6058      	str	r0, [r3, #4]
  I2C_RESET_CR2(hi2c);
 80061ea:	685a      	ldr	r2, [r3, #4]
 80061ec:	402a      	ands	r2, r5
 80061ee:	605a      	str	r2, [r3, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80061f0:	699a      	ldr	r2, [r3, #24]
{
 80061f2:	460d      	mov	r5, r1
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80061f4:	0791      	lsls	r1, r2, #30
    hi2c->Instance->TXDR = 0x00U;
 80061f6:	bf44      	itt	mi
 80061f8:	2200      	movmi	r2, #0
 80061fa:	629a      	strmi	r2, [r3, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80061fc:	699a      	ldr	r2, [r3, #24]
 80061fe:	07d2      	lsls	r2, r2, #31
 8006200:	d403      	bmi.n	800620a <I2C_ITSlaveCplt+0x46>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8006202:	699a      	ldr	r2, [r3, #24]
 8006204:	f042 0201 	orr.w	r2, r2, #1
 8006208:	619a      	str	r2, [r3, #24]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 800620a:	0470      	lsls	r0, r6, #17
 800620c:	d547      	bpl.n	800629e <I2C_ITSlaveCplt+0xda>
    if (hi2c->hdmatx != NULL)
 800620e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8006210:	b11a      	cbz	r2, 800621a <I2C_ITSlaveCplt+0x56>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
 8006212:	6812      	ldr	r2, [r2, #0]
 8006214:	6852      	ldr	r2, [r2, #4]
 8006216:	b292      	uxth	r2, r2
 8006218:	8562      	strh	r2, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
 800621a:	076a      	lsls	r2, r5, #29
 800621c:	d509      	bpl.n	8006232 <I2C_ITSlaveCplt+0x6e>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800621e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006220:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006222:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr++;
 8006224:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006226:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8006228:	3301      	adds	r3, #1
    tmpITFlags &= ~I2C_FLAG_RXNE;
 800622a:	f025 0504 	bic.w	r5, r5, #4
    hi2c->pBuffPtr++;
 800622e:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8006230:	bb72      	cbnz	r2, 8006290 <I2C_ITSlaveCplt+0xcc>
  if (hi2c->XferCount != 0U)
 8006232:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006234:	b29b      	uxth	r3, r3
 8006236:	b11b      	cbz	r3, 8006240 <I2C_ITSlaveCplt+0x7c>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8006238:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800623a:	f043 0304 	orr.w	r3, r3, #4
 800623e:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->PreviousState = I2C_STATE_NONE;
 8006240:	2300      	movs	r3, #0
 8006242:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006244:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8006248:	6c66      	ldr	r6, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
 800624a:	6363      	str	r3, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800624c:	bb6e      	cbnz	r6, 80062aa <I2C_ITSlaveCplt+0xe6>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 800624e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006250:	4d21      	ldr	r5, [pc, #132]	; (80062d8 <I2C_ITSlaveCplt+0x114>)
 8006252:	42ab      	cmp	r3, r5
 8006254:	d10e      	bne.n	8006274 <I2C_ITSlaveCplt+0xb0>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8006256:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800625a:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800625e:	2b22      	cmp	r3, #34	; 0x22
    hi2c->State = HAL_I2C_STATE_READY;
 8006260:	f04f 0320 	mov.w	r3, #32
 8006264:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8006268:	d028      	beq.n	80062bc <I2C_ITSlaveCplt+0xf8>
    hi2c->SlaveTxCpltCallback(hi2c);
 800626a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800626c:	4620      	mov	r0, r4
}
 800626e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hi2c->SlaveTxCpltCallback(hi2c);
 8006272:	4718      	bx	r3
    I2C_ITSlaveSeqCplt(hi2c);
 8006274:	4620      	mov	r0, r4
 8006276:	f7ff ff63 	bl	8006140 <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
 800627a:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800627c:	62e5      	str	r5, [r4, #44]	; 0x2c
    __HAL_UNLOCK(hi2c);
 800627e:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 8006282:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->ListenCpltCallback(hi2c);
 8006286:	4620      	mov	r0, r4
 8006288:	6de3      	ldr	r3, [r4, #92]	; 0x5c
}
 800628a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hi2c->ListenCpltCallback(hi2c);
 800628e:	4718      	bx	r3
      hi2c->XferCount--;
 8006290:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006292:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8006294:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8006296:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8006298:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 800629a:	8563      	strh	r3, [r4, #42]	; 0x2a
 800629c:	e7c9      	b.n	8006232 <I2C_ITSlaveCplt+0x6e>
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 800629e:	0431      	lsls	r1, r6, #16
 80062a0:	d5bb      	bpl.n	800621a <I2C_ITSlaveCplt+0x56>
    if (hi2c->hdmarx != NULL)
 80062a2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80062a4:	2a00      	cmp	r2, #0
 80062a6:	d1b4      	bne.n	8006212 <I2C_ITSlaveCplt+0x4e>
 80062a8:	e7b7      	b.n	800621a <I2C_ITSlaveCplt+0x56>
    I2C_ITError(hi2c, hi2c->ErrorCode);
 80062aa:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80062ac:	4620      	mov	r0, r4
 80062ae:	f7ff fe4f 	bl	8005f50 <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 80062b2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80062b6:	2b28      	cmp	r3, #40	; 0x28
 80062b8:	d005      	beq.n	80062c6 <I2C_ITSlaveCplt+0x102>
}
 80062ba:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->SlaveRxCpltCallback(hi2c);
 80062bc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80062be:	4620      	mov	r0, r4
}
 80062c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hi2c->SlaveRxCpltCallback(hi2c);
 80062c4:	4718      	bx	r3
      I2C_ITListenCplt(hi2c, tmpITFlags);
 80062c6:	4629      	mov	r1, r5
 80062c8:	4620      	mov	r0, r4
}
 80062ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      I2C_ITListenCplt(hi2c, tmpITFlags);
 80062ce:	f7ff bec9 	b.w	8006064 <I2C_ITListenCplt>
 80062d2:	bf00      	nop
 80062d4:	fe00e800 	.word	0xfe00e800
 80062d8:	ffff0000 	.word	0xffff0000

080062dc <I2C_Slave_ISR_IT>:
{
 80062dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
 80062de:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
 80062e2:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
 80062e4:	2b01      	cmp	r3, #1
 80062e6:	d078      	beq.n	80063da <I2C_Slave_ISR_IT+0xfe>
 80062e8:	4617      	mov	r7, r2
 80062ea:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 80062ec:	068a      	lsls	r2, r1, #26
 80062ee:	4604      	mov	r4, r0
 80062f0:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
 80062f2:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 80062f6:	d501      	bpl.n	80062fc <I2C_Slave_ISR_IT+0x20>
 80062f8:	06bb      	lsls	r3, r7, #26
 80062fa:	d45a      	bmi.n	80063b2 <I2C_Slave_ISR_IT+0xd6>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 80062fc:	06ea      	lsls	r2, r5, #27
 80062fe:	d515      	bpl.n	800632c <I2C_Slave_ISR_IT+0x50>
 8006300:	06fb      	lsls	r3, r7, #27
 8006302:	d513      	bpl.n	800632c <I2C_Slave_ISR_IT+0x50>
    if (hi2c->XferCount == 0U)
 8006304:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006306:	b29b      	uxth	r3, r3
 8006308:	2b00      	cmp	r3, #0
 800630a:	d157      	bne.n	80063bc <I2C_Slave_ISR_IT+0xe0>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
 800630c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006310:	2b28      	cmp	r3, #40	; 0x28
 8006312:	d07c      	beq.n	800640e <I2C_Slave_ISR_IT+0x132>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8006314:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8006318:	2b29      	cmp	r3, #41	; 0x29
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800631a:	6823      	ldr	r3, [r4, #0]
 800631c:	f04f 0210 	mov.w	r2, #16
 8006320:	61da      	str	r2, [r3, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8006322:	d060      	beq.n	80063e6 <I2C_Slave_ISR_IT+0x10a>
  __HAL_UNLOCK(hi2c);
 8006324:	2000      	movs	r0, #0
 8006326:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 800632a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 800632c:	076a      	lsls	r2, r5, #29
 800632e:	d40d      	bmi.n	800634c <I2C_Slave_ISR_IT+0x70>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 8006330:	0728      	lsls	r0, r5, #28
 8006332:	d529      	bpl.n	8006388 <I2C_Slave_ISR_IT+0xac>
 8006334:	0739      	lsls	r1, r7, #28
 8006336:	d527      	bpl.n	8006388 <I2C_Slave_ISR_IT+0xac>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8006338:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800633c:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8006340:	2b28      	cmp	r3, #40	; 0x28
 8006342:	d060      	beq.n	8006406 <I2C_Slave_ISR_IT+0x12a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8006344:	6823      	ldr	r3, [r4, #0]
 8006346:	2208      	movs	r2, #8
 8006348:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
 800634a:	e7eb      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 800634c:	077b      	lsls	r3, r7, #29
 800634e:	d5ef      	bpl.n	8006330 <I2C_Slave_ISR_IT+0x54>
    if (hi2c->XferCount > 0U)
 8006350:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006352:	b29b      	uxth	r3, r3
 8006354:	b16b      	cbz	r3, 8006372 <I2C_Slave_ISR_IT+0x96>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006356:	6822      	ldr	r2, [r4, #0]
 8006358:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800635a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800635c:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 800635e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 8006360:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8006362:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8006364:	3b01      	subs	r3, #1
 8006366:	b29b      	uxth	r3, r3
      hi2c->pBuffPtr++;
 8006368:	3101      	adds	r1, #1
      hi2c->XferSize--;
 800636a:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 800636c:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 800636e:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8006370:	8522      	strh	r2, [r4, #40]	; 0x28
    if ((hi2c->XferCount == 0U) && \
 8006372:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006374:	b29b      	uxth	r3, r3
 8006376:	2b00      	cmp	r3, #0
 8006378:	d1d4      	bne.n	8006324 <I2C_Slave_ISR_IT+0x48>
 800637a:	f516 3f80 	cmn.w	r6, #65536	; 0x10000
 800637e:	d0d1      	beq.n	8006324 <I2C_Slave_ISR_IT+0x48>
        I2C_ITSlaveSeqCplt(hi2c);
 8006380:	4620      	mov	r0, r4
 8006382:	f7ff fedd 	bl	8006140 <I2C_ITSlaveSeqCplt>
 8006386:	e7cd      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 8006388:	07aa      	lsls	r2, r5, #30
 800638a:	d5cb      	bpl.n	8006324 <I2C_Slave_ISR_IT+0x48>
 800638c:	07bb      	lsls	r3, r7, #30
 800638e:	d5c9      	bpl.n	8006324 <I2C_Slave_ISR_IT+0x48>
    if (hi2c->XferCount > 0U)
 8006390:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8006392:	b29b      	uxth	r3, r3
 8006394:	b31b      	cbz	r3, 80063de <I2C_Slave_ISR_IT+0x102>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8006396:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8006398:	6823      	ldr	r3, [r4, #0]
 800639a:	f811 2b01 	ldrb.w	r2, [r1], #1
 800639e:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 80063a0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80063a2:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->pBuffPtr++;
 80063a4:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
 80063a6:	3b01      	subs	r3, #1
 80063a8:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 80063aa:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 80063ac:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80063ae:	8522      	strh	r2, [r4, #40]	; 0x28
 80063b0:	e7b8      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
 80063b2:	f7ff ff07 	bl	80061c4 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 80063b6:	06ea      	lsls	r2, r5, #27
 80063b8:	d5b8      	bpl.n	800632c <I2C_Slave_ISR_IT+0x50>
 80063ba:	e7a1      	b.n	8006300 <I2C_Slave_ISR_IT+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80063bc:	6823      	ldr	r3, [r4, #0]
 80063be:	2210      	movs	r2, #16
 80063c0:	61da      	str	r2, [r3, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80063c2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80063c4:	f043 0304 	orr.w	r3, r3, #4
 80063c8:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 80063ca:	f036 7380 	bics.w	r3, r6, #16777216	; 0x1000000
 80063ce:	d1a9      	bne.n	8006324 <I2C_Slave_ISR_IT+0x48>
        I2C_ITError(hi2c, hi2c->ErrorCode);
 80063d0:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80063d2:	4620      	mov	r0, r4
 80063d4:	f7ff fdbc 	bl	8005f50 <I2C_ITError>
 80063d8:	e7a4      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>
  __HAL_LOCK(hi2c);
 80063da:	2002      	movs	r0, #2
}
 80063dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
 80063de:	f036 7380 	bics.w	r3, r6, #16777216	; 0x1000000
 80063e2:	d0cd      	beq.n	8006380 <I2C_Slave_ISR_IT+0xa4>
 80063e4:	e79e      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 80063e6:	f516 3f80 	cmn.w	r6, #65536	; 0x10000
 80063ea:	d09b      	beq.n	8006324 <I2C_Slave_ISR_IT+0x48>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80063ec:	699a      	ldr	r2, [r3, #24]
 80063ee:	0790      	lsls	r0, r2, #30
    hi2c->Instance->TXDR = 0x00U;
 80063f0:	bf44      	itt	mi
 80063f2:	2200      	movmi	r2, #0
 80063f4:	629a      	strmi	r2, [r3, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80063f6:	699a      	ldr	r2, [r3, #24]
 80063f8:	07d1      	lsls	r1, r2, #31
 80063fa:	d4c1      	bmi.n	8006380 <I2C_Slave_ISR_IT+0xa4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80063fc:	699a      	ldr	r2, [r3, #24]
 80063fe:	f042 0201 	orr.w	r2, r2, #1
 8006402:	619a      	str	r2, [r3, #24]
 8006404:	e7bc      	b.n	8006380 <I2C_Slave_ISR_IT+0xa4>
 8006406:	4620      	mov	r0, r4
 8006408:	f7ff fe60 	bl	80060cc <I2C_ITAddrCplt.isra.0.part.0>
 800640c:	e78a      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
 800640e:	f1b6 7f00 	cmp.w	r6, #33554432	; 0x2000000
 8006412:	f47f af7f 	bne.w	8006314 <I2C_Slave_ISR_IT+0x38>
        I2C_ITListenCplt(hi2c, tmpITFlags);
 8006416:	4629      	mov	r1, r5
 8006418:	4620      	mov	r0, r4
 800641a:	f7ff fe23 	bl	8006064 <I2C_ITListenCplt>
 800641e:	e781      	b.n	8006324 <I2C_Slave_ISR_IT+0x48>

08006420 <HAL_I2C_EV_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8006420:	6802      	ldr	r2, [r0, #0]
  if (hi2c->XferISR != NULL)
 8006422:	6b43      	ldr	r3, [r0, #52]	; 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8006424:	6991      	ldr	r1, [r2, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8006426:	6812      	ldr	r2, [r2, #0]
  if (hi2c->XferISR != NULL)
 8006428:	b103      	cbz	r3, 800642c <HAL_I2C_EV_IRQHandler+0xc>
    hi2c->XferISR(hi2c, itflags, itsources);
 800642a:	4718      	bx	r3
}
 800642c:	4770      	bx	lr
 800642e:	bf00      	nop

08006430 <HAL_I2C_ER_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8006430:	6803      	ldr	r3, [r0, #0]
 8006432:	699a      	ldr	r2, [r3, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8006434:	6819      	ldr	r1, [r3, #0]
{
 8006436:	b410      	push	{r4}
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8006438:	05d4      	lsls	r4, r2, #23
 800643a:	d52f      	bpl.n	800649c <HAL_I2C_ER_IRQHandler+0x6c>
 800643c:	060c      	lsls	r4, r1, #24
 800643e:	d51f      	bpl.n	8006480 <HAL_I2C_ER_IRQHandler+0x50>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8006440:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8006442:	f041 0101 	orr.w	r1, r1, #1
 8006446:	6441      	str	r1, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8006448:	f44f 7480 	mov.w	r4, #256	; 0x100
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800644c:	0551      	lsls	r1, r2, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800644e:	61dc      	str	r4, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8006450:	d529      	bpl.n	80064a6 <HAL_I2C_ER_IRQHandler+0x76>
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8006452:	6c41      	ldr	r1, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8006454:	f44f 6480 	mov.w	r4, #1024	; 0x400
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8006458:	f041 0108 	orr.w	r1, r1, #8
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800645c:	0592      	lsls	r2, r2, #22
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 800645e:	6441      	str	r1, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8006460:	61dc      	str	r4, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8006462:	d506      	bpl.n	8006472 <HAL_I2C_ER_IRQHandler+0x42>
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8006464:	6c42      	ldr	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8006466:	f44f 7100 	mov.w	r1, #512	; 0x200
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 800646a:	f042 0202 	orr.w	r2, r2, #2
 800646e:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8006470:	61d9      	str	r1, [r3, #28]
  tmperror = hi2c->ErrorCode;
 8006472:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8006474:	f011 0f0b 	tst.w	r1, #11
 8006478:	d10c      	bne.n	8006494 <HAL_I2C_ER_IRQHandler+0x64>
}
 800647a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800647e:	4770      	bx	lr
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8006480:	0554      	lsls	r4, r2, #21
 8006482:	d4f6      	bmi.n	8006472 <HAL_I2C_ER_IRQHandler+0x42>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8006484:	0594      	lsls	r4, r2, #22
 8006486:	d5f4      	bpl.n	8006472 <HAL_I2C_ER_IRQHandler+0x42>
 8006488:	0609      	lsls	r1, r1, #24
 800648a:	d4eb      	bmi.n	8006464 <HAL_I2C_ER_IRQHandler+0x34>
  tmperror = hi2c->ErrorCode;
 800648c:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 800648e:	f011 0f0b 	tst.w	r1, #11
 8006492:	d0f2      	beq.n	800647a <HAL_I2C_ER_IRQHandler+0x4a>
}
 8006494:	f85d 4b04 	ldr.w	r4, [sp], #4
    I2C_ITError(hi2c, tmperror);
 8006498:	f7ff bd5a 	b.w	8005f50 <I2C_ITError>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800649c:	0554      	lsls	r4, r2, #21
 800649e:	d5f1      	bpl.n	8006484 <HAL_I2C_ER_IRQHandler+0x54>
 80064a0:	0609      	lsls	r1, r1, #24
 80064a2:	d4d6      	bmi.n	8006452 <HAL_I2C_ER_IRQHandler+0x22>
 80064a4:	e7e5      	b.n	8006472 <HAL_I2C_ER_IRQHandler+0x42>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 80064a6:	0592      	lsls	r2, r2, #22
 80064a8:	d4dc      	bmi.n	8006464 <HAL_I2C_ER_IRQHandler+0x34>
 80064aa:	e7e2      	b.n	8006472 <HAL_I2C_ER_IRQHandler+0x42>

080064ac <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80064ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80064b0:	6806      	ldr	r6, [r0, #0]
{
 80064b2:	b085      	sub	sp, #20
 80064b4:	4604      	mov	r4, r0
  uint32_t i, ep_intr, epint, epnum;
  uint32_t fifoemptymsk, temp;
  USB_OTG_EPTypeDef *ep;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 80064b6:	4630      	mov	r0, r6
 80064b8:	f006 fb2e 	bl	800cb18 <USB_GetMode>
 80064bc:	b110      	cbz	r0, 80064c4 <HAL_PCD_IRQHandler+0x18>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 80064be:	b005      	add	sp, #20
 80064c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 80064c4:	4682      	mov	sl, r0
 80064c6:	6820      	ldr	r0, [r4, #0]
 80064c8:	f006 faf4 	bl	800cab4 <USB_ReadInterrupts>
 80064cc:	2800      	cmp	r0, #0
 80064ce:	d0f6      	beq.n	80064be <HAL_PCD_IRQHandler+0x12>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 80064d0:	6820      	ldr	r0, [r4, #0]
 80064d2:	f006 faef 	bl	800cab4 <USB_ReadInterrupts>
 80064d6:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80064da:	6820      	ldr	r0, [r4, #0]
 80064dc:	bf1e      	ittt	ne
 80064de:	6943      	ldrne	r3, [r0, #20]
 80064e0:	f003 0302 	andne.w	r3, r3, #2
 80064e4:	6143      	strne	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80064e6:	f006 fae5 	bl	800cab4 <USB_ReadInterrupts>
 80064ea:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80064ee:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80064f0:	d012      	beq.n	8006518 <HAL_PCD_IRQHandler+0x6c>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80064f2:	6983      	ldr	r3, [r0, #24]
 80064f4:	f023 0310 	bic.w	r3, r3, #16
 80064f8:	6183      	str	r3, [r0, #24]
      temp = USBx->GRXSTSP;
 80064fa:	6a35      	ldr	r5, [r6, #32]
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 80064fc:	f3c5 4343 	ubfx	r3, r5, #17, #4
 8006500:	2b02      	cmp	r3, #2
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8006502:	f005 070f 	and.w	r7, r5, #15
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8006506:	f000 825a 	beq.w	80069be <HAL_PCD_IRQHandler+0x512>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 800650a:	2b06      	cmp	r3, #6
 800650c:	f000 81aa 	beq.w	8006864 <HAL_PCD_IRQHandler+0x3b8>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8006510:	6983      	ldr	r3, [r0, #24]
 8006512:	f043 0310 	orr.w	r3, r3, #16
 8006516:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8006518:	f006 facc 	bl	800cab4 <USB_ReadInterrupts>
 800651c:	f410 2f00 	tst.w	r0, #524288	; 0x80000
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8006520:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8006522:	f040 80c2 	bne.w	80066aa <HAL_PCD_IRQHandler+0x1fe>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8006526:	f006 fac5 	bl	800cab4 <USB_ReadInterrupts>
 800652a:	f410 2f80 	tst.w	r0, #262144	; 0x40000
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800652e:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8006530:	d175      	bne.n	800661e <HAL_PCD_IRQHandler+0x172>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8006532:	f006 fabf 	bl	800cab4 <USB_ReadInterrupts>
 8006536:	2800      	cmp	r0, #0
 8006538:	db5d      	blt.n	80065f6 <HAL_PCD_IRQHandler+0x14a>
 800653a:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 800653c:	f006 faba 	bl	800cab4 <USB_ReadInterrupts>
 8006540:	0500      	lsls	r0, r0, #20
 8006542:	d44d      	bmi.n	80065e0 <HAL_PCD_IRQHandler+0x134>
 8006544:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 8006546:	f006 fab5 	bl	800cab4 <USB_ReadInterrupts>
 800654a:	0102      	lsls	r2, r0, #4
 800654c:	d514      	bpl.n	8006578 <HAL_PCD_IRQHandler+0xcc>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 800654e:	6822      	ldr	r2, [r4, #0]
 8006550:	6953      	ldr	r3, [r2, #20]
 8006552:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8006556:	6153      	str	r3, [r2, #20]
      if (hpcd->LPM_State == LPM_L0)
 8006558:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 800655c:	2b00      	cmp	r3, #0
 800655e:	f040 816b 	bne.w	8006838 <HAL_PCD_IRQHandler+0x38c>
        hpcd->LPM_State = LPM_L1;
 8006562:	2101      	movs	r1, #1
 8006564:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8006568:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800656a:	f3c3 0383 	ubfx	r3, r3, #2, #4
 800656e:	f8c4 33f8 	str.w	r3, [r4, #1016]	; 0x3f8
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 8006572:	4620      	mov	r0, r4
 8006574:	f000 fb5c 	bl	8006c30 <HAL_PCDEx_LPM_Callback>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8006578:	6820      	ldr	r0, [r4, #0]
 800657a:	f006 fa9b 	bl	800cab4 <USB_ReadInterrupts>
 800657e:	04c3      	lsls	r3, r0, #19
 8006580:	f100 810a 	bmi.w	8006798 <HAL_PCD_IRQHandler+0x2ec>
 8006584:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8006586:	f006 fa95 	bl	800cab4 <USB_ReadInterrupts>
 800658a:	f410 5f00 	tst.w	r0, #8192	; 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 800658e:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8006590:	f040 80eb 	bne.w	800676a <HAL_PCD_IRQHandler+0x2be>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8006594:	f006 fa8e 	bl	800cab4 <USB_ReadInterrupts>
 8006598:	0707      	lsls	r7, r0, #28
 800659a:	f100 80dd 	bmi.w	8006758 <HAL_PCD_IRQHandler+0x2ac>
 800659e:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 80065a0:	f006 fa88 	bl	800cab4 <USB_ReadInterrupts>
 80065a4:	02c6      	lsls	r6, r0, #11
 80065a6:	f100 80cd 	bmi.w	8006744 <HAL_PCD_IRQHandler+0x298>
 80065aa:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 80065ac:	f006 fa82 	bl	800cab4 <USB_ReadInterrupts>
 80065b0:	0285      	lsls	r5, r0, #10
 80065b2:	f100 80bd 	bmi.w	8006730 <HAL_PCD_IRQHandler+0x284>
 80065b6:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 80065b8:	f006 fa7c 	bl	800cab4 <USB_ReadInterrupts>
 80065bc:	0040      	lsls	r0, r0, #1
 80065be:	f100 80ae 	bmi.w	800671e <HAL_PCD_IRQHandler+0x272>
 80065c2:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 80065c4:	f006 fa76 	bl	800cab4 <USB_ReadInterrupts>
 80065c8:	0741      	lsls	r1, r0, #29
 80065ca:	f57f af78 	bpl.w	80064be <HAL_PCD_IRQHandler+0x12>
      temp = hpcd->Instance->GOTGINT;
 80065ce:	6823      	ldr	r3, [r4, #0]
 80065d0:	685d      	ldr	r5, [r3, #4]
      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 80065d2:	076a      	lsls	r2, r5, #29
 80065d4:	f100 8215 	bmi.w	8006a02 <HAL_PCD_IRQHandler+0x556>
      hpcd->Instance->GOTGINT |= temp;
 80065d8:	685a      	ldr	r2, [r3, #4]
 80065da:	432a      	orrs	r2, r5
 80065dc:	605a      	str	r2, [r3, #4]
 80065de:	e76e      	b.n	80064be <HAL_PCD_IRQHandler+0x12>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80065e0:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
 80065e4:	07d9      	lsls	r1, r3, #31
 80065e6:	f100 8208 	bmi.w	80069fa <HAL_PCD_IRQHandler+0x54e>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80065ea:	6820      	ldr	r0, [r4, #0]
 80065ec:	6943      	ldr	r3, [r0, #20]
 80065ee:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80065f2:	6143      	str	r3, [r0, #20]
 80065f4:	e7a7      	b.n	8006546 <HAL_PCD_IRQHandler+0x9a>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80065f6:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804
 80065fa:	f023 0301 	bic.w	r3, r3, #1
 80065fe:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
      if (hpcd->LPM_State == LPM_L1)
 8006602:	f894 33f4 	ldrb.w	r3, [r4, #1012]	; 0x3f4
 8006606:	2b01      	cmp	r3, #1
 8006608:	f000 8125 	beq.w	8006856 <HAL_PCD_IRQHandler+0x3aa>
        HAL_PCD_ResumeCallback(hpcd);
 800660c:	4620      	mov	r0, r4
 800660e:	f7fd fcbf 	bl	8003f90 <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8006612:	6820      	ldr	r0, [r4, #0]
 8006614:	6943      	ldr	r3, [r0, #20]
 8006616:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800661a:	6143      	str	r3, [r0, #20]
 800661c:	e78e      	b.n	800653c <HAL_PCD_IRQHandler+0x90>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800661e:	f006 fa55 	bl	800cacc <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 8006622:	4681      	mov	r9, r0
 8006624:	6820      	ldr	r0, [r4, #0]
 8006626:	f1b9 0f00 	cmp.w	r9, #0
 800662a:	d082      	beq.n	8006532 <HAL_PCD_IRQHandler+0x86>
 800662c:	f506 6310 	add.w	r3, r6, #2304	; 0x900
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8006630:	e9cd 3600 	strd	r3, r6, [sp]
 8006634:	4625      	mov	r5, r4
      epnum = 0U;
 8006636:	f04f 0b00 	mov.w	fp, #0
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800663a:	f8cd a008 	str.w	sl, [sp, #8]
 800663e:	e007      	b.n	8006650 <HAL_PCD_IRQHandler+0x1a4>
      while (ep_intr != 0U)
 8006640:	ea5f 0959 	movs.w	r9, r9, lsr #1
        epnum++;
 8006644:	f10b 0b01 	add.w	fp, fp, #1
      while (ep_intr != 0U)
 8006648:	f105 051c 	add.w	r5, r5, #28
 800664c:	f000 811d 	beq.w	800688a <HAL_PCD_IRQHandler+0x3de>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8006650:	f019 0f01 	tst.w	r9, #1
 8006654:	d0f4      	beq.n	8006640 <HAL_PCD_IRQHandler+0x194>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8006656:	fa5f f78b 	uxtb.w	r7, fp
 800665a:	4639      	mov	r1, r7
 800665c:	f006 fa48 	bl	800caf0 <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8006660:	07c3      	lsls	r3, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8006662:	4606      	mov	r6, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8006664:	f100 8114 	bmi.w	8006890 <HAL_PCD_IRQHandler+0x3e4>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8006668:	0730      	lsls	r0, r6, #28
 800666a:	d504      	bpl.n	8006676 <HAL_PCD_IRQHandler+0x1ca>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 800666c:	9b00      	ldr	r3, [sp, #0]
 800666e:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 8006672:	2208      	movs	r2, #8
 8006674:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8006676:	06f1      	lsls	r1, r6, #27
 8006678:	d504      	bpl.n	8006684 <HAL_PCD_IRQHandler+0x1d8>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 800667a:	9b00      	ldr	r3, [sp, #0]
 800667c:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 8006680:	2210      	movs	r2, #16
 8006682:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8006684:	0672      	lsls	r2, r6, #25
 8006686:	d504      	bpl.n	8006692 <HAL_PCD_IRQHandler+0x1e6>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8006688:	9b00      	ldr	r3, [sp, #0]
 800668a:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 800668e:	2240      	movs	r2, #64	; 0x40
 8006690:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8006692:	07b3      	lsls	r3, r6, #30
 8006694:	d504      	bpl.n	80066a0 <HAL_PCD_IRQHandler+0x1f4>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8006696:	9b00      	ldr	r3, [sp, #0]
 8006698:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 800669c:	2202      	movs	r2, #2
 800669e:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80066a0:	0636      	lsls	r6, r6, #24
 80066a2:	f100 810c 	bmi.w	80068be <HAL_PCD_IRQHandler+0x412>
 80066a6:	6820      	ldr	r0, [r4, #0]
 80066a8:	e7ca      	b.n	8006640 <HAL_PCD_IRQHandler+0x194>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80066aa:	f006 fa07 	bl	800cabc <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 80066ae:	4605      	mov	r5, r0
 80066b0:	6820      	ldr	r0, [r4, #0]
 80066b2:	2d00      	cmp	r5, #0
 80066b4:	f43f af37 	beq.w	8006526 <HAL_PCD_IRQHandler+0x7a>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;

  if (gSNPSiD == USB_OTG_CORE_ID_310A)
 80066b8:	f8df 9364 	ldr.w	r9, [pc, #868]	; 8006a20 <HAL_PCD_IRQHandler+0x574>
      epnum = 0U;
 80066bc:	2700      	movs	r7, #0
 80066be:	f506 6830 	add.w	r8, r6, #2816	; 0xb00
 80066c2:	e004      	b.n	80066ce <HAL_PCD_IRQHandler+0x222>
      while (ep_intr != 0U)
 80066c4:	086d      	lsrs	r5, r5, #1
        epnum++;
 80066c6:	f107 0701 	add.w	r7, r7, #1
      while (ep_intr != 0U)
 80066ca:	f43f af2c 	beq.w	8006526 <HAL_PCD_IRQHandler+0x7a>
        if ((ep_intr & 0x1U) != 0U)
 80066ce:	07e9      	lsls	r1, r5, #31
 80066d0:	d5f8      	bpl.n	80066c4 <HAL_PCD_IRQHandler+0x218>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80066d2:	b2f9      	uxtb	r1, r7
 80066d4:	9100      	str	r1, [sp, #0]
 80066d6:	f006 fa01 	bl	800cadc <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80066da:	f010 0f01 	tst.w	r0, #1
 80066de:	9900      	ldr	r1, [sp, #0]
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80066e0:	4683      	mov	fp, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80066e2:	f040 814e 	bne.w	8006982 <HAL_PCD_IRQHandler+0x4d6>
 80066e6:	6820      	ldr	r0, [r4, #0]
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 80066e8:	f01b 0f08 	tst.w	fp, #8
 80066ec:	f040 8131 	bne.w	8006952 <HAL_PCD_IRQHandler+0x4a6>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 80066f0:	f01b 0f10 	tst.w	fp, #16
 80066f4:	d003      	beq.n	80066fe <HAL_PCD_IRQHandler+0x252>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 80066f6:	eb08 1347 	add.w	r3, r8, r7, lsl #5
 80066fa:	2210      	movs	r2, #16
 80066fc:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80066fe:	f01b 0f20 	tst.w	fp, #32
 8006702:	d003      	beq.n	800670c <HAL_PCD_IRQHandler+0x260>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8006704:	eb08 1347 	add.w	r3, r8, r7, lsl #5
 8006708:	2220      	movs	r2, #32
 800670a:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 800670c:	f41b 5f00 	tst.w	fp, #8192	; 0x2000
 8006710:	d0d8      	beq.n	80066c4 <HAL_PCD_IRQHandler+0x218>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 8006712:	eb08 1347 	add.w	r3, r8, r7, lsl #5
 8006716:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800671a:	609a      	str	r2, [r3, #8]
 800671c:	e7d2      	b.n	80066c4 <HAL_PCD_IRQHandler+0x218>
      HAL_PCD_ConnectCallback(hpcd);
 800671e:	4620      	mov	r0, r4
 8006720:	f7fd fc42 	bl	8003fa8 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8006724:	6820      	ldr	r0, [r4, #0]
 8006726:	6943      	ldr	r3, [r0, #20]
 8006728:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 800672c:	6143      	str	r3, [r0, #20]
 800672e:	e749      	b.n	80065c4 <HAL_PCD_IRQHandler+0x118>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8006730:	4620      	mov	r0, r4
 8006732:	2100      	movs	r1, #0
 8006734:	f7fd fc30 	bl	8003f98 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8006738:	6820      	ldr	r0, [r4, #0]
 800673a:	6943      	ldr	r3, [r0, #20]
 800673c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8006740:	6143      	str	r3, [r0, #20]
 8006742:	e739      	b.n	80065b8 <HAL_PCD_IRQHandler+0x10c>
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8006744:	4620      	mov	r0, r4
 8006746:	2100      	movs	r1, #0
 8006748:	f7fd fc2a 	bl	8003fa0 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 800674c:	6820      	ldr	r0, [r4, #0]
 800674e:	6943      	ldr	r3, [r0, #20]
 8006750:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8006754:	6143      	str	r3, [r0, #20]
 8006756:	e729      	b.n	80065ac <HAL_PCD_IRQHandler+0x100>
      HAL_PCD_SOFCallback(hpcd);
 8006758:	4620      	mov	r0, r4
 800675a:	f7fd fc03 	bl	8003f64 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 800675e:	6820      	ldr	r0, [r4, #0]
 8006760:	6943      	ldr	r3, [r0, #20]
 8006762:	f003 0308 	and.w	r3, r3, #8
 8006766:	6143      	str	r3, [r0, #20]
 8006768:	e71a      	b.n	80065a0 <HAL_PCD_IRQHandler+0xf4>
      (void)USB_ActivateSetup(hpcd->Instance);
 800676a:	f006 f9d9 	bl	800cb20 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 800676e:	6820      	ldr	r0, [r4, #0]
 8006770:	f005 ff54 	bl	800c61c <USB_GetDevSpeed>
 8006774:	60e0      	str	r0, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8006776:	6825      	ldr	r5, [r4, #0]
 8006778:	f001 f848 	bl	800780c <HAL_RCC_GetHCLKFreq>
 800677c:	7b22      	ldrb	r2, [r4, #12]
 800677e:	4601      	mov	r1, r0
 8006780:	4628      	mov	r0, r5
 8006782:	f005 fec1 	bl	800c508 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 8006786:	4620      	mov	r0, r4
 8006788:	f7fd fbf0 	bl	8003f6c <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800678c:	6820      	ldr	r0, [r4, #0]
 800678e:	6943      	ldr	r3, [r0, #20]
 8006790:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8006794:	6143      	str	r3, [r0, #20]
 8006796:	e6fd      	b.n	8006594 <HAL_PCD_IRQHandler+0xe8>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8006798:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800679c:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800679e:	f023 0301 	bic.w	r3, r3, #1
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80067a2:	2110      	movs	r1, #16
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80067a4:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 80067a8:	f005 ff26 	bl	800c5f8 <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80067ac:	6860      	ldr	r0, [r4, #4]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80067ae:	f506 6500 	add.w	r5, r6, #2048	; 0x800
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80067b2:	b300      	cbz	r0, 80067f6 <HAL_PCD_IRQHandler+0x34a>
 80067b4:	f506 6310 	add.w	r3, r6, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 80067b8:	f64f 317f 	movw	r1, #64383	; 0xfb7f
 80067bc:	6099      	str	r1, [r3, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 80067be:	681a      	ldr	r2, [r3, #0]
 80067c0:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80067c4:	601a      	str	r2, [r3, #0]
        USBx_INEP(i)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 80067c6:	681a      	ldr	r2, [r3, #0]
 80067c8:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80067cc:	601a      	str	r2, [r3, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 80067ce:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80067d2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80067d6:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80067da:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 80067de:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80067e2:	f10a 0a01 	add.w	sl, sl, #1
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 80067e6:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80067ea:	4582      	cmp	sl, r0
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 80067ec:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80067f0:	f103 0320 	add.w	r3, r3, #32
 80067f4:	d1e2      	bne.n	80067bc <HAL_PCD_IRQHandler+0x310>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 80067f6:	69eb      	ldr	r3, [r5, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 80067f8:	6b22      	ldr	r2, [r4, #48]	; 0x30
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 80067fa:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 80067fe:	61eb      	str	r3, [r5, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8006800:	b9f2      	cbnz	r2, 8006840 <HAL_PCD_IRQHandler+0x394>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8006802:	696b      	ldr	r3, [r5, #20]
 8006804:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8006808:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 800680c:	616b      	str	r3, [r5, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 800680e:	692b      	ldr	r3, [r5, #16]
 8006810:	f043 030b 	orr.w	r3, r3, #11
 8006814:	612b      	str	r3, [r5, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8006816:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 800681a:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800681c:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8006820:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8006824:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8006828:	f006 f98a 	bl	800cb40 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 800682c:	6820      	ldr	r0, [r4, #0]
 800682e:	6943      	ldr	r3, [r0, #20]
 8006830:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8006834:	6143      	str	r3, [r0, #20]
 8006836:	e6a6      	b.n	8006586 <HAL_PCD_IRQHandler+0xda>
        HAL_PCD_SuspendCallback(hpcd);
 8006838:	4620      	mov	r0, r4
 800683a:	f7fd fba5 	bl	8003f88 <HAL_PCD_SuspendCallback>
 800683e:	e69b      	b.n	8006578 <HAL_PCD_IRQHandler+0xcc>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8006840:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8006844:	f043 030b 	orr.w	r3, r3, #11
 8006848:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 800684c:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800684e:	f043 030b 	orr.w	r3, r3, #11
 8006852:	646b      	str	r3, [r5, #68]	; 0x44
 8006854:	e7df      	b.n	8006816 <HAL_PCD_IRQHandler+0x36a>
        hpcd->LPM_State = LPM_L0;
 8006856:	2100      	movs	r1, #0
 8006858:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800685c:	4620      	mov	r0, r4
 800685e:	f000 f9e7 	bl	8006c30 <HAL_PCDEx_LPM_Callback>
 8006862:	e6d6      	b.n	8006612 <HAL_PCD_IRQHandler+0x166>
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8006864:	2208      	movs	r2, #8
 8006866:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 800686a:	4630      	mov	r0, r6
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 800686c:	ebc7 07c7 	rsb	r7, r7, r7, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8006870:	f006 f8a4 	bl	800c9bc <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8006874:	eb04 0287 	add.w	r2, r4, r7, lsl #2
 8006878:	f3c5 130a 	ubfx	r3, r5, #4, #11
 800687c:	f8d2 1214 	ldr.w	r1, [r2, #532]	; 0x214
 8006880:	6820      	ldr	r0, [r4, #0]
 8006882:	440b      	add	r3, r1
 8006884:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
 8006888:	e642      	b.n	8006510 <HAL_PCD_IRQHandler+0x64>
 800688a:	e9dd 6a01 	ldrd	r6, sl, [sp, #4]
 800688e:	e650      	b.n	8006532 <HAL_PCD_IRQHandler+0x86>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8006890:	9b01      	ldr	r3, [sp, #4]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8006892:	f00b 000f 	and.w	r0, fp, #15
 8006896:	2201      	movs	r2, #1
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8006898:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800689c:	fa02 f000 	lsl.w	r0, r2, r0
 80068a0:	9a00      	ldr	r2, [sp, #0]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80068a2:	ea21 0100 	bic.w	r1, r1, r0
 80068a6:	eb02 124b 	add.w	r2, r2, fp, lsl #5
 80068aa:	f8c3 1834 	str.w	r1, [r3, #2100]	; 0x834
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80068ae:	4613      	mov	r3, r2
 80068b0:	2201      	movs	r2, #1
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80068b2:	4639      	mov	r1, r7
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80068b4:	609a      	str	r2, [r3, #8]
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80068b6:	4620      	mov	r0, r4
 80068b8:	f7fd fb4a 	bl	8003f50 <HAL_PCD_DataInStageCallback>
 80068bc:	e6d4      	b.n	8006668 <HAL_PCD_IRQHandler+0x1bc>
  if (ep->xfer_count > ep->xfer_len)
 80068be:	e9d5 1314 	ldrd	r1, r3, [r5, #80]	; 0x50
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80068c2:	f8d4 8000 	ldr.w	r8, [r4]
  if (ep->xfer_count > ep->xfer_len)
 80068c6:	428b      	cmp	r3, r1
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80068c8:	4640      	mov	r0, r8
  if (ep->xfer_count > ep->xfer_len)
 80068ca:	f63f aeb9 	bhi.w	8006640 <HAL_PCD_IRQHandler+0x194>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80068ce:	f508 6a10 	add.w	sl, r8, #2304	; 0x900
  len32b = (len + 3U) / 4U;
 80068d2:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  uint32_t USBx_BASE = (uint32_t)USBx;
 80068d4:	f8cd 800c 	str.w	r8, [sp, #12]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80068d8:	eb0a 1a4b 	add.w	sl, sl, fp, lsl #5
  len = ep->xfer_len - ep->xfer_count;
 80068dc:	eba1 0c03 	sub.w	ip, r1, r3
  len32b = (len + 3U) / 4U;
 80068e0:	4562      	cmp	r2, ip
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80068e2:	f8da 6018 	ldr.w	r6, [sl, #24]
  len32b = (len + 3U) / 4U;
 80068e6:	bf28      	it	cs
 80068e8:	4662      	movcs	r2, ip
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80068ea:	b2b6      	uxth	r6, r6
  len32b = (len + 3U) / 4U;
 80068ec:	3203      	adds	r2, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80068ee:	ebb6 0f92 	cmp.w	r6, r2, lsr #2
 80068f2:	d217      	bcs.n	8006924 <HAL_PCD_IRQHandler+0x478>
 80068f4:	e08e      	b.n	8006a14 <HAL_PCD_IRQHandler+0x568>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 80068f6:	b1d9      	cbz	r1, 8006930 <HAL_PCD_IRQHandler+0x484>
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len);
 80068f8:	e9d5 3111 	ldrd	r3, r1, [r5, #68]	; 0x44
 80068fc:	429e      	cmp	r6, r3
 80068fe:	bf28      	it	cs
 8006900:	461e      	movcs	r6, r3
 8006902:	b2b3      	uxth	r3, r6
 8006904:	f006 f84a 	bl	800c99c <USB_WritePacket>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8006908:	f8da 2018 	ldr.w	r2, [sl, #24]
    ep->xfer_buff  += len;
 800690c:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    ep->xfer_count += len;
 800690e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    ep->xfer_buff  += len;
 8006910:	4431      	add	r1, r6
    ep->xfer_count += len;
 8006912:	4433      	add	r3, r6
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8006914:	b292      	uxth	r2, r2
    len32b = (len + 3U) / 4U;
 8006916:	3603      	adds	r6, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8006918:	ebb2 0f96 	cmp.w	r2, r6, lsr #2
    ep->xfer_buff  += len;
 800691c:	64a9      	str	r1, [r5, #72]	; 0x48
    ep->xfer_count += len;
 800691e:	656b      	str	r3, [r5, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8006920:	d374      	bcc.n	8006a0c <HAL_PCD_IRQHandler+0x560>
 8006922:	6d29      	ldr	r1, [r5, #80]	; 0x50
 8006924:	4299      	cmp	r1, r3
    len = ep->xfer_len - ep->xfer_count;
 8006926:	eba1 0603 	sub.w	r6, r1, r3
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len);
 800692a:	463a      	mov	r2, r7
 800692c:	4640      	mov	r0, r8
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800692e:	d8e2      	bhi.n	80068f6 <HAL_PCD_IRQHandler+0x44a>
 8006930:	f8d4 8000 	ldr.w	r8, [r4]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8006934:	9b03      	ldr	r3, [sp, #12]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8006936:	2001      	movs	r0, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8006938:	f503 6100 	add.w	r1, r3, #2048	; 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800693c:	f00b 020f 	and.w	r2, fp, #15
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8006940:	f8d3 3834 	ldr.w	r3, [r3, #2100]	; 0x834
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8006944:	fa00 f202 	lsl.w	r2, r0, r2
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8006948:	ea23 0302 	bic.w	r3, r3, r2
 800694c:	4640      	mov	r0, r8
 800694e:	634b      	str	r3, [r1, #52]	; 0x34
 8006950:	e676      	b.n	8006640 <HAL_PCD_IRQHandler+0x194>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8006952:	eb08 1347 	add.w	r3, r8, r7, lsl #5
 8006956:	2208      	movs	r2, #8
 8006958:	609a      	str	r2, [r3, #8]
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800695a:	6c02      	ldr	r2, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800695c:	eb00 1347 	add.w	r3, r0, r7, lsl #5

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8006960:	482e      	ldr	r0, [pc, #184]	; (8006a1c <HAL_PCD_IRQHandler+0x570>)
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8006962:	f8d3 1b08 	ldr.w	r1, [r3, #2824]	; 0xb08
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8006966:	4282      	cmp	r2, r0
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8006968:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800696c:	d904      	bls.n	8006978 <HAL_PCD_IRQHandler+0x4cc>
 800696e:	040a      	lsls	r2, r1, #16
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8006970:	bf44      	itt	mi
 8006972:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
 8006976:	609a      	strmi	r2, [r3, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8006978:	4620      	mov	r0, r4
 800697a:	f7fd fad9 	bl	8003f30 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  return HAL_OK;
 800697e:	6820      	ldr	r0, [r4, #0]
 8006980:	e6b6      	b.n	80066f0 <HAL_PCD_IRQHandler+0x244>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8006982:	eb08 1347 	add.w	r3, r8, r7, lsl #5
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8006986:	6820      	ldr	r0, [r4, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8006988:	2201      	movs	r2, #1
 800698a:	609a      	str	r2, [r3, #8]
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800698c:	6c02      	ldr	r2, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800698e:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 8006992:	eb03 1347 	add.w	r3, r3, r7, lsl #5
  if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8006996:	454a      	cmp	r2, r9
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8006998:	f8d3 c008 	ldr.w	ip, [r3, #8]
  if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800699c:	d10b      	bne.n	80069b6 <HAL_PCD_IRQHandler+0x50a>
    if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 800699e:	f41c 4f00 	tst.w	ip, #32768	; 0x8000
 80069a2:	d003      	beq.n	80069ac <HAL_PCD_IRQHandler+0x500>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80069a4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80069a8:	609a      	str	r2, [r3, #8]
 80069aa:	e69d      	b.n	80066e8 <HAL_PCD_IRQHandler+0x23c>
      if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80069ac:	f01c 0f20 	tst.w	ip, #32
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80069b0:	bf1c      	itt	ne
 80069b2:	2220      	movne	r2, #32
 80069b4:	609a      	strne	r2, [r3, #8]
    HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80069b6:	4620      	mov	r0, r4
 80069b8:	f7fd fac0 	bl	8003f3c <HAL_PCD_DataOutStageCallback>
 80069bc:	e693      	b.n	80066e6 <HAL_PCD_IRQHandler+0x23a>
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 80069be:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 80069c2:	421d      	tst	r5, r3
 80069c4:	f43f ada4 	beq.w	8006510 <HAL_PCD_IRQHandler+0x64>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 80069c8:	ebc7 07c7 	rsb	r7, r7, r7, lsl #3
 80069cc:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 80069d0:	f3c5 120a 	ubfx	r2, r5, #4, #11
 80069d4:	f8d7 1208 	ldr.w	r1, [r7, #520]	; 0x208
 80069d8:	4630      	mov	r0, r6
 80069da:	f005 ffef 	bl	800c9bc <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80069de:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80069e2:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
 80069e6:	6820      	ldr	r0, [r4, #0]
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 80069e8:	f3c5 150a 	ubfx	r5, r5, #4, #11
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80069ec:	442a      	add	r2, r5
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80069ee:	442b      	add	r3, r5
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80069f0:	f8c7 2208 	str.w	r2, [r7, #520]	; 0x208
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80069f4:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
 80069f8:	e58a      	b.n	8006510 <HAL_PCD_IRQHandler+0x64>
        HAL_PCD_SuspendCallback(hpcd);
 80069fa:	4620      	mov	r0, r4
 80069fc:	f7fd fac4 	bl	8003f88 <HAL_PCD_SuspendCallback>
 8006a00:	e5f3      	b.n	80065ea <HAL_PCD_IRQHandler+0x13e>
        HAL_PCD_DisconnectCallback(hpcd);
 8006a02:	4620      	mov	r0, r4
 8006a04:	f7fd fad4 	bl	8003fb0 <HAL_PCD_DisconnectCallback>
 8006a08:	6823      	ldr	r3, [r4, #0]
 8006a0a:	e5e5      	b.n	80065d8 <HAL_PCD_IRQHandler+0x12c>
 8006a0c:	f8d4 8000 	ldr.w	r8, [r4]
 8006a10:	6d29      	ldr	r1, [r5, #80]	; 0x50
 8006a12:	4640      	mov	r0, r8
  if (ep->xfer_len <= ep->xfer_count)
 8006a14:	428b      	cmp	r3, r1
 8006a16:	f4ff ae13 	bcc.w	8006640 <HAL_PCD_IRQHandler+0x194>
 8006a1a:	e78b      	b.n	8006934 <HAL_PCD_IRQHandler+0x488>
 8006a1c:	4f54300a 	.word	0x4f54300a
 8006a20:	4f54310a 	.word	0x4f54310a

08006a24 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8006a24:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8006a28:	2a01      	cmp	r2, #1
 8006a2a:	d00d      	beq.n	8006a48 <HAL_PCD_SetAddress+0x24>
{
 8006a2c:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd);
 8006a2e:	2201      	movs	r2, #1
 8006a30:	4604      	mov	r4, r0
  hpcd->USB_Address = address;
 8006a32:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
  __HAL_LOCK(hpcd);
 8006a36:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8006a3a:	6800      	ldr	r0, [r0, #0]
 8006a3c:	f006 f82a 	bl	800ca94 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8006a40:	2000      	movs	r0, #0
 8006a42:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8006a46:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8006a48:	2002      	movs	r0, #2
}
 8006a4a:	4770      	bx	lr

08006a4c <HAL_PCD_EP_Open>:
{
 8006a4c:	b570      	push	{r4, r5, r6, lr}
 8006a4e:	f001 050f 	and.w	r5, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 8006a52:	f011 0f80 	tst.w	r1, #128	; 0x80
    ep->is_in = 1U;
 8006a56:	ebc5 01c5 	rsb	r1, r5, r5, lsl #3
{
 8006a5a:	4606      	mov	r6, r0
    ep->is_in = 1U;
 8006a5c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006a60:	f04f 041c 	mov.w	r4, #28
  if ((ep_addr & 0x80U) == 0x80U)
 8006a64:	d11e      	bne.n	8006aa4 <HAL_PCD_EP_Open+0x58>
    ep->is_in = 0U;
 8006a66:	2000      	movs	r0, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8006a68:	fb04 6405 	mla	r4, r4, r5, r6
    ep->is_in = 0U;
 8006a6c:	f881 01fd 	strb.w	r0, [r1, #509]	; 0x1fd
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8006a70:	f504 71fe 	add.w	r1, r4, #508	; 0x1fc
  if (ep->is_in != 0U)
 8006a74:	7848      	ldrb	r0, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8006a76:	700d      	strb	r5, [r1, #0]
  ep->maxpacket = ep_mps;
 8006a78:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8006a7a:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in != 0U)
 8006a7c:	b100      	cbz	r0, 8006a80 <HAL_PCD_EP_Open+0x34>
    ep->tx_fifo_num = ep->num;
 8006a7e:	80cd      	strh	r5, [r1, #6]
  if (ep_type == EP_TYPE_BULK)
 8006a80:	2b02      	cmp	r3, #2
    ep->data_pid_start = 0U;
 8006a82:	bf04      	itt	eq
 8006a84:	2300      	moveq	r3, #0
 8006a86:	710b      	strbeq	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 8006a88:	f896 33bc 	ldrb.w	r3, [r6, #956]	; 0x3bc
 8006a8c:	2b01      	cmp	r3, #1
 8006a8e:	d011      	beq.n	8006ab4 <HAL_PCD_EP_Open+0x68>
 8006a90:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8006a92:	6830      	ldr	r0, [r6, #0]
  __HAL_LOCK(hpcd);
 8006a94:	f886 33bc 	strb.w	r3, [r6, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8006a98:	f005 fdca 	bl	800c630 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8006a9c:	2000      	movs	r0, #0
 8006a9e:	f886 03bc 	strb.w	r0, [r6, #956]	; 0x3bc
}
 8006aa2:	bd70      	pop	{r4, r5, r6, pc}
    ep->is_in = 1U;
 8006aa4:	2001      	movs	r0, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006aa6:	fb04 6405 	mla	r4, r4, r5, r6
    ep->is_in = 1U;
 8006aaa:	f881 003d 	strb.w	r0, [r1, #61]	; 0x3d
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006aae:	f104 013c 	add.w	r1, r4, #60	; 0x3c
    ep->is_in = 1U;
 8006ab2:	e7df      	b.n	8006a74 <HAL_PCD_EP_Open+0x28>
  __HAL_LOCK(hpcd);
 8006ab4:	2002      	movs	r0, #2
}
 8006ab6:	bd70      	pop	{r4, r5, r6, pc}

08006ab8 <HAL_PCD_EP_Receive>:
{
 8006ab8:	b538      	push	{r3, r4, r5, lr}
 8006aba:	f001 040f 	and.w	r4, r1, #15
  ep->xfer_buff = pBuf;
 8006abe:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
 8006ac2:	eb00 0585 	add.w	r5, r0, r5, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8006ac6:	211c      	movs	r1, #28
 8006ac8:	fb01 0104 	mla	r1, r1, r4, r0
  ep->xfer_buff = pBuf;
 8006acc:	f8c5 2208 	str.w	r2, [r5, #520]	; 0x208
  ep->xfer_count = 0U;
 8006ad0:	2200      	movs	r2, #0
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8006ad2:	6800      	ldr	r0, [r0, #0]
  ep->xfer_len = len;
 8006ad4:	f8c5 3210 	str.w	r3, [r5, #528]	; 0x210
  ep->num = ep_addr & EP_ADDR_MSK;
 8006ad8:	f885 41fc 	strb.w	r4, [r5, #508]	; 0x1fc
  ep->xfer_count = 0U;
 8006adc:	f8c5 2214 	str.w	r2, [r5, #532]	; 0x214
  ep->is_in = 0U;
 8006ae0:	f885 21fd 	strb.w	r2, [r5, #509]	; 0x1fd
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8006ae4:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8006ae8:	b91c      	cbnz	r4, 8006af2 <HAL_PCD_EP_Receive+0x3a>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8006aea:	f005 fec7 	bl	800c87c <USB_EP0StartXfer>
}
 8006aee:	2000      	movs	r0, #0
 8006af0:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8006af2:	f005 fde9 	bl	800c6c8 <USB_EPStartXfer>
}
 8006af6:	2000      	movs	r0, #0
 8006af8:	bd38      	pop	{r3, r4, r5, pc}
 8006afa:	bf00      	nop

08006afc <HAL_PCD_EP_Transmit>:
{
 8006afc:	b538      	push	{r3, r4, r5, lr}
 8006afe:	f001 040f 	and.w	r4, r1, #15
  ep->xfer_buff = pBuf;
 8006b02:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
 8006b06:	eb00 0585 	add.w	r5, r0, r5, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006b0a:	211c      	movs	r1, #28
 8006b0c:	fb01 0104 	mla	r1, r1, r4, r0
  ep->xfer_buff = pBuf;
 8006b10:	64aa      	str	r2, [r5, #72]	; 0x48
  ep->xfer_len = len;
 8006b12:	652b      	str	r3, [r5, #80]	; 0x50
  ep->xfer_count = 0U;
 8006b14:	2200      	movs	r2, #0
  ep->is_in = 1U;
 8006b16:	2301      	movs	r3, #1
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8006b18:	6800      	ldr	r0, [r0, #0]
  ep->num = ep_addr & EP_ADDR_MSK;
 8006b1a:	f885 403c 	strb.w	r4, [r5, #60]	; 0x3c
  ep->xfer_count = 0U;
 8006b1e:	656a      	str	r2, [r5, #84]	; 0x54
  ep->is_in = 1U;
 8006b20:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006b24:	313c      	adds	r1, #60	; 0x3c
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8006b26:	b91c      	cbnz	r4, 8006b30 <HAL_PCD_EP_Transmit+0x34>
    (void)USB_EP0StartXfer(hpcd->Instance, ep);
 8006b28:	f005 fea8 	bl	800c87c <USB_EP0StartXfer>
}
 8006b2c:	2000      	movs	r0, #0
 8006b2e:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 8006b30:	f005 fdca 	bl	800c6c8 <USB_EPStartXfer>
}
 8006b34:	2000      	movs	r0, #0
 8006b36:	bd38      	pop	{r3, r4, r5, pc}

08006b38 <HAL_PCD_EP_SetStall>:
{
 8006b38:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8006b3a:	6843      	ldr	r3, [r0, #4]
 8006b3c:	f001 050f 	and.w	r5, r1, #15
 8006b40:	429d      	cmp	r5, r3
 8006b42:	d833      	bhi.n	8006bac <HAL_PCD_EP_SetStall+0x74>
  if ((0x80U & ep_addr) == 0x80U)
 8006b44:	060b      	lsls	r3, r1, #24
 8006b46:	4604      	mov	r4, r0
 8006b48:	d41c      	bmi.n	8006b84 <HAL_PCD_EP_SetStall+0x4c>
    ep->is_in = 0U;
 8006b4a:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8006b4e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->OUT_ep[ep_addr];
 8006b52:	201c      	movs	r0, #28
 8006b54:	fb00 4101 	mla	r1, r0, r1, r4
    ep->is_in = 0U;
 8006b58:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 8006b5a:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8006b5e:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
  ep->is_stall = 1U;
 8006b62:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8006b64:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8006b66:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8006b68:	f894 23bc 	ldrb.w	r2, [r4, #956]	; 0x3bc
 8006b6c:	429a      	cmp	r2, r3
 8006b6e:	d01b      	beq.n	8006ba8 <HAL_PCD_EP_SetStall+0x70>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8006b70:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8006b72:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8006b76:	f005 ff33 	bl	800c9e0 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8006b7a:	b1cd      	cbz	r5, 8006bb0 <HAL_PCD_EP_SetStall+0x78>
  __HAL_UNLOCK(hpcd);
 8006b7c:	2000      	movs	r0, #0
 8006b7e:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8006b82:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 8006b84:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006b88:	211c      	movs	r1, #28
 8006b8a:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 8006b8e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8006b92:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006b94:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 8006b96:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  ep->is_stall = 1U;
 8006b9a:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8006b9c:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8006b9e:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8006ba0:	f894 23bc 	ldrb.w	r2, [r4, #956]	; 0x3bc
 8006ba4:	429a      	cmp	r2, r3
 8006ba6:	d1e3      	bne.n	8006b70 <HAL_PCD_EP_SetStall+0x38>
 8006ba8:	2002      	movs	r0, #2
}
 8006baa:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8006bac:	2001      	movs	r0, #1
}
 8006bae:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8006bb0:	6820      	ldr	r0, [r4, #0]
 8006bb2:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8006bb6:	f005 ffc3 	bl	800cb40 <USB_EP0_OutStart>
 8006bba:	e7df      	b.n	8006b7c <HAL_PCD_EP_SetStall+0x44>

08006bbc <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8006bbc:	6842      	ldr	r2, [r0, #4]
{
 8006bbe:	b538      	push	{r3, r4, r5, lr}
 8006bc0:	f001 030f 	and.w	r3, r1, #15
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8006bc4:	4293      	cmp	r3, r2
 8006bc6:	d830      	bhi.n	8006c2a <HAL_PCD_EP_ClrStall+0x6e>
    ep->is_in = 1U;
 8006bc8:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
  if ((0x80U & ep_addr) == 0x80U)
 8006bcc:	f011 0f80 	tst.w	r1, #128	; 0x80
 8006bd0:	4604      	mov	r4, r0
    ep->is_in = 1U;
 8006bd2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006bd6:	f04f 011c 	mov.w	r1, #28
  if ((0x80U & ep_addr) == 0x80U)
 8006bda:	d117      	bne.n	8006c0c <HAL_PCD_EP_ClrStall+0x50>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8006bdc:	fb01 4103 	mla	r1, r1, r3, r4
 8006be0:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8006be4:	2000      	movs	r0, #0
  ep->is_stall = 0U;
 8006be6:	2500      	movs	r5, #0
    ep->is_in = 0U;
 8006be8:	f882 01fd 	strb.w	r0, [r2, #509]	; 0x1fd
  ep->num = ep_addr & EP_ADDR_MSK;
 8006bec:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 8006bee:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8006bf0:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8006bf4:	2b01      	cmp	r3, #1
 8006bf6:	d016      	beq.n	8006c26 <HAL_PCD_EP_ClrStall+0x6a>
 8006bf8:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8006bfa:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8006bfc:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8006c00:	f005 ff1c 	bl	800ca3c <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8006c04:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
  return HAL_OK;
 8006c08:	4628      	mov	r0, r5
}
 8006c0a:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8006c0c:	fb01 4103 	mla	r1, r1, r3, r4
 8006c10:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 8006c12:	2001      	movs	r0, #1
  ep->is_stall = 0U;
 8006c14:	2500      	movs	r5, #0
    ep->is_in = 1U;
 8006c16:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->num = ep_addr & EP_ADDR_MSK;
 8006c1a:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 8006c1c:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8006c1e:	f894 33bc 	ldrb.w	r3, [r4, #956]	; 0x3bc
 8006c22:	2b01      	cmp	r3, #1
 8006c24:	d1e8      	bne.n	8006bf8 <HAL_PCD_EP_ClrStall+0x3c>
 8006c26:	2002      	movs	r0, #2
}
 8006c28:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8006c2a:	2001      	movs	r0, #1
}
 8006c2c:	bd38      	pop	{r3, r4, r5, pc}
 8006c2e:	bf00      	nop

08006c30 <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8006c30:	4770      	bx	lr
 8006c32:	bf00      	nop

08006c34 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8006c34:	4a02      	ldr	r2, [pc, #8]	; (8006c40 <HAL_PWR_EnableBkUpAccess+0xc>)
 8006c36:	6813      	ldr	r3, [r2, #0]
 8006c38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006c3c:	6013      	str	r3, [r2, #0]
}
 8006c3e:	4770      	bx	lr
 8006c40:	40007000 	.word	0x40007000

08006c44 <HAL_PWR_ConfigPVD>:
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
  assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));

  /* Set PLS bits according to PVDLevel value */
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 8006c44:	491c      	ldr	r1, [pc, #112]	; (8006cb8 <HAL_PWR_ConfigPVD+0x74>)

  /* Clear any previous config. Keep it clear if no event or IT mode is selected */
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 8006c46:	4b1d      	ldr	r3, [pc, #116]	; (8006cbc <HAL_PWR_ConfigPVD+0x78>)
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 8006c48:	684a      	ldr	r2, [r1, #4]
{
 8006c4a:	b410      	push	{r4}
  MODIFY_REG(PWR->CR2, PWR_CR2_PLS, sConfigPVD->PVDLevel);
 8006c4c:	6804      	ldr	r4, [r0, #0]
 8006c4e:	f022 020e 	bic.w	r2, r2, #14
 8006c52:	4322      	orrs	r2, r4
 8006c54:	604a      	str	r2, [r1, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 8006c56:	685a      	ldr	r2, [r3, #4]
 8006c58:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006c5c:	605a      	str	r2, [r3, #4]
  __HAL_PWR_PVD_EXTI_DISABLE_IT();
 8006c5e:	681a      	ldr	r2, [r3, #0]
 8006c60:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006c64:	601a      	str	r2, [r3, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
 8006c66:	68da      	ldr	r2, [r3, #12]
 8006c68:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006c6c:	60da      	str	r2, [r3, #12]
  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 8006c6e:	689a      	ldr	r2, [r3, #8]
 8006c70:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006c74:	609a      	str	r2, [r3, #8]

  /* Configure interrupt mode */
  if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 8006c76:	6842      	ldr	r2, [r0, #4]
 8006c78:	03d4      	lsls	r4, r2, #15
 8006c7a:	d503      	bpl.n	8006c84 <HAL_PWR_ConfigPVD+0x40>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT();
 8006c7c:	6819      	ldr	r1, [r3, #0]
 8006c7e:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8006c82:	6019      	str	r1, [r3, #0]
  }

  /* Configure event mode */
  if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 8006c84:	0390      	lsls	r0, r2, #14
 8006c86:	d504      	bpl.n	8006c92 <HAL_PWR_ConfigPVD+0x4e>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 8006c88:	490c      	ldr	r1, [pc, #48]	; (8006cbc <HAL_PWR_ConfigPVD+0x78>)
 8006c8a:	684b      	ldr	r3, [r1, #4]
 8006c8c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006c90:	604b      	str	r3, [r1, #4]
  }

  /* Configure the edge */
  if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 8006c92:	07d1      	lsls	r1, r2, #31
 8006c94:	d504      	bpl.n	8006ca0 <HAL_PWR_ConfigPVD+0x5c>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 8006c96:	4909      	ldr	r1, [pc, #36]	; (8006cbc <HAL_PWR_ConfigPVD+0x78>)
 8006c98:	688b      	ldr	r3, [r1, #8]
 8006c9a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006c9e:	608b      	str	r3, [r1, #8]
  }

  if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 8006ca0:	0793      	lsls	r3, r2, #30
 8006ca2:	d504      	bpl.n	8006cae <HAL_PWR_ConfigPVD+0x6a>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 8006ca4:	4a05      	ldr	r2, [pc, #20]	; (8006cbc <HAL_PWR_ConfigPVD+0x78>)
 8006ca6:	68d3      	ldr	r3, [r2, #12]
 8006ca8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006cac:	60d3      	str	r3, [r2, #12]
  }

  return HAL_OK;
}
 8006cae:	2000      	movs	r0, #0
 8006cb0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006cb4:	4770      	bx	lr
 8006cb6:	bf00      	nop
 8006cb8:	40007000 	.word	0x40007000
 8006cbc:	40010400 	.word	0x40010400

08006cc0 <HAL_PWR_EnablePVD>:
  * @brief Enable the Power Voltage Detector (PVD).
  * @retval None
  */
void HAL_PWR_EnablePVD(void)
{
  SET_BIT(PWR->CR2, PWR_CR2_PVDE);
 8006cc0:	4a02      	ldr	r2, [pc, #8]	; (8006ccc <HAL_PWR_EnablePVD+0xc>)
 8006cc2:	6853      	ldr	r3, [r2, #4]
 8006cc4:	f043 0301 	orr.w	r3, r3, #1
 8006cc8:	6053      	str	r3, [r2, #4]
}
 8006cca:	4770      	bx	lr
 8006ccc:	40007000 	.word	0x40007000

08006cd0 <HAL_PWREx_GetVoltageRange>:
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006cd0:	4b07      	ldr	r3, [pc, #28]	; (8006cf0 <HAL_PWREx_GetVoltageRange+0x20>)
 8006cd2:	6818      	ldr	r0, [r3, #0]
 8006cd4:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8006cd8:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8006cdc:	d006      	beq.n	8006cec <HAL_PWREx_GetVoltageRange+0x1c>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 8006cde:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
    {
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
 8006ce2:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 8006ce6:	bf18      	it	ne
 8006ce8:	f44f 7000 	movne.w	r0, #512	; 0x200
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8006cec:	4770      	bx	lr
 8006cee:	bf00      	nop
 8006cf0:	40007000 	.word	0x40007000

08006cf4 <HAL_PWREx_ControlVoltageScaling>:

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006cf4:	4a3b      	ldr	r2, [pc, #236]	; (8006de4 <HAL_PWREx_ControlVoltageScaling+0xf0>)
{
 8006cf6:	b410      	push	{r4}
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006cf8:	6813      	ldr	r3, [r2, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8006cfa:	b968      	cbnz	r0, 8006d18 <HAL_PWREx_ControlVoltageScaling+0x24>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006cfc:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8006d00:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006d04:	d014      	beq.n	8006d30 <HAL_PWREx_ControlVoltageScaling+0x3c>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d06:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8006d0a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006d0e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    }
  }
#endif

  return HAL_OK;
}
 8006d12:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006d16:	4770      	bx	lr
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8006d18:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8006d1c:	d02f      	beq.n	8006d7e <HAL_PWREx_ControlVoltageScaling+0x8a>
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8006d1e:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8006d22:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8006d26:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8006d28:	2000      	movs	r0, #0
}
 8006d2a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006d2e:	4770      	bx	lr
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d30:	f8d2 1080 	ldr.w	r1, [r2, #128]	; 0x80
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006d34:	4b2c      	ldr	r3, [pc, #176]	; (8006de8 <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8006d36:	482d      	ldr	r0, [pc, #180]	; (8006dec <HAL_PWREx_ControlVoltageScaling+0xf8>)
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d38:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8006d3c:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8006d40:	6811      	ldr	r1, [r2, #0]
 8006d42:	f421 61c0 	bic.w	r1, r1, #1536	; 0x600
 8006d46:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8006d4a:	6011      	str	r1, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006d4c:	681c      	ldr	r4, [r3, #0]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006d4e:	6951      	ldr	r1, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006d50:	2332      	movs	r3, #50	; 0x32
 8006d52:	fb03 f304 	mul.w	r3, r3, r4
 8006d56:	fba0 0303 	umull	r0, r3, r0, r3
 8006d5a:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006d5c:	0548      	lsls	r0, r1, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006d5e:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006d62:	d506      	bpl.n	8006d72 <HAL_PWREx_ControlVoltageScaling+0x7e>
 8006d64:	e000      	b.n	8006d68 <HAL_PWREx_ControlVoltageScaling+0x74>
 8006d66:	b123      	cbz	r3, 8006d72 <HAL_PWREx_ControlVoltageScaling+0x7e>
 8006d68:	6951      	ldr	r1, [r2, #20]
 8006d6a:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8006d6c:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006d70:	d4f9      	bmi.n	8006d66 <HAL_PWREx_ControlVoltageScaling+0x72>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8006d72:	4b1c      	ldr	r3, [pc, #112]	; (8006de4 <HAL_PWREx_ControlVoltageScaling+0xf0>)
 8006d74:	695b      	ldr	r3, [r3, #20]
 8006d76:	055c      	lsls	r4, r3, #21
 8006d78:	d5d6      	bpl.n	8006d28 <HAL_PWREx_ControlVoltageScaling+0x34>
        return HAL_TIMEOUT;
 8006d7a:	2003      	movs	r0, #3
 8006d7c:	e7c9      	b.n	8006d12 <HAL_PWREx_ControlVoltageScaling+0x1e>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8006d7e:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8006d82:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006d86:	d009      	beq.n	8006d9c <HAL_PWREx_ControlVoltageScaling+0xa8>
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d88:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
}
 8006d8c:	f85d 4b04 	ldr.w	r4, [sp], #4
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d90:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  return HAL_OK;
 8006d94:	2000      	movs	r0, #0
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d96:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 8006d9a:	4770      	bx	lr
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006d9c:	f8d2 1080 	ldr.w	r1, [r2, #128]	; 0x80
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006da0:	4b11      	ldr	r3, [pc, #68]	; (8006de8 <HAL_PWREx_ControlVoltageScaling+0xf4>)
 8006da2:	4812      	ldr	r0, [pc, #72]	; (8006dec <HAL_PWREx_ControlVoltageScaling+0xf8>)
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8006da4:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8006da8:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8006dac:	6811      	ldr	r1, [r2, #0]
 8006dae:	f421 61c0 	bic.w	r1, r1, #1536	; 0x600
 8006db2:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8006db6:	6011      	str	r1, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006db8:	681c      	ldr	r4, [r3, #0]
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006dba:	6951      	ldr	r1, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006dbc:	2332      	movs	r3, #50	; 0x32
 8006dbe:	fb03 f304 	mul.w	r3, r3, r4
 8006dc2:	fba0 0303 	umull	r0, r3, r0, r3
 8006dc6:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006dc8:	0548      	lsls	r0, r1, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8006dca:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006dce:	d5d0      	bpl.n	8006d72 <HAL_PWREx_ControlVoltageScaling+0x7e>
 8006dd0:	e001      	b.n	8006dd6 <HAL_PWREx_ControlVoltageScaling+0xe2>
 8006dd2:	2b00      	cmp	r3, #0
 8006dd4:	d0cd      	beq.n	8006d72 <HAL_PWREx_ControlVoltageScaling+0x7e>
 8006dd6:	6951      	ldr	r1, [r2, #20]
 8006dd8:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8006dda:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8006dde:	d5c8      	bpl.n	8006d72 <HAL_PWREx_ControlVoltageScaling+0x7e>
 8006de0:	e7f7      	b.n	8006dd2 <HAL_PWREx_ControlVoltageScaling+0xde>
 8006de2:	bf00      	nop
 8006de4:	40007000 	.word	0x40007000
 8006de8:	20000124 	.word	0x20000124
 8006dec:	431bde83 	.word	0x431bde83

08006df0 <HAL_PWREx_EnterSHUTDOWNMode>:
  */
void HAL_PWREx_EnterSHUTDOWNMode(void)
{

  /* Set Shutdown mode */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 8006df0:	4906      	ldr	r1, [pc, #24]	; (8006e0c <HAL_PWREx_EnterSHUTDOWNMode+0x1c>)

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006df2:	4a07      	ldr	r2, [pc, #28]	; (8006e10 <HAL_PWREx_EnterSHUTDOWNMode+0x20>)
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_SHUTDOWN);
 8006df4:	680b      	ldr	r3, [r1, #0]
 8006df6:	f023 0307 	bic.w	r3, r3, #7
 8006dfa:	f043 0304 	orr.w	r3, r3, #4
 8006dfe:	600b      	str	r3, [r1, #0]
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8006e00:	6913      	ldr	r3, [r2, #16]
 8006e02:	f043 0304 	orr.w	r3, r3, #4
 8006e06:	6113      	str	r3, [r2, #16]
/* This option is used to ensure that store operations are completed */
#if defined ( __CC_ARM)
  __force_stores();
#endif
  /* Request Wait For Interrupt */
  __WFI();
 8006e08:	bf30      	wfi
}
 8006e0a:	4770      	bx	lr
 8006e0c:	40007000 	.word	0x40007000
 8006e10:	e000ed00 	.word	0xe000ed00

08006e14 <HAL_PWREx_PVM1Callback>:
__weak void HAL_PWREx_PVM1Callback(void)
{
  /* NOTE : This function should not be modified; when the callback is needed,
            HAL_PWREx_PVM1Callback() API can be implemented in the user file
   */
}
 8006e14:	4770      	bx	lr
 8006e16:	bf00      	nop

08006e18 <HAL_PWREx_PVM2Callback>:
 8006e18:	4770      	bx	lr
 8006e1a:	bf00      	nop

08006e1c <HAL_PWREx_PVM3Callback>:
 8006e1c:	4770      	bx	lr
 8006e1e:	bf00      	nop

08006e20 <HAL_PWREx_PVM4Callback>:
 8006e20:	4770      	bx	lr
 8006e22:	bf00      	nop

08006e24 <HAL_PWREx_PVD_PVM_IRQHandler>:
{
 8006e24:	b510      	push	{r4, lr}
  if(__HAL_PWR_PVD_EXTI_GET_FLAG() != 0x0U)
 8006e26:	4c17      	ldr	r4, [pc, #92]	; (8006e84 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8006e28:	6963      	ldr	r3, [r4, #20]
 8006e2a:	03db      	lsls	r3, r3, #15
 8006e2c:	d424      	bmi.n	8006e78 <HAL_PWREx_PVD_PVM_IRQHandler+0x54>
  if(__HAL_PWR_PVM1_EXTI_GET_FLAG() != 0x0U)
 8006e2e:	4c15      	ldr	r4, [pc, #84]	; (8006e84 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8006e30:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006e32:	0718      	lsls	r0, r3, #28
 8006e34:	d41b      	bmi.n	8006e6e <HAL_PWREx_PVD_PVM_IRQHandler+0x4a>
  if(__HAL_PWR_PVM2_EXTI_GET_FLAG() != 0x0U)
 8006e36:	4c13      	ldr	r4, [pc, #76]	; (8006e84 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8006e38:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006e3a:	06d9      	lsls	r1, r3, #27
 8006e3c:	d412      	bmi.n	8006e64 <HAL_PWREx_PVD_PVM_IRQHandler+0x40>
  if(__HAL_PWR_PVM3_EXTI_GET_FLAG() != 0x0U)
 8006e3e:	4c11      	ldr	r4, [pc, #68]	; (8006e84 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8006e40:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006e42:	069a      	lsls	r2, r3, #26
 8006e44:	d409      	bmi.n	8006e5a <HAL_PWREx_PVD_PVM_IRQHandler+0x36>
  if(__HAL_PWR_PVM4_EXTI_GET_FLAG() != 0x0U)
 8006e46:	4c0f      	ldr	r4, [pc, #60]	; (8006e84 <HAL_PWREx_PVD_PVM_IRQHandler+0x60>)
 8006e48:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8006e4a:	065b      	lsls	r3, r3, #25
 8006e4c:	d400      	bmi.n	8006e50 <HAL_PWREx_PVD_PVM_IRQHandler+0x2c>
}
 8006e4e:	bd10      	pop	{r4, pc}
    HAL_PWREx_PVM4Callback();
 8006e50:	f7ff ffe6 	bl	8006e20 <HAL_PWREx_PVM4Callback>
    __HAL_PWR_PVM4_EXTI_CLEAR_FLAG();
 8006e54:	2340      	movs	r3, #64	; 0x40
 8006e56:	6363      	str	r3, [r4, #52]	; 0x34
}
 8006e58:	bd10      	pop	{r4, pc}
    HAL_PWREx_PVM3Callback();
 8006e5a:	f7ff ffdf 	bl	8006e1c <HAL_PWREx_PVM3Callback>
    __HAL_PWR_PVM3_EXTI_CLEAR_FLAG();
 8006e5e:	2320      	movs	r3, #32
 8006e60:	6363      	str	r3, [r4, #52]	; 0x34
 8006e62:	e7f0      	b.n	8006e46 <HAL_PWREx_PVD_PVM_IRQHandler+0x22>
    HAL_PWREx_PVM2Callback();
 8006e64:	f7ff ffd8 	bl	8006e18 <HAL_PWREx_PVM2Callback>
    __HAL_PWR_PVM2_EXTI_CLEAR_FLAG();
 8006e68:	2310      	movs	r3, #16
 8006e6a:	6363      	str	r3, [r4, #52]	; 0x34
 8006e6c:	e7e7      	b.n	8006e3e <HAL_PWREx_PVD_PVM_IRQHandler+0x1a>
    HAL_PWREx_PVM1Callback();
 8006e6e:	f7ff ffd1 	bl	8006e14 <HAL_PWREx_PVM1Callback>
    __HAL_PWR_PVM1_EXTI_CLEAR_FLAG();
 8006e72:	2308      	movs	r3, #8
 8006e74:	6363      	str	r3, [r4, #52]	; 0x34
 8006e76:	e7de      	b.n	8006e36 <HAL_PWREx_PVD_PVM_IRQHandler+0x12>
    HAL_PWR_PVDCallback();
 8006e78:	f7fb ff30 	bl	8002cdc <HAL_PWR_PVDCallback>
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 8006e7c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8006e80:	6163      	str	r3, [r4, #20]
 8006e82:	e7d4      	b.n	8006e2e <HAL_PWREx_PVD_PVM_IRQHandler+0xa>
 8006e84:	40010400 	.word	0x40010400

08006e88 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8006e88:	b530      	push	{r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8006e8a:	4d1e      	ldr	r5, [pc, #120]	; (8006f04 <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 8006e8c:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8006e8e:	00db      	lsls	r3, r3, #3
{
 8006e90:	b083      	sub	sp, #12
 8006e92:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8006e94:	d51b      	bpl.n	8006ece <RCC_SetFlashLatencyFromMSIRange+0x46>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8006e96:	f7ff ff1b 	bl	8006cd0 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8006e9a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8006e9e:	d028      	beq.n	8006ef2 <RCC_SetFlashLatencyFromMSIRange+0x6a>
  }
  else
  {
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(msirange >= RCC_MSIRANGE_8)
 8006ea0:	2c7f      	cmp	r4, #127	; 0x7f
 8006ea2:	d812      	bhi.n	8006eca <RCC_SetFlashLatencyFromMSIRange+0x42>
      /* MSI >= 16Mhz */
      latency = FLASH_LATENCY_2; /* 2WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_7)
 8006ea4:	f1a4 0470 	sub.w	r4, r4, #112	; 0x70
 8006ea8:	fab4 f484 	clz	r4, r4
 8006eac:	0964      	lsrs	r4, r4, #5
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8006eae:	4916      	ldr	r1, [pc, #88]	; (8006f08 <RCC_SetFlashLatencyFromMSIRange+0x80>)
 8006eb0:	680b      	ldr	r3, [r1, #0]
 8006eb2:	f023 030f 	bic.w	r3, r3, #15
 8006eb6:	4323      	orrs	r3, r4
 8006eb8:	600b      	str	r3, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 8006eba:	6808      	ldr	r0, [r1, #0]
 8006ebc:	f000 000f 	and.w	r0, r0, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 8006ec0:	1b00      	subs	r0, r0, r4
 8006ec2:	bf18      	it	ne
 8006ec4:	2001      	movne	r0, #1
 8006ec6:	b003      	add	sp, #12
 8006ec8:	bd30      	pop	{r4, r5, pc}
        latency = FLASH_LATENCY_2; /* 2WS */
 8006eca:	2402      	movs	r4, #2
 8006ecc:	e7ef      	b.n	8006eae <RCC_SetFlashLatencyFromMSIRange+0x26>
    __HAL_RCC_PWR_CLK_ENABLE();
 8006ece:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8006ed0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8006ed4:	65ab      	str	r3, [r5, #88]	; 0x58
 8006ed6:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8006ed8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006edc:	9301      	str	r3, [sp, #4]
 8006ede:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8006ee0:	f7ff fef6 	bl	8006cd0 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8006ee4:	6dab      	ldr	r3, [r5, #88]	; 0x58
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8006ee6:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    __HAL_RCC_PWR_CLK_DISABLE();
 8006eea:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006eee:	65ab      	str	r3, [r5, #88]	; 0x58
  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8006ef0:	d1d6      	bne.n	8006ea0 <RCC_SetFlashLatencyFromMSIRange+0x18>
    if(msirange > RCC_MSIRANGE_8)
 8006ef2:	2c80      	cmp	r4, #128	; 0x80
 8006ef4:	d904      	bls.n	8006f00 <RCC_SetFlashLatencyFromMSIRange+0x78>
      if(msirange > RCC_MSIRANGE_10)
 8006ef6:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_1; /* 1WS */
 8006ef8:	bf8c      	ite	hi
 8006efa:	2402      	movhi	r4, #2
 8006efc:	2401      	movls	r4, #1
 8006efe:	e7d6      	b.n	8006eae <RCC_SetFlashLatencyFromMSIRange+0x26>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8006f00:	2400      	movs	r4, #0
 8006f02:	e7d4      	b.n	8006eae <RCC_SetFlashLatencyFromMSIRange+0x26>
 8006f04:	40021000 	.word	0x40021000
 8006f08:	40022000 	.word	0x40022000

08006f0c <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006f0c:	4a24      	ldr	r2, [pc, #144]	; (8006fa0 <HAL_RCC_GetSysClockFreq+0x94>)
 8006f0e:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006f10:	68d2      	ldr	r2, [r2, #12]
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8006f12:	f013 030c 	ands.w	r3, r3, #12
 8006f16:	d008      	beq.n	8006f2a <HAL_RCC_GetSysClockFreq+0x1e>
 8006f18:	2b0c      	cmp	r3, #12
 8006f1a:	d037      	beq.n	8006f8c <HAL_RCC_GetSysClockFreq+0x80>
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8006f1c:	2b04      	cmp	r3, #4
 8006f1e:	4821      	ldr	r0, [pc, #132]	; (8006fa4 <HAL_RCC_GetSysClockFreq+0x98>)
 8006f20:	d03a      	beq.n	8006f98 <HAL_RCC_GetSysClockFreq+0x8c>
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 8006f22:	2b08      	cmp	r3, #8
 8006f24:	bf18      	it	ne
 8006f26:	2000      	movne	r0, #0
 8006f28:	4770      	bx	lr
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8006f2a:	4a1d      	ldr	r2, [pc, #116]	; (8006fa0 <HAL_RCC_GetSysClockFreq+0x94>)
 8006f2c:	6811      	ldr	r1, [r2, #0]
 8006f2e:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8006f30:	bf54      	ite	pl
 8006f32:	f8d2 2094 	ldrpl.w	r2, [r2, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8006f36:	6812      	ldrmi	r2, [r2, #0]
    msirange = MSIRangeTable[msirange];
 8006f38:	491b      	ldr	r1, [pc, #108]	; (8006fa8 <HAL_RCC_GetSysClockFreq+0x9c>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8006f3a:	bf54      	ite	pl
 8006f3c:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8006f40:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 8006f44:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8006f48:	b1fb      	cbz	r3, 8006f8a <HAL_RCC_GetSysClockFreq+0x7e>
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8006f4a:	2b0c      	cmp	r3, #12
 8006f4c:	d125      	bne.n	8006f9a <HAL_RCC_GetSysClockFreq+0x8e>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006f4e:	4b14      	ldr	r3, [pc, #80]	; (8006fa0 <HAL_RCC_GetSysClockFreq+0x94>)
{
 8006f50:	b430      	push	{r4, r5}
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006f52:	68dc      	ldr	r4, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006f54:	68d9      	ldr	r1, [r3, #12]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8006f56:	68da      	ldr	r2, [r3, #12]
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006f58:	68db      	ldr	r3, [r3, #12]
      pllvco = HSI_VALUE;
 8006f5a:	4d12      	ldr	r5, [pc, #72]	; (8006fa4 <HAL_RCC_GetSysClockFreq+0x98>)
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8006f5c:	f004 0403 	and.w	r4, r4, #3
    switch (pllsource)
 8006f60:	3c02      	subs	r4, #2
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006f62:	f3c3 6341 	ubfx	r3, r3, #25, #2
      pllvco = HSI_VALUE;
 8006f66:	2c01      	cmp	r4, #1
 8006f68:	bf98      	it	ls
 8006f6a:	4628      	movls	r0, r5
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006f6c:	f3c1 1103 	ubfx	r1, r1, #4, #4
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8006f70:	f3c2 2206 	ubfx	r2, r2, #8, #7
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006f74:	3301      	adds	r3, #1
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8006f76:	3101      	adds	r1, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8006f78:	fb00 f002 	mul.w	r0, r0, r2
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8006f7c:	005b      	lsls	r3, r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8006f7e:	fbb0 f0f1 	udiv	r0, r0, r1
}
 8006f82:	bc30      	pop	{r4, r5}
    sysclockfreq = pllvco / pllr;
 8006f84:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8006f88:	4770      	bx	lr
 8006f8a:	4770      	bx	lr
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006f8c:	f002 0203 	and.w	r2, r2, #3
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8006f90:	2a01      	cmp	r2, #1
 8006f92:	d0ca      	beq.n	8006f2a <HAL_RCC_GetSysClockFreq+0x1e>
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8006f94:	2000      	movs	r0, #0
 8006f96:	e7da      	b.n	8006f4e <HAL_RCC_GetSysClockFreq+0x42>
 8006f98:	4770      	bx	lr
 8006f9a:	2000      	movs	r0, #0
  return sysclockfreq;
 8006f9c:	4770      	bx	lr
 8006f9e:	bf00      	nop
 8006fa0:	40021000 	.word	0x40021000
 8006fa4:	00f42400 	.word	0x00f42400
 8006fa8:	0801a13c 	.word	0x0801a13c

08006fac <HAL_RCC_OscConfig>:
  if(RCC_OscInitStruct == NULL)
 8006fac:	2800      	cmp	r0, #0
 8006fae:	f000 8239 	beq.w	8007424 <HAL_RCC_OscConfig+0x478>
{
 8006fb2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006fb6:	4a99      	ldr	r2, [pc, #612]	; (800721c <HAL_RCC_OscConfig+0x270>)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8006fb8:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006fba:	6895      	ldr	r5, [r2, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006fbc:	68d6      	ldr	r6, [r2, #12]
 8006fbe:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8006fc0:	06d8      	lsls	r0, r3, #27
{
 8006fc2:	b083      	sub	sp, #12
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8006fc4:	f005 050c 	and.w	r5, r5, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8006fc8:	f006 0603 	and.w	r6, r6, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8006fcc:	d52e      	bpl.n	800702c <HAL_RCC_OscConfig+0x80>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8006fce:	2d00      	cmp	r5, #0
 8006fd0:	f000 812b 	beq.w	800722a <HAL_RCC_OscConfig+0x27e>
 8006fd4:	2d0c      	cmp	r5, #12
 8006fd6:	f000 8125 	beq.w	8007224 <HAL_RCC_OscConfig+0x278>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8006fda:	69a3      	ldr	r3, [r4, #24]
        __HAL_RCC_MSI_ENABLE();
 8006fdc:	4f8f      	ldr	r7, [pc, #572]	; (800721c <HAL_RCC_OscConfig+0x270>)
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8006fde:	2b00      	cmp	r3, #0
 8006fe0:	f000 819b 	beq.w	800731a <HAL_RCC_OscConfig+0x36e>
        __HAL_RCC_MSI_ENABLE();
 8006fe4:	683b      	ldr	r3, [r7, #0]
 8006fe6:	f043 0301 	orr.w	r3, r3, #1
 8006fea:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 8006fec:	f7fd fdf8 	bl	8004be0 <HAL_GetTick>
 8006ff0:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8006ff2:	e006      	b.n	8007002 <HAL_RCC_OscConfig+0x56>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8006ff4:	f7fd fdf4 	bl	8004be0 <HAL_GetTick>
 8006ff8:	eba0 0008 	sub.w	r0, r0, r8
 8006ffc:	2802      	cmp	r0, #2
 8006ffe:	f200 819c 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8007002:	683b      	ldr	r3, [r7, #0]
 8007004:	079b      	lsls	r3, r3, #30
 8007006:	d5f5      	bpl.n	8006ff4 <HAL_RCC_OscConfig+0x48>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8007008:	683b      	ldr	r3, [r7, #0]
 800700a:	f043 0308 	orr.w	r3, r3, #8
 800700e:	603b      	str	r3, [r7, #0]
 8007010:	683b      	ldr	r3, [r7, #0]
 8007012:	6a22      	ldr	r2, [r4, #32]
 8007014:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8007018:	4313      	orrs	r3, r2
 800701a:	603b      	str	r3, [r7, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800701c:	687b      	ldr	r3, [r7, #4]
 800701e:	69e2      	ldr	r2, [r4, #28]
 8007020:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8007024:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007028:	607b      	str	r3, [r7, #4]
 800702a:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800702c:	07d9      	lsls	r1, r3, #31
 800702e:	f100 80cc 	bmi.w	80071ca <HAL_RCC_OscConfig+0x21e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8007032:	0799      	lsls	r1, r3, #30
 8007034:	d523      	bpl.n	800707e <HAL_RCC_OscConfig+0xd2>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 8007036:	2d04      	cmp	r5, #4
 8007038:	f000 815f 	beq.w	80072fa <HAL_RCC_OscConfig+0x34e>
 800703c:	2d0c      	cmp	r5, #12
 800703e:	f000 8159 	beq.w	80072f4 <HAL_RCC_OscConfig+0x348>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8007042:	68e3      	ldr	r3, [r4, #12]
        __HAL_RCC_HSI_ENABLE();
 8007044:	4e75      	ldr	r6, [pc, #468]	; (800721c <HAL_RCC_OscConfig+0x270>)
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8007046:	2b00      	cmp	r3, #0
 8007048:	f000 8192 	beq.w	8007370 <HAL_RCC_OscConfig+0x3c4>
        __HAL_RCC_HSI_ENABLE();
 800704c:	6833      	ldr	r3, [r6, #0]
 800704e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007052:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8007054:	f7fd fdc4 	bl	8004be0 <HAL_GetTick>
 8007058:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800705a:	e005      	b.n	8007068 <HAL_RCC_OscConfig+0xbc>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800705c:	f7fd fdc0 	bl	8004be0 <HAL_GetTick>
 8007060:	1bc0      	subs	r0, r0, r7
 8007062:	2802      	cmp	r0, #2
 8007064:	f200 8169 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8007068:	6833      	ldr	r3, [r6, #0]
 800706a:	055b      	lsls	r3, r3, #21
 800706c:	d5f6      	bpl.n	800705c <HAL_RCC_OscConfig+0xb0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800706e:	6873      	ldr	r3, [r6, #4]
 8007070:	6922      	ldr	r2, [r4, #16]
 8007072:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8007076:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800707a:	6073      	str	r3, [r6, #4]
 800707c:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800707e:	0719      	lsls	r1, r3, #28
 8007080:	d519      	bpl.n	80070b6 <HAL_RCC_OscConfig+0x10a>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8007082:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 8007084:	4e65      	ldr	r6, [pc, #404]	; (800721c <HAL_RCC_OscConfig+0x270>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8007086:	2b00      	cmp	r3, #0
 8007088:	f000 8120 	beq.w	80072cc <HAL_RCC_OscConfig+0x320>
      __HAL_RCC_LSI_ENABLE();
 800708c:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8007090:	f043 0301 	orr.w	r3, r3, #1
 8007094:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
      tickstart = HAL_GetTick();
 8007098:	f7fd fda2 	bl	8004be0 <HAL_GetTick>
 800709c:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800709e:	e005      	b.n	80070ac <HAL_RCC_OscConfig+0x100>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80070a0:	f7fd fd9e 	bl	8004be0 <HAL_GetTick>
 80070a4:	1bc0      	subs	r0, r0, r7
 80070a6:	2802      	cmp	r0, #2
 80070a8:	f200 8147 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80070ac:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 80070b0:	079a      	lsls	r2, r3, #30
 80070b2:	d5f5      	bpl.n	80070a0 <HAL_RCC_OscConfig+0xf4>
 80070b4:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80070b6:	075f      	lsls	r7, r3, #29
 80070b8:	d53f      	bpl.n	800713a <HAL_RCC_OscConfig+0x18e>
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 80070ba:	4b58      	ldr	r3, [pc, #352]	; (800721c <HAL_RCC_OscConfig+0x270>)
 80070bc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80070be:	00d6      	lsls	r6, r2, #3
 80070c0:	f100 8154 	bmi.w	800736c <HAL_RCC_OscConfig+0x3c0>
      __HAL_RCC_PWR_CLK_ENABLE();
 80070c4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80070c6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80070ca:	659a      	str	r2, [r3, #88]	; 0x58
 80070cc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80070ce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80070d2:	9301      	str	r3, [sp, #4]
 80070d4:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80070d6:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80070d8:	4f51      	ldr	r7, [pc, #324]	; (8007220 <HAL_RCC_OscConfig+0x274>)
 80070da:	683b      	ldr	r3, [r7, #0]
 80070dc:	05d8      	lsls	r0, r3, #23
 80070de:	f140 81a3 	bpl.w	8007428 <HAL_RCC_OscConfig+0x47c>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80070e2:	68a3      	ldr	r3, [r4, #8]
 80070e4:	2b01      	cmp	r3, #1
 80070e6:	f000 8155 	beq.w	8007394 <HAL_RCC_OscConfig+0x3e8>
 80070ea:	2b05      	cmp	r3, #5
 80070ec:	f000 81c7 	beq.w	800747e <HAL_RCC_OscConfig+0x4d2>
 80070f0:	4f4a      	ldr	r7, [pc, #296]	; (800721c <HAL_RCC_OscConfig+0x270>)
 80070f2:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80070f6:	f022 0201 	bic.w	r2, r2, #1
 80070fa:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
 80070fe:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8007102:	f022 0204 	bic.w	r2, r2, #4
 8007106:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800710a:	2b00      	cmp	r3, #0
 800710c:	f040 8149 	bne.w	80073a2 <HAL_RCC_OscConfig+0x3f6>
      tickstart = HAL_GetTick();
 8007110:	f7fd fd66 	bl	8004be0 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007114:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8007118:	4680      	mov	r8, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800711a:	e006      	b.n	800712a <HAL_RCC_OscConfig+0x17e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800711c:	f7fd fd60 	bl	8004be0 <HAL_GetTick>
 8007120:	eba0 0008 	sub.w	r0, r0, r8
 8007124:	4548      	cmp	r0, r9
 8007126:	f200 8108 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800712a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800712e:	079b      	lsls	r3, r3, #30
 8007130:	d4f4      	bmi.n	800711c <HAL_RCC_OscConfig+0x170>
    if(pwrclkchanged == SET)
 8007132:	2e00      	cmp	r6, #0
 8007134:	f040 818a 	bne.w	800744c <HAL_RCC_OscConfig+0x4a0>
 8007138:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800713a:	069e      	lsls	r6, r3, #26
 800713c:	d518      	bpl.n	8007170 <HAL_RCC_OscConfig+0x1c4>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800713e:	6a63      	ldr	r3, [r4, #36]	; 0x24
      __HAL_RCC_HSI48_ENABLE();
 8007140:	4e36      	ldr	r6, [pc, #216]	; (800721c <HAL_RCC_OscConfig+0x270>)
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8007142:	2b00      	cmp	r3, #0
 8007144:	f000 815a 	beq.w	80073fc <HAL_RCC_OscConfig+0x450>
      __HAL_RCC_HSI48_ENABLE();
 8007148:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 800714c:	f043 0301 	orr.w	r3, r3, #1
 8007150:	f8c6 3098 	str.w	r3, [r6, #152]	; 0x98
      tickstart = HAL_GetTick();
 8007154:	f7fd fd44 	bl	8004be0 <HAL_GetTick>
 8007158:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800715a:	e005      	b.n	8007168 <HAL_RCC_OscConfig+0x1bc>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800715c:	f7fd fd40 	bl	8004be0 <HAL_GetTick>
 8007160:	1bc0      	subs	r0, r0, r7
 8007162:	2802      	cmp	r0, #2
 8007164:	f200 80e9 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8007168:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 800716c:	0798      	lsls	r0, r3, #30
 800716e:	d5f5      	bpl.n	800715c <HAL_RCC_OscConfig+0x1b0>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8007170:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007172:	b333      	cbz	r3, 80071c2 <HAL_RCC_OscConfig+0x216>
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8007174:	2b02      	cmp	r3, #2
 8007176:	f000 8190 	beq.w	800749a <HAL_RCC_OscConfig+0x4ee>
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 800717a:	2d0c      	cmp	r5, #12
 800717c:	f000 8096 	beq.w	80072ac <HAL_RCC_OscConfig+0x300>
        __HAL_RCC_PLL_DISABLE();
 8007180:	4b26      	ldr	r3, [pc, #152]	; (800721c <HAL_RCC_OscConfig+0x270>)
 8007182:	681a      	ldr	r2, [r3, #0]
 8007184:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8007188:	601a      	str	r2, [r3, #0]
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 800718a:	681a      	ldr	r2, [r3, #0]
 800718c:	f012 5f20 	tst.w	r2, #671088640	; 0x28000000
 8007190:	d103      	bne.n	800719a <HAL_RCC_OscConfig+0x1ee>
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8007192:	68da      	ldr	r2, [r3, #12]
 8007194:	f022 0203 	bic.w	r2, r2, #3
 8007198:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 800719a:	4c20      	ldr	r4, [pc, #128]	; (800721c <HAL_RCC_OscConfig+0x270>)
 800719c:	68e3      	ldr	r3, [r4, #12]
 800719e:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 80071a2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80071a6:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80071a8:	f7fd fd1a 	bl	8004be0 <HAL_GetTick>
 80071ac:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80071ae:	e005      	b.n	80071bc <HAL_RCC_OscConfig+0x210>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80071b0:	f7fd fd16 	bl	8004be0 <HAL_GetTick>
 80071b4:	1b40      	subs	r0, r0, r5
 80071b6:	2802      	cmp	r0, #2
 80071b8:	f200 80bf 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80071bc:	6823      	ldr	r3, [r4, #0]
 80071be:	019b      	lsls	r3, r3, #6
 80071c0:	d4f6      	bmi.n	80071b0 <HAL_RCC_OscConfig+0x204>
  return HAL_OK;
 80071c2:	2000      	movs	r0, #0
}
 80071c4:	b003      	add	sp, #12
 80071c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 80071ca:	2d08      	cmp	r5, #8
 80071cc:	d074      	beq.n	80072b8 <HAL_RCC_OscConfig+0x30c>
 80071ce:	2d0c      	cmp	r5, #12
 80071d0:	d070      	beq.n	80072b4 <HAL_RCC_OscConfig+0x308>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80071d2:	6863      	ldr	r3, [r4, #4]
 80071d4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80071d8:	f000 80b3 	beq.w	8007342 <HAL_RCC_OscConfig+0x396>
 80071dc:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80071e0:	f000 8140 	beq.w	8007464 <HAL_RCC_OscConfig+0x4b8>
 80071e4:	4f0d      	ldr	r7, [pc, #52]	; (800721c <HAL_RCC_OscConfig+0x270>)
 80071e6:	683a      	ldr	r2, [r7, #0]
 80071e8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80071ec:	603a      	str	r2, [r7, #0]
 80071ee:	683a      	ldr	r2, [r7, #0]
 80071f0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80071f4:	603a      	str	r2, [r7, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80071f6:	2b00      	cmp	r3, #0
 80071f8:	f040 80a8 	bne.w	800734c <HAL_RCC_OscConfig+0x3a0>
        tickstart = HAL_GetTick();
 80071fc:	f7fd fcf0 	bl	8004be0 <HAL_GetTick>
 8007200:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8007202:	e006      	b.n	8007212 <HAL_RCC_OscConfig+0x266>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8007204:	f7fd fcec 	bl	8004be0 <HAL_GetTick>
 8007208:	eba0 0008 	sub.w	r0, r0, r8
 800720c:	2864      	cmp	r0, #100	; 0x64
 800720e:	f200 8094 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8007212:	683b      	ldr	r3, [r7, #0]
 8007214:	0398      	lsls	r0, r3, #14
 8007216:	d4f5      	bmi.n	8007204 <HAL_RCC_OscConfig+0x258>
 8007218:	6823      	ldr	r3, [r4, #0]
 800721a:	e70a      	b.n	8007032 <HAL_RCC_OscConfig+0x86>
 800721c:	40021000 	.word	0x40021000
 8007220:	40007000 	.word	0x40007000
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 8007224:	2e01      	cmp	r6, #1
 8007226:	f47f aed8 	bne.w	8006fda <HAL_RCC_OscConfig+0x2e>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800722a:	4ba9      	ldr	r3, [pc, #676]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 800722c:	681b      	ldr	r3, [r3, #0]
 800722e:	0799      	lsls	r1, r3, #30
 8007230:	d439      	bmi.n	80072a6 <HAL_RCC_OscConfig+0x2fa>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8007232:	4ba7      	ldr	r3, [pc, #668]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 8007234:	6a20      	ldr	r0, [r4, #32]
 8007236:	681a      	ldr	r2, [r3, #0]
 8007238:	0712      	lsls	r2, r2, #28
 800723a:	bf56      	itet	pl
 800723c:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8007240:	681b      	ldrmi	r3, [r3, #0]
 8007242:	091b      	lsrpl	r3, r3, #4
 8007244:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8007248:	4298      	cmp	r0, r3
 800724a:	f200 80bf 	bhi.w	80073cc <HAL_RCC_OscConfig+0x420>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800724e:	4ba0      	ldr	r3, [pc, #640]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 8007250:	681a      	ldr	r2, [r3, #0]
 8007252:	f042 0208 	orr.w	r2, r2, #8
 8007256:	601a      	str	r2, [r3, #0]
 8007258:	681a      	ldr	r2, [r3, #0]
 800725a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800725e:	4302      	orrs	r2, r0
 8007260:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8007262:	685a      	ldr	r2, [r3, #4]
 8007264:	69e1      	ldr	r1, [r4, #28]
 8007266:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800726a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800726e:	605a      	str	r2, [r3, #4]
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 8007270:	2d00      	cmp	r5, #0
 8007272:	f000 80f1 	beq.w	8007458 <HAL_RCC_OscConfig+0x4ac>
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8007276:	f7ff fe49 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
 800727a:	4a95      	ldr	r2, [pc, #596]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 800727c:	4995      	ldr	r1, [pc, #596]	; (80074d4 <HAL_RCC_OscConfig+0x528>)
 800727e:	6892      	ldr	r2, [r2, #8]
 8007280:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8007284:	4603      	mov	r3, r0
 8007286:	5c8a      	ldrb	r2, [r1, r2]
        status = HAL_InitTick(uwTickPrio);
 8007288:	4893      	ldr	r0, [pc, #588]	; (80074d8 <HAL_RCC_OscConfig+0x52c>)
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800728a:	4994      	ldr	r1, [pc, #592]	; (80074dc <HAL_RCC_OscConfig+0x530>)
        status = HAL_InitTick(uwTickPrio);
 800728c:	6800      	ldr	r0, [r0, #0]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800728e:	f002 021f 	and.w	r2, r2, #31
 8007292:	40d3      	lsrs	r3, r2
 8007294:	600b      	str	r3, [r1, #0]
        status = HAL_InitTick(uwTickPrio);
 8007296:	f7fd fc63 	bl	8004b60 <HAL_InitTick>
        if(status != HAL_OK)
 800729a:	b940      	cbnz	r0, 80072ae <HAL_RCC_OscConfig+0x302>
 800729c:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800729e:	07d9      	lsls	r1, r3, #31
 80072a0:	f57f aec7 	bpl.w	8007032 <HAL_RCC_OscConfig+0x86>
 80072a4:	e791      	b.n	80071ca <HAL_RCC_OscConfig+0x21e>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80072a6:	69a3      	ldr	r3, [r4, #24]
 80072a8:	2b00      	cmp	r3, #0
 80072aa:	d1c2      	bne.n	8007232 <HAL_RCC_OscConfig+0x286>
          return HAL_ERROR;
 80072ac:	2001      	movs	r0, #1
}
 80072ae:	b003      	add	sp, #12
 80072b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 80072b4:	2e03      	cmp	r6, #3
 80072b6:	d18c      	bne.n	80071d2 <HAL_RCC_OscConfig+0x226>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80072b8:	4a85      	ldr	r2, [pc, #532]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 80072ba:	6812      	ldr	r2, [r2, #0]
 80072bc:	0392      	lsls	r2, r2, #14
 80072be:	f57f aeb8 	bpl.w	8007032 <HAL_RCC_OscConfig+0x86>
 80072c2:	6862      	ldr	r2, [r4, #4]
 80072c4:	2a00      	cmp	r2, #0
 80072c6:	f47f aeb4 	bne.w	8007032 <HAL_RCC_OscConfig+0x86>
 80072ca:	e7ef      	b.n	80072ac <HAL_RCC_OscConfig+0x300>
      __HAL_RCC_LSI_DISABLE();
 80072cc:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 80072d0:	f023 0301 	bic.w	r3, r3, #1
 80072d4:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
      tickstart = HAL_GetTick();
 80072d8:	f7fd fc82 	bl	8004be0 <HAL_GetTick>
 80072dc:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80072de:	e004      	b.n	80072ea <HAL_RCC_OscConfig+0x33e>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80072e0:	f7fd fc7e 	bl	8004be0 <HAL_GetTick>
 80072e4:	1bc0      	subs	r0, r0, r7
 80072e6:	2802      	cmp	r0, #2
 80072e8:	d827      	bhi.n	800733a <HAL_RCC_OscConfig+0x38e>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 80072ea:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 80072ee:	079b      	lsls	r3, r3, #30
 80072f0:	d4f6      	bmi.n	80072e0 <HAL_RCC_OscConfig+0x334>
 80072f2:	e6df      	b.n	80070b4 <HAL_RCC_OscConfig+0x108>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80072f4:	2e02      	cmp	r6, #2
 80072f6:	f47f aea4 	bne.w	8007042 <HAL_RCC_OscConfig+0x96>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80072fa:	4a75      	ldr	r2, [pc, #468]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 80072fc:	6812      	ldr	r2, [r2, #0]
 80072fe:	0552      	lsls	r2, r2, #21
 8007300:	d502      	bpl.n	8007308 <HAL_RCC_OscConfig+0x35c>
 8007302:	68e2      	ldr	r2, [r4, #12]
 8007304:	2a00      	cmp	r2, #0
 8007306:	d0d1      	beq.n	80072ac <HAL_RCC_OscConfig+0x300>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8007308:	4971      	ldr	r1, [pc, #452]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 800730a:	6920      	ldr	r0, [r4, #16]
 800730c:	684a      	ldr	r2, [r1, #4]
 800730e:	f022 42fe 	bic.w	r2, r2, #2130706432	; 0x7f000000
 8007312:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8007316:	604a      	str	r2, [r1, #4]
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8007318:	e6b1      	b.n	800707e <HAL_RCC_OscConfig+0xd2>
        __HAL_RCC_MSI_DISABLE();
 800731a:	683b      	ldr	r3, [r7, #0]
 800731c:	f023 0301 	bic.w	r3, r3, #1
 8007320:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 8007322:	f7fd fc5d 	bl	8004be0 <HAL_GetTick>
 8007326:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8007328:	683b      	ldr	r3, [r7, #0]
 800732a:	0798      	lsls	r0, r3, #30
 800732c:	d5b6      	bpl.n	800729c <HAL_RCC_OscConfig+0x2f0>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800732e:	f7fd fc57 	bl	8004be0 <HAL_GetTick>
 8007332:	eba0 0008 	sub.w	r0, r0, r8
 8007336:	2802      	cmp	r0, #2
 8007338:	d9f6      	bls.n	8007328 <HAL_RCC_OscConfig+0x37c>
            return HAL_TIMEOUT;
 800733a:	2003      	movs	r0, #3
}
 800733c:	b003      	add	sp, #12
 800733e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8007342:	4a63      	ldr	r2, [pc, #396]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 8007344:	6813      	ldr	r3, [r2, #0]
 8007346:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800734a:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800734c:	f7fd fc48 	bl	8004be0 <HAL_GetTick>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8007350:	f8df 817c 	ldr.w	r8, [pc, #380]	; 80074d0 <HAL_RCC_OscConfig+0x524>
        tickstart = HAL_GetTick();
 8007354:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8007356:	e004      	b.n	8007362 <HAL_RCC_OscConfig+0x3b6>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8007358:	f7fd fc42 	bl	8004be0 <HAL_GetTick>
 800735c:	1bc0      	subs	r0, r0, r7
 800735e:	2864      	cmp	r0, #100	; 0x64
 8007360:	d8eb      	bhi.n	800733a <HAL_RCC_OscConfig+0x38e>
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8007362:	f8d8 3000 	ldr.w	r3, [r8]
 8007366:	039b      	lsls	r3, r3, #14
 8007368:	d5f6      	bpl.n	8007358 <HAL_RCC_OscConfig+0x3ac>
 800736a:	e755      	b.n	8007218 <HAL_RCC_OscConfig+0x26c>
    FlagStatus       pwrclkchanged = RESET;
 800736c:	2600      	movs	r6, #0
 800736e:	e6b3      	b.n	80070d8 <HAL_RCC_OscConfig+0x12c>
        __HAL_RCC_HSI_DISABLE();
 8007370:	6833      	ldr	r3, [r6, #0]
 8007372:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007376:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 8007378:	f7fd fc32 	bl	8004be0 <HAL_GetTick>
 800737c:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800737e:	e004      	b.n	800738a <HAL_RCC_OscConfig+0x3de>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8007380:	f7fd fc2e 	bl	8004be0 <HAL_GetTick>
 8007384:	1bc0      	subs	r0, r0, r7
 8007386:	2802      	cmp	r0, #2
 8007388:	d8d7      	bhi.n	800733a <HAL_RCC_OscConfig+0x38e>
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 800738a:	6833      	ldr	r3, [r6, #0]
 800738c:	0558      	lsls	r0, r3, #21
 800738e:	d4f7      	bmi.n	8007380 <HAL_RCC_OscConfig+0x3d4>
 8007390:	6823      	ldr	r3, [r4, #0]
 8007392:	e674      	b.n	800707e <HAL_RCC_OscConfig+0xd2>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8007394:	4a4e      	ldr	r2, [pc, #312]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 8007396:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800739a:	f043 0301 	orr.w	r3, r3, #1
 800739e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      tickstart = HAL_GetTick();
 80073a2:	f7fd fc1d 	bl	8004be0 <HAL_GetTick>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80073a6:	f8df 8128 	ldr.w	r8, [pc, #296]	; 80074d0 <HAL_RCC_OscConfig+0x524>
      tickstart = HAL_GetTick();
 80073aa:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80073ac:	f241 3988 	movw	r9, #5000	; 0x1388
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80073b0:	e004      	b.n	80073bc <HAL_RCC_OscConfig+0x410>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80073b2:	f7fd fc15 	bl	8004be0 <HAL_GetTick>
 80073b6:	1bc0      	subs	r0, r0, r7
 80073b8:	4548      	cmp	r0, r9
 80073ba:	d8be      	bhi.n	800733a <HAL_RCC_OscConfig+0x38e>
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80073bc:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 80073c0:	079a      	lsls	r2, r3, #30
 80073c2:	d5f6      	bpl.n	80073b2 <HAL_RCC_OscConfig+0x406>
    if(pwrclkchanged == SET)
 80073c4:	2e00      	cmp	r6, #0
 80073c6:	f43f aeb7 	beq.w	8007138 <HAL_RCC_OscConfig+0x18c>
 80073ca:	e03f      	b.n	800744c <HAL_RCC_OscConfig+0x4a0>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80073cc:	f7ff fd5c 	bl	8006e88 <RCC_SetFlashLatencyFromMSIRange>
 80073d0:	2800      	cmp	r0, #0
 80073d2:	f47f af6b 	bne.w	80072ac <HAL_RCC_OscConfig+0x300>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80073d6:	4b3e      	ldr	r3, [pc, #248]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 80073d8:	681a      	ldr	r2, [r3, #0]
 80073da:	f042 0208 	orr.w	r2, r2, #8
 80073de:	601a      	str	r2, [r3, #0]
 80073e0:	681a      	ldr	r2, [r3, #0]
 80073e2:	6a21      	ldr	r1, [r4, #32]
 80073e4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80073e8:	430a      	orrs	r2, r1
 80073ea:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80073ec:	685a      	ldr	r2, [r3, #4]
 80073ee:	69e1      	ldr	r1, [r4, #28]
 80073f0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80073f4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80073f8:	605a      	str	r2, [r3, #4]
 80073fa:	e73c      	b.n	8007276 <HAL_RCC_OscConfig+0x2ca>
      __HAL_RCC_HSI48_DISABLE();
 80073fc:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 8007400:	f023 0301 	bic.w	r3, r3, #1
 8007404:	f8c6 3098 	str.w	r3, [r6, #152]	; 0x98
      tickstart = HAL_GetTick();
 8007408:	f7fd fbea 	bl	8004be0 <HAL_GetTick>
 800740c:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800740e:	e004      	b.n	800741a <HAL_RCC_OscConfig+0x46e>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8007410:	f7fd fbe6 	bl	8004be0 <HAL_GetTick>
 8007414:	1bc0      	subs	r0, r0, r7
 8007416:	2802      	cmp	r0, #2
 8007418:	d88f      	bhi.n	800733a <HAL_RCC_OscConfig+0x38e>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 800741a:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 800741e:	0799      	lsls	r1, r3, #30
 8007420:	d4f6      	bmi.n	8007410 <HAL_RCC_OscConfig+0x464>
 8007422:	e6a5      	b.n	8007170 <HAL_RCC_OscConfig+0x1c4>
    return HAL_ERROR;
 8007424:	2001      	movs	r0, #1
}
 8007426:	4770      	bx	lr
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8007428:	683b      	ldr	r3, [r7, #0]
 800742a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800742e:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 8007430:	f7fd fbd6 	bl	8004be0 <HAL_GetTick>
 8007434:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8007436:	683b      	ldr	r3, [r7, #0]
 8007438:	05d9      	lsls	r1, r3, #23
 800743a:	f53f ae52 	bmi.w	80070e2 <HAL_RCC_OscConfig+0x136>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800743e:	f7fd fbcf 	bl	8004be0 <HAL_GetTick>
 8007442:	eba0 0008 	sub.w	r0, r0, r8
 8007446:	2802      	cmp	r0, #2
 8007448:	d9f5      	bls.n	8007436 <HAL_RCC_OscConfig+0x48a>
 800744a:	e776      	b.n	800733a <HAL_RCC_OscConfig+0x38e>
      __HAL_RCC_PWR_CLK_DISABLE();
 800744c:	4a20      	ldr	r2, [pc, #128]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 800744e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8007450:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8007454:	6593      	str	r3, [r2, #88]	; 0x58
 8007456:	e66f      	b.n	8007138 <HAL_RCC_OscConfig+0x18c>
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8007458:	f7ff fd16 	bl	8006e88 <RCC_SetFlashLatencyFromMSIRange>
 800745c:	2800      	cmp	r0, #0
 800745e:	f43f af0a 	beq.w	8007276 <HAL_RCC_OscConfig+0x2ca>
 8007462:	e723      	b.n	80072ac <HAL_RCC_OscConfig+0x300>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8007464:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007468:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 800746c:	681a      	ldr	r2, [r3, #0]
 800746e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8007472:	601a      	str	r2, [r3, #0]
 8007474:	681a      	ldr	r2, [r3, #0]
 8007476:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800747a:	601a      	str	r2, [r3, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800747c:	e766      	b.n	800734c <HAL_RCC_OscConfig+0x3a0>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800747e:	4b14      	ldr	r3, [pc, #80]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 8007480:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8007484:	f042 0204 	orr.w	r2, r2, #4
 8007488:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 800748c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8007490:	f042 0201 	orr.w	r2, r2, #1
 8007494:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8007498:	e783      	b.n	80073a2 <HAL_RCC_OscConfig+0x3f6>
      pll_config = RCC->PLLCFGR;
 800749a:	4e0d      	ldr	r6, [pc, #52]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800749c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      pll_config = RCC->PLLCFGR;
 800749e:	68f3      	ldr	r3, [r6, #12]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80074a0:	f003 0103 	and.w	r1, r3, #3
 80074a4:	4291      	cmp	r1, r2
 80074a6:	d055      	beq.n	8007554 <HAL_RCC_OscConfig+0x5a8>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 80074a8:	2d0c      	cmp	r5, #12
 80074aa:	f43f aeff 	beq.w	80072ac <HAL_RCC_OscConfig+0x300>
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 80074ae:	4d08      	ldr	r5, [pc, #32]	; (80074d0 <HAL_RCC_OscConfig+0x524>)
 80074b0:	682b      	ldr	r3, [r5, #0]
 80074b2:	015a      	lsls	r2, r3, #5
 80074b4:	f53f aefa 	bmi.w	80072ac <HAL_RCC_OscConfig+0x300>
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
 80074b8:	682b      	ldr	r3, [r5, #0]
 80074ba:	00db      	lsls	r3, r3, #3
 80074bc:	f53f aef6 	bmi.w	80072ac <HAL_RCC_OscConfig+0x300>
            __HAL_RCC_PLL_DISABLE();
 80074c0:	682b      	ldr	r3, [r5, #0]
 80074c2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80074c6:	602b      	str	r3, [r5, #0]
            tickstart = HAL_GetTick();
 80074c8:	f7fd fb8a 	bl	8004be0 <HAL_GetTick>
 80074cc:	4606      	mov	r6, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80074ce:	e00d      	b.n	80074ec <HAL_RCC_OscConfig+0x540>
 80074d0:	40021000 	.word	0x40021000
 80074d4:	0801a16c 	.word	0x0801a16c
 80074d8:	2000012c 	.word	0x2000012c
 80074dc:	20000124 	.word	0x20000124
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80074e0:	f7fd fb7e 	bl	8004be0 <HAL_GetTick>
 80074e4:	1b80      	subs	r0, r0, r6
 80074e6:	2802      	cmp	r0, #2
 80074e8:	f63f af27 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80074ec:	682b      	ldr	r3, [r5, #0]
 80074ee:	019f      	lsls	r7, r3, #6
 80074f0:	d4f6      	bmi.n	80074e0 <HAL_RCC_OscConfig+0x534>
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80074f2:	68e9      	ldr	r1, [r5, #12]
 80074f4:	4b36      	ldr	r3, [pc, #216]	; (80075d0 <HAL_RCC_OscConfig+0x624>)
 80074f6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80074f8:	6b67      	ldr	r7, [r4, #52]	; 0x34
 80074fa:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 80074fc:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80074fe:	400b      	ands	r3, r1
 8007500:	4313      	orrs	r3, r2
 8007502:	e9d4 120f 	ldrd	r1, r2, [r4, #60]	; 0x3c
 8007506:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 800750a:	ea43 63c6 	orr.w	r3, r3, r6, lsl #27
 800750e:	3801      	subs	r0, #1
 8007510:	0849      	lsrs	r1, r1, #1
 8007512:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8007516:	3901      	subs	r1, #1
 8007518:	0852      	lsrs	r2, r2, #1
 800751a:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 800751e:	3a01      	subs	r2, #1
 8007520:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8007524:	60eb      	str	r3, [r5, #12]
            __HAL_RCC_PLL_ENABLE();
 8007526:	682b      	ldr	r3, [r5, #0]
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8007528:	4e2a      	ldr	r6, [pc, #168]	; (80075d4 <HAL_RCC_OscConfig+0x628>)
            __HAL_RCC_PLL_ENABLE();
 800752a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800752e:	602b      	str	r3, [r5, #0]
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8007530:	68eb      	ldr	r3, [r5, #12]
 8007532:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8007536:	60eb      	str	r3, [r5, #12]
            tickstart = HAL_GetTick();
 8007538:	f7fd fb52 	bl	8004be0 <HAL_GetTick>
 800753c:	4604      	mov	r4, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800753e:	e005      	b.n	800754c <HAL_RCC_OscConfig+0x5a0>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8007540:	f7fd fb4e 	bl	8004be0 <HAL_GetTick>
 8007544:	1b00      	subs	r0, r0, r4
 8007546:	2802      	cmp	r0, #2
 8007548:	f63f aef7 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800754c:	6833      	ldr	r3, [r6, #0]
 800754e:	0198      	lsls	r0, r3, #6
 8007550:	d5f6      	bpl.n	8007540 <HAL_RCC_OscConfig+0x594>
 8007552:	e636      	b.n	80071c2 <HAL_RCC_OscConfig+0x216>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8007554:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8007556:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800755a:	3901      	subs	r1, #1
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800755c:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8007560:	d1a2      	bne.n	80074a8 <HAL_RCC_OscConfig+0x4fc>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8007562:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8007564:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8007568:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 800756c:	d19c      	bne.n	80074a8 <HAL_RCC_OscConfig+0x4fc>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 800756e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8007570:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8007574:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8007578:	d196      	bne.n	80074a8 <HAL_RCC_OscConfig+0x4fc>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 800757a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800757c:	0852      	lsrs	r2, r2, #1
 800757e:	3a01      	subs	r2, #1
 8007580:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8007584:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8007588:	d18e      	bne.n	80074a8 <HAL_RCC_OscConfig+0x4fc>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 800758a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800758c:	0852      	lsrs	r2, r2, #1
 800758e:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8007592:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8007594:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 8007598:	d186      	bne.n	80074a8 <HAL_RCC_OscConfig+0x4fc>
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800759a:	6833      	ldr	r3, [r6, #0]
 800759c:	0199      	lsls	r1, r3, #6
 800759e:	f53f ae10 	bmi.w	80071c2 <HAL_RCC_OscConfig+0x216>
          __HAL_RCC_PLL_ENABLE();
 80075a2:	6833      	ldr	r3, [r6, #0]
 80075a4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80075a8:	6033      	str	r3, [r6, #0]
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80075aa:	68f3      	ldr	r3, [r6, #12]
 80075ac:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80075b0:	60f3      	str	r3, [r6, #12]
          tickstart = HAL_GetTick();
 80075b2:	f7fd fb15 	bl	8004be0 <HAL_GetTick>
 80075b6:	4604      	mov	r4, r0
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80075b8:	e005      	b.n	80075c6 <HAL_RCC_OscConfig+0x61a>
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80075ba:	f7fd fb11 	bl	8004be0 <HAL_GetTick>
 80075be:	1b00      	subs	r0, r0, r4
 80075c0:	2802      	cmp	r0, #2
 80075c2:	f63f aeba 	bhi.w	800733a <HAL_RCC_OscConfig+0x38e>
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80075c6:	6833      	ldr	r3, [r6, #0]
 80075c8:	019a      	lsls	r2, r3, #6
 80075ca:	d5f6      	bpl.n	80075ba <HAL_RCC_OscConfig+0x60e>
 80075cc:	e5f9      	b.n	80071c2 <HAL_RCC_OscConfig+0x216>
 80075ce:	bf00      	nop
 80075d0:	019d800c 	.word	0x019d800c
 80075d4:	40021000 	.word	0x40021000

080075d8 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 80075d8:	2800      	cmp	r0, #0
 80075da:	f000 8095 	beq.w	8007708 <HAL_RCC_ClockConfig+0x130>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80075de:	4a83      	ldr	r2, [pc, #524]	; (80077ec <HAL_RCC_ClockConfig+0x214>)
{
 80075e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80075e4:	6813      	ldr	r3, [r2, #0]
 80075e6:	f003 030f 	and.w	r3, r3, #15
 80075ea:	428b      	cmp	r3, r1
 80075ec:	460d      	mov	r5, r1
 80075ee:	4604      	mov	r4, r0
 80075f0:	d20c      	bcs.n	800760c <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80075f2:	6813      	ldr	r3, [r2, #0]
 80075f4:	f023 030f 	bic.w	r3, r3, #15
 80075f8:	430b      	orrs	r3, r1
 80075fa:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80075fc:	6813      	ldr	r3, [r2, #0]
 80075fe:	f003 030f 	and.w	r3, r3, #15
 8007602:	428b      	cmp	r3, r1
 8007604:	d002      	beq.n	800760c <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8007606:	2001      	movs	r0, #1
}
 8007608:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800760c:	6823      	ldr	r3, [r4, #0]
 800760e:	07da      	lsls	r2, r3, #31
 8007610:	d56d      	bpl.n	80076ee <HAL_RCC_ClockConfig+0x116>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8007612:	6862      	ldr	r2, [r4, #4]
 8007614:	2a03      	cmp	r2, #3
 8007616:	d079      	beq.n	800770c <HAL_RCC_ClockConfig+0x134>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8007618:	4b75      	ldr	r3, [pc, #468]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800761a:	2a02      	cmp	r2, #2
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800761c:	681b      	ldr	r3, [r3, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800761e:	d070      	beq.n	8007702 <HAL_RCC_ClockConfig+0x12a>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8007620:	2a00      	cmp	r2, #0
 8007622:	f040 8096 	bne.w	8007752 <HAL_RCC_ClockConfig+0x17a>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8007626:	079e      	lsls	r6, r3, #30
 8007628:	d5ed      	bpl.n	8007606 <HAL_RCC_ClockConfig+0x2e>
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 800762a:	f7ff fc6f 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
 800762e:	4b71      	ldr	r3, [pc, #452]	; (80077f4 <HAL_RCC_ClockConfig+0x21c>)
 8007630:	4298      	cmp	r0, r3
 8007632:	f200 8083 	bhi.w	800773c <HAL_RCC_ClockConfig+0x164>
 8007636:	6862      	ldr	r2, [r4, #4]
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8007638:	f04f 0900 	mov.w	r9, #0
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800763c:	4e6c      	ldr	r6, [pc, #432]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 800763e:	68b3      	ldr	r3, [r6, #8]
 8007640:	f023 0303 	bic.w	r3, r3, #3
 8007644:	431a      	orrs	r2, r3
 8007646:	60b2      	str	r2, [r6, #8]
    tickstart = HAL_GetTick();
 8007648:	f7fd faca 	bl	8004be0 <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800764c:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8007650:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8007652:	e004      	b.n	800765e <HAL_RCC_ClockConfig+0x86>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8007654:	f7fd fac4 	bl	8004be0 <HAL_GetTick>
 8007658:	1bc0      	subs	r0, r0, r7
 800765a:	4540      	cmp	r0, r8
 800765c:	d86c      	bhi.n	8007738 <HAL_RCC_ClockConfig+0x160>
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800765e:	68b3      	ldr	r3, [r6, #8]
 8007660:	6862      	ldr	r2, [r4, #4]
 8007662:	f003 030c 	and.w	r3, r3, #12
 8007666:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800766a:	d1f3      	bne.n	8007654 <HAL_RCC_ClockConfig+0x7c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800766c:	6823      	ldr	r3, [r4, #0]
 800766e:	0799      	lsls	r1, r3, #30
 8007670:	d43f      	bmi.n	80076f2 <HAL_RCC_ClockConfig+0x11a>
    if(hpre == RCC_SYSCLK_DIV2)
 8007672:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
 8007676:	d103      	bne.n	8007680 <HAL_RCC_ClockConfig+0xa8>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8007678:	68b2      	ldr	r2, [r6, #8]
 800767a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800767e:	60b2      	str	r2, [r6, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8007680:	495a      	ldr	r1, [pc, #360]	; (80077ec <HAL_RCC_ClockConfig+0x214>)
 8007682:	680a      	ldr	r2, [r1, #0]
 8007684:	f002 020f 	and.w	r2, r2, #15
 8007688:	42aa      	cmp	r2, r5
 800768a:	d909      	bls.n	80076a0 <HAL_RCC_ClockConfig+0xc8>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800768c:	680a      	ldr	r2, [r1, #0]
 800768e:	f022 020f 	bic.w	r2, r2, #15
 8007692:	432a      	orrs	r2, r5
 8007694:	600a      	str	r2, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8007696:	680a      	ldr	r2, [r1, #0]
 8007698:	f002 020f 	and.w	r2, r2, #15
 800769c:	42aa      	cmp	r2, r5
 800769e:	d1b2      	bne.n	8007606 <HAL_RCC_ClockConfig+0x2e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80076a0:	075a      	lsls	r2, r3, #29
 80076a2:	d506      	bpl.n	80076b2 <HAL_RCC_ClockConfig+0xda>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80076a4:	4952      	ldr	r1, [pc, #328]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 80076a6:	68e0      	ldr	r0, [r4, #12]
 80076a8:	688a      	ldr	r2, [r1, #8]
 80076aa:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80076ae:	4302      	orrs	r2, r0
 80076b0:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80076b2:	071b      	lsls	r3, r3, #28
 80076b4:	d507      	bpl.n	80076c6 <HAL_RCC_ClockConfig+0xee>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80076b6:	4a4e      	ldr	r2, [pc, #312]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 80076b8:	6921      	ldr	r1, [r4, #16]
 80076ba:	6893      	ldr	r3, [r2, #8]
 80076bc:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80076c0:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80076c4:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80076c6:	f7ff fc21 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
 80076ca:	4a49      	ldr	r2, [pc, #292]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 80076cc:	4c4a      	ldr	r4, [pc, #296]	; (80077f8 <HAL_RCC_ClockConfig+0x220>)
 80076ce:	6892      	ldr	r2, [r2, #8]
 80076d0:	494a      	ldr	r1, [pc, #296]	; (80077fc <HAL_RCC_ClockConfig+0x224>)
 80076d2:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80076d6:	4603      	mov	r3, r0
 80076d8:	5ca2      	ldrb	r2, [r4, r2]
  status = HAL_InitTick(uwTickPrio);
 80076da:	4849      	ldr	r0, [pc, #292]	; (8007800 <HAL_RCC_ClockConfig+0x228>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80076dc:	f002 021f 	and.w	r2, r2, #31
 80076e0:	40d3      	lsrs	r3, r2
 80076e2:	600b      	str	r3, [r1, #0]
  status = HAL_InitTick(uwTickPrio);
 80076e4:	6800      	ldr	r0, [r0, #0]
}
 80076e6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  status = HAL_InitTick(uwTickPrio);
 80076ea:	f7fd ba39 	b.w	8004b60 <HAL_InitTick>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80076ee:	079f      	lsls	r7, r3, #30
 80076f0:	d5c6      	bpl.n	8007680 <HAL_RCC_ClockConfig+0xa8>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80076f2:	493f      	ldr	r1, [pc, #252]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 80076f4:	68a0      	ldr	r0, [r4, #8]
 80076f6:	688a      	ldr	r2, [r1, #8]
 80076f8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80076fc:	4302      	orrs	r2, r0
 80076fe:	608a      	str	r2, [r1, #8]
 8007700:	e7be      	b.n	8007680 <HAL_RCC_ClockConfig+0xa8>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8007702:	039f      	lsls	r7, r3, #14
 8007704:	d491      	bmi.n	800762a <HAL_RCC_ClockConfig+0x52>
 8007706:	e77e      	b.n	8007606 <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8007708:	2001      	movs	r0, #1
}
 800770a:	4770      	bx	lr
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800770c:	4938      	ldr	r1, [pc, #224]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 800770e:	6808      	ldr	r0, [r1, #0]
 8007710:	0186      	lsls	r6, r0, #6
 8007712:	f57f af78 	bpl.w	8007606 <HAL_RCC_ClockConfig+0x2e>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 8007716:	68c8      	ldr	r0, [r1, #12]
 8007718:	f000 0003 	and.w	r0, r0, #3
 800771c:	2801      	cmp	r0, #1
 800771e:	d01c      	beq.n	800775a <HAL_RCC_ClockConfig+0x182>
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8007720:	68c8      	ldr	r0, [r1, #12]
 8007722:	f000 0003 	and.w	r0, r0, #3

  switch (pllsource)
 8007726:	3802      	subs	r0, #2
 8007728:	2801      	cmp	r0, #1
 800772a:	d95c      	bls.n	80077e6 <HAL_RCC_ClockConfig+0x20e>
  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
    break;
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800772c:	68cb      	ldr	r3, [r1, #12]
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 800772e:	68cb      	ldr	r3, [r1, #12]
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8007730:	68cb      	ldr	r3, [r1, #12]
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8007732:	f04f 0900 	mov.w	r9, #0
 8007736:	e781      	b.n	800763c <HAL_RCC_ClockConfig+0x64>
        return HAL_TIMEOUT;
 8007738:	2003      	movs	r0, #3
 800773a:	e765      	b.n	8007608 <HAL_RCC_ClockConfig+0x30>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 800773c:	4a2c      	ldr	r2, [pc, #176]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
 800773e:	6893      	ldr	r3, [r2, #8]
 8007740:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8007744:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007748:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 800774a:	6862      	ldr	r2, [r4, #4]
 800774c:	f04f 0980 	mov.w	r9, #128	; 0x80
 8007750:	e774      	b.n	800763c <HAL_RCC_ClockConfig+0x64>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8007752:	0558      	lsls	r0, r3, #21
 8007754:	f57f af57 	bpl.w	8007606 <HAL_RCC_ClockConfig+0x2e>
 8007758:	e767      	b.n	800762a <HAL_RCC_ClockConfig+0x52>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 800775a:	6808      	ldr	r0, [r1, #0]
    msirange = MSIRangeTable[msirange];
 800775c:	4e29      	ldr	r6, [pc, #164]	; (8007804 <HAL_RCC_ClockConfig+0x22c>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 800775e:	0700      	lsls	r0, r0, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8007760:	bf54      	ite	pl
 8007762:	f8d1 1094 	ldrpl.w	r1, [r1, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8007766:	6809      	ldrmi	r1, [r1, #0]
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8007768:	4821      	ldr	r0, [pc, #132]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 800776a:	bf54      	ite	pl
 800776c:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8007770:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8007774:	68c0      	ldr	r0, [r0, #12]
    msirange = MSIRangeTable[msirange];
 8007776:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
    pllvco = HSI_VALUE;
 800777a:	4e23      	ldr	r6, [pc, #140]	; (8007808 <HAL_RCC_ClockConfig+0x230>)
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800777c:	f000 0003 	and.w	r0, r0, #3
  switch (pllsource)
 8007780:	3802      	subs	r0, #2
    pllvco = HSI_VALUE;
 8007782:	2801      	cmp	r0, #1
 8007784:	bf98      	it	ls
 8007786:	4631      	movls	r1, r6
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8007788:	4e19      	ldr	r6, [pc, #100]	; (80077f0 <HAL_RCC_ClockConfig+0x218>)
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 800778a:	4f1a      	ldr	r7, [pc, #104]	; (80077f4 <HAL_RCC_ClockConfig+0x21c>)
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800778c:	f8d6 c00c 	ldr.w	ip, [r6, #12]
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8007790:	f8d6 e00c 	ldr.w	lr, [r6, #12]
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8007794:	68f0      	ldr	r0, [r6, #12]
 8007796:	f3c0 6041 	ubfx	r0, r0, #25, #2
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800779a:	f3cc 1c03 	ubfx	ip, ip, #4, #4
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 800779e:	f3ce 2e06 	ubfx	lr, lr, #8, #7
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80077a2:	3001      	adds	r0, #1
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80077a4:	f10c 0c01 	add.w	ip, ip, #1
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 80077a8:	fb01 f10e 	mul.w	r1, r1, lr
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80077ac:	0040      	lsls	r0, r0, #1
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 80077ae:	fbb1 f1fc 	udiv	r1, r1, ip
  sysclockfreq = pllvco / pllr;
 80077b2:	fbb1 f1f0 	udiv	r1, r1, r0
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 80077b6:	42b9      	cmp	r1, r7
 80077b8:	d909      	bls.n	80077ce <HAL_RCC_ClockConfig+0x1f6>
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 80077ba:	68b1      	ldr	r1, [r6, #8]
 80077bc:	f011 0ff0 	tst.w	r1, #240	; 0xf0
 80077c0:	d008      	beq.n	80077d4 <HAL_RCC_ClockConfig+0x1fc>
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 80077c2:	f013 0902 	ands.w	r9, r3, #2
 80077c6:	f43f af39 	beq.w	800763c <HAL_RCC_ClockConfig+0x64>
 80077ca:	68a3      	ldr	r3, [r4, #8]
 80077cc:	b113      	cbz	r3, 80077d4 <HAL_RCC_ClockConfig+0x1fc>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 80077ce:	f04f 0900 	mov.w	r9, #0
 80077d2:	e733      	b.n	800763c <HAL_RCC_ClockConfig+0x64>
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 80077d4:	68b3      	ldr	r3, [r6, #8]
 80077d6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80077da:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80077de:	60b3      	str	r3, [r6, #8]
          hpre = RCC_SYSCLK_DIV2;
 80077e0:	f04f 0980 	mov.w	r9, #128	; 0x80
 80077e4:	e72a      	b.n	800763c <HAL_RCC_ClockConfig+0x64>
    pllvco = HSI_VALUE;
 80077e6:	4908      	ldr	r1, [pc, #32]	; (8007808 <HAL_RCC_ClockConfig+0x230>)
 80077e8:	e7ce      	b.n	8007788 <HAL_RCC_ClockConfig+0x1b0>
 80077ea:	bf00      	nop
 80077ec:	40022000 	.word	0x40022000
 80077f0:	40021000 	.word	0x40021000
 80077f4:	04c4b400 	.word	0x04c4b400
 80077f8:	0801a16c 	.word	0x0801a16c
 80077fc:	20000124 	.word	0x20000124
 8007800:	2000012c 	.word	0x2000012c
 8007804:	0801a13c 	.word	0x0801a13c
 8007808:	00f42400 	.word	0x00f42400

0800780c <HAL_RCC_GetHCLKFreq>:
  return SystemCoreClock;
 800780c:	4b01      	ldr	r3, [pc, #4]	; (8007814 <HAL_RCC_GetHCLKFreq+0x8>)
}
 800780e:	6818      	ldr	r0, [r3, #0]
 8007810:	4770      	bx	lr
 8007812:	bf00      	nop
 8007814:	20000124 	.word	0x20000124

08007818 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8007818:	4b05      	ldr	r3, [pc, #20]	; (8007830 <HAL_RCC_GetPCLK1Freq+0x18>)
 800781a:	4a06      	ldr	r2, [pc, #24]	; (8007834 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800781c:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800781e:	4906      	ldr	r1, [pc, #24]	; (8007838 <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8007820:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8007824:	6808      	ldr	r0, [r1, #0]
 8007826:	5cd3      	ldrb	r3, [r2, r3]
 8007828:	f003 031f 	and.w	r3, r3, #31
}
 800782c:	40d8      	lsrs	r0, r3
 800782e:	4770      	bx	lr
 8007830:	40021000 	.word	0x40021000
 8007834:	0801a17c 	.word	0x0801a17c
 8007838:	20000124 	.word	0x20000124

0800783c <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 800783c:	4b05      	ldr	r3, [pc, #20]	; (8007854 <HAL_RCC_GetPCLK2Freq+0x18>)
 800783e:	4a06      	ldr	r2, [pc, #24]	; (8007858 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8007840:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8007842:	4906      	ldr	r1, [pc, #24]	; (800785c <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8007844:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8007848:	6808      	ldr	r0, [r1, #0]
 800784a:	5cd3      	ldrb	r3, [r2, r3]
 800784c:	f003 031f 	and.w	r3, r3, #31
}
 8007850:	40d8      	lsrs	r0, r3
 8007852:	4770      	bx	lr
 8007854:	40021000 	.word	0x40021000
 8007858:	0801a17c 	.word	0x0801a17c
 800785c:	20000124 	.word	0x20000124

08007860 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8007860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8007862:	4b44      	ldr	r3, [pc, #272]	; (8007974 <RCCEx_PLLSAI1_Config+0x114>)
 8007864:	68da      	ldr	r2, [r3, #12]
 8007866:	0792      	lsls	r2, r2, #30
{
 8007868:	4605      	mov	r5, r0
 800786a:	460f      	mov	r7, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800786c:	d007      	beq.n	800787e <RCCEx_PLLSAI1_Config+0x1e>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 800786e:	68db      	ldr	r3, [r3, #12]
 8007870:	6802      	ldr	r2, [r0, #0]
 8007872:	f003 0303 	and.w	r3, r3, #3
 8007876:	4293      	cmp	r3, r2
 8007878:	d012      	beq.n	80078a0 <RCCEx_PLLSAI1_Config+0x40>
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
#endif
      )
    {
      status = HAL_ERROR;
 800787a:	2001      	movs	r0, #1
      }
    }
  }

  return status;
}
 800787c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai1->PLLSAI1Source)
 800787e:	6800      	ldr	r0, [r0, #0]
 8007880:	2802      	cmp	r0, #2
 8007882:	d04e      	beq.n	8007922 <RCCEx_PLLSAI1_Config+0xc2>
 8007884:	2803      	cmp	r0, #3
 8007886:	d045      	beq.n	8007914 <RCCEx_PLLSAI1_Config+0xb4>
 8007888:	2801      	cmp	r0, #1
 800788a:	d1f6      	bne.n	800787a <RCCEx_PLLSAI1_Config+0x1a>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 800788c:	681b      	ldr	r3, [r3, #0]
 800788e:	079b      	lsls	r3, r3, #30
 8007890:	d5f4      	bpl.n	800787c <RCCEx_PLLSAI1_Config+0x1c>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 8007892:	4a38      	ldr	r2, [pc, #224]	; (8007974 <RCCEx_PLLSAI1_Config+0x114>)
 8007894:	68d3      	ldr	r3, [r2, #12]
 8007896:	f023 0303 	bic.w	r3, r3, #3
 800789a:	4318      	orrs	r0, r3
 800789c:	60d0      	str	r0, [r2, #12]
  if(status == HAL_OK)
 800789e:	e001      	b.n	80078a4 <RCCEx_PLLSAI1_Config+0x44>
       ||
 80078a0:	2b00      	cmp	r3, #0
 80078a2:	d0ea      	beq.n	800787a <RCCEx_PLLSAI1_Config+0x1a>
    __HAL_RCC_PLLSAI1_DISABLE();
 80078a4:	4c33      	ldr	r4, [pc, #204]	; (8007974 <RCCEx_PLLSAI1_Config+0x114>)
 80078a6:	6823      	ldr	r3, [r4, #0]
 80078a8:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80078ac:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 80078ae:	f7fd f997 	bl	8004be0 <HAL_GetTick>
 80078b2:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 80078b4:	e004      	b.n	80078c0 <RCCEx_PLLSAI1_Config+0x60>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80078b6:	f7fd f993 	bl	8004be0 <HAL_GetTick>
 80078ba:	1b83      	subs	r3, r0, r6
 80078bc:	2b02      	cmp	r3, #2
 80078be:	d834      	bhi.n	800792a <RCCEx_PLLSAI1_Config+0xca>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 80078c0:	6823      	ldr	r3, [r4, #0]
 80078c2:	011a      	lsls	r2, r3, #4
 80078c4:	d4f7      	bmi.n	80078b6 <RCCEx_PLLSAI1_Config+0x56>
      if(Divider == DIVIDER_P_UPDATE)
 80078c6:	2f00      	cmp	r7, #0
 80078c8:	d131      	bne.n	800792e <RCCEx_PLLSAI1_Config+0xce>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80078ca:	e9d5 6302 	ldrd	r6, r3, [r5, #8]
 80078ce:	6920      	ldr	r0, [r4, #16]
 80078d0:	4929      	ldr	r1, [pc, #164]	; (8007978 <RCCEx_PLLSAI1_Config+0x118>)
 80078d2:	686a      	ldr	r2, [r5, #4]
 80078d4:	06db      	lsls	r3, r3, #27
 80078d6:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 80078da:	4001      	ands	r1, r0
 80078dc:	430b      	orrs	r3, r1
 80078de:	3a01      	subs	r2, #1
 80078e0:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 80078e4:	6123      	str	r3, [r4, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 80078e6:	4c23      	ldr	r4, [pc, #140]	; (8007974 <RCCEx_PLLSAI1_Config+0x114>)
 80078e8:	6823      	ldr	r3, [r4, #0]
 80078ea:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80078ee:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 80078f0:	f7fd f976 	bl	8004be0 <HAL_GetTick>
 80078f4:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 80078f6:	e004      	b.n	8007902 <RCCEx_PLLSAI1_Config+0xa2>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80078f8:	f7fd f972 	bl	8004be0 <HAL_GetTick>
 80078fc:	1b83      	subs	r3, r0, r6
 80078fe:	2b02      	cmp	r3, #2
 8007900:	d813      	bhi.n	800792a <RCCEx_PLLSAI1_Config+0xca>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8007902:	6823      	ldr	r3, [r4, #0]
 8007904:	011b      	lsls	r3, r3, #4
 8007906:	d5f7      	bpl.n	80078f8 <RCCEx_PLLSAI1_Config+0x98>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8007908:	69aa      	ldr	r2, [r5, #24]
 800790a:	6923      	ldr	r3, [r4, #16]
 800790c:	4313      	orrs	r3, r2
 800790e:	6123      	str	r3, [r4, #16]
 8007910:	2000      	movs	r0, #0
}
 8007912:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8007914:	681a      	ldr	r2, [r3, #0]
 8007916:	0394      	lsls	r4, r2, #14
 8007918:	d4bb      	bmi.n	8007892 <RCCEx_PLLSAI1_Config+0x32>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 800791a:	681b      	ldr	r3, [r3, #0]
 800791c:	0359      	lsls	r1, r3, #13
 800791e:	d5ac      	bpl.n	800787a <RCCEx_PLLSAI1_Config+0x1a>
 8007920:	e7b7      	b.n	8007892 <RCCEx_PLLSAI1_Config+0x32>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8007922:	681b      	ldr	r3, [r3, #0]
 8007924:	055e      	lsls	r6, r3, #21
 8007926:	d5a8      	bpl.n	800787a <RCCEx_PLLSAI1_Config+0x1a>
 8007928:	e7b3      	b.n	8007892 <RCCEx_PLLSAI1_Config+0x32>
        status = HAL_TIMEOUT;
 800792a:	2003      	movs	r0, #3
}
 800792c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      else if(Divider == DIVIDER_Q_UPDATE)
 800792e:	2f01      	cmp	r7, #1
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8007930:	6926      	ldr	r6, [r4, #16]
      else if(Divider == DIVIDER_Q_UPDATE)
 8007932:	d00f      	beq.n	8007954 <RCCEx_PLLSAI1_Config+0xf4>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8007934:	e9d5 1001 	ldrd	r1, r0, [r5, #4]
 8007938:	4b10      	ldr	r3, [pc, #64]	; (800797c <RCCEx_PLLSAI1_Config+0x11c>)
 800793a:	696a      	ldr	r2, [r5, #20]
 800793c:	4033      	ands	r3, r6
 800793e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8007942:	3901      	subs	r1, #1
 8007944:	0852      	lsrs	r2, r2, #1
 8007946:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800794a:	3a01      	subs	r2, #1
 800794c:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8007950:	6123      	str	r3, [r4, #16]
 8007952:	e7c8      	b.n	80078e6 <RCCEx_PLLSAI1_Config+0x86>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8007954:	e9d5 1001 	ldrd	r1, r0, [r5, #4]
 8007958:	4b09      	ldr	r3, [pc, #36]	; (8007980 <RCCEx_PLLSAI1_Config+0x120>)
 800795a:	692a      	ldr	r2, [r5, #16]
 800795c:	4033      	ands	r3, r6
 800795e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8007962:	3901      	subs	r1, #1
 8007964:	0852      	lsrs	r2, r2, #1
 8007966:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800796a:	3a01      	subs	r2, #1
 800796c:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8007970:	6123      	str	r3, [r4, #16]
 8007972:	e7b8      	b.n	80078e6 <RCCEx_PLLSAI1_Config+0x86>
 8007974:	40021000 	.word	0x40021000
 8007978:	07ff800f 	.word	0x07ff800f
 800797c:	f9ff800f 	.word	0xf9ff800f
 8007980:	ff9f800f 	.word	0xff9f800f

08007984 <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
{
 8007984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8007986:	4b44      	ldr	r3, [pc, #272]	; (8007a98 <RCCEx_PLLSAI2_Config+0x114>)
 8007988:	68da      	ldr	r2, [r3, #12]
 800798a:	0792      	lsls	r2, r2, #30
{
 800798c:	4605      	mov	r5, r0
 800798e:	460f      	mov	r7, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8007990:	d007      	beq.n	80079a2 <RCCEx_PLLSAI2_Config+0x1e>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8007992:	68db      	ldr	r3, [r3, #12]
 8007994:	6802      	ldr	r2, [r0, #0]
 8007996:	f003 0303 	and.w	r3, r3, #3
 800799a:	4293      	cmp	r3, r2
 800799c:	d012      	beq.n	80079c4 <RCCEx_PLLSAI2_Config+0x40>
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai2->PLLSAI2M)
#endif
      )
    {
      status = HAL_ERROR;
 800799e:	2001      	movs	r0, #1
      }
    }
  }

  return status;
}
 80079a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai2->PLLSAI2Source)
 80079a2:	6800      	ldr	r0, [r0, #0]
 80079a4:	2802      	cmp	r0, #2
 80079a6:	d04e      	beq.n	8007a46 <RCCEx_PLLSAI2_Config+0xc2>
 80079a8:	2803      	cmp	r0, #3
 80079aa:	d045      	beq.n	8007a38 <RCCEx_PLLSAI2_Config+0xb4>
 80079ac:	2801      	cmp	r0, #1
 80079ae:	d1f6      	bne.n	800799e <RCCEx_PLLSAI2_Config+0x1a>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 80079b0:	681b      	ldr	r3, [r3, #0]
 80079b2:	079b      	lsls	r3, r3, #30
 80079b4:	d5f4      	bpl.n	80079a0 <RCCEx_PLLSAI2_Config+0x1c>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 80079b6:	4a38      	ldr	r2, [pc, #224]	; (8007a98 <RCCEx_PLLSAI2_Config+0x114>)
 80079b8:	68d3      	ldr	r3, [r2, #12]
 80079ba:	f023 0303 	bic.w	r3, r3, #3
 80079be:	4318      	orrs	r0, r3
 80079c0:	60d0      	str	r0, [r2, #12]
  if(status == HAL_OK)
 80079c2:	e001      	b.n	80079c8 <RCCEx_PLLSAI2_Config+0x44>
       ||
 80079c4:	2b00      	cmp	r3, #0
 80079c6:	d0ea      	beq.n	800799e <RCCEx_PLLSAI2_Config+0x1a>
    __HAL_RCC_PLLSAI2_DISABLE();
 80079c8:	4c33      	ldr	r4, [pc, #204]	; (8007a98 <RCCEx_PLLSAI2_Config+0x114>)
 80079ca:	6823      	ldr	r3, [r4, #0]
 80079cc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80079d0:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 80079d2:	f7fd f905 	bl	8004be0 <HAL_GetTick>
 80079d6:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 80079d8:	e004      	b.n	80079e4 <RCCEx_PLLSAI2_Config+0x60>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80079da:	f7fd f901 	bl	8004be0 <HAL_GetTick>
 80079de:	1b83      	subs	r3, r0, r6
 80079e0:	2b02      	cmp	r3, #2
 80079e2:	d834      	bhi.n	8007a4e <RCCEx_PLLSAI2_Config+0xca>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 80079e4:	6823      	ldr	r3, [r4, #0]
 80079e6:	009a      	lsls	r2, r3, #2
 80079e8:	d4f7      	bmi.n	80079da <RCCEx_PLLSAI2_Config+0x56>
      if(Divider == DIVIDER_P_UPDATE)
 80079ea:	2f00      	cmp	r7, #0
 80079ec:	d131      	bne.n	8007a52 <RCCEx_PLLSAI2_Config+0xce>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 80079ee:	e9d5 6302 	ldrd	r6, r3, [r5, #8]
 80079f2:	6960      	ldr	r0, [r4, #20]
 80079f4:	4929      	ldr	r1, [pc, #164]	; (8007a9c <RCCEx_PLLSAI2_Config+0x118>)
 80079f6:	686a      	ldr	r2, [r5, #4]
 80079f8:	06db      	lsls	r3, r3, #27
 80079fa:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 80079fe:	4001      	ands	r1, r0
 8007a00:	430b      	orrs	r3, r1
 8007a02:	3a01      	subs	r2, #1
 8007a04:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8007a08:	6163      	str	r3, [r4, #20]
      __HAL_RCC_PLLSAI2_ENABLE();
 8007a0a:	4c23      	ldr	r4, [pc, #140]	; (8007a98 <RCCEx_PLLSAI2_Config+0x114>)
 8007a0c:	6823      	ldr	r3, [r4, #0]
 8007a0e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007a12:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 8007a14:	f7fd f8e4 	bl	8004be0 <HAL_GetTick>
 8007a18:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8007a1a:	e004      	b.n	8007a26 <RCCEx_PLLSAI2_Config+0xa2>
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8007a1c:	f7fd f8e0 	bl	8004be0 <HAL_GetTick>
 8007a20:	1b83      	subs	r3, r0, r6
 8007a22:	2b02      	cmp	r3, #2
 8007a24:	d813      	bhi.n	8007a4e <RCCEx_PLLSAI2_Config+0xca>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8007a26:	6823      	ldr	r3, [r4, #0]
 8007a28:	009b      	lsls	r3, r3, #2
 8007a2a:	d5f7      	bpl.n	8007a1c <RCCEx_PLLSAI2_Config+0x98>
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8007a2c:	69aa      	ldr	r2, [r5, #24]
 8007a2e:	6963      	ldr	r3, [r4, #20]
 8007a30:	4313      	orrs	r3, r2
 8007a32:	6163      	str	r3, [r4, #20]
 8007a34:	2000      	movs	r0, #0
}
 8007a36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8007a38:	681a      	ldr	r2, [r3, #0]
 8007a3a:	0394      	lsls	r4, r2, #14
 8007a3c:	d4bb      	bmi.n	80079b6 <RCCEx_PLLSAI2_Config+0x32>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8007a3e:	681b      	ldr	r3, [r3, #0]
 8007a40:	0359      	lsls	r1, r3, #13
 8007a42:	d5ac      	bpl.n	800799e <RCCEx_PLLSAI2_Config+0x1a>
 8007a44:	e7b7      	b.n	80079b6 <RCCEx_PLLSAI2_Config+0x32>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8007a46:	681b      	ldr	r3, [r3, #0]
 8007a48:	055e      	lsls	r6, r3, #21
 8007a4a:	d5a8      	bpl.n	800799e <RCCEx_PLLSAI2_Config+0x1a>
 8007a4c:	e7b3      	b.n	80079b6 <RCCEx_PLLSAI2_Config+0x32>
        status = HAL_TIMEOUT;
 8007a4e:	2003      	movs	r0, #3
}
 8007a50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      else if(Divider == DIVIDER_Q_UPDATE)
 8007a52:	2f01      	cmp	r7, #1
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8007a54:	6966      	ldr	r6, [r4, #20]
      else if(Divider == DIVIDER_Q_UPDATE)
 8007a56:	d00f      	beq.n	8007a78 <RCCEx_PLLSAI2_Config+0xf4>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8007a58:	e9d5 1001 	ldrd	r1, r0, [r5, #4]
 8007a5c:	4b10      	ldr	r3, [pc, #64]	; (8007aa0 <RCCEx_PLLSAI2_Config+0x11c>)
 8007a5e:	696a      	ldr	r2, [r5, #20]
 8007a60:	4033      	ands	r3, r6
 8007a62:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8007a66:	3901      	subs	r1, #1
 8007a68:	0852      	lsrs	r2, r2, #1
 8007a6a:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8007a6e:	3a01      	subs	r2, #1
 8007a70:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8007a74:	6163      	str	r3, [r4, #20]
 8007a76:	e7c8      	b.n	8007a0a <RCCEx_PLLSAI2_Config+0x86>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8007a78:	e9d5 1001 	ldrd	r1, r0, [r5, #4]
 8007a7c:	4b09      	ldr	r3, [pc, #36]	; (8007aa4 <RCCEx_PLLSAI2_Config+0x120>)
 8007a7e:	692a      	ldr	r2, [r5, #16]
 8007a80:	4033      	ands	r3, r6
 8007a82:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8007a86:	3901      	subs	r1, #1
 8007a88:	0852      	lsrs	r2, r2, #1
 8007a8a:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8007a8e:	3a01      	subs	r2, #1
 8007a90:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8007a94:	6163      	str	r3, [r4, #20]
 8007a96:	e7b8      	b.n	8007a0a <RCCEx_PLLSAI2_Config+0x86>
 8007a98:	40021000 	.word	0x40021000
 8007a9c:	07ff800f 	.word	0x07ff800f
 8007aa0:	f9ff800f 	.word	0xf9ff800f
 8007aa4:	ff9f800f 	.word	0xff9f800f

08007aa8 <HAL_RCCEx_PeriphCLKConfig>:
{
 8007aa8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8007aac:	6803      	ldr	r3, [r0, #0]
 8007aae:	f413 6500 	ands.w	r5, r3, #2048	; 0x800
{
 8007ab2:	b082      	sub	sp, #8
 8007ab4:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8007ab6:	d023      	beq.n	8007b00 <HAL_RCCEx_PeriphCLKConfig+0x58>
    switch(PeriphClkInit->Sai1ClockSelection)
 8007ab8:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 8007aba:	2940      	cmp	r1, #64	; 0x40
 8007abc:	f000 825e 	beq.w	8007f7c <HAL_RCCEx_PeriphCLKConfig+0x4d4>
 8007ac0:	d810      	bhi.n	8007ae4 <HAL_RCCEx_PeriphCLKConfig+0x3c>
 8007ac2:	2900      	cmp	r1, #0
 8007ac4:	f000 8214 	beq.w	8007ef0 <HAL_RCCEx_PeriphCLKConfig+0x448>
 8007ac8:	2920      	cmp	r1, #32
 8007aca:	f040 8282 	bne.w	8007fd2 <HAL_RCCEx_PeriphCLKConfig+0x52a>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8007ace:	2100      	movs	r1, #0
 8007ad0:	3020      	adds	r0, #32
 8007ad2:	f7ff ff57 	bl	8007984 <RCCEx_PLLSAI2_Config>
 8007ad6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8007ad8:	2d00      	cmp	r5, #0
 8007ada:	f040 824d 	bne.w	8007f78 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
 8007ade:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8007ae0:	6823      	ldr	r3, [r4, #0]
 8007ae2:	e004      	b.n	8007aee <HAL_RCCEx_PeriphCLKConfig+0x46>
    switch(PeriphClkInit->Sai1ClockSelection)
 8007ae4:	2960      	cmp	r1, #96	; 0x60
 8007ae6:	d002      	beq.n	8007aee <HAL_RCCEx_PeriphCLKConfig+0x46>
 8007ae8:	2980      	cmp	r1, #128	; 0x80
 8007aea:	f040 8272 	bne.w	8007fd2 <HAL_RCCEx_PeriphCLKConfig+0x52a>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8007aee:	48b3      	ldr	r0, [pc, #716]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007af0:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8007af4:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8007af8:	4311      	orrs	r1, r2
 8007afa:	f8c0 109c 	str.w	r1, [r0, #156]	; 0x9c
 8007afe:	2500      	movs	r5, #0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8007b00:	04d8      	lsls	r0, r3, #19
 8007b02:	f140 8147 	bpl.w	8007d94 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
    switch(PeriphClkInit->Sai2ClockSelection)
 8007b06:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8007b08:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8007b0c:	f000 822d 	beq.w	8007f6a <HAL_RCCEx_PeriphCLKConfig+0x4c2>
 8007b10:	f200 8133 	bhi.w	8007d7a <HAL_RCCEx_PeriphCLKConfig+0x2d2>
 8007b14:	2900      	cmp	r1, #0
 8007b16:	f000 81f3 	beq.w	8007f00 <HAL_RCCEx_PeriphCLKConfig+0x458>
 8007b1a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8007b1e:	f040 8255 	bne.w	8007fcc <HAL_RCCEx_PeriphCLKConfig+0x524>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8007b22:	2100      	movs	r1, #0
 8007b24:	f104 0020 	add.w	r0, r4, #32
 8007b28:	f7ff ff2c 	bl	8007984 <RCCEx_PLLSAI2_Config>
 8007b2c:	6823      	ldr	r3, [r4, #0]
 8007b2e:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 8007b30:	2e00      	cmp	r6, #0
 8007b32:	f040 812d 	bne.w	8007d90 <HAL_RCCEx_PeriphCLKConfig+0x2e8>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8007b36:	49a1      	ldr	r1, [pc, #644]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007b38:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8007b3a:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8007b3e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8007b42:	4302      	orrs	r2, r0
 8007b44:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8007b48:	0399      	lsls	r1, r3, #14
 8007b4a:	f100 8127 	bmi.w	8007d9c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8007b4e:	07da      	lsls	r2, r3, #31
 8007b50:	d508      	bpl.n	8007b64 <HAL_RCCEx_PeriphCLKConfig+0xbc>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8007b52:	499a      	ldr	r1, [pc, #616]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007b54:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007b56:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007b5a:	f022 0203 	bic.w	r2, r2, #3
 8007b5e:	4302      	orrs	r2, r0
 8007b60:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8007b64:	079f      	lsls	r7, r3, #30
 8007b66:	d508      	bpl.n	8007b7a <HAL_RCCEx_PeriphCLKConfig+0xd2>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8007b68:	4994      	ldr	r1, [pc, #592]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007b6a:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8007b6c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007b70:	f022 020c 	bic.w	r2, r2, #12
 8007b74:	4302      	orrs	r2, r0
 8007b76:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8007b7a:	0758      	lsls	r0, r3, #29
 8007b7c:	d508      	bpl.n	8007b90 <HAL_RCCEx_PeriphCLKConfig+0xe8>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8007b7e:	498f      	ldr	r1, [pc, #572]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007b80:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8007b82:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007b86:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8007b8a:	4302      	orrs	r2, r0
 8007b8c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8007b90:	0719      	lsls	r1, r3, #28
 8007b92:	d508      	bpl.n	8007ba6 <HAL_RCCEx_PeriphCLKConfig+0xfe>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8007b94:	4989      	ldr	r1, [pc, #548]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007b96:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8007b98:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007b9c:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8007ba0:	4302      	orrs	r2, r0
 8007ba2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8007ba6:	06da      	lsls	r2, r3, #27
 8007ba8:	d508      	bpl.n	8007bbc <HAL_RCCEx_PeriphCLKConfig+0x114>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8007baa:	4984      	ldr	r1, [pc, #528]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007bac:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8007bae:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007bb2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8007bb6:	4302      	orrs	r2, r0
 8007bb8:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8007bbc:	069f      	lsls	r7, r3, #26
 8007bbe:	d508      	bpl.n	8007bd2 <HAL_RCCEx_PeriphCLKConfig+0x12a>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8007bc0:	497e      	ldr	r1, [pc, #504]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007bc2:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8007bc4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007bc8:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8007bcc:	4302      	orrs	r2, r0
 8007bce:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8007bd2:	0598      	lsls	r0, r3, #22
 8007bd4:	d508      	bpl.n	8007be8 <HAL_RCCEx_PeriphCLKConfig+0x140>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8007bd6:	4979      	ldr	r1, [pc, #484]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007bd8:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8007bda:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007bde:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8007be2:	4302      	orrs	r2, r0
 8007be4:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8007be8:	0559      	lsls	r1, r3, #21
 8007bea:	d508      	bpl.n	8007bfe <HAL_RCCEx_PeriphCLKConfig+0x156>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8007bec:	4973      	ldr	r1, [pc, #460]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007bee:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8007bf0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007bf4:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8007bf8:	4302      	orrs	r2, r0
 8007bfa:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8007bfe:	065a      	lsls	r2, r3, #25
 8007c00:	d508      	bpl.n	8007c14 <HAL_RCCEx_PeriphCLKConfig+0x16c>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8007c02:	496e      	ldr	r1, [pc, #440]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007c04:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8007c06:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007c0a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8007c0e:	4302      	orrs	r2, r0
 8007c10:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8007c14:	061f      	lsls	r7, r3, #24
 8007c16:	d508      	bpl.n	8007c2a <HAL_RCCEx_PeriphCLKConfig+0x182>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8007c18:	4968      	ldr	r1, [pc, #416]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007c1a:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8007c1c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007c20:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8007c24:	4302      	orrs	r2, r0
 8007c26:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8007c2a:	05d8      	lsls	r0, r3, #23
 8007c2c:	d508      	bpl.n	8007c40 <HAL_RCCEx_PeriphCLKConfig+0x198>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8007c2e:	4963      	ldr	r1, [pc, #396]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007c30:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8007c32:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007c36:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8007c3a:	4302      	orrs	r2, r0
 8007c3c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8007c40:	02d9      	lsls	r1, r3, #11
 8007c42:	d508      	bpl.n	8007c56 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8007c44:	495d      	ldr	r1, [pc, #372]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007c46:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8007c48:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8007c4c:	f022 0203 	bic.w	r2, r2, #3
 8007c50:	4302      	orrs	r2, r0
 8007c52:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8007c56:	049a      	lsls	r2, r3, #18
 8007c58:	d510      	bpl.n	8007c7c <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8007c5a:	4958      	ldr	r1, [pc, #352]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007c5c:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8007c5e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007c62:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8007c66:	4302      	orrs	r2, r0
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8007c68:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8007c6c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8007c70:	f000 814c 	beq.w	8007f0c <HAL_RCCEx_PeriphCLKConfig+0x464>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8007c74:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 8007c78:	f000 8186 	beq.w	8007f88 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8007c7c:	031f      	lsls	r7, r3, #12
 8007c7e:	d51a      	bpl.n	8007cb6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8007c80:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8007c82:	4a4e      	ldr	r2, [pc, #312]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007c84:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 8007c88:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
 8007c8c:	f000 8143 	beq.w	8007f16 <HAL_RCCEx_PeriphCLKConfig+0x46e>
 8007c90:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8007c94:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
 8007c98:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 8007c9c:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 8007ca0:	4301      	orrs	r1, r0
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8007ca2:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8007ca6:	f8c2 1088 	str.w	r1, [r2, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8007caa:	f040 80e7 	bne.w	8007e7c <HAL_RCCEx_PeriphCLKConfig+0x3d4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007cae:	68d1      	ldr	r1, [r2, #12]
 8007cb0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007cb4:	60d1      	str	r1, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8007cb6:	0358      	lsls	r0, r3, #13
 8007cb8:	d510      	bpl.n	8007cdc <HAL_RCCEx_PeriphCLKConfig+0x234>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8007cba:	4940      	ldr	r1, [pc, #256]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007cbc:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8007cbe:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8007cc2:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8007cc6:	4302      	orrs	r2, r0
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8007cc8:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8007ccc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8007cd0:	f000 812a 	beq.w	8007f28 <HAL_RCCEx_PeriphCLKConfig+0x480>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8007cd4:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 8007cd8:	f000 8161 	beq.w	8007f9e <HAL_RCCEx_PeriphCLKConfig+0x4f6>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8007cdc:	0459      	lsls	r1, r3, #17
 8007cde:	d50d      	bpl.n	8007cfc <HAL_RCCEx_PeriphCLKConfig+0x254>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8007ce0:	4836      	ldr	r0, [pc, #216]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007ce2:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 8007ce6:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8007cea:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8007cee:	430a      	orrs	r2, r1
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8007cf0:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8007cf4:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8007cf8:	f000 8123 	beq.w	8007f42 <HAL_RCCEx_PeriphCLKConfig+0x49a>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8007cfc:	03da      	lsls	r2, r3, #15
 8007cfe:	d509      	bpl.n	8007d14 <HAL_RCCEx_PeriphCLKConfig+0x26c>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8007d00:	492e      	ldr	r1, [pc, #184]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007d02:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8007d06:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8007d0a:	f022 0204 	bic.w	r2, r2, #4
 8007d0e:	4302      	orrs	r2, r0
 8007d10:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 8007d14:	029f      	lsls	r7, r3, #10
 8007d16:	d509      	bpl.n	8007d2c <HAL_RCCEx_PeriphCLKConfig+0x284>
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8007d18:	4928      	ldr	r1, [pc, #160]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007d1a:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8007d1e:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8007d22:	f022 0218 	bic.w	r2, r2, #24
 8007d26:	4302      	orrs	r2, r0
 8007d28:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8007d2c:	0258      	lsls	r0, r3, #9
 8007d2e:	f100 80b4 	bmi.w	8007e9a <HAL_RCCEx_PeriphCLKConfig+0x3f2>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DSI) == RCC_PERIPHCLK_DSI)
 8007d32:	021a      	lsls	r2, r3, #8
 8007d34:	d50d      	bpl.n	8007d52 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 8007d36:	4821      	ldr	r0, [pc, #132]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007d38:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8007d3c:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8007d40:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8007d44:	430a      	orrs	r2, r1
    if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
 8007d46:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
    __HAL_RCC_DSI_CONFIG(PeriphClkInit->DsiClockSelection);
 8007d4a:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
    if(PeriphClkInit->DsiClockSelection == RCC_DSICLKSOURCE_PLLSAI2)
 8007d4e:	f000 8103 	beq.w	8007f58 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8007d52:	01db      	lsls	r3, r3, #7
 8007d54:	d50d      	bpl.n	8007d72 <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8007d56:	4a19      	ldr	r2, [pc, #100]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007d58:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 8007d5c:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8007d60:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8007d64:	430b      	orrs	r3, r1
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8007d66:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8007d6a:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8007d6e:	f000 80e0 	beq.w	8007f32 <HAL_RCCEx_PeriphCLKConfig+0x48a>
}
 8007d72:	4628      	mov	r0, r5
 8007d74:	b002      	add	sp, #8
 8007d76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch(PeriphClkInit->Sai2ClockSelection)
 8007d7a:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 8007d7e:	d003      	beq.n	8007d88 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
 8007d80:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8007d84:	f040 8122 	bne.w	8007fcc <HAL_RCCEx_PeriphCLKConfig+0x524>
 8007d88:	462e      	mov	r6, r5
    if(ret == HAL_OK)
 8007d8a:	2e00      	cmp	r6, #0
 8007d8c:	f43f aed3 	beq.w	8007b36 <HAL_RCCEx_PeriphCLKConfig+0x8e>
 8007d90:	4635      	mov	r5, r6
 8007d92:	e000      	b.n	8007d96 <HAL_RCCEx_PeriphCLKConfig+0x2ee>
 8007d94:	462e      	mov	r6, r5
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8007d96:	0399      	lsls	r1, r3, #14
 8007d98:	f57f aed9 	bpl.w	8007b4e <HAL_RCCEx_PeriphCLKConfig+0xa6>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8007d9c:	4b07      	ldr	r3, [pc, #28]	; (8007dbc <HAL_RCCEx_PeriphCLKConfig+0x314>)
 8007d9e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007da0:	00d2      	lsls	r2, r2, #3
 8007da2:	d55f      	bpl.n	8007e64 <HAL_RCCEx_PeriphCLKConfig+0x3bc>
    FlagStatus       pwrclkchanged = RESET;
 8007da4:	f04f 0900 	mov.w	r9, #0
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8007da8:	4f05      	ldr	r7, [pc, #20]	; (8007dc0 <HAL_RCCEx_PeriphCLKConfig+0x318>)
 8007daa:	683b      	ldr	r3, [r7, #0]
 8007dac:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007db0:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007db2:	f7fc ff15 	bl	8004be0 <HAL_GetTick>
 8007db6:	4680      	mov	r8, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8007db8:	e00b      	b.n	8007dd2 <HAL_RCCEx_PeriphCLKConfig+0x32a>
 8007dba:	bf00      	nop
 8007dbc:	40021000 	.word	0x40021000
 8007dc0:	40007000 	.word	0x40007000
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8007dc4:	f7fc ff0c 	bl	8004be0 <HAL_GetTick>
 8007dc8:	eba0 0308 	sub.w	r3, r0, r8
 8007dcc:	2b02      	cmp	r3, #2
 8007dce:	f200 808c 	bhi.w	8007eea <HAL_RCCEx_PeriphCLKConfig+0x442>
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8007dd2:	683b      	ldr	r3, [r7, #0]
 8007dd4:	05db      	lsls	r3, r3, #23
 8007dd6:	d5f5      	bpl.n	8007dc4 <HAL_RCCEx_PeriphCLKConfig+0x31c>
    if(ret == HAL_OK)
 8007dd8:	2e00      	cmp	r6, #0
 8007dda:	f040 80f3 	bne.w	8007fc4 <HAL_RCCEx_PeriphCLKConfig+0x51c>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8007dde:	4f7e      	ldr	r7, [pc, #504]	; (8007fd8 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 8007de0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8007de4:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8007de8:	d028      	beq.n	8007e3c <HAL_RCCEx_PeriphCLKConfig+0x394>
 8007dea:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8007dee:	429a      	cmp	r2, r3
 8007df0:	d026      	beq.n	8007e40 <HAL_RCCEx_PeriphCLKConfig+0x398>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8007df2:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 8007df6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8007dfa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8007dfe:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8007e02:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8007e06:	f421 7040 	bic.w	r0, r1, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 8007e0a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8007e0e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8007e12:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8007e16:	07c8      	lsls	r0, r1, #31
 8007e18:	f140 80d6 	bpl.w	8007fc8 <HAL_RCCEx_PeriphCLKConfig+0x520>
        tickstart = HAL_GetTick();
 8007e1c:	f7fc fee0 	bl	8004be0 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007e20:	f241 3a88 	movw	sl, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8007e24:	4680      	mov	r8, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8007e26:	e005      	b.n	8007e34 <HAL_RCCEx_PeriphCLKConfig+0x38c>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007e28:	f7fc feda 	bl	8004be0 <HAL_GetTick>
 8007e2c:	eba0 0008 	sub.w	r0, r0, r8
 8007e30:	4550      	cmp	r0, sl
 8007e32:	d85a      	bhi.n	8007eea <HAL_RCCEx_PeriphCLKConfig+0x442>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8007e34:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8007e38:	0799      	lsls	r1, r3, #30
 8007e3a:	d5f5      	bpl.n	8007e28 <HAL_RCCEx_PeriphCLKConfig+0x380>
 8007e3c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8007e40:	4965      	ldr	r1, [pc, #404]	; (8007fd8 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 8007e42:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8007e46:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8007e4a:	4313      	orrs	r3, r2
 8007e4c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
    if(pwrclkchanged == SET)
 8007e50:	f1b9 0f00 	cmp.w	r9, #0
 8007e54:	d004      	beq.n	8007e60 <HAL_RCCEx_PeriphCLKConfig+0x3b8>
      __HAL_RCC_PWR_CLK_DISABLE();
 8007e56:	4a60      	ldr	r2, [pc, #384]	; (8007fd8 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 8007e58:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8007e5a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8007e5e:	6593      	str	r3, [r2, #88]	; 0x58
 8007e60:	6823      	ldr	r3, [r4, #0]
 8007e62:	e674      	b.n	8007b4e <HAL_RCCEx_PeriphCLKConfig+0xa6>
      __HAL_RCC_PWR_CLK_ENABLE();
 8007e64:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007e66:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007e6a:	659a      	str	r2, [r3, #88]	; 0x58
 8007e6c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007e6e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8007e72:	9301      	str	r3, [sp, #4]
 8007e74:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8007e76:	f04f 0901 	mov.w	r9, #1
 8007e7a:	e795      	b.n	8007da8 <HAL_RCCEx_PeriphCLKConfig+0x300>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8007e7c:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
 8007e80:	f47f af19 	bne.w	8007cb6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8007e84:	2101      	movs	r1, #1
 8007e86:	1d20      	adds	r0, r4, #4
 8007e88:	f7ff fcea 	bl	8007860 <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8007e8c:	6823      	ldr	r3, [r4, #0]
 8007e8e:	4606      	mov	r6, r0
 8007e90:	2800      	cmp	r0, #0
 8007e92:	f43f af10 	beq.w	8007cb6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
 8007e96:	4605      	mov	r5, r0
 8007e98:	e70d      	b.n	8007cb6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_PLLSAI2_DISABLE();
 8007e9a:	4f4f      	ldr	r7, [pc, #316]	; (8007fd8 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 8007e9c:	683b      	ldr	r3, [r7, #0]
 8007e9e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8007ea2:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007ea4:	f7fc fe9c 	bl	8004be0 <HAL_GetTick>
 8007ea8:	4680      	mov	r8, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8007eaa:	e005      	b.n	8007eb8 <HAL_RCCEx_PeriphCLKConfig+0x410>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8007eac:	f7fc fe98 	bl	8004be0 <HAL_GetTick>
 8007eb0:	eba0 0308 	sub.w	r3, r0, r8
 8007eb4:	2b02      	cmp	r3, #2
 8007eb6:	d87d      	bhi.n	8007fb4 <HAL_RCCEx_PeriphCLKConfig+0x50c>
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8007eb8:	683b      	ldr	r3, [r7, #0]
 8007eba:	0099      	lsls	r1, r3, #2
 8007ebc:	d4f6      	bmi.n	8007eac <HAL_RCCEx_PeriphCLKConfig+0x404>
    if(ret == HAL_OK)
 8007ebe:	2e00      	cmp	r6, #0
 8007ec0:	d17b      	bne.n	8007fba <HAL_RCCEx_PeriphCLKConfig+0x512>
      __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
 8007ec2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8007ec6:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8007eca:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8007ece:	4313      	orrs	r3, r2
 8007ed0:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_R_UPDATE);
 8007ed4:	2102      	movs	r1, #2
 8007ed6:	f104 0020 	add.w	r0, r4, #32
 8007eda:	f7ff fd53 	bl	8007984 <RCCEx_PLLSAI2_Config>
    if(ret != HAL_OK)
 8007ede:	6823      	ldr	r3, [r4, #0]
 8007ee0:	2800      	cmp	r0, #0
 8007ee2:	f43f af26 	beq.w	8007d32 <HAL_RCCEx_PeriphCLKConfig+0x28a>
 8007ee6:	4605      	mov	r5, r0
 8007ee8:	e723      	b.n	8007d32 <HAL_RCCEx_PeriphCLKConfig+0x28a>
        ret = HAL_TIMEOUT;
 8007eea:	2503      	movs	r5, #3
 8007eec:	462e      	mov	r6, r5
 8007eee:	e7af      	b.n	8007e50 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8007ef0:	3004      	adds	r0, #4
 8007ef2:	f7ff fcb5 	bl	8007860 <RCCEx_PLLSAI1_Config>
 8007ef6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8007ef8:	2d00      	cmp	r5, #0
 8007efa:	f43f adf0 	beq.w	8007ade <HAL_RCCEx_PeriphCLKConfig+0x36>
 8007efe:	e03b      	b.n	8007f78 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8007f00:	1d20      	adds	r0, r4, #4
 8007f02:	f7ff fcad 	bl	8007860 <RCCEx_PLLSAI1_Config>
 8007f06:	6823      	ldr	r3, [r4, #0]
 8007f08:	4606      	mov	r6, r0
      break;
 8007f0a:	e611      	b.n	8007b30 <HAL_RCCEx_PeriphCLKConfig+0x88>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007f0c:	68ca      	ldr	r2, [r1, #12]
 8007f0e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007f12:	60ca      	str	r2, [r1, #12]
 8007f14:	e6b2      	b.n	8007c7c <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8007f16:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8007f1a:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8007f1e:	68d1      	ldr	r1, [r2, #12]
 8007f20:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8007f24:	60d1      	str	r1, [r2, #12]
 8007f26:	e6c6      	b.n	8007cb6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007f28:	68ca      	ldr	r2, [r1, #12]
 8007f2a:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007f2e:	60ca      	str	r2, [r1, #12]
 8007f30:	e6d4      	b.n	8007cdc <HAL_RCCEx_PeriphCLKConfig+0x234>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007f32:	68d3      	ldr	r3, [r2, #12]
}
 8007f34:	4628      	mov	r0, r5
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8007f36:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8007f3a:	60d3      	str	r3, [r2, #12]
}
 8007f3c:	b002      	add	sp, #8
 8007f3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8007f42:	2102      	movs	r1, #2
 8007f44:	1d20      	adds	r0, r4, #4
 8007f46:	f7ff fc8b 	bl	8007860 <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8007f4a:	6823      	ldr	r3, [r4, #0]
 8007f4c:	4606      	mov	r6, r0
 8007f4e:	2800      	cmp	r0, #0
 8007f50:	f43f aed4 	beq.w	8007cfc <HAL_RCCEx_PeriphCLKConfig+0x254>
 8007f54:	4605      	mov	r5, r0
 8007f56:	e6d1      	b.n	8007cfc <HAL_RCCEx_PeriphCLKConfig+0x254>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_Q_UPDATE);
 8007f58:	2101      	movs	r1, #1
 8007f5a:	f104 0020 	add.w	r0, r4, #32
 8007f5e:	f7ff fd11 	bl	8007984 <RCCEx_PLLSAI2_Config>
      if(ret != HAL_OK)
 8007f62:	b368      	cbz	r0, 8007fc0 <HAL_RCCEx_PeriphCLKConfig+0x518>
 8007f64:	6823      	ldr	r3, [r4, #0]
 8007f66:	4605      	mov	r5, r0
 8007f68:	e6f3      	b.n	8007d52 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8007f6a:	491b      	ldr	r1, [pc, #108]	; (8007fd8 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 8007f6c:	68ca      	ldr	r2, [r1, #12]
 8007f6e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8007f72:	60ca      	str	r2, [r1, #12]
      break;
 8007f74:	462e      	mov	r6, r5
 8007f76:	e5db      	b.n	8007b30 <HAL_RCCEx_PeriphCLKConfig+0x88>
 8007f78:	6823      	ldr	r3, [r4, #0]
 8007f7a:	e5c1      	b.n	8007b00 <HAL_RCCEx_PeriphCLKConfig+0x58>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8007f7c:	4816      	ldr	r0, [pc, #88]	; (8007fd8 <HAL_RCCEx_PeriphCLKConfig+0x530>)
 8007f7e:	68c2      	ldr	r2, [r0, #12]
 8007f80:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8007f84:	60c2      	str	r2, [r0, #12]
    if(ret == HAL_OK)
 8007f86:	e5b2      	b.n	8007aee <HAL_RCCEx_PeriphCLKConfig+0x46>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8007f88:	2101      	movs	r1, #1
 8007f8a:	1d20      	adds	r0, r4, #4
 8007f8c:	f7ff fc68 	bl	8007860 <RCCEx_PLLSAI1_Config>
        if(ret != HAL_OK)
 8007f90:	6823      	ldr	r3, [r4, #0]
 8007f92:	4606      	mov	r6, r0
 8007f94:	2800      	cmp	r0, #0
 8007f96:	f43f ae71 	beq.w	8007c7c <HAL_RCCEx_PeriphCLKConfig+0x1d4>
 8007f9a:	4605      	mov	r5, r0
 8007f9c:	e66e      	b.n	8007c7c <HAL_RCCEx_PeriphCLKConfig+0x1d4>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8007f9e:	2101      	movs	r1, #1
 8007fa0:	1d20      	adds	r0, r4, #4
 8007fa2:	f7ff fc5d 	bl	8007860 <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8007fa6:	6823      	ldr	r3, [r4, #0]
 8007fa8:	4606      	mov	r6, r0
 8007faa:	2800      	cmp	r0, #0
 8007fac:	f43f ae96 	beq.w	8007cdc <HAL_RCCEx_PeriphCLKConfig+0x234>
 8007fb0:	4605      	mov	r5, r0
 8007fb2:	e693      	b.n	8007cdc <HAL_RCCEx_PeriphCLKConfig+0x234>
 8007fb4:	6823      	ldr	r3, [r4, #0]
        ret = HAL_TIMEOUT;
 8007fb6:	2503      	movs	r5, #3
 8007fb8:	e6bb      	b.n	8007d32 <HAL_RCCEx_PeriphCLKConfig+0x28a>
 8007fba:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 8007fbc:	4635      	mov	r5, r6
 8007fbe:	e6b8      	b.n	8007d32 <HAL_RCCEx_PeriphCLKConfig+0x28a>
 8007fc0:	6823      	ldr	r3, [r4, #0]
 8007fc2:	e6c6      	b.n	8007d52 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
 8007fc4:	4635      	mov	r5, r6
 8007fc6:	e743      	b.n	8007e50 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
 8007fc8:	4613      	mov	r3, r2
 8007fca:	e739      	b.n	8007e40 <HAL_RCCEx_PeriphCLKConfig+0x398>
    switch(PeriphClkInit->Sai2ClockSelection)
 8007fcc:	2501      	movs	r5, #1
 8007fce:	462e      	mov	r6, r5
 8007fd0:	e6e1      	b.n	8007d96 <HAL_RCCEx_PeriphCLKConfig+0x2ee>
    switch(PeriphClkInit->Sai1ClockSelection)
 8007fd2:	2501      	movs	r5, #1
 8007fd4:	e594      	b.n	8007b00 <HAL_RCCEx_PeriphCLKConfig+0x58>
 8007fd6:	bf00      	nop
 8007fd8:	40021000 	.word	0x40021000

08007fdc <HAL_RTC_SetAlarm_IT>:
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8007fdc:	f890 3020 	ldrb.w	r3, [r0, #32]
 8007fe0:	2b01      	cmp	r3, #1
 8007fe2:	f000 80ec 	beq.w	80081be <HAL_RTC_SetAlarm_IT+0x1e2>
{
 8007fe6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007fea:	4605      	mov	r5, r0

  hrtc->State = HAL_RTC_STATE_BUSY;
 8007fec:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 8007fee:	2001      	movs	r0, #1

  if (Format == RTC_FORMAT_BIN)
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8007ff0:	682e      	ldr	r6, [r5, #0]
  __HAL_LOCK(hrtc);
 8007ff2:	f885 0020 	strb.w	r0, [r5, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8007ff6:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  if (Format == RTC_FORMAT_BIN)
 8007ffa:	2a00      	cmp	r2, #0
 8007ffc:	d058      	beq.n	80080b0 <HAL_RTC_SetAlarm_IT+0xd4>
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));
  }
  else
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8007ffe:	68b2      	ldr	r2, [r6, #8]
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
    }

#endif /* USE_FULL_ASSERT */
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8008000:	6a0b      	ldr	r3, [r1, #32]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
              ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8008002:	7888      	ldrb	r0, [r1, #2]
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8008004:	f012 0240 	ands.w	r2, r2, #64	; 0x40
 8008008:	bf16      	itet	ne
 800800a:	78cc      	ldrbne	r4, [r1, #3]
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 800800c:	70ca      	strbeq	r2, [r1, #3]
 800800e:	05a2      	lslne	r2, r4, #22
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8008010:	694c      	ldr	r4, [r1, #20]
 8008012:	431c      	orrs	r4, r3
 8008014:	780b      	ldrb	r3, [r1, #0]
 8008016:	4304      	orrs	r4, r0
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8008018:	7848      	ldrb	r0, [r1, #1]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 800801a:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 800801e:	f891 3024 	ldrb.w	r3, [r1, #36]	; 0x24
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8008022:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
 8008026:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
 800802a:	4314      	orrs	r4, r2
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
              ((uint32_t)sAlarm->AlarmMask));
  }
  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 800802c:	69ca      	ldr	r2, [r1, #28]
 800802e:	684f      	ldr	r7, [r1, #4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);

  /* Configure the Alarm register */
  if (sAlarm->Alarm == RTC_ALARM_A)
 8008030:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8008032:	4317      	orrs	r7, r2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008034:	21ca      	movs	r1, #202	; 0xca
 8008036:	2253      	movs	r2, #83	; 0x53
 8008038:	6271      	str	r1, [r6, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 800803a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800803e:	6272      	str	r2, [r6, #36]	; 0x24
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8008040:	68b3      	ldr	r3, [r6, #8]
  if (sAlarm->Alarm == RTC_ALARM_A)
 8008042:	f000 809a 	beq.w	800817a <HAL_RTC_SetAlarm_IT+0x19e>
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
  }
  else
  {
    /* Disable the Alarm B interrupt */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8008046:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800804a:	60b3      	str	r3, [r6, #8]

    /* Clear flag alarm B */
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 800804c:	68f3      	ldr	r3, [r6, #12]
 800804e:	b2db      	uxtb	r3, r3
 8008050:	f463 7320 	orn	r3, r3, #640	; 0x280
 8008054:	60f3      	str	r3, [r6, #12]

#if defined (RTC_FLAG_ALRBWF)
    uint32_t tickstart = HAL_GetTick();
 8008056:	f7fc fdc3 	bl	8004be0 <HAL_GetTick>
 800805a:	4606      	mov	r6, r0
    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 800805c:	e005      	b.n	800806a <HAL_RTC_SetAlarm_IT+0x8e>
    {
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 800805e:	f7fc fdbf 	bl	8004be0 <HAL_GetTick>
 8008062:	1b83      	subs	r3, r0, r6
 8008064:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8008068:	d87c      	bhi.n	8008164 <HAL_RTC_SetAlarm_IT+0x188>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == 0U)
 800806a:	682b      	ldr	r3, [r5, #0]
 800806c:	68da      	ldr	r2, [r3, #12]
 800806e:	f012 0802 	ands.w	r8, r2, #2
 8008072:	d0f4      	beq.n	800805e <HAL_RTC_SetAlarm_IT+0x82>
        return HAL_TIMEOUT;
      }
    }
#endif

    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8008074:	621c      	str	r4, [r3, #32]
    /* Configure the Alarm B Sub Second register */
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8008076:	649f      	str	r7, [r3, #72]	; 0x48
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8008078:	689a      	ldr	r2, [r3, #8]
 800807a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800807e:	609a      	str	r2, [r3, #8]
    /* Configure the Alarm interrupt */
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 8008080:	689a      	ldr	r2, [r3, #8]
 8008082:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8008086:	609a      	str	r2, [r3, #8]
  }

  /* RTC Alarm Interrupt Configuration: EXTI configuration */
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8008088:	4a4e      	ldr	r2, [pc, #312]	; (80081c4 <HAL_RTC_SetAlarm_IT+0x1e8>)
 800808a:	6811      	ldr	r1, [r2, #0]
 800808c:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 8008090:	6011      	str	r1, [r2, #0]
  __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
 8008092:	6891      	ldr	r1, [r2, #8]
 8008094:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 8008098:	6091      	str	r1, [r2, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800809a:	20ff      	movs	r0, #255	; 0xff

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 800809c:	2200      	movs	r2, #0
  hrtc->State = HAL_RTC_STATE_READY;
 800809e:	2401      	movs	r4, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80080a0:	6258      	str	r0, [r3, #36]	; 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 80080a2:	f885 4021 	strb.w	r4, [r5, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 80080a6:	f885 2020 	strb.w	r2, [r5, #32]

  return HAL_OK;
 80080aa:	4610      	mov	r0, r2
}
 80080ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 80080b0:	68b0      	ldr	r0, [r6, #8]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80080b2:	780c      	ldrb	r4, [r1, #0]
    if (sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 80080b4:	6a0f      	ldr	r7, [r1, #32]
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 80080b6:	f010 0c40 	ands.w	ip, r0, #64	; 0x40
 80080ba:	bf16      	itet	ne
 80080bc:	f891 c003 	ldrbne.w	ip, [r1, #3]
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 80080c0:	f881 c003 	strbeq.w	ip, [r1, #3]
 80080c4:	ea4f 5c8c 	movne.w	ip, ip, lsl #22
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
  uint8_t temp = Value;

  while (temp >= 10U)
 80080c8:	2c09      	cmp	r4, #9
 80080ca:	d909      	bls.n	80080e0 <HAL_RTC_SetAlarm_IT+0x104>
  uint32_t bcdhigh = 0U;
 80080cc:	2300      	movs	r3, #0
  {
    bcdhigh++;
    temp -= 10U;
 80080ce:	3c0a      	subs	r4, #10
 80080d0:	b2e4      	uxtb	r4, r4
  while (temp >= 10U)
 80080d2:	2c09      	cmp	r4, #9
    bcdhigh++;
 80080d4:	f103 0301 	add.w	r3, r3, #1
  while (temp >= 10U)
 80080d8:	d8f9      	bhi.n	80080ce <HAL_RTC_SetAlarm_IT+0xf2>
 80080da:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 80080de:	b2e4      	uxtb	r4, r4
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80080e0:	784b      	ldrb	r3, [r1, #1]
  while (temp >= 10U)
 80080e2:	2b09      	cmp	r3, #9
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80080e4:	ea4f 4004 	mov.w	r0, r4, lsl #16
  while (temp >= 10U)
 80080e8:	d909      	bls.n	80080fe <HAL_RTC_SetAlarm_IT+0x122>
  uint32_t bcdhigh = 0U;
 80080ea:	2400      	movs	r4, #0
    temp -= 10U;
 80080ec:	3b0a      	subs	r3, #10
 80080ee:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 80080f0:	2b09      	cmp	r3, #9
    bcdhigh++;
 80080f2:	f104 0401 	add.w	r4, r4, #1
  while (temp >= 10U)
 80080f6:	d8f9      	bhi.n	80080ec <HAL_RTC_SetAlarm_IT+0x110>
 80080f8:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
 80080fc:	b2db      	uxtb	r3, r3
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80080fe:	f891 8002 	ldrb.w	r8, [r1, #2]
  while (temp >= 10U)
 8008102:	f1b8 0f09 	cmp.w	r8, #9
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8008106:	ea4f 2303 	mov.w	r3, r3, lsl #8
  while (temp >= 10U)
 800810a:	d90e      	bls.n	800812a <HAL_RTC_SetAlarm_IT+0x14e>
  uint32_t bcdhigh = 0U;
 800810c:	f04f 0e00 	mov.w	lr, #0
    temp -= 10U;
 8008110:	f1a8 080a 	sub.w	r8, r8, #10
 8008114:	fa5f f888 	uxtb.w	r8, r8
  while (temp >= 10U)
 8008118:	f1b8 0f09 	cmp.w	r8, #9
    bcdhigh++;
 800811c:	f10e 0e01 	add.w	lr, lr, #1
  while (temp >= 10U)
 8008120:	d8f6      	bhi.n	8008110 <HAL_RTC_SetAlarm_IT+0x134>
 8008122:	ea48 180e 	orr.w	r8, r8, lr, lsl #4
 8008126:	fa5f f888 	uxtb.w	r8, r8
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 800812a:	f891 e024 	ldrb.w	lr, [r1, #36]	; 0x24
  while (temp >= 10U)
 800812e:	f1be 0f09 	cmp.w	lr, #9
 8008132:	d90c      	bls.n	800814e <HAL_RTC_SetAlarm_IT+0x172>
    temp -= 10U;
 8008134:	f1ae 040a 	sub.w	r4, lr, #10
 8008138:	fa5f fe84 	uxtb.w	lr, r4
  while (temp >= 10U)
 800813c:	f1be 0f09 	cmp.w	lr, #9
    bcdhigh++;
 8008140:	f102 0201 	add.w	r2, r2, #1
  while (temp >= 10U)
 8008144:	d8f6      	bhi.n	8008134 <HAL_RTC_SetAlarm_IT+0x158>
 8008146:	ea4e 1402 	orr.w	r4, lr, r2, lsl #4
 800814a:	fa5f fe84 	uxtb.w	lr, r4
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 800814e:	694c      	ldr	r4, [r1, #20]
 8008150:	433c      	orrs	r4, r7
 8008152:	ea44 040c 	orr.w	r4, r4, ip
 8008156:	4304      	orrs	r4, r0
 8008158:	4323      	orrs	r3, r4
 800815a:	ea43 0408 	orr.w	r4, r3, r8
 800815e:	ea44 640e 	orr.w	r4, r4, lr, lsl #24
 8008162:	e763      	b.n	800802c <HAL_RTC_SetAlarm_IT+0x50>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008164:	682a      	ldr	r2, [r5, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008166:	2303      	movs	r3, #3
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8008168:	21ff      	movs	r1, #255	; 0xff
 800816a:	6251      	str	r1, [r2, #36]	; 0x24
        __HAL_UNLOCK(hrtc);
 800816c:	f885 8020 	strb.w	r8, [r5, #32]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008170:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
        return HAL_TIMEOUT;
 8008174:	4618      	mov	r0, r3
}
 8008176:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 800817a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800817e:	60b3      	str	r3, [r6, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8008180:	68f3      	ldr	r3, [r6, #12]
 8008182:	b2db      	uxtb	r3, r3
 8008184:	f463 73c0 	orn	r3, r3, #384	; 0x180
 8008188:	60f3      	str	r3, [r6, #12]
    uint32_t tickstart = HAL_GetTick();
 800818a:	f7fc fd29 	bl	8004be0 <HAL_GetTick>
 800818e:	4606      	mov	r6, r0
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 8008190:	e005      	b.n	800819e <HAL_RTC_SetAlarm_IT+0x1c2>
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8008192:	f7fc fd25 	bl	8004be0 <HAL_GetTick>
 8008196:	1b80      	subs	r0, r0, r6
 8008198:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800819c:	d8e2      	bhi.n	8008164 <HAL_RTC_SetAlarm_IT+0x188>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == 0U)
 800819e:	682b      	ldr	r3, [r5, #0]
 80081a0:	68da      	ldr	r2, [r3, #12]
 80081a2:	f012 0801 	ands.w	r8, r2, #1
 80081a6:	d0f4      	beq.n	8008192 <HAL_RTC_SetAlarm_IT+0x1b6>
    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 80081a8:	61dc      	str	r4, [r3, #28]
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 80081aa:	645f      	str	r7, [r3, #68]	; 0x44
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 80081ac:	689a      	ldr	r2, [r3, #8]
 80081ae:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80081b2:	609a      	str	r2, [r3, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRA);
 80081b4:	689a      	ldr	r2, [r3, #8]
 80081b6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80081ba:	609a      	str	r2, [r3, #8]
 80081bc:	e764      	b.n	8008088 <HAL_RTC_SetAlarm_IT+0xac>
  __HAL_LOCK(hrtc);
 80081be:	2002      	movs	r0, #2
}
 80081c0:	4770      	bx	lr
 80081c2:	bf00      	nop
 80081c4:	40010400 	.word	0x40010400

080081c8 <RTC_ExitInitMode>:
{
 80081c8:	b538      	push	{r3, r4, r5, lr}
  CLEAR_BIT(RTC->ISR, RTC_ISR_INIT);
 80081ca:	4b22      	ldr	r3, [pc, #136]	; (8008254 <RTC_ExitInitMode+0x8c>)
 80081cc:	68da      	ldr	r2, [r3, #12]
 80081ce:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80081d2:	60da      	str	r2, [r3, #12]
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 80081d4:	689a      	ldr	r2, [r3, #8]
 80081d6:	0691      	lsls	r1, r2, #26
{
 80081d8:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 80081da:	d414      	bmi.n	8008206 <RTC_ExitInitMode+0x3e>
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 80081dc:	6802      	ldr	r2, [r0, #0]
 80081de:	68d3      	ldr	r3, [r2, #12]
 80081e0:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 80081e4:	60d3      	str	r3, [r2, #12]
  tickstart = HAL_GetTick();
 80081e6:	f7fc fcfb 	bl	8004be0 <HAL_GetTick>
 80081ea:	4605      	mov	r5, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 80081ec:	e005      	b.n	80081fa <RTC_ExitInitMode+0x32>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80081ee:	f7fc fcf7 	bl	8004be0 <HAL_GetTick>
 80081f2:	1b43      	subs	r3, r0, r5
 80081f4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80081f8:	d827      	bhi.n	800824a <RTC_ExitInitMode+0x82>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 80081fa:	6823      	ldr	r3, [r4, #0]
 80081fc:	68db      	ldr	r3, [r3, #12]
 80081fe:	069a      	lsls	r2, r3, #26
 8008200:	d5f5      	bpl.n	80081ee <RTC_ExitInitMode+0x26>
  HAL_StatusTypeDef status = HAL_OK;
 8008202:	2000      	movs	r0, #0
}
 8008204:	bd38      	pop	{r3, r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8008206:	689a      	ldr	r2, [r3, #8]
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8008208:	6801      	ldr	r1, [r0, #0]
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 800820a:	f022 0220 	bic.w	r2, r2, #32
 800820e:	609a      	str	r2, [r3, #8]
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8008210:	68cb      	ldr	r3, [r1, #12]
 8008212:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8008216:	60cb      	str	r3, [r1, #12]
  tickstart = HAL_GetTick();
 8008218:	f7fc fce2 	bl	8004be0 <HAL_GetTick>
 800821c:	4605      	mov	r5, r0
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800821e:	e005      	b.n	800822c <RTC_ExitInitMode+0x64>
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8008220:	f7fc fcde 	bl	8004be0 <HAL_GetTick>
 8008224:	1b43      	subs	r3, r0, r5
 8008226:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800822a:	d80a      	bhi.n	8008242 <RTC_ExitInitMode+0x7a>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800822c:	6823      	ldr	r3, [r4, #0]
 800822e:	68db      	ldr	r3, [r3, #12]
 8008230:	069b      	lsls	r3, r3, #26
 8008232:	d5f5      	bpl.n	8008220 <RTC_ExitInitMode+0x58>
  HAL_StatusTypeDef status = HAL_OK;
 8008234:	2000      	movs	r0, #0
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8008236:	4a07      	ldr	r2, [pc, #28]	; (8008254 <RTC_ExitInitMode+0x8c>)
 8008238:	6893      	ldr	r3, [r2, #8]
 800823a:	f043 0320 	orr.w	r3, r3, #32
 800823e:	6093      	str	r3, [r2, #8]
}
 8008240:	bd38      	pop	{r3, r4, r5, pc}
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008242:	2003      	movs	r0, #3
 8008244:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      status = HAL_TIMEOUT;
 8008248:	e7f5      	b.n	8008236 <RTC_ExitInitMode+0x6e>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800824a:	2003      	movs	r0, #3
 800824c:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
}
 8008250:	bd38      	pop	{r3, r4, r5, pc}
 8008252:	bf00      	nop
 8008254:	40002800 	.word	0x40002800

08008258 <HAL_RTC_Init>:
  if (hrtc != NULL)
 8008258:	2800      	cmp	r0, #0
 800825a:	d053      	beq.n	8008304 <HAL_RTC_Init+0xac>
{
 800825c:	b538      	push	{r3, r4, r5, lr}
    if (hrtc->State == HAL_RTC_STATE_RESET)
 800825e:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8008262:	4604      	mov	r4, r0
 8008264:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8008268:	2b00      	cmp	r3, #0
 800826a:	d046      	beq.n	80082fa <HAL_RTC_Init+0xa2>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800826c:	6823      	ldr	r3, [r4, #0]
 800826e:	21ca      	movs	r1, #202	; 0xca
 8008270:	2253      	movs	r2, #83	; 0x53
    hrtc->State = HAL_RTC_STATE_BUSY;
 8008272:	2002      	movs	r0, #2
 8008274:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008278:	6259      	str	r1, [r3, #36]	; 0x24
 800827a:	625a      	str	r2, [r3, #36]	; 0x24
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800827c:	68da      	ldr	r2, [r3, #12]
 800827e:	0651      	lsls	r1, r2, #25
 8008280:	d529      	bpl.n	80082d6 <HAL_RTC_Init+0x7e>
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 8008282:	6899      	ldr	r1, [r3, #8]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8008284:	6862      	ldr	r2, [r4, #4]
 8008286:	6925      	ldr	r5, [r4, #16]
 8008288:	69a0      	ldr	r0, [r4, #24]
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 800828a:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
 800828e:	f021 0140 	bic.w	r1, r1, #64	; 0x40
 8008292:	6099      	str	r1, [r3, #8]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8008294:	6899      	ldr	r1, [r3, #8]
 8008296:	432a      	orrs	r2, r5
 8008298:	4302      	orrs	r2, r0
 800829a:	430a      	orrs	r2, r1
      hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
 800829c:	68e1      	ldr	r1, [r4, #12]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 800829e:	609a      	str	r2, [r3, #8]
      hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
 80082a0:	6119      	str	r1, [r3, #16]
      hrtc->Instance->PRER |= (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 80082a2:	691a      	ldr	r2, [r3, #16]
 80082a4:	68a1      	ldr	r1, [r4, #8]
 80082a6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80082aa:	611a      	str	r2, [r3, #16]
      status = RTC_ExitInitMode(hrtc);
 80082ac:	4620      	mov	r0, r4
 80082ae:	f7ff ff8b 	bl	80081c8 <RTC_ExitInitMode>
      if (status == HAL_OK)
 80082b2:	b978      	cbnz	r0, 80082d4 <HAL_RTC_Init+0x7c>
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 80082b4:	6823      	ldr	r3, [r4, #0]
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80082b6:	6965      	ldr	r5, [r4, #20]
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 80082b8:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80082ba:	69e2      	ldr	r2, [r4, #28]
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 80082bc:	f021 0103 	bic.w	r1, r1, #3
 80082c0:	64d9      	str	r1, [r3, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80082c2:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 80082c4:	432a      	orrs	r2, r5
 80082c6:	430a      	orrs	r2, r1
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80082c8:	25ff      	movs	r5, #255	; 0xff
          hrtc->State = HAL_RTC_STATE_READY;
 80082ca:	2101      	movs	r1, #1
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80082cc:	64da      	str	r2, [r3, #76]	; 0x4c
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80082ce:	625d      	str	r5, [r3, #36]	; 0x24
          hrtc->State = HAL_RTC_STATE_READY;
 80082d0:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
}
 80082d4:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80082d6:	f04f 32ff 	mov.w	r2, #4294967295
 80082da:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 80082dc:	f7fc fc80 	bl	8004be0 <HAL_GetTick>
 80082e0:	4605      	mov	r5, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80082e2:	e005      	b.n	80082f0 <HAL_RTC_Init+0x98>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 80082e4:	f7fc fc7c 	bl	8004be0 <HAL_GetTick>
 80082e8:	1b43      	subs	r3, r0, r5
 80082ea:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80082ee:	d80b      	bhi.n	8008308 <HAL_RTC_Init+0xb0>
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80082f0:	6823      	ldr	r3, [r4, #0]
 80082f2:	68da      	ldr	r2, [r3, #12]
 80082f4:	0652      	lsls	r2, r2, #25
 80082f6:	d4c4      	bmi.n	8008282 <HAL_RTC_Init+0x2a>
 80082f8:	e7f4      	b.n	80082e4 <HAL_RTC_Init+0x8c>
      hrtc->Lock = HAL_UNLOCKED;
 80082fa:	f880 2020 	strb.w	r2, [r0, #32]
      HAL_RTC_MspInit(hrtc);
 80082fe:	f7fa fcd1 	bl	8002ca4 <HAL_RTC_MspInit>
 8008302:	e7b3      	b.n	800826c <HAL_RTC_Init+0x14>
  HAL_StatusTypeDef status = HAL_ERROR;
 8008304:	2001      	movs	r0, #1
}
 8008306:	4770      	bx	lr
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8008308:	6823      	ldr	r3, [r4, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800830a:	2003      	movs	r0, #3
 800830c:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8008310:	68db      	ldr	r3, [r3, #12]
}
 8008312:	bd38      	pop	{r3, r4, r5, pc}

08008314 <HAL_RTC_SetTime>:
{
 8008314:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008318:	4605      	mov	r5, r0
  __HAL_LOCK(hrtc);
 800831a:	f890 0020 	ldrb.w	r0, [r0, #32]
 800831e:	2801      	cmp	r0, #1
 8008320:	d05d      	beq.n	80083de <HAL_RTC_SetTime+0xca>
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008322:	682e      	ldr	r6, [r5, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8008324:	2302      	movs	r3, #2
 8008326:	4617      	mov	r7, r2
  __HAL_LOCK(hrtc);
 8008328:	2201      	movs	r2, #1
 800832a:	f885 2020 	strb.w	r2, [r5, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 800832e:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8008332:	22ca      	movs	r2, #202	; 0xca
 8008334:	2353      	movs	r3, #83	; 0x53
 8008336:	6272      	str	r2, [r6, #36]	; 0x24
 8008338:	6273      	str	r3, [r6, #36]	; 0x24
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 800833a:	68f3      	ldr	r3, [r6, #12]
 800833c:	065a      	lsls	r2, r3, #25
 800833e:	460c      	mov	r4, r1
 8008340:	d539      	bpl.n	80083b6 <HAL_RTC_SetTime+0xa2>
    if (Format == RTC_FORMAT_BIN)
 8008342:	2f00      	cmp	r7, #0
 8008344:	d15a      	bne.n	80083fc <HAL_RTC_SetTime+0xe8>
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8008346:	68b3      	ldr	r3, [r6, #8]
 8008348:	f013 0c40 	ands.w	ip, r3, #64	; 0x40
 800834c:	bf16      	itet	ne
 800834e:	78e3      	ldrbne	r3, [r4, #3]
        sTime->TimeFormat = 0x00U;
 8008350:	70e7      	strbeq	r7, [r4, #3]
 8008352:	ea4f 5c83 	movne.w	ip, r3, lsl #22
      tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 8008356:	7823      	ldrb	r3, [r4, #0]
  while (temp >= 10U)
 8008358:	2b09      	cmp	r3, #9
 800835a:	d909      	bls.n	8008370 <HAL_RTC_SetTime+0x5c>
  uint32_t bcdhigh = 0U;
 800835c:	2100      	movs	r1, #0
    temp -= 10U;
 800835e:	3b0a      	subs	r3, #10
 8008360:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 8008362:	2b09      	cmp	r3, #9
    bcdhigh++;
 8008364:	f101 0101 	add.w	r1, r1, #1
  while (temp >= 10U)
 8008368:	d8f9      	bhi.n	800835e <HAL_RTC_SetTime+0x4a>
 800836a:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
 800836e:	b2cb      	uxtb	r3, r1
                          ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8008370:	7860      	ldrb	r0, [r4, #1]
  while (temp >= 10U)
 8008372:	2809      	cmp	r0, #9
      tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 8008374:	ea4f 4103 	mov.w	r1, r3, lsl #16
  while (temp >= 10U)
 8008378:	d909      	bls.n	800838e <HAL_RTC_SetTime+0x7a>
  uint32_t bcdhigh = 0U;
 800837a:	2300      	movs	r3, #0
    temp -= 10U;
 800837c:	380a      	subs	r0, #10
 800837e:	b2c0      	uxtb	r0, r0
  while (temp >= 10U)
 8008380:	2809      	cmp	r0, #9
    bcdhigh++;
 8008382:	f103 0301 	add.w	r3, r3, #1
  while (temp >= 10U)
 8008386:	d8f9      	bhi.n	800837c <HAL_RTC_SetTime+0x68>
 8008388:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 800838c:	b2c0      	uxtb	r0, r0
                          ((uint32_t)RTC_ByteToBcd2(sTime->Seconds) << RTC_TR_SU_Pos) | \
 800838e:	78a2      	ldrb	r2, [r4, #2]
  while (temp >= 10U)
 8008390:	2a09      	cmp	r2, #9
                          ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8008392:	ea4f 2000 	mov.w	r0, r0, lsl #8
  while (temp >= 10U)
 8008396:	d909      	bls.n	80083ac <HAL_RTC_SetTime+0x98>
    temp -= 10U;
 8008398:	f1a2 030a 	sub.w	r3, r2, #10
 800839c:	b2da      	uxtb	r2, r3
  while (temp >= 10U)
 800839e:	2a09      	cmp	r2, #9
    bcdhigh++;
 80083a0:	f107 0701 	add.w	r7, r7, #1
  while (temp >= 10U)
 80083a4:	d8f8      	bhi.n	8008398 <HAL_RTC_SetTime+0x84>
 80083a6:	ea42 1307 	orr.w	r3, r2, r7, lsl #4
 80083aa:	b2da      	uxtb	r2, r3
      tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
 80083ac:	ea41 030c 	orr.w	r3, r1, ip
 80083b0:	4303      	orrs	r3, r0
 80083b2:	4313      	orrs	r3, r2
 80083b4:	e031      	b.n	800841a <HAL_RTC_SetTime+0x106>
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80083b6:	f04f 33ff 	mov.w	r3, #4294967295
 80083ba:	60f3      	str	r3, [r6, #12]
    tickstart = HAL_GetTick();
 80083bc:	f7fc fc10 	bl	8004be0 <HAL_GetTick>
 80083c0:	4680      	mov	r8, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80083c2:	e006      	b.n	80083d2 <HAL_RTC_SetTime+0xbe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 80083c4:	f7fc fc0c 	bl	8004be0 <HAL_GetTick>
 80083c8:	eba0 0308 	sub.w	r3, r0, r8
 80083cc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80083d0:	d808      	bhi.n	80083e4 <HAL_RTC_SetTime+0xd0>
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80083d2:	682e      	ldr	r6, [r5, #0]
 80083d4:	68f3      	ldr	r3, [r6, #12]
 80083d6:	065b      	lsls	r3, r3, #25
 80083d8:	d5f4      	bpl.n	80083c4 <HAL_RTC_SetTime+0xb0>
    if (Format == RTC_FORMAT_BIN)
 80083da:	b97f      	cbnz	r7, 80083fc <HAL_RTC_SetTime+0xe8>
 80083dc:	e7b3      	b.n	8008346 <HAL_RTC_SetTime+0x32>
  __HAL_LOCK(hrtc);
 80083de:	2002      	movs	r0, #2
}
 80083e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80083e4:	682b      	ldr	r3, [r5, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80083e6:	2003      	movs	r0, #3
 80083e8:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80083ec:	22ff      	movs	r2, #255	; 0xff
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80083ee:	68d9      	ldr	r1, [r3, #12]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80083f0:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 80083f2:	2300      	movs	r3, #0
 80083f4:	f885 3020 	strb.w	r3, [r5, #32]
}
 80083f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 80083fc:	68b2      	ldr	r2, [r6, #8]
      tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 80083fe:	7820      	ldrb	r0, [r4, #0]
                ((uint32_t)(sTime->Seconds) << RTC_TR_SU_Pos) | \
 8008400:	78a1      	ldrb	r1, [r4, #2]
      if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8008402:	f012 0240 	ands.w	r2, r2, #64	; 0x40
 8008406:	bf16      	itet	ne
 8008408:	78e3      	ldrbne	r3, [r4, #3]
        sTime->TimeFormat = 0x00U;
 800840a:	70e2      	strbeq	r2, [r4, #3]
 800840c:	059a      	lslne	r2, r3, #22
                ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 800840e:	7863      	ldrb	r3, [r4, #1]
 8008410:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 8008412:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8008416:	430b      	orrs	r3, r1
      tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
 8008418:	4313      	orrs	r3, r2
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 800841a:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 800841e:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008422:	6033      	str	r3, [r6, #0]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
 8008424:	68b2      	ldr	r2, [r6, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8008426:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BKP);
 800842a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800842e:	60b2      	str	r2, [r6, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8008430:	68b2      	ldr	r2, [r6, #8]
 8008432:	430b      	orrs	r3, r1
 8008434:	4313      	orrs	r3, r2
 8008436:	60b3      	str	r3, [r6, #8]
    status = RTC_ExitInitMode(hrtc);
 8008438:	4628      	mov	r0, r5
 800843a:	f7ff fec5 	bl	80081c8 <RTC_ExitInitMode>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800843e:	682b      	ldr	r3, [r5, #0]
 8008440:	22ff      	movs	r2, #255	; 0xff
 8008442:	625a      	str	r2, [r3, #36]	; 0x24
  if (status == HAL_OK)
 8008444:	2800      	cmp	r0, #0
 8008446:	d1d4      	bne.n	80083f2 <HAL_RTC_SetTime+0xde>
    hrtc->State = HAL_RTC_STATE_READY;
 8008448:	2301      	movs	r3, #1
 800844a:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
 800844e:	e7d0      	b.n	80083f2 <HAL_RTC_SetTime+0xde>

08008450 <HAL_RTC_SetDate>:
{
 8008450:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hrtc);
 8008452:	f890 4020 	ldrb.w	r4, [r0, #32]
 8008456:	2c01      	cmp	r4, #1
 8008458:	d07f      	beq.n	800855a <HAL_RTC_SetDate+0x10a>
 800845a:	4605      	mov	r5, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 800845c:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 800845e:	2001      	movs	r0, #1
 8008460:	f885 0020 	strb.w	r0, [r5, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8008464:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8008468:	784b      	ldrb	r3, [r1, #1]
 800846a:	b31a      	cbz	r2, 80084b4 <HAL_RTC_SetDate+0x64>
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 800846c:	78cc      	ldrb	r4, [r1, #3]
                  (((uint32_t)sDate->Date) << RTC_DR_DU_Pos) | \
 800846e:	788a      	ldrb	r2, [r1, #2]
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
 8008470:	7808      	ldrb	r0, [r1, #0]
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 8008472:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 8008474:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
 8008478:	4313      	orrs	r3, r2
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
 800847a:	ea43 3440 	orr.w	r4, r3, r0, lsl #13
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800847e:	682a      	ldr	r2, [r5, #0]
 8008480:	21ca      	movs	r1, #202	; 0xca
 8008482:	2353      	movs	r3, #83	; 0x53
 8008484:	6251      	str	r1, [r2, #36]	; 0x24
 8008486:	6253      	str	r3, [r2, #36]	; 0x24
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 8008488:	68d3      	ldr	r3, [r2, #12]
 800848a:	0659      	lsls	r1, r3, #25
 800848c:	d549      	bpl.n	8008522 <HAL_RTC_SetDate+0xd2>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 800848e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8008492:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 8008496:	6054      	str	r4, [r2, #4]
    status = RTC_ExitInitMode(hrtc);
 8008498:	4628      	mov	r0, r5
 800849a:	f7ff fe95 	bl	80081c8 <RTC_ExitInitMode>
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800849e:	682b      	ldr	r3, [r5, #0]
 80084a0:	22ff      	movs	r2, #255	; 0xff
 80084a2:	625a      	str	r2, [r3, #36]	; 0x24
  if (status == HAL_OK)
 80084a4:	b910      	cbnz	r0, 80084ac <HAL_RTC_SetDate+0x5c>
    hrtc->State = HAL_RTC_STATE_READY ;
 80084a6:	2301      	movs	r3, #1
 80084a8:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 80084ac:	2300      	movs	r3, #0
 80084ae:	f885 3020 	strb.w	r3, [r5, #32]
}
 80084b2:	bd70      	pop	{r4, r5, r6, pc}
  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 80084b4:	06d8      	lsls	r0, r3, #27
 80084b6:	d54c      	bpl.n	8008552 <HAL_RTC_SetDate+0x102>
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 80084b8:	78cc      	ldrb	r4, [r1, #3]
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 80084ba:	f023 0310 	bic.w	r3, r3, #16
 80084be:	330a      	adds	r3, #10
 80084c0:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 80084c2:	2c09      	cmp	r4, #9
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 80084c4:	704b      	strb	r3, [r1, #1]
  while (temp >= 10U)
 80084c6:	d94a      	bls.n	800855e <HAL_RTC_SetDate+0x10e>
  uint32_t bcdhigh = 0U;
 80084c8:	2000      	movs	r0, #0
    temp -= 10U;
 80084ca:	3c0a      	subs	r4, #10
 80084cc:	b2e4      	uxtb	r4, r4
  while (temp >= 10U)
 80084ce:	2c09      	cmp	r4, #9
    bcdhigh++;
 80084d0:	f100 0001 	add.w	r0, r0, #1
  while (temp >= 10U)
 80084d4:	d8f9      	bhi.n	80084ca <HAL_RTC_SetDate+0x7a>
 80084d6:	ea44 1400 	orr.w	r4, r4, r0, lsl #4
 80084da:	b2e4      	uxtb	r4, r4
 80084dc:	2b09      	cmp	r3, #9
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 80084de:	ea4f 4404 	mov.w	r4, r4, lsl #16
  while (temp >= 10U)
 80084e2:	d909      	bls.n	80084f8 <HAL_RTC_SetDate+0xa8>
  uint32_t bcdhigh = 0U;
 80084e4:	2000      	movs	r0, #0
    temp -= 10U;
 80084e6:	3b0a      	subs	r3, #10
 80084e8:	b2db      	uxtb	r3, r3
  while (temp >= 10U)
 80084ea:	2b09      	cmp	r3, #9
    bcdhigh++;
 80084ec:	f100 0001 	add.w	r0, r0, #1
  while (temp >= 10U)
 80084f0:	d8f9      	bhi.n	80084e6 <HAL_RTC_SetDate+0x96>
 80084f2:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 80084f6:	b2db      	uxtb	r3, r3
                  ((uint32_t)RTC_ByteToBcd2(sDate->Date) << RTC_DR_DU_Pos) | \
 80084f8:	7888      	ldrb	r0, [r1, #2]
  while (temp >= 10U)
 80084fa:	2809      	cmp	r0, #9
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 80084fc:	ea4f 2303 	mov.w	r3, r3, lsl #8
  while (temp >= 10U)
 8008500:	d908      	bls.n	8008514 <HAL_RTC_SetDate+0xc4>
    temp -= 10U;
 8008502:	380a      	subs	r0, #10
 8008504:	b2c0      	uxtb	r0, r0
  while (temp >= 10U)
 8008506:	2809      	cmp	r0, #9
    bcdhigh++;
 8008508:	f102 0201 	add.w	r2, r2, #1
  while (temp >= 10U)
 800850c:	d8f9      	bhi.n	8008502 <HAL_RTC_SetDate+0xb2>
 800850e:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 8008512:	b2c0      	uxtb	r0, r0
                  ((uint32_t)sDate->WeekDay << RTC_DR_WDU_Pos));
 8008514:	780a      	ldrb	r2, [r1, #0]
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8008516:	ea44 3442 	orr.w	r4, r4, r2, lsl #13
 800851a:	4323      	orrs	r3, r4
 800851c:	ea43 0400 	orr.w	r4, r3, r0
 8008520:	e7ad      	b.n	800847e <HAL_RTC_SetDate+0x2e>
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8008522:	f04f 33ff 	mov.w	r3, #4294967295
 8008526:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 8008528:	f7fc fb5a 	bl	8004be0 <HAL_GetTick>
 800852c:	4606      	mov	r6, r0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 800852e:	682a      	ldr	r2, [r5, #0]
 8008530:	68d3      	ldr	r3, [r2, #12]
 8008532:	065b      	lsls	r3, r3, #25
 8008534:	d4ab      	bmi.n	800848e <HAL_RTC_SetDate+0x3e>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8008536:	f7fc fb53 	bl	8004be0 <HAL_GetTick>
 800853a:	1b80      	subs	r0, r0, r6
 800853c:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008540:	d9f5      	bls.n	800852e <HAL_RTC_SetDate+0xde>
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8008542:	682b      	ldr	r3, [r5, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8008544:	2003      	movs	r0, #3
 8008546:	f885 0021 	strb.w	r0, [r5, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800854a:	22ff      	movs	r2, #255	; 0xff
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 800854c:	68d9      	ldr	r1, [r3, #12]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800854e:	625a      	str	r2, [r3, #36]	; 0x24
  if (status == HAL_OK)
 8008550:	e7ac      	b.n	80084ac <HAL_RTC_SetDate+0x5c>
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 8008552:	78cc      	ldrb	r4, [r1, #3]
  while (temp >= 10U)
 8008554:	2c09      	cmp	r4, #9
 8008556:	d8b7      	bhi.n	80084c8 <HAL_RTC_SetDate+0x78>
 8008558:	e7c0      	b.n	80084dc <HAL_RTC_SetDate+0x8c>
  __HAL_LOCK(hrtc);
 800855a:	2002      	movs	r0, #2
}
 800855c:	bd70      	pop	{r4, r5, r6, pc}
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
 800855e:	0424      	lsls	r4, r4, #16
  while (temp >= 10U)
 8008560:	e7c0      	b.n	80084e4 <HAL_RTC_SetDate+0x94>
 8008562:	bf00      	nop

08008564 <SD_FindSCR>:
  * @param  hsd Pointer to SD handle
  * @param  pSCR pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8008564:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008568:	b086      	sub	sp, #24
 800856a:	4605      	mov	r5, r0
 800856c:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800856e:	f7fc fb37 	bl	8004be0 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8008572:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
 8008574:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8008576:	6828      	ldr	r0, [r5, #0]
 8008578:	f002 fdb4 	bl	800b0e4 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800857c:	4604      	mov	r4, r0
 800857e:	b118      	cbz	r0, 8008588 <SD_FindSCR+0x24>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 8008580:	4620      	mov	r0, r4
 8008582:	b006      	add	sp, #24
 8008584:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8008588:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 800858a:	6828      	ldr	r0, [r5, #0]
 800858c:	0409      	lsls	r1, r1, #16
 800858e:	f003 fabb 	bl	800bb08 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008592:	4604      	mov	r4, r0
 8008594:	2800      	cmp	r0, #0
 8008596:	d1f3      	bne.n	8008580 <SD_FindSCR+0x1c>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8008598:	f04f 32ff 	mov.w	r2, #4294967295
 800859c:	2308      	movs	r3, #8
 800859e:	e9cd 2300 	strd	r2, r3, [sp]
 80085a2:	2230      	movs	r2, #48	; 0x30
 80085a4:	2302      	movs	r3, #2
 80085a6:	e9cd 2302 	strd	r2, r3, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 80085aa:	4669      	mov	r1, sp
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 80085ac:	2200      	movs	r2, #0
 80085ae:	2301      	movs	r3, #1
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 80085b0:	6828      	ldr	r0, [r5, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 80085b2:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 80085b6:	f002 fd81 	bl	800b0bc <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 80085ba:	6828      	ldr	r0, [r5, #0]
 80085bc:	f003 fc2e 	bl	800be1c <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 80085c0:	4604      	mov	r4, r0
 80085c2:	2800      	cmp	r0, #0
 80085c4:	d1dc      	bne.n	8008580 <SD_FindSCR+0x1c>
  uint32_t tempscr[2U] = {0U, 0U};
 80085c6:	4682      	mov	sl, r0
 80085c8:	4681      	mov	r9, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 80085ca:	f240 582a 	movw	r8, #1322	; 0x52a
 80085ce:	e004      	b.n	80085da <SD_FindSCR+0x76>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 80085d0:	f7fc fb06 	bl	8004be0 <HAL_GetTick>
 80085d4:	1b83      	subs	r3, r0, r6
 80085d6:	3301      	adds	r3, #1
 80085d8:	d024      	beq.n	8008624 <SD_FindSCR+0xc0>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 80085da:	6828      	ldr	r0, [r5, #0]
 80085dc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80085de:	ea13 0f08 	tst.w	r3, r8
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 80085e2:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 80085e4:	d10c      	bne.n	8008600 <SD_FindSCR+0x9c>
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 80085e6:	0319      	lsls	r1, r3, #12
 80085e8:	d4f2      	bmi.n	80085d0 <SD_FindSCR+0x6c>
 80085ea:	2c00      	cmp	r4, #0
 80085ec:	d1f0      	bne.n	80085d0 <SD_FindSCR+0x6c>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
 80085ee:	f002 fd47 	bl	800b080 <SDMMC_ReadFIFO>
 80085f2:	4681      	mov	r9, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 80085f4:	6828      	ldr	r0, [r5, #0]
 80085f6:	f002 fd43 	bl	800b080 <SDMMC_ReadFIFO>
      index++;
 80085fa:	2401      	movs	r4, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 80085fc:	4682      	mov	sl, r0
      index++;
 80085fe:	e7e7      	b.n	80085d0 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8008600:	071a      	lsls	r2, r3, #28
 8008602:	d415      	bmi.n	8008630 <SD_FindSCR+0xcc>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8008604:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008606:	079b      	lsls	r3, r3, #30
 8008608:	d40f      	bmi.n	800862a <SD_FindSCR+0xc6>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800860a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800860c:	f014 0420 	ands.w	r4, r4, #32
 8008610:	d111      	bne.n	8008636 <SD_FindSCR+0xd2>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8008612:	490a      	ldr	r1, [pc, #40]	; (800863c <SD_FindSCR+0xd8>)
 8008614:	6381      	str	r1, [r0, #56]	; 0x38
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8008616:	fa9a f28a 	rev.w	r2, sl
 800861a:	fa99 f389 	rev.w	r3, r9
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 800861e:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
 8008622:	e7ad      	b.n	8008580 <SD_FindSCR+0x1c>
      return HAL_SD_ERROR_TIMEOUT;
 8008624:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8008628:	e7aa      	b.n	8008580 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800862a:	2402      	movs	r4, #2
 800862c:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800862e:	e7a7      	b.n	8008580 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8008630:	2408      	movs	r4, #8
 8008632:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8008634:	e7a4      	b.n	8008580 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8008636:	2420      	movs	r4, #32
 8008638:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 800863a:	e7a1      	b.n	8008580 <SD_FindSCR+0x1c>
 800863c:	18000f3a 	.word	0x18000f3a

08008640 <HAL_SD_MspInit>:
}
 8008640:	4770      	bx	lr
 8008642:	bf00      	nop

08008644 <HAL_SD_ReadBlocks_DMA>:
{
 8008644:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008648:	4604      	mov	r4, r0
 800864a:	b088      	sub	sp, #32
  if(NULL == pData)
 800864c:	2900      	cmp	r1, #0
 800864e:	d061      	beq.n	8008714 <HAL_SD_ReadBlocks_DMA+0xd0>
 8008650:	460d      	mov	r5, r1
  if(hsd->State == HAL_SD_STATE_READY)
 8008652:	f890 1034 	ldrb.w	r1, [r0, #52]	; 0x34
 8008656:	2901      	cmp	r1, #1
 8008658:	fa5f f881 	uxtb.w	r8, r1
 800865c:	d142      	bne.n	80086e4 <HAL_SD_ReadBlocks_DMA+0xa0>
 800865e:	4616      	mov	r6, r2
 8008660:	461f      	mov	r7, r3
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8008662:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8008664:	19f1      	adds	r1, r6, r7
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8008666:	2200      	movs	r2, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8008668:	4299      	cmp	r1, r3
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800866a:	6382      	str	r2, [r0, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800866c:	d840      	bhi.n	80086f0 <HAL_SD_ReadBlocks_DMA+0xac>
    hsd->Instance->DCTRL = 0U;
 800866e:	6800      	ldr	r0, [r0, #0]
      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8008670:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    hsd->State = HAL_SD_STATE_BUSY;
 8008672:	2303      	movs	r3, #3
 8008674:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
 8008678:	027b      	lsls	r3, r7, #9
    hsd->Instance->DCTRL = 0U;
 800867a:	62c2      	str	r2, [r0, #44]	; 0x2c
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 800867c:	9303      	str	r3, [sp, #12]
      hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
 800867e:	e9c4 530a 	strd	r5, r3, [r4, #40]	; 0x28
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8008682:	f04f 32ff 	mov.w	r2, #4294967295
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8008686:	2390      	movs	r3, #144	; 0x90
      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8008688:	2901      	cmp	r1, #1
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800868a:	9202      	str	r2, [sp, #8]
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800868c:	9304      	str	r3, [sp, #16]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800868e:	f04f 0202 	mov.w	r2, #2
      config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8008692:	f04f 0300 	mov.w	r3, #0
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8008696:	a902      	add	r1, sp, #8
      config.DPSM          = SDMMC_DPSM_DISABLE;
 8008698:	e9cd 3306 	strd	r3, r3, [sp, #24]
        add *= 512U;
 800869c:	bf18      	it	ne
 800869e:	0276      	lslne	r6, r6, #9
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 80086a0:	9205      	str	r2, [sp, #20]
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 80086a2:	f002 fd0b 	bl	800b0bc <SDMMC_ConfigData>
      __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 80086a6:	6820      	ldr	r0, [r4, #0]
 80086a8:	68c3      	ldr	r3, [r0, #12]
      hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
 80086aa:	2201      	movs	r2, #1
      __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 80086ac:	f043 0340 	orr.w	r3, r3, #64	; 0x40
      if(NumberOfBlocks > 1U)
 80086b0:	4297      	cmp	r7, r2
      __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 80086b2:	60c3      	str	r3, [r0, #12]
      hsd->Instance->IDMABASE0 = (uint32_t) pData ;
 80086b4:	6585      	str	r5, [r0, #88]	; 0x58
      hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
 80086b6:	6502      	str	r2, [r0, #80]	; 0x50
      if(NumberOfBlocks > 1U)
 80086b8:	d936      	bls.n	8008728 <HAL_SD_ReadBlocks_DMA+0xe4>
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 80086ba:	2382      	movs	r3, #130	; 0x82
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 80086bc:	4631      	mov	r1, r6
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 80086be:	6323      	str	r3, [r4, #48]	; 0x30
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 80086c0:	f002 fe60 	bl	800b384 <SDMMC_CmdReadMultiBlock>
      if(errorstate != HAL_SD_ERROR_NONE)
 80086c4:	b1e0      	cbz	r0, 8008700 <HAL_SD_ReadBlocks_DMA+0xbc>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80086c6:	6823      	ldr	r3, [r4, #0]
 80086c8:	4a1c      	ldr	r2, [pc, #112]	; (800873c <HAL_SD_ReadBlocks_DMA+0xf8>)
 80086ca:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 80086cc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80086ce:	4318      	orrs	r0, r3
 80086d0:	63a0      	str	r0, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 80086d2:	2201      	movs	r2, #1
        hsd->Context = SD_CONTEXT_NONE;
 80086d4:	2300      	movs	r3, #0
}
 80086d6:	4640      	mov	r0, r8
        hsd->State = HAL_SD_STATE_READY;
 80086d8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 80086dc:	6323      	str	r3, [r4, #48]	; 0x30
}
 80086de:	b008      	add	sp, #32
 80086e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_BUSY;
 80086e4:	f04f 0802 	mov.w	r8, #2
}
 80086e8:	4640      	mov	r0, r8
 80086ea:	b008      	add	sp, #32
 80086ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 80086f0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80086f2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80086f6:	6383      	str	r3, [r0, #56]	; 0x38
}
 80086f8:	4640      	mov	r0, r8
 80086fa:	b008      	add	sp, #32
 80086fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8008700:	6822      	ldr	r2, [r4, #0]
 8008702:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
      return HAL_OK;
 8008704:	4680      	mov	r8, r0
      __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8008706:	f443 7395 	orr.w	r3, r3, #298	; 0x12a
}
 800870a:	4640      	mov	r0, r8
      __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 800870c:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 800870e:	b008      	add	sp, #32
 8008710:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8008714:	6b83      	ldr	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 8008716:	f04f 0801 	mov.w	r8, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800871a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800871e:	6383      	str	r3, [r0, #56]	; 0x38
}
 8008720:	4640      	mov	r0, r8
 8008722:	b008      	add	sp, #32
 8008724:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8008728:	2381      	movs	r3, #129	; 0x81
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800872a:	4631      	mov	r1, r6
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 800872c:	6323      	str	r3, [r4, #48]	; 0x30
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800872e:	f002 fd81 	bl	800b234 <SDMMC_CmdReadSingleBlock>
 8008732:	9001      	str	r0, [sp, #4]
      if(errorstate != HAL_SD_ERROR_NONE)
 8008734:	2800      	cmp	r0, #0
 8008736:	d0e3      	beq.n	8008700 <HAL_SD_ReadBlocks_DMA+0xbc>
 8008738:	e7c5      	b.n	80086c6 <HAL_SD_ReadBlocks_DMA+0x82>
 800873a:	bf00      	nop
 800873c:	1fe00fff 	.word	0x1fe00fff

08008740 <HAL_SD_WriteBlocks_DMA>:
{
 8008740:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008744:	4604      	mov	r4, r0
 8008746:	b087      	sub	sp, #28
  if(NULL == pData)
 8008748:	2900      	cmp	r1, #0
 800874a:	d060      	beq.n	800880e <HAL_SD_WriteBlocks_DMA+0xce>
 800874c:	460d      	mov	r5, r1
  if(hsd->State == HAL_SD_STATE_READY)
 800874e:	f890 1034 	ldrb.w	r1, [r0, #52]	; 0x34
 8008752:	2901      	cmp	r1, #1
 8008754:	fa5f f881 	uxtb.w	r8, r1
 8008758:	d141      	bne.n	80087de <HAL_SD_WriteBlocks_DMA+0x9e>
 800875a:	4616      	mov	r6, r2
 800875c:	461f      	mov	r7, r3
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800875e:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8008760:	19f1      	adds	r1, r6, r7
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8008762:	2200      	movs	r2, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8008764:	4299      	cmp	r1, r3
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8008766:	6382      	str	r2, [r0, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8008768:	d83f      	bhi.n	80087ea <HAL_SD_WriteBlocks_DMA+0xaa>
    hsd->Instance->DCTRL = 0U;
 800876a:	6800      	ldr	r0, [r0, #0]
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800876c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    hsd->State = HAL_SD_STATE_BUSY;
 800876e:	2303      	movs	r3, #3
 8008770:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
 8008774:	027b      	lsls	r3, r7, #9
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8008776:	2901      	cmp	r1, #1
    hsd->Instance->DCTRL = 0U;
 8008778:	62c2      	str	r2, [r0, #44]	; 0x2c
    config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 800877a:	9301      	str	r3, [sp, #4]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800877c:	f04f 32ff 	mov.w	r2, #4294967295
    hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
 8008780:	e9c4 5308 	strd	r5, r3, [r4, #32]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8008784:	f04f 0990 	mov.w	r9, #144	; 0x90
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 8008788:	f04f 0300 	mov.w	r3, #0
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800878c:	4669      	mov	r1, sp
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800878e:	e9cd 9302 	strd	r9, r3, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
 8008792:	e9cd 3304 	strd	r3, r3, [sp, #16]
      add *= 512U;
 8008796:	bf18      	it	ne
 8008798:	0276      	lslne	r6, r6, #9
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800879a:	9200      	str	r2, [sp, #0]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800879c:	f002 fc8e 	bl	800b0bc <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 80087a0:	6820      	ldr	r0, [r4, #0]
 80087a2:	68c3      	ldr	r3, [r0, #12]
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
 80087a4:	2201      	movs	r2, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 80087a6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    if(NumberOfBlocks > 1U)
 80087aa:	4297      	cmp	r7, r2
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 80087ac:	60c3      	str	r3, [r0, #12]
    hsd->Instance->IDMABASE0 = (uint32_t) pData ;
 80087ae:	6585      	str	r5, [r0, #88]	; 0x58
    hsd->Instance->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
 80087b0:	6502      	str	r2, [r0, #80]	; 0x50
    if(NumberOfBlocks > 1U)
 80087b2:	d936      	bls.n	8008822 <HAL_SD_WriteBlocks_DMA+0xe2>
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 80087b4:	23a0      	movs	r3, #160	; 0xa0
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 80087b6:	4631      	mov	r1, r6
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 80087b8:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 80087ba:	f002 ff33 	bl	800b624 <SDMMC_CmdWriteMultiBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
 80087be:	b1e0      	cbz	r0, 80087fa <HAL_SD_WriteBlocks_DMA+0xba>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80087c0:	6823      	ldr	r3, [r4, #0]
 80087c2:	4a1c      	ldr	r2, [pc, #112]	; (8008834 <HAL_SD_WriteBlocks_DMA+0xf4>)
 80087c4:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 80087c6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80087c8:	4318      	orrs	r0, r3
 80087ca:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80087cc:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 80087ce:	2300      	movs	r3, #0
}
 80087d0:	4640      	mov	r0, r8
      hsd->State = HAL_SD_STATE_READY;
 80087d2:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80087d6:	6323      	str	r3, [r4, #48]	; 0x30
}
 80087d8:	b007      	add	sp, #28
 80087da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return HAL_BUSY;
 80087de:	f04f 0802 	mov.w	r8, #2
}
 80087e2:	4640      	mov	r0, r8
 80087e4:	b007      	add	sp, #28
 80087e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 80087ea:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80087ec:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80087f0:	6383      	str	r3, [r0, #56]	; 0x38
}
 80087f2:	4640      	mov	r0, r8
 80087f4:	b007      	add	sp, #28
 80087f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
 80087fa:	6822      	ldr	r2, [r4, #0]
 80087fc:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
      return HAL_OK;
 80087fe:	4680      	mov	r8, r0
      __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
 8008800:	f443 738d 	orr.w	r3, r3, #282	; 0x11a
}
 8008804:	4640      	mov	r0, r8
      __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND));
 8008806:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 8008808:	b007      	add	sp, #28
 800880a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800880e:	6b83      	ldr	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 8008810:	f04f 0801 	mov.w	r8, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8008814:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8008818:	6383      	str	r3, [r0, #56]	; 0x38
}
 800881a:	4640      	mov	r0, r8
 800881c:	b007      	add	sp, #28
 800881e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8008822:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 8008826:	4631      	mov	r1, r6
 8008828:	f002 fe54 	bl	800b4d4 <SDMMC_CmdWriteSingleBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
 800882c:	2800      	cmp	r0, #0
 800882e:	d0e4      	beq.n	80087fa <HAL_SD_WriteBlocks_DMA+0xba>
 8008830:	e7c6      	b.n	80087c0 <HAL_SD_WriteBlocks_DMA+0x80>
 8008832:	bf00      	nop
 8008834:	1fe00fff 	.word	0x1fe00fff

08008838 <HAL_SD_ErrorCallback>:
 8008838:	4770      	bx	lr
 800883a:	bf00      	nop

0800883c <HAL_SD_IRQHandler>:
{
 800883c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008840:	4604      	mov	r4, r0
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 8008842:	6800      	ldr	r0, [r0, #0]
  uint32_t context = hsd->Context;
 8008844:	6b25      	ldr	r5, [r4, #48]	; 0x30
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 8008846:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008848:	041a      	lsls	r2, r3, #16
{
 800884a:	b082      	sub	sp, #8
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 800884c:	d52e      	bpl.n	80088ac <HAL_SD_IRQHandler+0x70>
 800884e:	072b      	lsls	r3, r5, #28
 8008850:	f100 80e8 	bmi.w	8008a24 <HAL_SD_IRQHandler+0x1e8>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
 8008854:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008856:	05db      	lsls	r3, r3, #23
 8008858:	d57f      	bpl.n	800895a <HAL_SD_IRQHandler+0x11e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 800885a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800885e:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT |\
 8008860:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8008862:	f423 4341 	bic.w	r3, r3, #49408	; 0xc100
 8008866:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
 800886a:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
 800886c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800886e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008872:	63c3      	str	r3, [r0, #60]	; 0x3c
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 8008874:	68c3      	ldr	r3, [r0, #12]
 8008876:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800887a:	60c3      	str	r3, [r0, #12]
    else if((context & SD_CONTEXT_DMA) != 0U)
 800887c:	0629      	lsls	r1, r5, #24
 800887e:	d512      	bpl.n	80088a6 <HAL_SD_IRQHandler+0x6a>
      hsd->Instance->DLEN = 0;
 8008880:	2300      	movs	r3, #0
      if(((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8008882:	f015 0f22 	tst.w	r5, #34	; 0x22
      hsd->Instance->DLEN = 0;
 8008886:	6283      	str	r3, [r0, #40]	; 0x28
      hsd->Instance->DCTRL = 0;
 8008888:	62c3      	str	r3, [r0, #44]	; 0x2c
      hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
 800888a:	6503      	str	r3, [r0, #80]	; 0x50
      if(((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 800888c:	f040 810f 	bne.w	8008aae <HAL_SD_IRQHandler+0x272>
      hsd->State = HAL_SD_STATE_READY;
 8008890:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 8008892:	2300      	movs	r3, #0
      if(((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8008894:	f015 0f30 	tst.w	r5, #48	; 0x30
      hsd->State = HAL_SD_STATE_READY;
 8008898:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800889c:	6323      	str	r3, [r4, #48]	; 0x30
      if(((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 800889e:	f040 8102 	bne.w	8008aa6 <HAL_SD_IRQHandler+0x26a>
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 80088a2:	07aa      	lsls	r2, r5, #30
 80088a4:	d126      	bne.n	80088f4 <HAL_SD_IRQHandler+0xb8>
}
 80088a6:	b002      	add	sp, #8
 80088a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
 80088ac:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80088ae:	05df      	lsls	r7, r3, #23
 80088b0:	d526      	bpl.n	8008900 <HAL_SD_IRQHandler+0xc4>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 80088b2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80088b6:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT |\
 80088b8:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80088ba:	f423 4341 	bic.w	r3, r3, #49408	; 0xc100
 80088be:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
 80088c2:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
 80088c4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80088c6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80088ca:	63c3      	str	r3, [r0, #60]	; 0x3c
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 80088cc:	68c3      	ldr	r3, [r0, #12]
    if((context & SD_CONTEXT_IT) != 0U)
 80088ce:	072e      	lsls	r6, r5, #28
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 80088d0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80088d4:	60c3      	str	r3, [r0, #12]
    if((context & SD_CONTEXT_IT) != 0U)
 80088d6:	d5d1      	bpl.n	800887c <HAL_SD_IRQHandler+0x40>
      if(((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 80088d8:	f015 0f22 	tst.w	r5, #34	; 0x22
 80088dc:	f040 80c9 	bne.w	8008a72 <HAL_SD_IRQHandler+0x236>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 80088e0:	4b7c      	ldr	r3, [pc, #496]	; (8008ad4 <HAL_SD_IRQHandler+0x298>)
 80088e2:	6383      	str	r3, [r0, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 80088e4:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 80088e6:	2300      	movs	r3, #0
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 80088e8:	07a8      	lsls	r0, r5, #30
      hsd->State = HAL_SD_STATE_READY;
 80088ea:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80088ee:	6323      	str	r3, [r4, #48]	; 0x30
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 80088f0:	f000 80b9 	beq.w	8008a66 <HAL_SD_IRQHandler+0x22a>
        HAL_SD_RxCpltCallback(hsd);
 80088f4:	4620      	mov	r0, r4
 80088f6:	f7fc f905 	bl	8004b04 <HAL_SD_RxCpltCallback>
}
 80088fa:	b002      	add	sp, #8
 80088fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 8008900:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008902:	045b      	lsls	r3, r3, #17
 8008904:	d52a      	bpl.n	800895c <HAL_SD_IRQHandler+0x120>
 8008906:	072f      	lsls	r7, r5, #28
 8008908:	d528      	bpl.n	800895c <HAL_SD_IRQHandler+0x120>
{
  uint32_t count, data, dataremaining;
  uint8_t* tmp;

  tmp = hsd->pTxBuffPtr;
  dataremaining = hsd->TxXferSize;
 800890a:	6a66      	ldr	r6, [r4, #36]	; 0x24

  if (dataremaining > 0U)
 800890c:	2e00      	cmp	r6, #0
 800890e:	d0ca      	beq.n	80088a6 <HAL_SD_IRQHandler+0x6a>
  tmp = hsd->pTxBuffPtr;
 8008910:	6a27      	ldr	r7, [r4, #32]
 8008912:	f107 0804 	add.w	r8, r7, #4
 8008916:	f107 0524 	add.w	r5, r7, #36	; 0x24
 800891a:	e000      	b.n	800891e <HAL_SD_IRQHandler+0xe2>
 800891c:	6820      	ldr	r0, [r4, #0]
  {
    /* Write data to SDMMC Tx FIFO */
    for(count = 0U; count < 8U; count++)
    {
      data = (uint32_t)(*tmp);
 800891e:	f818 3c04 	ldrb.w	r3, [r8, #-4]
 8008922:	9301      	str	r3, [sp, #4]
      tmp++;
      dataremaining--;
      data |= ((uint32_t)(*tmp) << 8U);
 8008924:	f818 2c03 	ldrb.w	r2, [r8, #-3]
 8008928:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800892c:	9301      	str	r3, [sp, #4]
      tmp++;
      dataremaining--;
      data |= ((uint32_t)(*tmp) << 16U);
 800892e:	f818 2c02 	ldrb.w	r2, [r8, #-2]
 8008932:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008936:	9301      	str	r3, [sp, #4]
      tmp++;
      dataremaining--;
      data |= ((uint32_t)(*tmp) << 24U);
 8008938:	f818 2c01 	ldrb.w	r2, [r8, #-1]
      tmp++;
      dataremaining--;
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800893c:	a901      	add	r1, sp, #4
      data |= ((uint32_t)(*tmp) << 24U);
 800893e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8008942:	f108 0804 	add.w	r8, r8, #4
 8008946:	9301      	str	r3, [sp, #4]
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 8008948:	f002 fb9e 	bl	800b088 <SDMMC_WriteFIFO>
    for(count = 0U; count < 8U; count++)
 800894c:	45a8      	cmp	r8, r5
 800894e:	d1e5      	bne.n	800891c <HAL_SD_IRQHandler+0xe0>
    }

    hsd->pTxBuffPtr = tmp;
 8008950:	3720      	adds	r7, #32
    hsd->TxXferSize = dataremaining;
 8008952:	3e20      	subs	r6, #32
 8008954:	e9c4 7608 	strd	r7, r6, [r4, #32]
  }
}
 8008958:	e7a5      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
  else if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 800895a:	6b43      	ldr	r3, [r0, #52]	; 0x34
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_TXUNDERR) != RESET)
 800895c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800895e:	f013 0f3a 	tst.w	r3, #58	; 0x3a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
 8008962:	6b43      	ldr	r3, [r0, #52]	; 0x34
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_TXUNDERR) != RESET)
 8008964:	d04f      	beq.n	8008a06 <HAL_SD_IRQHandler+0x1ca>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DCRCFAIL) != RESET)
 8008966:	079e      	lsls	r6, r3, #30
 8008968:	d503      	bpl.n	8008972 <HAL_SD_IRQHandler+0x136>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800896a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800896c:	f043 0302 	orr.w	r3, r3, #2
 8008970:	63a3      	str	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_DTIMEOUT) != RESET)
 8008972:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008974:	0719      	lsls	r1, r3, #28
 8008976:	d503      	bpl.n	8008980 <HAL_SD_IRQHandler+0x144>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8008978:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800897a:	f043 0308 	orr.w	r3, r3, #8
 800897e:	63a3      	str	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_RXOVERR) != RESET)
 8008980:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008982:	069a      	lsls	r2, r3, #26
 8008984:	d503      	bpl.n	800898e <HAL_SD_IRQHandler+0x152>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 8008986:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008988:	f043 0320 	orr.w	r3, r3, #32
 800898c:	63a3      	str	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_IT_TXUNDERR) != RESET)
 800898e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008990:	06db      	lsls	r3, r3, #27
 8008992:	d503      	bpl.n	800899c <HAL_SD_IRQHandler+0x160>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 8008994:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008996:	f043 0310 	orr.w	r3, r3, #16
 800899a:	63a3      	str	r3, [r4, #56]	; 0x38
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800899c:	4b4d      	ldr	r3, [pc, #308]	; (8008ad4 <HAL_SD_IRQHandler+0x298>)
 800899e:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 80089a0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80089a2:	f423 739d 	bic.w	r3, r3, #314	; 0x13a
 80089a6:	63c3      	str	r3, [r0, #60]	; 0x3c
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 80089a8:	68c3      	ldr	r3, [r0, #12]
 80089aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80089ae:	60c3      	str	r3, [r0, #12]
    hsd->Instance->DCTRL |= SDMMC_DCTRL_FIFORST;
 80089b0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80089b2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80089b6:	62c3      	str	r3, [r0, #44]	; 0x2c
    hsd->Instance->CMD |= SDMMC_CMD_CMDSTOP;
 80089b8:	68c3      	ldr	r3, [r0, #12]
 80089ba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80089be:	60c3      	str	r3, [r0, #12]
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 80089c0:	f002 fed8 	bl	800b774 <SDMMC_CmdStopTransfer>
 80089c4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    hsd->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
 80089c6:	6823      	ldr	r3, [r4, #0]
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 80089c8:	4310      	orrs	r0, r2
 80089ca:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->Instance->CMD &= ~(SDMMC_CMD_CMDSTOP);
 80089cc:	68da      	ldr	r2, [r3, #12]
 80089ce:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80089d2:	60da      	str	r2, [r3, #12]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DABORT);
 80089d4:	f44f 6100 	mov.w	r1, #2048	; 0x800
    if((context & SD_CONTEXT_IT) != 0U)
 80089d8:	f015 0208 	ands.w	r2, r5, #8
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DABORT);
 80089dc:	6399      	str	r1, [r3, #56]	; 0x38
    if((context & SD_CONTEXT_IT) != 0U)
 80089de:	d14d      	bne.n	8008a7c <HAL_SD_IRQHandler+0x240>
    else if((context & SD_CONTEXT_DMA) != 0U)
 80089e0:	062f      	lsls	r7, r5, #24
 80089e2:	f57f af60 	bpl.w	80088a6 <HAL_SD_IRQHandler+0x6a>
      if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80089e6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80089e8:	2900      	cmp	r1, #0
 80089ea:	f43f af5c 	beq.w	80088a6 <HAL_SD_IRQHandler+0x6a>
        __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
 80089ee:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
        hsd->State = HAL_SD_STATE_READY;
 80089f0:	2501      	movs	r5, #1
        __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_IDMABTC);
 80089f2:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
 80089f6:	63d9      	str	r1, [r3, #60]	; 0x3c
        HAL_SD_ErrorCallback(hsd);
 80089f8:	4620      	mov	r0, r4
        hsd->Instance->IDMACTRL = SDMMC_DISABLE_IDMA;
 80089fa:	651a      	str	r2, [r3, #80]	; 0x50
        hsd->State = HAL_SD_STATE_READY;
 80089fc:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
        HAL_SD_ErrorCallback(hsd);
 8008a00:	f7ff ff1a 	bl	8008838 <HAL_SD_ErrorCallback>
 8008a04:	e74f      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_IDMABTC) != RESET)
 8008a06:	00de      	lsls	r6, r3, #3
 8008a08:	f57f af4d 	bpl.w	80088a6 <HAL_SD_IRQHandler+0x6a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_IDMABTC);
 8008a0c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8008a10:	6383      	str	r3, [r0, #56]	; 0x38
    if(READ_BIT(hsd->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
 8008a12:	6d03      	ldr	r3, [r0, #80]	; 0x50
        HAL_SDEx_Write_DMADoubleBuffer1CpltCallback(hsd);
 8008a14:	4620      	mov	r0, r4
    if(READ_BIT(hsd->Instance->IDMACTRL, SDMMC_IDMA_IDMABACT) == 0U)
 8008a16:	075c      	lsls	r4, r3, #29
 8008a18:	d439      	bmi.n	8008a8e <HAL_SD_IRQHandler+0x252>
      if((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 8008a1a:	06a9      	lsls	r1, r5, #26
 8008a1c:	d556      	bpl.n	8008acc <HAL_SD_IRQHandler+0x290>
        HAL_SDEx_Write_DMADoubleBuffer1CpltCallback(hsd);
 8008a1e:	f000 fc81 	bl	8009324 <HAL_SDEx_Write_DMADoubleBuffer1CpltCallback>
 8008a22:	e740      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
  dataremaining = hsd->RxXferSize;
 8008a24:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  if (dataremaining > 0U)
 8008a26:	2e00      	cmp	r6, #0
 8008a28:	f43f af3d 	beq.w	80088a6 <HAL_SD_IRQHandler+0x6a>
  tmp = hsd->pRxBuffPtr;
 8008a2c:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 8008a2e:	f107 0804 	add.w	r8, r7, #4
 8008a32:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8008a36:	e000      	b.n	8008a3a <HAL_SD_IRQHandler+0x1fe>
 8008a38:	6820      	ldr	r0, [r4, #0]
      data = SDMMC_ReadFIFO(hsd->Instance);
 8008a3a:	f002 fb21 	bl	800b080 <SDMMC_ReadFIFO>
      *tmp = (uint8_t)(data & 0xFFU);
 8008a3e:	f808 0c04 	strb.w	r0, [r8, #-4]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 8008a42:	0a02      	lsrs	r2, r0, #8
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 8008a44:	0c03      	lsrs	r3, r0, #16
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 8008a46:	0e00      	lsrs	r0, r0, #24
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 8008a48:	f808 2c03 	strb.w	r2, [r8, #-3]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 8008a4c:	f808 3c02 	strb.w	r3, [r8, #-2]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 8008a50:	f808 0c01 	strb.w	r0, [r8, #-1]
    for(count = 0U; count < 8U; count++)
 8008a54:	f108 0804 	add.w	r8, r8, #4
 8008a58:	45a8      	cmp	r8, r5
 8008a5a:	d1ed      	bne.n	8008a38 <HAL_SD_IRQHandler+0x1fc>
    hsd->pRxBuffPtr = tmp;
 8008a5c:	3720      	adds	r7, #32
    hsd->RxXferSize = dataremaining;
 8008a5e:	3e20      	subs	r6, #32
 8008a60:	e9c4 760a 	strd	r7, r6, [r4, #40]	; 0x28
 8008a64:	e71f      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
        HAL_SD_TxCpltCallback(hsd);
 8008a66:	4620      	mov	r0, r4
 8008a68:	f7fc f848 	bl	8004afc <HAL_SD_TxCpltCallback>
}
 8008a6c:	b002      	add	sp, #8
 8008a6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8008a72:	f002 fe7f 	bl	800b774 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 8008a76:	b978      	cbnz	r0, 8008a98 <HAL_SD_IRQHandler+0x25c>
 8008a78:	6820      	ldr	r0, [r4, #0]
 8008a7a:	e731      	b.n	80088e0 <HAL_SD_IRQHandler+0xa4>
      hsd->State = HAL_SD_STATE_READY;
 8008a7c:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 8008a7e:	2300      	movs	r3, #0
      hsd->State = HAL_SD_STATE_READY;
 8008a80:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      HAL_SD_ErrorCallback(hsd);
 8008a84:	4620      	mov	r0, r4
      hsd->Context = SD_CONTEXT_NONE;
 8008a86:	6323      	str	r3, [r4, #48]	; 0x30
      HAL_SD_ErrorCallback(hsd);
 8008a88:	f7ff fed6 	bl	8008838 <HAL_SD_ErrorCallback>
 8008a8c:	e70b      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
      if((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 8008a8e:	06aa      	lsls	r2, r5, #26
 8008a90:	d519      	bpl.n	8008ac6 <HAL_SD_IRQHandler+0x28a>
        HAL_SDEx_Write_DMADoubleBuffer0CpltCallback(hsd);
 8008a92:	f000 fc45 	bl	8009320 <HAL_SDEx_Write_DMADoubleBuffer0CpltCallback>
 8008a96:	e706      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
          hsd->ErrorCode |= errorstate;
 8008a98:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008a9a:	4318      	orrs	r0, r3
 8008a9c:	63a0      	str	r0, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 8008a9e:	4620      	mov	r0, r4
 8008aa0:	f7ff feca 	bl	8008838 <HAL_SD_ErrorCallback>
 8008aa4:	e7e8      	b.n	8008a78 <HAL_SD_IRQHandler+0x23c>
        HAL_SD_TxCpltCallback(hsd);
 8008aa6:	4620      	mov	r0, r4
 8008aa8:	f7fc f828 	bl	8004afc <HAL_SD_TxCpltCallback>
 8008aac:	e6f9      	b.n	80088a2 <HAL_SD_IRQHandler+0x66>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8008aae:	f002 fe61 	bl	800b774 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 8008ab2:	2800      	cmp	r0, #0
 8008ab4:	f43f aeec 	beq.w	8008890 <HAL_SD_IRQHandler+0x54>
          hsd->ErrorCode |= errorstate;
 8008ab8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8008aba:	4318      	orrs	r0, r3
 8008abc:	63a0      	str	r0, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 8008abe:	4620      	mov	r0, r4
 8008ac0:	f7ff feba 	bl	8008838 <HAL_SD_ErrorCallback>
 8008ac4:	e6e4      	b.n	8008890 <HAL_SD_IRQHandler+0x54>
        HAL_SDEx_Read_DMADoubleBuffer0CpltCallback(hsd);
 8008ac6:	f000 fc27 	bl	8009318 <HAL_SDEx_Read_DMADoubleBuffer0CpltCallback>
}
 8008aca:	e6ec      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
        HAL_SDEx_Read_DMADoubleBuffer1CpltCallback(hsd);
 8008acc:	f000 fc26 	bl	800931c <HAL_SDEx_Read_DMADoubleBuffer1CpltCallback>
 8008ad0:	e6e9      	b.n	80088a6 <HAL_SD_IRQHandler+0x6a>
 8008ad2:	bf00      	nop
 8008ad4:	18000f3a 	.word	0x18000f3a

08008ad8 <HAL_SD_GetCardCSD>:
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8008ad8:	6e02      	ldr	r2, [r0, #96]	; 0x60
{
 8008ada:	b4f0      	push	{r4, r5, r6, r7}
 8008adc:	4603      	mov	r3, r0
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8008ade:	0f94      	lsrs	r4, r2, #30
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8008ae0:	f3c2 6083 	ubfx	r0, r2, #26, #4
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8008ae4:	700c      	strb	r4, [r1, #0]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8008ae6:	f3c2 6501 	ubfx	r5, r2, #24, #2
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8008aea:	7048      	strb	r0, [r1, #1]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8008aec:	f3c2 4407 	ubfx	r4, r2, #16, #8
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 8008af0:	f3c2 2007 	ubfx	r0, r2, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8008af4:	b2d2      	uxtb	r2, r2
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8008af6:	708d      	strb	r5, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8008af8:	70cc      	strb	r4, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 8008afa:	7108      	strb	r0, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8008afc:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 8008afe:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8008b00:	0d15      	lsrs	r5, r2, #20
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 8008b02:	f3c2 4403 	ubfx	r4, r2, #16, #4
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 8008b06:	80cd      	strh	r5, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 8008b08:	720c      	strb	r4, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 8008b0a:	f3c2 35c0 	ubfx	r5, r2, #15, #1
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8008b0e:	f3c2 3480 	ubfx	r4, r2, #14, #1
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 8008b12:	724d      	strb	r5, [r1, #9]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 8008b14:	2000      	movs	r0, #0
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8008b16:	728c      	strb	r4, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 8008b18:	f3c2 3540 	ubfx	r5, r2, #13, #1
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 8008b1c:	f3c2 3400 	ubfx	r4, r2, #12, #1
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 8008b20:	72cd      	strb	r5, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 8008b22:	730c      	strb	r4, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 8008b24:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 8008b26:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008b28:	2800      	cmp	r0, #0
 8008b2a:	d16c      	bne.n	8008c06 <HAL_SD_GetCardCSD+0x12e>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 8008b2c:	6e98      	ldr	r0, [r3, #104]	; 0x68
 8008b2e:	f640 74fc 	movw	r4, #4092	; 0xffc
 8008b32:	ea04 0282 	and.w	r2, r4, r2, lsl #2
 8008b36:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
 8008b3a:	610a      	str	r2, [r1, #16]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 8008b3c:	f3c0 5542 	ubfx	r5, r0, #21, #3
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 8008b40:	f3c0 4482 	ubfx	r4, r0, #18, #3
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 8008b44:	f3c0 32c2 	ubfx	r2, r0, #15, #3
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 8008b48:	f3c0 67c2 	ubfx	r7, r0, #27, #3
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 8008b4c:	f3c0 6602 	ubfx	r6, r0, #24, #3
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 8008b50:	750f      	strb	r7, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 8008b52:	754e      	strb	r6, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 8008b54:	758d      	strb	r5, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 8008b56:	75cc      	strb	r4, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 8008b58:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8008b5a:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 8008b5c:	7e0c      	ldrb	r4, [r1, #24]
 8008b5e:	f004 0407 	and.w	r4, r4, #7
 8008b62:	3402      	adds	r4, #2
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8008b64:	3201      	adds	r2, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 8008b66:	40a2      	lsls	r2, r4
 8008b68:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 8008b6a:	7a0d      	ldrb	r5, [r1, #8]
 8008b6c:	2401      	movs	r4, #1
 8008b6e:	f005 050f 	and.w	r5, r5, #15
 8008b72:	40ac      	lsls	r4, r5
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 8008b74:	0a65      	lsrs	r5, r4, #9
 8008b76:	fb02 f205 	mul.w	r2, r2, r5
 8008b7a:	e9c3 4214 	strd	r4, r2, [r3, #80]	; 0x50
    hsd->SdCard.LogBlockSize = 512U;
 8008b7e:	f44f 7500 	mov.w	r5, #512	; 0x200
 8008b82:	659d      	str	r5, [r3, #88]	; 0x58
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 8008b84:	f3c0 3480 	ubfx	r4, r0, #14, #1
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 8008b88:	f3c0 12c6 	ubfx	r2, r0, #7, #7
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 8008b8c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 8008b90:	764c      	strb	r4, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 8008b92:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 8008b94:	76c8      	strb	r0, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 8008b96:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008b98:	0fda      	lsrs	r2, r3, #31
 8008b9a:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8008b9c:	f3c3 7541 	ubfx	r5, r3, #29, #2
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 8008ba0:	f3c3 6482 	ubfx	r4, r3, #26, #3
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8008ba4:	f3c3 5283 	ubfx	r2, r3, #22, #4
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8008ba8:	774d      	strb	r5, [r1, #29]
  pCSD->Reserved3 = 0;
 8008baa:	2000      	movs	r0, #0
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 8008bac:	778c      	strb	r4, [r1, #30]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8008bae:	f3c3 5540 	ubfx	r5, r3, #21, #1
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8008bb2:	77ca      	strb	r2, [r1, #31]
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8008bb4:	f3c3 4400 	ubfx	r4, r3, #16, #1
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 8008bb8:	f3c3 32c0 	ubfx	r2, r3, #15, #1
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8008bbc:	f881 5020 	strb.w	r5, [r1, #32]
  pCSD->Reserved3 = 0;
 8008bc0:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 8008bc4:	f3c3 3580 	ubfx	r5, r3, #14, #1
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8008bc8:	f881 4022 	strb.w	r4, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 8008bcc:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 8008bd0:	f3c3 3440 	ubfx	r4, r3, #13, #1
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8008bd4:	f3c3 3200 	ubfx	r2, r3, #12, #1
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 8008bd8:	f881 5024 	strb.w	r5, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 8008bdc:	f881 4025 	strb.w	r4, [r1, #37]	; 0x25
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 8008be0:	f3c3 2581 	ubfx	r5, r3, #10, #2
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8008be4:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8008be8:	f3c3 2401 	ubfx	r4, r3, #8, #2
  pCSD->Reserved4 = 1;
 8008bec:	2201      	movs	r2, #1
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8008bee:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 8008bf2:	f881 5027 	strb.w	r5, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8008bf6:	f881 4028 	strb.w	r4, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8008bfa:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
 8008bfe:	f881 202a 	strb.w	r2, [r1, #42]	; 0x2a
}
 8008c02:	bcf0      	pop	{r4, r5, r6, r7}
 8008c04:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8008c06:	2801      	cmp	r0, #1
 8008c08:	d110      	bne.n	8008c2c <HAL_SD_GetCardCSD+0x154>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 8008c0a:	6e98      	ldr	r0, [r3, #104]	; 0x68
 8008c0c:	0412      	lsls	r2, r2, #16
 8008c0e:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 8008c12:	ea42 4210 	orr.w	r2, r2, r0, lsr #16
 8008c16:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 8008c18:	690a      	ldr	r2, [r1, #16]
 8008c1a:	3201      	adds	r2, #1
 8008c1c:	0292      	lsls	r2, r2, #10
    hsd->SdCard.BlockSize = 512U;
 8008c1e:	f44f 7400 	mov.w	r4, #512	; 0x200
 8008c22:	e9c3 4214 	strd	r4, r2, [r3, #80]	; 0x50
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 8008c26:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 8008c28:	659c      	str	r4, [r3, #88]	; 0x58
 8008c2a:	e7ab      	b.n	8008b84 <HAL_SD_GetCardCSD+0xac>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8008c2c:	681a      	ldr	r2, [r3, #0]
 8008c2e:	4906      	ldr	r1, [pc, #24]	; (8008c48 <HAL_SD_GetCardCSD+0x170>)
 8008c30:	6391      	str	r1, [r2, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8008c32:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8008c34:	2101      	movs	r1, #1
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8008c36:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8008c3a:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8008c3c:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
    return HAL_ERROR;
 8008c40:	4608      	mov	r0, r1
}
 8008c42:	bcf0      	pop	{r4, r5, r6, r7}
 8008c44:	4770      	bx	lr
 8008c46:	bf00      	nop
 8008c48:	1fe00fff 	.word	0x1fe00fff

08008c4c <HAL_SD_InitCard>:
{
 8008c4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008c50:	4604      	mov	r4, r0
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 8008c52:	6981      	ldr	r1, [r0, #24]
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 8008c54:	6825      	ldr	r5, [r4, #0]
{
 8008c56:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8008c58:	2300      	movs	r3, #0
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 8008c5a:	2901      	cmp	r1, #1
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8008c5c:	f04f 0200 	mov.w	r2, #0
 8008c60:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8008c64:	e9cd 2308 	strd	r2, r3, [sp, #32]
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 8008c68:	bf08      	it	eq
 8008c6a:	682b      	ldreq	r3, [r5, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 8008c6c:	f04f 008a 	mov.w	r0, #138	; 0x8a
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 8008c70:	bf04      	itt	eq
 8008c72:	f043 0310 	orreq.w	r3, r3, #16
 8008c76:	602b      	streq	r3, [r5, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 8008c78:	900a      	str	r0, [sp, #40]	; 0x28
  status = SDMMC_Init(hsd->Instance, Init);
 8008c7a:	ab09      	add	r3, sp, #36	; 0x24
 8008c7c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8008c80:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8008c84:	ab06      	add	r3, sp, #24
 8008c86:	cb0e      	ldmia	r3, {r1, r2, r3}
 8008c88:	4628      	mov	r0, r5
 8008c8a:	f002 f9df 	bl	800b04c <SDMMC_Init>
  if(status != HAL_OK)
 8008c8e:	b120      	cbz	r0, 8008c9a <HAL_SD_InitCard+0x4e>
    return HAL_ERROR;
 8008c90:	2601      	movs	r6, #1
}
 8008c92:	4630      	mov	r0, r6
 8008c94:	b018      	add	sp, #96	; 0x60
 8008c96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  status = SDMMC_PowerState_ON(hsd->Instance);
 8008c9a:	6820      	ldr	r0, [r4, #0]
 8008c9c:	f002 f9fa 	bl	800b094 <SDMMC_PowerState_ON>
  if(status != HAL_OK)
 8008ca0:	2800      	cmp	r0, #0
 8008ca2:	d1f5      	bne.n	8008c90 <HAL_SD_InitCard+0x44>
  __IO uint32_t count = 0U;
 8008ca4:	9005      	str	r0, [sp, #20]
  uint32_t tickstart = HAL_GetTick();
 8008ca6:	f7fb ff9b 	bl	8004be0 <HAL_GetTick>
 8008caa:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8008cac:	6820      	ldr	r0, [r4, #0]
 8008cae:	f002 febd 	bl	800ba2c <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008cb2:	4605      	mov	r5, r0
 8008cb4:	b148      	cbz	r0, 8008cca <HAL_SD_InitCard+0x7e>
    hsd->State = HAL_SD_STATE_READY;
 8008cb6:	2601      	movs	r6, #1
 8008cb8:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8008cbc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
}
 8008cbe:	4630      	mov	r0, r6
    hsd->ErrorCode |= errorstate;
 8008cc0:	4315      	orrs	r5, r2
 8008cc2:	63a5      	str	r5, [r4, #56]	; 0x38
}
 8008cc4:	b018      	add	sp, #96	; 0x60
 8008cc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 8008cca:	6820      	ldr	r0, [r4, #0]
 8008ccc:	f002 feda 	bl	800ba84 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008cd0:	2800      	cmp	r0, #0
 8008cd2:	f040 80bb 	bne.w	8008e4c <HAL_SD_InitCard+0x200>
    hsd->SdCard.CardVersion = CARD_V2_X;
 8008cd6:	2301      	movs	r3, #1
 8008cd8:	6423      	str	r3, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8008cda:	6820      	ldr	r0, [r4, #0]
 8008cdc:	2100      	movs	r1, #0
 8008cde:	f002 ff13 	bl	800bb08 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8008ce2:	bb18      	cbnz	r0, 8008d2c <HAL_SD_InitCard+0xe0>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8008ce4:	9a05      	ldr	r2, [sp, #20]
 8008ce6:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8008cea:	429a      	cmp	r2, r3
 8008cec:	f200 80bb 	bhi.w	8008e66 <HAL_SD_InitCard+0x21a>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 8008cf0:	4f86      	ldr	r7, [pc, #536]	; (8008f0c <HAL_SD_InitCard+0x2c0>)
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8008cf2:	f64f 78fe 	movw	r8, #65534	; 0xfffe
 8008cf6:	e010      	b.n	8008d1a <HAL_SD_InitCard+0xce>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 8008cf8:	6820      	ldr	r0, [r4, #0]
 8008cfa:	f002 ffad 	bl	800bc58 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8008cfe:	4601      	mov	r1, r0
 8008d00:	b9a0      	cbnz	r0, 8008d2c <HAL_SD_InitCard+0xe0>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8008d02:	6820      	ldr	r0, [r4, #0]
 8008d04:	f002 f9d6 	bl	800b0b4 <SDMMC_GetResponse>
    count++;
 8008d08:	9b05      	ldr	r3, [sp, #20]
 8008d0a:	3301      	adds	r3, #1
 8008d0c:	9305      	str	r3, [sp, #20]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8008d0e:	9b05      	ldr	r3, [sp, #20]
 8008d10:	4543      	cmp	r3, r8
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8008d12:	ea4f 72d0 	mov.w	r2, r0, lsr #31
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8008d16:	d80c      	bhi.n	8008d32 <HAL_SD_InitCard+0xe6>
 8008d18:	b95a      	cbnz	r2, 8008d32 <HAL_SD_InitCard+0xe6>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8008d1a:	2100      	movs	r1, #0
 8008d1c:	6820      	ldr	r0, [r4, #0]
 8008d1e:	f002 fef3 	bl	800bb08 <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 8008d22:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
 8008d24:	4605      	mov	r5, r0
 8008d26:	2800      	cmp	r0, #0
 8008d28:	d0e6      	beq.n	8008cf8 <HAL_SD_InitCard+0xac>
 8008d2a:	e7c4      	b.n	8008cb6 <HAL_SD_InitCard+0x6a>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8008d2c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8008d30:	e7c1      	b.n	8008cb6 <HAL_SD_InitCard+0x6a>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 8008d32:	9a05      	ldr	r2, [sp, #20]
 8008d34:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8008d38:	429a      	cmp	r2, r3
 8008d3a:	f200 809f 	bhi.w	8008e7c <HAL_SD_InitCard+0x230>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8008d3e:	0045      	lsls	r5, r0, #1
 8008d40:	f140 8096 	bpl.w	8008e70 <HAL_SD_InitCard+0x224>
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 8008d44:	69a3      	ldr	r3, [r4, #24]
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 8008d46:	2201      	movs	r2, #1
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 8008d48:	4293      	cmp	r3, r2
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 8008d4a:	63e2      	str	r2, [r4, #60]	; 0x3c
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 8008d4c:	f000 8099 	beq.w	8008e82 <HAL_SD_InitCard+0x236>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008d50:	6820      	ldr	r0, [r4, #0]
  uint16_t sd_rca = 1U;
 8008d52:	2301      	movs	r3, #1
 8008d54:	f8ad 3012 	strh.w	r3, [sp, #18]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 8008d58:	f002 f9a8 	bl	800b0ac <SDMMC_GetPowerState>
 8008d5c:	b348      	cbz	r0, 8008db2 <HAL_SD_InitCard+0x166>
  if(hsd->SdCard.CardType != CARD_SECURED)
 8008d5e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008d60:	2b03      	cmp	r3, #3
 8008d62:	d12f      	bne.n	8008dc4 <HAL_SD_InitCard+0x178>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 8008d64:	2104      	movs	r1, #4
 8008d66:	6820      	ldr	r0, [r4, #0]
 8008d68:	f002 f9a4 	bl	800b0b4 <SDMMC_GetResponse>
 8008d6c:	0d00      	lsrs	r0, r0, #20
 8008d6e:	6460      	str	r0, [r4, #68]	; 0x44
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 8008d70:	a90d      	add	r1, sp, #52	; 0x34
 8008d72:	4620      	mov	r0, r4
 8008d74:	f7ff feb0 	bl	8008ad8 <HAL_SD_GetCardCSD>
 8008d78:	4606      	mov	r6, r0
 8008d7a:	2800      	cmp	r0, #0
 8008d7c:	d17b      	bne.n	8008e76 <HAL_SD_InitCard+0x22a>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 8008d7e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8008d80:	6820      	ldr	r0, [r4, #0]
 8008d82:	0412      	lsls	r2, r2, #16
 8008d84:	4633      	mov	r3, r6
 8008d86:	f002 fda9 	bl	800b8dc <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008d8a:	b9a0      	cbnz	r0, 8008db6 <HAL_SD_InitCard+0x16a>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8008d8c:	6820      	ldr	r0, [r4, #0]
 8008d8e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008d92:	f002 f9a7 	bl	800b0e4 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008d96:	2800      	cmp	r0, #0
 8008d98:	f43f af7b 	beq.w	8008c92 <HAL_SD_InitCard+0x46>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8008d9c:	6823      	ldr	r3, [r4, #0]
 8008d9e:	4a5c      	ldr	r2, [pc, #368]	; (8008f10 <HAL_SD_InitCard+0x2c4>)
 8008da0:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 8008da2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8008da4:	2301      	movs	r3, #1
    hsd->ErrorCode |= errorstate;
 8008da6:	4310      	orrs	r0, r2
 8008da8:	63a0      	str	r0, [r4, #56]	; 0x38
    return HAL_ERROR;
 8008daa:	461e      	mov	r6, r3
    hsd->State = HAL_SD_STATE_READY;
 8008dac:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_ERROR;
 8008db0:	e76f      	b.n	8008c92 <HAL_SD_InitCard+0x46>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8008db2:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
    hsd->State = HAL_SD_STATE_READY;
 8008db6:	2601      	movs	r6, #1
 8008db8:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8008dbc:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8008dbe:	4302      	orrs	r2, r0
 8008dc0:	63a2      	str	r2, [r4, #56]	; 0x38
    return HAL_ERROR;
 8008dc2:	e766      	b.n	8008c92 <HAL_SD_InitCard+0x46>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 8008dc4:	6820      	ldr	r0, [r4, #0]
 8008dc6:	f003 f8d1 	bl	800bf6c <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 8008dca:	2800      	cmp	r0, #0
 8008dcc:	d1f3      	bne.n	8008db6 <HAL_SD_InitCard+0x16a>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8008dce:	4601      	mov	r1, r0
 8008dd0:	6820      	ldr	r0, [r4, #0]
 8008dd2:	f002 f96f 	bl	800b0b4 <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8008dd6:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8008dd8:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8008dda:	6820      	ldr	r0, [r4, #0]
 8008ddc:	f002 f96a 	bl	800b0b4 <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8008de0:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8008de2:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8008de4:	6820      	ldr	r0, [r4, #0]
 8008de6:	f002 f965 	bl	800b0b4 <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8008dea:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8008dec:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8008dee:	6820      	ldr	r0, [r4, #0]
 8008df0:	f002 f960 	bl	800b0b4 <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
 8008df4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8008df6:	67e0      	str	r0, [r4, #124]	; 0x7c
  if(hsd->SdCard.CardType != CARD_SECURED)
 8008df8:	2b03      	cmp	r3, #3
 8008dfa:	d0b3      	beq.n	8008d64 <HAL_SD_InitCard+0x118>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 8008dfc:	6820      	ldr	r0, [r4, #0]
 8008dfe:	f10d 0112 	add.w	r1, sp, #18
 8008e02:	f003 f931 	bl	800c068 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 8008e06:	2800      	cmp	r0, #0
 8008e08:	d1d5      	bne.n	8008db6 <HAL_SD_InitCard+0x16a>
  if(hsd->SdCard.CardType != CARD_SECURED)
 8008e0a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008e0c:	2b03      	cmp	r3, #3
 8008e0e:	d0a9      	beq.n	8008d64 <HAL_SD_InitCard+0x118>
    hsd->SdCard.RelCardAdd = sd_rca;
 8008e10:	f8bd 1012 	ldrh.w	r1, [sp, #18]
 8008e14:	64a1      	str	r1, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8008e16:	6820      	ldr	r0, [r4, #0]
 8008e18:	0409      	lsls	r1, r1, #16
 8008e1a:	f003 f8e7 	bl	800bfec <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 8008e1e:	2800      	cmp	r0, #0
 8008e20:	d1c9      	bne.n	8008db6 <HAL_SD_InitCard+0x16a>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8008e22:	4601      	mov	r1, r0
 8008e24:	6820      	ldr	r0, [r4, #0]
 8008e26:	f002 f945 	bl	800b0b4 <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8008e2a:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8008e2c:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8008e2e:	6820      	ldr	r0, [r4, #0]
 8008e30:	f002 f940 	bl	800b0b4 <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8008e34:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8008e36:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8008e38:	6820      	ldr	r0, [r4, #0]
 8008e3a:	f002 f93b 	bl	800b0b4 <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8008e3e:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8008e40:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8008e42:	6820      	ldr	r0, [r4, #0]
 8008e44:	f002 f936 	bl	800b0b4 <SDMMC_GetResponse>
 8008e48:	66e0      	str	r0, [r4, #108]	; 0x6c
 8008e4a:	e78b      	b.n	8008d64 <HAL_SD_InitCard+0x118>
    hsd->SdCard.CardVersion = CARD_V1_X;
 8008e4c:	6425      	str	r5, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8008e4e:	6820      	ldr	r0, [r4, #0]
 8008e50:	f002 fdec 	bl	800ba2c <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 8008e54:	4605      	mov	r5, r0
 8008e56:	2800      	cmp	r0, #0
 8008e58:	f47f af2d 	bne.w	8008cb6 <HAL_SD_InitCard+0x6a>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
 8008e5c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8008e5e:	2b01      	cmp	r3, #1
 8008e60:	f47f af40 	bne.w	8008ce4 <HAL_SD_InitCard+0x98>
 8008e64:	e739      	b.n	8008cda <HAL_SD_InitCard+0x8e>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 8008e66:	9a05      	ldr	r2, [sp, #20]
 8008e68:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8008e6c:	429a      	cmp	r2, r3
 8008e6e:	d805      	bhi.n	8008e7c <HAL_SD_InitCard+0x230>
    hsd->SdCard.CardType = CARD_SDSC;
 8008e70:	2300      	movs	r3, #0
 8008e72:	63e3      	str	r3, [r4, #60]	; 0x3c
 8008e74:	e76c      	b.n	8008d50 <HAL_SD_InitCard+0x104>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8008e76:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8008e7a:	e79c      	b.n	8008db6 <HAL_SD_InitCard+0x16a>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 8008e7c:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
 8008e80:	e719      	b.n	8008cb6 <HAL_SD_InitCard+0x6a>
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
 8008e82:	f010 7f80 	tst.w	r0, #16777216	; 0x1000000
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 8008e86:	6820      	ldr	r0, [r4, #0]
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
 8008e88:	f43f af63 	beq.w	8008d52 <HAL_SD_InitCard+0x106>
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 8008e8c:	6803      	ldr	r3, [r0, #0]
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 8008e8e:	f44f 7200 	mov.w	r2, #512	; 0x200
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 8008e92:	f043 0308 	orr.w	r3, r3, #8
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 8008e96:	65e2      	str	r2, [r4, #92]	; 0x5c
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 8008e98:	6003      	str	r3, [r0, #0]
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
 8008e9a:	f003 fa8d 	bl	800c3b8 <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
 8008e9e:	4605      	mov	r5, r0
 8008ea0:	b128      	cbz	r0, 8008eae <HAL_SD_InitCard+0x262>
 8008ea2:	e708      	b.n	8008cb6 <HAL_SD_InitCard+0x6a>
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8008ea4:	f7fb fe9c 	bl	8004be0 <HAL_GetTick>
 8008ea8:	1b80      	subs	r0, r0, r6
 8008eaa:	3001      	adds	r0, #1
 8008eac:	d02b      	beq.n	8008f06 <HAL_SD_InitCard+0x2ba>
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
 8008eae:	6823      	ldr	r3, [r4, #0]
 8008eb0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8008eb2:	0150      	lsls	r0, r2, #5
 8008eb4:	d5f6      	bpl.n	8008ea4 <HAL_SD_InitCard+0x258>
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
 8008eb6:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8008eba:	639a      	str	r2, [r3, #56]	; 0x38
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
 8008ebc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008ebe:	02d9      	lsls	r1, r3, #11
 8008ec0:	f57f af34 	bpl.w	8008d2c <HAL_SD_InitCard+0xe0>
          HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 8008ec4:	2001      	movs	r0, #1
 8008ec6:	f000 fa25 	bl	8009314 <HAL_SDEx_DriveTransceiver_1_8V_Callback>
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
 8008eca:	6820      	ldr	r0, [r4, #0]
 8008ecc:	6803      	ldr	r3, [r0, #0]
 8008ece:	f043 0304 	orr.w	r3, r3, #4
 8008ed2:	6003      	str	r3, [r0, #0]
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
 8008ed4:	e005      	b.n	8008ee2 <HAL_SD_InitCard+0x296>
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8008ed6:	f7fb fe83 	bl	8004be0 <HAL_GetTick>
 8008eda:	1b80      	subs	r0, r0, r6
 8008edc:	3001      	adds	r0, #1
 8008ede:	d012      	beq.n	8008f06 <HAL_SD_InitCard+0x2ba>
 8008ee0:	6820      	ldr	r0, [r4, #0]
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
 8008ee2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008ee4:	019a      	lsls	r2, r3, #6
 8008ee6:	d5f6      	bpl.n	8008ed6 <HAL_SD_InitCard+0x28a>
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
 8008ee8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008eec:	6383      	str	r3, [r0, #56]	; 0x38
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
 8008eee:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008ef0:	02db      	lsls	r3, r3, #11
 8008ef2:	d4c3      	bmi.n	8008e7c <HAL_SD_InitCard+0x230>
          hsd->Instance->POWER = 0x13U;
 8008ef4:	2113      	movs	r1, #19
          hsd->Instance->ICR = 0xFFFFFFFFU;
 8008ef6:	f04f 32ff 	mov.w	r2, #4294967295
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 8008efa:	f44f 7300 	mov.w	r3, #512	; 0x200
          hsd->Instance->POWER = 0x13U;
 8008efe:	6001      	str	r1, [r0, #0]
          hsd->Instance->ICR = 0xFFFFFFFFU;
 8008f00:	6382      	str	r2, [r0, #56]	; 0x38
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 8008f02:	65e3      	str	r3, [r4, #92]	; 0x5c
  if(errorstate != HAL_SD_ERROR_NONE)
 8008f04:	e725      	b.n	8008d52 <HAL_SD_InitCard+0x106>
            return HAL_SD_ERROR_TIMEOUT;
 8008f06:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 8008f0a:	e6d4      	b.n	8008cb6 <HAL_SD_InitCard+0x6a>
 8008f0c:	c1100000 	.word	0xc1100000
 8008f10:	1fe00fff 	.word	0x1fe00fff

08008f14 <HAL_SD_GetCardStatus>:
{
 8008f14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008f18:	b096      	sub	sp, #88	; 0x58
 8008f1a:	4604      	mov	r4, r0
 8008f1c:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
 8008f1e:	f7fb fe5f 	bl	8004be0 <HAL_GetTick>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8008f22:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
 8008f24:	4606      	mov	r6, r0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8008f26:	6820      	ldr	r0, [r4, #0]
 8008f28:	f002 f8c4 	bl	800b0b4 <SDMMC_GetResponse>
 8008f2c:	0182      	lsls	r2, r0, #6
 8008f2e:	d45b      	bmi.n	8008fe8 <HAL_SD_GetCardStatus+0xd4>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 8008f30:	6820      	ldr	r0, [r4, #0]
 8008f32:	2140      	movs	r1, #64	; 0x40
 8008f34:	f002 f8d6 	bl	800b0e4 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008f38:	4603      	mov	r3, r0
 8008f3a:	b1e0      	cbz	r0, 8008f76 <HAL_SD_GetCardStatus+0x62>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 8008f3c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8008f3e:	63a2      	str	r2, [r4, #56]	; 0x38
  if(errorstate != HAL_SD_ERROR_NONE)
 8008f40:	6820      	ldr	r0, [r4, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8008f42:	4a59      	ldr	r2, [pc, #356]	; (80090a8 <HAL_SD_GetCardStatus+0x194>)
 8008f44:	6382      	str	r2, [r0, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 8008f46:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8008f48:	2101      	movs	r1, #1
    hsd->ErrorCode |= errorstate;
 8008f4a:	4313      	orrs	r3, r2
 8008f4c:	63a3      	str	r3, [r4, #56]	; 0x38
    status = HAL_ERROR;
 8008f4e:	460e      	mov	r6, r1
    hsd->State = HAL_SD_STATE_READY;
 8008f50:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8008f54:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008f58:	f002 f8c4 	bl	800b0e4 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008f5c:	b138      	cbz	r0, 8008f6e <HAL_SD_GetCardStatus+0x5a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8008f5e:	6823      	ldr	r3, [r4, #0]
 8008f60:	4a51      	ldr	r2, [pc, #324]	; (80090a8 <HAL_SD_GetCardStatus+0x194>)
 8008f62:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8008f64:	2301      	movs	r3, #1
    hsd->ErrorCode = errorstate;
 8008f66:	63a0      	str	r0, [r4, #56]	; 0x38
    status = HAL_ERROR;
 8008f68:	461e      	mov	r6, r3
    hsd->State = HAL_SD_STATE_READY;
 8008f6a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8008f6e:	4630      	mov	r0, r6
 8008f70:	b016      	add	sp, #88	; 0x58
 8008f72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8008f76:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8008f78:	6820      	ldr	r0, [r4, #0]
 8008f7a:	0409      	lsls	r1, r1, #16
 8008f7c:	f002 fdc4 	bl	800bb08 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008f80:	4603      	mov	r3, r0
 8008f82:	2800      	cmp	r0, #0
 8008f84:	d1da      	bne.n	8008f3c <HAL_SD_GetCardStatus+0x28>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8008f86:	f04f 32ff 	mov.w	r2, #4294967295
 8008f8a:	2340      	movs	r3, #64	; 0x40
 8008f8c:	e9cd 2300 	strd	r2, r3, [sp]
 8008f90:	2260      	movs	r2, #96	; 0x60
 8008f92:	2302      	movs	r3, #2
 8008f94:	e9cd 2302 	strd	r2, r3, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8008f98:	4669      	mov	r1, sp
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8008f9a:	2301      	movs	r3, #1
 8008f9c:	2200      	movs	r2, #0
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8008f9e:	6820      	ldr	r0, [r4, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8008fa0:	e9cd 2304 	strd	r2, r3, [sp, #16]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8008fa4:	f002 f88a 	bl	800b0bc <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
 8008fa8:	6820      	ldr	r0, [r4, #0]
 8008faa:	f003 f95d 	bl	800c268 <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008fae:	4603      	mov	r3, r0
 8008fb0:	2800      	cmp	r0, #0
 8008fb2:	d1c3      	bne.n	8008f3c <HAL_SD_GetCardStatus+0x28>
  uint32_t *pData = pSDstatus;
 8008fb4:	af06      	add	r7, sp, #24
 8008fb6:	e004      	b.n	8008fc2 <HAL_SD_GetCardStatus+0xae>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8008fb8:	f7fb fe12 	bl	8004be0 <HAL_GetTick>
 8008fbc:	1b80      	subs	r0, r0, r6
 8008fbe:	3001      	adds	r0, #1
 8008fc0:	d016      	beq.n	8008ff0 <HAL_SD_GetCardStatus+0xdc>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8008fc2:	6820      	ldr	r0, [r4, #0]
 8008fc4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008fc6:	f413 7f95 	tst.w	r3, #298	; 0x12a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 8008fca:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8008fcc:	d113      	bne.n	8008ff6 <HAL_SD_GetCardStatus+0xe2>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 8008fce:	041b      	lsls	r3, r3, #16
 8008fd0:	d5f2      	bpl.n	8008fb8 <HAL_SD_GetCardStatus+0xa4>
 8008fd2:	f107 0820 	add.w	r8, r7, #32
 8008fd6:	e000      	b.n	8008fda <HAL_SD_GetCardStatus+0xc6>
 8008fd8:	6820      	ldr	r0, [r4, #0]
        *pData = SDMMC_ReadFIFO(hsd->Instance);
 8008fda:	f002 f851 	bl	800b080 <SDMMC_ReadFIFO>
 8008fde:	f847 0b04 	str.w	r0, [r7], #4
      for(count = 0U; count < 8U; count++)
 8008fe2:	4547      	cmp	r7, r8
 8008fe4:	d1f8      	bne.n	8008fd8 <HAL_SD_GetCardStatus+0xc4>
 8008fe6:	e7e7      	b.n	8008fb8 <HAL_SD_GetCardStatus+0xa4>
  if(errorstate != HAL_SD_ERROR_NONE)
 8008fe8:	6820      	ldr	r0, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8008fea:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008fee:	e7a8      	b.n	8008f42 <HAL_SD_GetCardStatus+0x2e>
      return HAL_SD_ERROR_TIMEOUT;
 8008ff0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8008ff4:	e7a4      	b.n	8008f40 <HAL_SD_GetCardStatus+0x2c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8008ff6:	0719      	lsls	r1, r3, #28
 8008ff8:	d450      	bmi.n	800909c <HAL_SD_GetCardStatus+0x188>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8008ffa:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008ffc:	079a      	lsls	r2, r3, #30
 8008ffe:	d44f      	bmi.n	80090a0 <HAL_SD_GetCardStatus+0x18c>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8009000:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8009002:	069b      	lsls	r3, r3, #26
 8009004:	d50a      	bpl.n	800901c <HAL_SD_GetCardStatus+0x108>
 8009006:	e04d      	b.n	80090a4 <HAL_SD_GetCardStatus+0x190>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 8009008:	f002 f83a 	bl	800b080 <SDMMC_ReadFIFO>
 800900c:	f847 0b04 	str.w	r0, [r7], #4
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8009010:	f7fb fde6 	bl	8004be0 <HAL_GetTick>
 8009014:	1b80      	subs	r0, r0, r6
 8009016:	3001      	adds	r0, #1
 8009018:	d0ea      	beq.n	8008ff0 <HAL_SD_GetCardStatus+0xdc>
 800901a:	6820      	ldr	r0, [r4, #0]
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800901c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800901e:	f413 5c80 	ands.w	ip, r3, #4096	; 0x1000
 8009022:	d1f1      	bne.n	8009008 <HAL_SD_GetCardStatus+0xf4>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 8009024:	9906      	ldr	r1, [sp, #24]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 8009026:	f8dd e020 	ldr.w	lr, [sp, #32]
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800902a:	4b20      	ldr	r3, [pc, #128]	; (80090ac <HAL_SD_GetCardStatus+0x198>)
 800902c:	6383      	str	r3, [r0, #56]	; 0x38
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800902e:	0a0a      	lsrs	r2, r1, #8
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 8009030:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009032:	9f07      	ldr	r7, [sp, #28]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 8009034:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8009038:	ea42 6211 	orr.w	r2, r2, r1, lsr #24
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800903c:	f3c1 1881 	ubfx	r8, r1, #6, #2
  HAL_StatusTypeDef status = HAL_OK;
 8009040:	4666      	mov	r6, ip
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 8009042:	f3c1 1140 	ubfx	r1, r1, #5, #1
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 8009046:	ea4f 4c1e 	mov.w	ip, lr, lsr #16
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800904a:	f885 8000 	strb.w	r8, [r5]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800904e:	b292      	uxth	r2, r2
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 8009050:	7069      	strb	r1, [r5, #1]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 8009052:	ba3f      	rev	r7, r7
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 8009054:	f02c 0cff 	bic.w	ip, ip, #255	; 0xff
 8009058:	b2d9      	uxtb	r1, r3
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800905a:	806a      	strh	r2, [r5, #2]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800905c:	ea4c 0101 	orr.w	r1, ip, r1
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 8009060:	606f      	str	r7, [r5, #4]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 8009062:	fa5f fc8e 	uxtb.w	ip, lr
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 8009066:	f3ce 2707 	ubfx	r7, lr, #8, #8
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800906a:	f3ce 5203 	ubfx	r2, lr, #20, #4
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800906e:	f885 c008 	strb.w	ip, [r5, #8]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 8009072:	f3c3 2e85 	ubfx	lr, r3, #10, #6
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 8009076:	726f      	strb	r7, [r5, #9]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 8009078:	f3c3 2c01 	ubfx	ip, r3, #8, #2
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800907c:	72aa      	strb	r2, [r5, #10]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800907e:	f3c3 1703 	ubfx	r7, r3, #4, #4
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 8009082:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 8009086:	81a9      	strh	r1, [r5, #12]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 8009088:	f003 030f 	and.w	r3, r3, #15
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800908c:	f885 e00e 	strb.w	lr, [r5, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 8009090:	f885 c00f 	strb.w	ip, [r5, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 8009094:	742f      	strb	r7, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 8009096:	746b      	strb	r3, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 8009098:	74aa      	strb	r2, [r5, #18]
 800909a:	e75b      	b.n	8008f54 <HAL_SD_GetCardStatus+0x40>
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800909c:	2308      	movs	r3, #8
 800909e:	e750      	b.n	8008f42 <HAL_SD_GetCardStatus+0x2e>
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 80090a0:	2302      	movs	r3, #2
 80090a2:	e74e      	b.n	8008f42 <HAL_SD_GetCardStatus+0x2e>
    return HAL_SD_ERROR_RX_OVERRUN;
 80090a4:	2320      	movs	r3, #32
 80090a6:	e74c      	b.n	8008f42 <HAL_SD_GetCardStatus+0x2e>
 80090a8:	1fe00fff 	.word	0x1fe00fff
 80090ac:	18000f3a 	.word	0x18000f3a

080090b0 <HAL_SD_GetCardInfo>:
{
 80090b0:	b4f0      	push	{r4, r5, r6, r7}
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 80090b2:	e9d0 c70f 	ldrd	ip, r7, [r0, #60]	; 0x3c
 80090b6:	e9d0 6511 	ldrd	r6, r5, [r0, #68]	; 0x44
 80090ba:	e9d0 4213 	ldrd	r4, r2, [r0, #76]	; 0x4c
 80090be:	e9d0 3015 	ldrd	r3, r0, [r0, #84]	; 0x54
 80090c2:	e9c1 c700 	strd	ip, r7, [r1]
 80090c6:	e9c1 6502 	strd	r6, r5, [r1, #8]
 80090ca:	e9c1 4204 	strd	r4, r2, [r1, #16]
 80090ce:	61c8      	str	r0, [r1, #28]
}
 80090d0:	bcf0      	pop	{r4, r5, r6, r7}
 80090d2:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 80090d4:	618b      	str	r3, [r1, #24]
}
 80090d6:	4770      	bx	lr

080090d8 <HAL_SD_ConfigWideBusOperation>:
{
 80090d8:	b530      	push	{r4, r5, lr}
  if(hsd->SdCard.CardType != CARD_SECURED)
 80090da:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
  hsd->State = HAL_SD_STATE_BUSY;
 80090dc:	2203      	movs	r2, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
 80090de:	4293      	cmp	r3, r2
{
 80090e0:	b08b      	sub	sp, #44	; 0x2c
 80090e2:	4604      	mov	r4, r0
  hsd->State = HAL_SD_STATE_BUSY;
 80090e4:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
{
 80090e8:	460d      	mov	r5, r1
  if(hsd->SdCard.CardType != CARD_SECURED)
 80090ea:	d025      	beq.n	8009138 <HAL_SD_ConfigWideBusOperation+0x60>
    if(WideMode == SDMMC_BUS_WIDE_8B)
 80090ec:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80090f0:	d022      	beq.n	8009138 <HAL_SD_ConfigWideBusOperation+0x60>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 80090f2:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 80090f6:	d064      	beq.n	80091c2 <HAL_SD_ConfigWideBusOperation+0xea>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 80090f8:	2900      	cmp	r1, #0
 80090fa:	d043      	beq.n	8009184 <HAL_SD_ConfigWideBusOperation+0xac>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80090fc:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80090fe:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8009102:	6383      	str	r3, [r0, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 8009104:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009106:	b9f3      	cbnz	r3, 8009146 <HAL_SD_ConfigWideBusOperation+0x6e>
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 8009108:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800910c:	6963      	ldr	r3, [r4, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800910e:	6922      	ldr	r2, [r4, #16]
    Init.BusWide             = WideMode;
 8009110:	9506      	str	r5, [sp, #24]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 8009112:	2b02      	cmp	r3, #2
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 8009114:	e9cd 0104 	strd	r0, r1, [sp, #16]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8009118:	9207      	str	r2, [sp, #28]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800911a:	d92a      	bls.n	8009172 <HAL_SD_ConfigWideBusOperation+0x9a>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
 800911c:	9308      	str	r3, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
 800911e:	ab0a      	add	r3, sp, #40	; 0x28
 8009120:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 8009124:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8009128:	ab04      	add	r3, sp, #16
 800912a:	cb0e      	ldmia	r3, {r1, r2, r3}
 800912c:	6820      	ldr	r0, [r4, #0]
 800912e:	f001 ff8d 	bl	800b04c <SDMMC_Init>
  HAL_StatusTypeDef status = HAL_OK;
 8009132:	2500      	movs	r5, #0
 8009134:	6820      	ldr	r0, [r4, #0]
 8009136:	e00a      	b.n	800914e <HAL_SD_ConfigWideBusOperation+0x76>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8009138:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800913a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800913e:	63a3      	str	r3, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 8009140:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009142:	2b00      	cmp	r3, #0
 8009144:	d0e0      	beq.n	8009108 <HAL_SD_ConfigWideBusOperation+0x30>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8009146:	6820      	ldr	r0, [r4, #0]
 8009148:	4b35      	ldr	r3, [pc, #212]	; (8009220 <HAL_SD_ConfigWideBusOperation+0x148>)
 800914a:	6383      	str	r3, [r0, #56]	; 0x38
    status = HAL_ERROR;
 800914c:	2501      	movs	r5, #1
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800914e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8009152:	f001 ffc7 	bl	800b0e4 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8009156:	b130      	cbz	r0, 8009166 <HAL_SD_ConfigWideBusOperation+0x8e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8009158:	6823      	ldr	r3, [r4, #0]
 800915a:	4a31      	ldr	r2, [pc, #196]	; (8009220 <HAL_SD_ConfigWideBusOperation+0x148>)
 800915c:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800915e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009160:	4318      	orrs	r0, r3
 8009162:	63a0      	str	r0, [r4, #56]	; 0x38
    status = HAL_ERROR;
 8009164:	2501      	movs	r5, #1
  hsd->State = HAL_SD_STATE_READY;
 8009166:	2301      	movs	r3, #1
}
 8009168:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
 800916a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800916e:	b00b      	add	sp, #44	; 0x2c
 8009170:	bd30      	pop	{r4, r5, pc}
    else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
 8009172:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8009174:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8009178:	d0d0      	beq.n	800911c <HAL_SD_ConfigWideBusOperation+0x44>
    else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800917a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800917e:	d040      	beq.n	8009202 <HAL_SD_ConfigWideBusOperation+0x12a>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
 8009180:	2303      	movs	r3, #3
 8009182:	e7cb      	b.n	800911c <HAL_SD_ConfigWideBusOperation+0x44>
  uint32_t scr[2U] = {0U, 0U};
 8009184:	2200      	movs	r2, #0
 8009186:	2300      	movs	r3, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8009188:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0U, 0U};
 800918a:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800918e:	f001 ff91 	bl	800b0b4 <SDMMC_GetResponse>
 8009192:	0182      	lsls	r2, r0, #6
 8009194:	d438      	bmi.n	8009208 <HAL_SD_ConfigWideBusOperation+0x130>
  errorstate = SD_FindSCR(hsd, scr);
 8009196:	a904      	add	r1, sp, #16
 8009198:	4620      	mov	r0, r4
 800919a:	f7ff f9e3 	bl	8008564 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800919e:	b960      	cbnz	r0, 80091ba <HAL_SD_ConfigWideBusOperation+0xe2>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 80091a0:	9b05      	ldr	r3, [sp, #20]
 80091a2:	03db      	lsls	r3, r3, #15
 80091a4:	d536      	bpl.n	8009214 <HAL_SD_ConfigWideBusOperation+0x13c>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80091a6:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80091a8:	6820      	ldr	r0, [r4, #0]
 80091aa:	0409      	lsls	r1, r1, #16
 80091ac:	f002 fcac 	bl	800bb08 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 80091b0:	b918      	cbnz	r0, 80091ba <HAL_SD_ConfigWideBusOperation+0xe2>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 80091b2:	4601      	mov	r1, r0
 80091b4:	6820      	ldr	r0, [r4, #0]
 80091b6:	f002 fd89 	bl	800bccc <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
 80091ba:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80091bc:	4308      	orrs	r0, r1
 80091be:	63a0      	str	r0, [r4, #56]	; 0x38
 80091c0:	e7be      	b.n	8009140 <HAL_SD_ConfigWideBusOperation+0x68>
  uint32_t scr[2U] = {0U, 0U};
 80091c2:	2200      	movs	r2, #0
 80091c4:	2300      	movs	r3, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 80091c6:	6800      	ldr	r0, [r0, #0]
 80091c8:	2100      	movs	r1, #0
  uint32_t scr[2U] = {0U, 0U};
 80091ca:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 80091ce:	f001 ff71 	bl	800b0b4 <SDMMC_GetResponse>
 80091d2:	0180      	lsls	r0, r0, #6
 80091d4:	d41b      	bmi.n	800920e <HAL_SD_ConfigWideBusOperation+0x136>
  errorstate = SD_FindSCR(hsd, scr);
 80091d6:	a904      	add	r1, sp, #16
 80091d8:	4620      	mov	r0, r4
 80091da:	f7ff f9c3 	bl	8008564 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 80091de:	b960      	cbnz	r0, 80091fa <HAL_SD_ConfigWideBusOperation+0x122>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 80091e0:	9b05      	ldr	r3, [sp, #20]
 80091e2:	0359      	lsls	r1, r3, #13
 80091e4:	d519      	bpl.n	800921a <HAL_SD_ConfigWideBusOperation+0x142>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80091e6:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80091e8:	6820      	ldr	r0, [r4, #0]
 80091ea:	0409      	lsls	r1, r1, #16
 80091ec:	f002 fc8c 	bl	800bb08 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 80091f0:	b918      	cbnz	r0, 80091fa <HAL_SD_ConfigWideBusOperation+0x122>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 80091f2:	6820      	ldr	r0, [r4, #0]
 80091f4:	2102      	movs	r1, #2
 80091f6:	f002 fd69 	bl	800bccc <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
 80091fa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80091fc:	4318      	orrs	r0, r3
 80091fe:	63a0      	str	r0, [r4, #56]	; 0x38
 8009200:	e79e      	b.n	8009140 <HAL_SD_ConfigWideBusOperation+0x68>
      Init.ClockDiv = SDMMC_HSpeed_CLK_DIV;
 8009202:	2302      	movs	r3, #2
 8009204:	9308      	str	r3, [sp, #32]
 8009206:	e78a      	b.n	800911e <HAL_SD_ConfigWideBusOperation+0x46>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8009208:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800920c:	e7d5      	b.n	80091ba <HAL_SD_ConfigWideBusOperation+0xe2>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800920e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8009212:	e7f2      	b.n	80091fa <HAL_SD_ConfigWideBusOperation+0x122>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8009214:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8009218:	e7cf      	b.n	80091ba <HAL_SD_ConfigWideBusOperation+0xe2>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800921a:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800921e:	e7ec      	b.n	80091fa <HAL_SD_ConfigWideBusOperation+0x122>
 8009220:	1fe00fff 	.word	0x1fe00fff

08009224 <HAL_SD_Init>:
{
 8009224:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009226:	b087      	sub	sp, #28
  if(hsd == NULL)
 8009228:	b168      	cbz	r0, 8009246 <HAL_SD_Init+0x22>
  if(hsd->State == HAL_SD_STATE_RESET)
 800922a:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800922e:	4604      	mov	r4, r0
 8009230:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8009234:	2b00      	cmp	r3, #0
 8009236:	d03e      	beq.n	80092b6 <HAL_SD_Init+0x92>
  hsd->State = HAL_SD_STATE_BUSY;
 8009238:	2303      	movs	r3, #3
 800923a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800923e:	4620      	mov	r0, r4
 8009240:	f7ff fd04 	bl	8008c4c <HAL_SD_InitCard>
 8009244:	b118      	cbz	r0, 800924e <HAL_SD_Init+0x2a>
    return HAL_ERROR;
 8009246:	2601      	movs	r6, #1
}
 8009248:	4630      	mov	r0, r6
 800924a:	b007      	add	sp, #28
 800924c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
 800924e:	a901      	add	r1, sp, #4
 8009250:	4620      	mov	r0, r4
 8009252:	f7ff fe5f 	bl	8008f14 <HAL_SD_GetCardStatus>
 8009256:	2800      	cmp	r0, #0
 8009258:	d1f5      	bne.n	8009246 <HAL_SD_Init+0x22>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800925a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  speedgrade = CardStatus.UhsSpeedGrade;
 800925c:	f89d 2014 	ldrb.w	r2, [sp, #20]
  unitsize = CardStatus.UhsAllocationUnitSize;
 8009260:	f89d 3015 	ldrb.w	r3, [sp, #21]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 8009264:	2901      	cmp	r1, #1
  speedgrade = CardStatus.UhsSpeedGrade;
 8009266:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
 8009268:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800926a:	d036      	beq.n	80092da <HAL_SD_Init+0xb6>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
 800926c:	65e0      	str	r0, [r4, #92]	; 0x5c
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
 800926e:	68e1      	ldr	r1, [r4, #12]
 8009270:	4620      	mov	r0, r4
 8009272:	f7ff ff31 	bl	80090d8 <HAL_SD_ConfigWideBusOperation>
 8009276:	4606      	mov	r6, r0
 8009278:	2800      	cmp	r0, #0
 800927a:	d1e4      	bne.n	8009246 <HAL_SD_Init+0x22>
  tickstart = HAL_GetTick();
 800927c:	f7fb fcb0 	bl	8004be0 <HAL_GetTick>
 8009280:	4607      	mov	r7, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 8009282:	e00b      	b.n	800929c <HAL_SD_Init+0x78>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8009284:	6820      	ldr	r0, [r4, #0]
 8009286:	f001 ff15 	bl	800b0b4 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 800928a:	f3c0 2043 	ubfx	r0, r0, #9, #4
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800928e:	2804      	cmp	r0, #4
 8009290:	d015      	beq.n	80092be <HAL_SD_Init+0x9a>
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
 8009292:	f7fb fca5 	bl	8004be0 <HAL_GetTick>
 8009296:	1bc3      	subs	r3, r0, r7
 8009298:	3301      	adds	r3, #1
 800929a:	d016      	beq.n	80092ca <HAL_SD_Init+0xa6>
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800929c:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800929e:	6820      	ldr	r0, [r4, #0]
 80092a0:	0409      	lsls	r1, r1, #16
 80092a2:	f002 ff39 	bl	800c118 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 80092a6:	4605      	mov	r5, r0
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80092a8:	4601      	mov	r1, r0
  if(errorstate != HAL_SD_ERROR_NONE)
 80092aa:	2800      	cmp	r0, #0
 80092ac:	d0ea      	beq.n	8009284 <HAL_SD_Init+0x60>
    hsd->ErrorCode |= errorstate;
 80092ae:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80092b0:	4305      	orrs	r5, r0
 80092b2:	63a5      	str	r5, [r4, #56]	; 0x38
  return (HAL_SD_CardStateTypeDef)cardstate;
 80092b4:	e7ed      	b.n	8009292 <HAL_SD_Init+0x6e>
    hsd->Lock = HAL_UNLOCKED;
 80092b6:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
 80092b8:	f7ff f9c2 	bl	8008640 <HAL_SD_MspInit>
 80092bc:	e7bc      	b.n	8009238 <HAL_SD_Init+0x14>
  hsd->State = HAL_SD_STATE_READY;
 80092be:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 80092c0:	63a5      	str	r5, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 80092c2:	6325      	str	r5, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 80092c4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 80092c8:	e7be      	b.n	8009248 <HAL_SD_Init+0x24>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 80092ca:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
      hsd->State= HAL_SD_STATE_READY;
 80092ce:	2301      	movs	r3, #1
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 80092d0:	63a2      	str	r2, [r4, #56]	; 0x38
      return HAL_TIMEOUT;
 80092d2:	2603      	movs	r6, #3
      hsd->State= HAL_SD_STATE_READY;
 80092d4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
 80092d8:	e7b6      	b.n	8009248 <HAL_SD_Init+0x24>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 80092da:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 80092dc:	bf14      	ite	ne
 80092de:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
 80092e2:	f44f 7380 	moveq.w	r3, #256	; 0x100
 80092e6:	65e3      	str	r3, [r4, #92]	; 0x5c
 80092e8:	e7c1      	b.n	800926e <HAL_SD_Init+0x4a>
 80092ea:	bf00      	nop

080092ec <HAL_SD_GetCardState>:
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80092ec:	6c81      	ldr	r1, [r0, #72]	; 0x48
{
 80092ee:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80092f0:	0409      	lsls	r1, r1, #16
{
 80092f2:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80092f4:	6800      	ldr	r0, [r0, #0]
 80092f6:	f002 ff0f 	bl	800c118 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 80092fa:	b120      	cbz	r0, 8009306 <HAL_SD_GetCardState+0x1a>
    hsd->ErrorCode |= errorstate;
 80092fc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80092fe:	4308      	orrs	r0, r1
 8009300:	63a0      	str	r0, [r4, #56]	; 0x38
 8009302:	2000      	movs	r0, #0
}
 8009304:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8009306:	4601      	mov	r1, r0
 8009308:	6820      	ldr	r0, [r4, #0]
 800930a:	f001 fed3 	bl	800b0b4 <SDMMC_GetResponse>
  if(errorstate != HAL_SD_ERROR_NONE)
 800930e:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 8009312:	bd10      	pop	{r4, pc}

08009314 <HAL_SDEx_DriveTransceiver_1_8V_Callback>:
  UNUSED(status);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_EnableTransciver could be implemented in the user file
   */
}
 8009314:	4770      	bx	lr
 8009316:	bf00      	nop

08009318 <HAL_SDEx_Read_DMADoubleBuffer0CpltCallback>:
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SDEx_Read_DMADoubleBuffer0CpltCallback can be implemented in the user file
   */
}
 8009318:	4770      	bx	lr
 800931a:	bf00      	nop

0800931c <HAL_SDEx_Read_DMADoubleBuffer1CpltCallback>:
 800931c:	4770      	bx	lr
 800931e:	bf00      	nop

08009320 <HAL_SDEx_Write_DMADoubleBuffer0CpltCallback>:
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop

08009324 <HAL_SDEx_Write_DMADoubleBuffer1CpltCallback>:
 8009324:	4770      	bx	lr
 8009326:	bf00      	nop

08009328 <HAL_SPI_MspInit>:
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_MspInit should be implemented in the user file
   */
}
 8009328:	4770      	bx	lr
 800932a:	bf00      	nop

0800932c <SPI_DMAHalfReceiveCplt>:
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 800932c:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* Call user Rx half complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->RxHalfCpltCallback(hspi);
 800932e:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8009330:	4718      	bx	r3
 8009332:	bf00      	nop

08009334 <SPI_DMAHalfTransmitReceiveCplt>:
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8009334:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* Call user TxRx half complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->TxRxHalfCpltCallback(hspi);
 8009336:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8009338:	4718      	bx	r3
 800933a:	bf00      	nop

0800933c <SPI_DMAError>:
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 800933c:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800933e:	6802      	ldr	r2, [r0, #0]

  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
  hspi->State = HAL_SPI_STATE_READY;
  /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->ErrorCallback(hspi);
 8009340:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8009342:	6853      	ldr	r3, [r2, #4]
 8009344:	f023 0303 	bic.w	r3, r3, #3
{
 8009348:	b410      	push	{r4}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800934a:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 800934c:	6e03      	ldr	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 800934e:	2401      	movs	r4, #1
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8009350:	f043 0310 	orr.w	r3, r3, #16
 8009354:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8009356:	f880 405d 	strb.w	r4, [r0, #93]	; 0x5d
#else
  HAL_SPI_ErrorCallback(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 800935a:	f85d 4b04 	ldr.w	r4, [sp], #4
  hspi->ErrorCallback(hspi);
 800935e:	4708      	bx	r1

08009360 <HAL_SPI_AbortCpltCallback>:
 8009360:	4770      	bx	lr
 8009362:	bf00      	nop

08009364 <HAL_SPI_TxCpltCallback>:
 8009364:	4770      	bx	lr
 8009366:	bf00      	nop

08009368 <HAL_SPI_RxCpltCallback>:
 8009368:	4770      	bx	lr
 800936a:	bf00      	nop

0800936c <HAL_SPI_TxRxCpltCallback>:
 800936c:	4770      	bx	lr
 800936e:	bf00      	nop

08009370 <HAL_SPI_TxHalfCpltCallback>:
 8009370:	4770      	bx	lr
 8009372:	bf00      	nop

08009374 <HAL_SPI_RxHalfCpltCallback>:
 8009374:	4770      	bx	lr
 8009376:	bf00      	nop

08009378 <HAL_SPI_TxRxHalfCpltCallback>:
 8009378:	4770      	bx	lr
 800937a:	bf00      	nop

0800937c <HAL_SPI_ErrorCallback>:
 800937c:	4770      	bx	lr
 800937e:	bf00      	nop

08009380 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8009380:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009382:	4605      	mov	r5, r0
 8009384:	460e      	mov	r6, r1
 8009386:	4617      	mov	r7, r2
 8009388:	1c71      	adds	r1, r6, #1
  while ((hspi->Instance->SR & Fifo) != State)
 800938a:	682c      	ldr	r4, [r5, #0]
 800938c:	d110      	bne.n	80093b0 <SPI_EndRxTxTransaction+0x30>
 800938e:	68a3      	ldr	r3, [r4, #8]
 8009390:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
 8009394:	d1fb      	bne.n	800938e <SPI_EndRxTxTransaction+0xe>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8009396:	68a3      	ldr	r3, [r4, #8]
 8009398:	061a      	lsls	r2, r3, #24
 800939a:	d4fc      	bmi.n	8009396 <SPI_EndRxTxTransaction+0x16>
  while ((hspi->Instance->SR & Fifo) != State)
 800939c:	68a0      	ldr	r0, [r4, #8]
 800939e:	f410 60c0 	ands.w	r0, r0, #1536	; 0x600
 80093a2:	d004      	beq.n	80093ae <SPI_EndRxTxTransaction+0x2e>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 80093a4:	7b23      	ldrb	r3, [r4, #12]
  while ((hspi->Instance->SR & Fifo) != State)
 80093a6:	68a0      	ldr	r0, [r4, #8]
 80093a8:	f410 60c0 	ands.w	r0, r0, #1536	; 0x600
 80093ac:	d1fa      	bne.n	80093a4 <SPI_EndRxTxTransaction+0x24>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
}
 80093ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while ((hspi->Instance->SR & Fifo) != State)
 80093b0:	68a3      	ldr	r3, [r4, #8]
 80093b2:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
 80093b6:	d02b      	beq.n	8009410 <SPI_EndRxTxTransaction+0x90>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 80093b8:	f7fb fc12 	bl	8004be0 <HAL_GetTick>
 80093bc:	1bc0      	subs	r0, r0, r7
 80093be:	4286      	cmp	r6, r0
 80093c0:	d8e2      	bhi.n	8009388 <SPI_EndRxTxTransaction+0x8>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80093c2:	e9d5 3100 	ldrd	r3, r1, [r5]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80093c6:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80093c8:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80093cc:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80093d0:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80093d2:	d02e      	beq.n	8009432 <SPI_EndRxTxTransaction+0xb2>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80093d4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80093d6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80093da:	d107      	bne.n	80093ec <SPI_EndRxTxTransaction+0x6c>
          SPI_RESET_CRC(hspi);
 80093dc:	681a      	ldr	r2, [r3, #0]
 80093de:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80093e2:	601a      	str	r2, [r3, #0]
 80093e4:	681a      	ldr	r2, [r3, #0]
 80093e6:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80093ea:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 80093ec:	2301      	movs	r3, #1
 80093ee:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80093f2:	6e2b      	ldr	r3, [r5, #96]	; 0x60
        __HAL_UNLOCK(hspi);
 80093f4:	2200      	movs	r2, #0
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80093f6:	f043 0320 	orr.w	r3, r3, #32
        __HAL_UNLOCK(hspi);
 80093fa:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80093fe:	662b      	str	r3, [r5, #96]	; 0x60
    return HAL_TIMEOUT;
 8009400:	2003      	movs	r0, #3
}
 8009402:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8009404:	f7fb fbec 	bl	8004be0 <HAL_GetTick>
 8009408:	1bc0      	subs	r0, r0, r7
 800940a:	4286      	cmp	r6, r0
 800940c:	d9d9      	bls.n	80093c2 <SPI_EndRxTxTransaction+0x42>
 800940e:	682c      	ldr	r4, [r5, #0]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8009410:	68a3      	ldr	r3, [r4, #8]
 8009412:	061b      	lsls	r3, r3, #24
 8009414:	d4f6      	bmi.n	8009404 <SPI_EndRxTxTransaction+0x84>
 8009416:	e006      	b.n	8009426 <SPI_EndRxTxTransaction+0xa6>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8009418:	7b23      	ldrb	r3, [r4, #12]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 800941a:	f7fb fbe1 	bl	8004be0 <HAL_GetTick>
 800941e:	1bc0      	subs	r0, r0, r7
 8009420:	4286      	cmp	r6, r0
 8009422:	d9ce      	bls.n	80093c2 <SPI_EndRxTxTransaction+0x42>
 8009424:	682c      	ldr	r4, [r5, #0]
  while ((hspi->Instance->SR & Fifo) != State)
 8009426:	68a3      	ldr	r3, [r4, #8]
 8009428:	f413 63c0 	ands.w	r3, r3, #1536	; 0x600
 800942c:	d1f4      	bne.n	8009418 <SPI_EndRxTxTransaction+0x98>
  return HAL_OK;
 800942e:	4618      	mov	r0, r3
}
 8009430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009432:	68aa      	ldr	r2, [r5, #8]
 8009434:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8009438:	d002      	beq.n	8009440 <SPI_EndRxTxTransaction+0xc0>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800943a:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800943e:	d1c9      	bne.n	80093d4 <SPI_EndRxTxTransaction+0x54>
          __HAL_SPI_DISABLE(hspi);
 8009440:	681a      	ldr	r2, [r3, #0]
 8009442:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009446:	601a      	str	r2, [r3, #0]
 8009448:	e7c4      	b.n	80093d4 <SPI_EndRxTxTransaction+0x54>
 800944a:	bf00      	nop

0800944c <SPI_EndRxTxTransaction.constprop.0>:
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
 800944c:	b538      	push	{r3, r4, r5, lr}
 800944e:	4604      	mov	r4, r0
 8009450:	460d      	mov	r5, r1
 8009452:	e004      	b.n	800945e <SPI_EndRxTxTransaction.constprop.0+0x12>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8009454:	f7fb fbc4 	bl	8004be0 <HAL_GetTick>
 8009458:	1b40      	subs	r0, r0, r5
 800945a:	2863      	cmp	r0, #99	; 0x63
 800945c:	d81b      	bhi.n	8009496 <SPI_EndRxTxTransaction.constprop.0+0x4a>
  while ((hspi->Instance->SR & Fifo) != State)
 800945e:	6823      	ldr	r3, [r4, #0]
 8009460:	689a      	ldr	r2, [r3, #8]
 8009462:	f412 5fc0 	tst.w	r2, #6144	; 0x1800
 8009466:	d1f5      	bne.n	8009454 <SPI_EndRxTxTransaction.constprop.0+0x8>
 8009468:	e005      	b.n	8009476 <SPI_EndRxTxTransaction.constprop.0+0x2a>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 800946a:	f7fb fbb9 	bl	8004be0 <HAL_GetTick>
 800946e:	1b40      	subs	r0, r0, r5
 8009470:	2863      	cmp	r0, #99	; 0x63
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8009472:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8009474:	d810      	bhi.n	8009498 <SPI_EndRxTxTransaction.constprop.0+0x4c>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8009476:	689a      	ldr	r2, [r3, #8]
 8009478:	0612      	lsls	r2, r2, #24
 800947a:	d4f6      	bmi.n	800946a <SPI_EndRxTxTransaction.constprop.0+0x1e>
 800947c:	e006      	b.n	800948c <SPI_EndRxTxTransaction.constprop.0+0x40>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 800947e:	7b1b      	ldrb	r3, [r3, #12]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8009480:	f7fb fbae 	bl	8004be0 <HAL_GetTick>
 8009484:	1b40      	subs	r0, r0, r5
 8009486:	2863      	cmp	r0, #99	; 0x63
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8009488:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 800948a:	d805      	bhi.n	8009498 <SPI_EndRxTxTransaction.constprop.0+0x4c>
  while ((hspi->Instance->SR & Fifo) != State)
 800948c:	6898      	ldr	r0, [r3, #8]
 800948e:	f410 60c0 	ands.w	r0, r0, #1536	; 0x600
 8009492:	d1f4      	bne.n	800947e <SPI_EndRxTxTransaction.constprop.0+0x32>
}
 8009494:	bd38      	pop	{r3, r4, r5, pc}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8009496:	6823      	ldr	r3, [r4, #0]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009498:	6861      	ldr	r1, [r4, #4]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800949a:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800949c:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80094a0:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80094a4:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80094a6:	d017      	beq.n	80094d8 <SPI_EndRxTxTransaction.constprop.0+0x8c>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80094a8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80094aa:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80094ae:	d107      	bne.n	80094c0 <SPI_EndRxTxTransaction.constprop.0+0x74>
          SPI_RESET_CRC(hspi);
 80094b0:	681a      	ldr	r2, [r3, #0]
 80094b2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80094b6:	601a      	str	r2, [r3, #0]
 80094b8:	681a      	ldr	r2, [r3, #0]
 80094ba:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80094be:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 80094c0:	2301      	movs	r3, #1
 80094c2:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80094c6:	6e23      	ldr	r3, [r4, #96]	; 0x60
        __HAL_UNLOCK(hspi);
 80094c8:	2200      	movs	r2, #0
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80094ca:	f043 0320 	orr.w	r3, r3, #32
        __HAL_UNLOCK(hspi);
 80094ce:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80094d2:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80094d4:	2003      	movs	r0, #3
}
 80094d6:	bd38      	pop	{r3, r4, r5, pc}
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80094d8:	68a2      	ldr	r2, [r4, #8]
 80094da:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80094de:	d002      	beq.n	80094e6 <SPI_EndRxTxTransaction.constprop.0+0x9a>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80094e0:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80094e4:	d1e0      	bne.n	80094a8 <SPI_EndRxTxTransaction.constprop.0+0x5c>
          __HAL_SPI_DISABLE(hspi);
 80094e6:	681a      	ldr	r2, [r3, #0]
 80094e8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80094ec:	601a      	str	r2, [r3, #0]
 80094ee:	e7db      	b.n	80094a8 <SPI_EndRxTxTransaction.constprop.0+0x5c>

080094f0 <SPI_DMATransmitReceiveCplt>:
{
 80094f0:	b570      	push	{r4, r5, r6, lr}
 80094f2:	4605      	mov	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 80094f4:	6a84      	ldr	r4, [r0, #40]	; 0x28
  tickstart = HAL_GetTick();
 80094f6:	f7fb fb73 	bl	8004be0 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80094fa:	682b      	ldr	r3, [r5, #0]
 80094fc:	681b      	ldr	r3, [r3, #0]
 80094fe:	069b      	lsls	r3, r3, #26
 8009500:	d504      	bpl.n	800950c <SPI_DMATransmitReceiveCplt+0x1c>
  hspi->TxRxCpltCallback(hspi);
 8009502:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009504:	4620      	mov	r0, r4
}
 8009506:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  hspi->TxRxCpltCallback(hspi);
 800950a:	4718      	bx	r3
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800950c:	6822      	ldr	r2, [r4, #0]
 800950e:	6853      	ldr	r3, [r2, #4]
 8009510:	f023 0320 	bic.w	r3, r3, #32
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8009514:	4601      	mov	r1, r0
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8009516:	6053      	str	r3, [r2, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8009518:	4620      	mov	r0, r4
 800951a:	f7ff ff97 	bl	800944c <SPI_EndRxTxTransaction.constprop.0>
 800951e:	b118      	cbz	r0, 8009528 <SPI_DMATransmitReceiveCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8009520:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8009522:	f043 0320 	orr.w	r3, r3, #32
 8009526:	6623      	str	r3, [r4, #96]	; 0x60
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8009528:	6821      	ldr	r1, [r4, #0]
 800952a:	684b      	ldr	r3, [r1, #4]
    hspi->TxXferCount = 0U;
 800952c:	2200      	movs	r2, #0
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800952e:	f023 0303 	bic.w	r3, r3, #3
    hspi->State = HAL_SPI_STATE_READY;
 8009532:	2001      	movs	r0, #1
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8009534:	604b      	str	r3, [r1, #4]
    hspi->TxXferCount = 0U;
 8009536:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0U;
 8009538:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
 800953c:	f884 005d 	strb.w	r0, [r4, #93]	; 0x5d
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8009540:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8009542:	2b00      	cmp	r3, #0
 8009544:	d0dd      	beq.n	8009502 <SPI_DMATransmitReceiveCplt+0x12>
      hspi->ErrorCallback(hspi);
 8009546:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8009548:	4620      	mov	r0, r4
}
 800954a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      hspi->ErrorCallback(hspi);
 800954e:	4718      	bx	r3

08009550 <SPI_EndRxTransaction.constprop.0>:
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
 8009550:	b538      	push	{r3, r4, r5, lr}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009552:	6843      	ldr	r3, [r0, #4]
 8009554:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
 8009558:	4604      	mov	r4, r0
 800955a:	460d      	mov	r5, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800955c:	d03a      	beq.n	80095d4 <SPI_EndRxTransaction.constprop.0+0x84>
 800955e:	6823      	ldr	r3, [r4, #0]
 8009560:	e005      	b.n	800956e <SPI_EndRxTransaction.constprop.0+0x1e>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8009562:	f7fb fb3d 	bl	8004be0 <HAL_GetTick>
 8009566:	1b40      	subs	r0, r0, r5
 8009568:	2863      	cmp	r0, #99	; 0x63
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800956a:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 800956c:	d81a      	bhi.n	80095a4 <SPI_EndRxTransaction.constprop.0+0x54>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800956e:	689a      	ldr	r2, [r3, #8]
 8009570:	0612      	lsls	r2, r2, #24
 8009572:	d4f6      	bmi.n	8009562 <SPI_EndRxTransaction.constprop.0+0x12>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009574:	6862      	ldr	r2, [r4, #4]
 8009576:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 800957a:	d001      	beq.n	8009580 <SPI_EndRxTransaction.constprop.0+0x30>
  return HAL_OK;
 800957c:	2000      	movs	r0, #0
}
 800957e:	bd38      	pop	{r3, r4, r5, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009580:	68a2      	ldr	r2, [r4, #8]
 8009582:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8009586:	d002      	beq.n	800958e <SPI_EndRxTransaction.constprop.0+0x3e>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8009588:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800958c:	d1f6      	bne.n	800957c <SPI_EndRxTransaction.constprop.0+0x2c>
  while ((hspi->Instance->SR & Fifo) != State)
 800958e:	689a      	ldr	r2, [r3, #8]
 8009590:	f412 6fc0 	tst.w	r2, #1536	; 0x600
 8009594:	d0f2      	beq.n	800957c <SPI_EndRxTransaction.constprop.0+0x2c>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8009596:	7b1b      	ldrb	r3, [r3, #12]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8009598:	f7fb fb22 	bl	8004be0 <HAL_GetTick>
 800959c:	1b40      	subs	r0, r0, r5
 800959e:	2863      	cmp	r0, #99	; 0x63
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80095a0:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 80095a2:	d9f4      	bls.n	800958e <SPI_EndRxTransaction.constprop.0+0x3e>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80095a4:	6861      	ldr	r1, [r4, #4]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80095a6:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80095a8:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80095ac:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80095b0:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80095b2:	d025      	beq.n	8009600 <SPI_EndRxTransaction.constprop.0+0xb0>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80095b4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80095b6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80095ba:	d018      	beq.n	80095ee <SPI_EndRxTransaction.constprop.0+0x9e>
        hspi->State = HAL_SPI_STATE_READY;
 80095bc:	2301      	movs	r3, #1
 80095be:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80095c2:	6e23      	ldr	r3, [r4, #96]	; 0x60
        __HAL_UNLOCK(hspi);
 80095c4:	2200      	movs	r2, #0
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80095c6:	f043 0320 	orr.w	r3, r3, #32
        __HAL_UNLOCK(hspi);
 80095ca:	f884 205c 	strb.w	r2, [r4, #92]	; 0x5c
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80095ce:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80095d0:	2003      	movs	r0, #3
}
 80095d2:	bd38      	pop	{r3, r4, r5, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80095d4:	6883      	ldr	r3, [r0, #8]
 80095d6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80095da:	d002      	beq.n	80095e2 <SPI_EndRxTransaction.constprop.0+0x92>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80095dc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80095e0:	d1bd      	bne.n	800955e <SPI_EndRxTransaction.constprop.0+0xe>
    __HAL_SPI_DISABLE(hspi);
 80095e2:	6823      	ldr	r3, [r4, #0]
 80095e4:	681a      	ldr	r2, [r3, #0]
 80095e6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80095ea:	601a      	str	r2, [r3, #0]
 80095ec:	e7bf      	b.n	800956e <SPI_EndRxTransaction.constprop.0+0x1e>
          SPI_RESET_CRC(hspi);
 80095ee:	681a      	ldr	r2, [r3, #0]
 80095f0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80095f4:	601a      	str	r2, [r3, #0]
 80095f6:	681a      	ldr	r2, [r3, #0]
 80095f8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80095fc:	601a      	str	r2, [r3, #0]
 80095fe:	e7dd      	b.n	80095bc <SPI_EndRxTransaction.constprop.0+0x6c>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8009600:	68a2      	ldr	r2, [r4, #8]
 8009602:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8009606:	d002      	beq.n	800960e <SPI_EndRxTransaction.constprop.0+0xbe>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8009608:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800960c:	d1d2      	bne.n	80095b4 <SPI_EndRxTransaction.constprop.0+0x64>
          __HAL_SPI_DISABLE(hspi);
 800960e:	681a      	ldr	r2, [r3, #0]
 8009610:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009614:	601a      	str	r2, [r3, #0]
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8009616:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009618:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800961c:	d1ce      	bne.n	80095bc <SPI_EndRxTransaction.constprop.0+0x6c>
 800961e:	e7e6      	b.n	80095ee <SPI_EndRxTransaction.constprop.0+0x9e>

08009620 <SPI_DMAReceiveCplt>:
{
 8009620:	b570      	push	{r4, r5, r6, lr}
 8009622:	4604      	mov	r4, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8009624:	6a85      	ldr	r5, [r0, #40]	; 0x28
  tickstart = HAL_GetTick();
 8009626:	f7fb fadb 	bl	8004be0 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800962a:	6823      	ldr	r3, [r4, #0]
 800962c:	681b      	ldr	r3, [r3, #0]
 800962e:	069b      	lsls	r3, r3, #26
 8009630:	d504      	bpl.n	800963c <SPI_DMAReceiveCplt+0x1c>
  hspi->RxCpltCallback(hspi);
 8009632:	6eab      	ldr	r3, [r5, #104]	; 0x68
 8009634:	4628      	mov	r0, r5
}
 8009636:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  hspi->RxCpltCallback(hspi);
 800963a:	4718      	bx	r3
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800963c:	682b      	ldr	r3, [r5, #0]
 800963e:	685a      	ldr	r2, [r3, #4]
 8009640:	f022 0220 	bic.w	r2, r2, #32
 8009644:	605a      	str	r2, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8009646:	685a      	ldr	r2, [r3, #4]
 8009648:	f022 0203 	bic.w	r2, r2, #3
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800964c:	4601      	mov	r1, r0
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800964e:	605a      	str	r2, [r3, #4]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8009650:	4628      	mov	r0, r5
 8009652:	f7ff ff7d 	bl	8009550 <SPI_EndRxTransaction.constprop.0>
 8009656:	b108      	cbz	r0, 800965c <SPI_DMAReceiveCplt+0x3c>
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8009658:	2320      	movs	r3, #32
 800965a:	662b      	str	r3, [r5, #96]	; 0x60
    hspi->State = HAL_SPI_STATE_READY;
 800965c:	2301      	movs	r3, #1
    hspi->RxXferCount = 0U;
 800965e:	2200      	movs	r2, #0
 8009660:	f8a5 2046 	strh.w	r2, [r5, #70]	; 0x46
    hspi->State = HAL_SPI_STATE_READY;
 8009664:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8009668:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800966a:	2b00      	cmp	r3, #0
 800966c:	d0e1      	beq.n	8009632 <SPI_DMAReceiveCplt+0x12>
      hspi->ErrorCallback(hspi);
 800966e:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8009670:	4628      	mov	r0, r5
}
 8009672:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      hspi->ErrorCallback(hspi);
 8009676:	4718      	bx	r3

08009678 <HAL_SPI_Init>:
  if (hspi == NULL)
 8009678:	2800      	cmp	r0, #0
 800967a:	d072      	beq.n	8009762 <HAL_SPI_Init+0xea>
{
 800967c:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hspi->State == HAL_SPI_STATE_RESET)
 800967e:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009682:	2200      	movs	r2, #0
{
 8009684:	b083      	sub	sp, #12
 8009686:	4604      	mov	r4, r0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8009688:	f003 01ff 	and.w	r1, r3, #255	; 0xff
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800968c:	6282      	str	r2, [r0, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 800968e:	b9bb      	cbnz	r3, 80096c0 <HAL_SPI_Init+0x48>
    if (hspi->MspInitCallback == NULL)
 8009690:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
 8009694:	4d3a      	ldr	r5, [pc, #232]	; (8009780 <HAL_SPI_Init+0x108>)
    hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
 8009696:	483b      	ldr	r0, [pc, #236]	; (8009784 <HAL_SPI_Init+0x10c>)
    hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
 8009698:	4a3b      	ldr	r2, [pc, #236]	; (8009788 <HAL_SPI_Init+0x110>)
    hspi->Lock = HAL_UNLOCKED;
 800969a:	f884 105c 	strb.w	r1, [r4, #92]	; 0x5c
    hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
 800969e:	6665      	str	r5, [r4, #100]	; 0x64
    hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
 80096a0:	493a      	ldr	r1, [pc, #232]	; (800978c <HAL_SPI_Init+0x114>)
    hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
 80096a2:	4d3b      	ldr	r5, [pc, #236]	; (8009790 <HAL_SPI_Init+0x118>)
    hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
 80096a4:	66a0      	str	r0, [r4, #104]	; 0x68
    hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
 80096a6:	6722      	str	r2, [r4, #112]	; 0x70
    hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
 80096a8:	483a      	ldr	r0, [pc, #232]	; (8009794 <HAL_SPI_Init+0x11c>)
    hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
 80096aa:	4a3b      	ldr	r2, [pc, #236]	; (8009798 <HAL_SPI_Init+0x120>)
    hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
 80096ac:	4e3b      	ldr	r6, [pc, #236]	; (800979c <HAL_SPI_Init+0x124>)
 80096ae:	66e6      	str	r6, [r4, #108]	; 0x6c
    hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
 80096b0:	e9c4 501d 	strd	r5, r0, [r4, #116]	; 0x74
    hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
 80096b4:	e9c4 121f 	strd	r1, r2, [r4, #124]	; 0x7c
    if (hspi->MspInitCallback == NULL)
 80096b8:	2b00      	cmp	r3, #0
 80096ba:	d05c      	beq.n	8009776 <HAL_SPI_Init+0xfe>
    hspi->MspInitCallback(hspi);
 80096bc:	4620      	mov	r0, r4
 80096be:	4798      	blx	r3
  __HAL_SPI_DISABLE(hspi);
 80096c0:	6821      	ldr	r1, [r4, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80096c2:	68e2      	ldr	r2, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 80096c4:	2302      	movs	r3, #2
 80096c6:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 80096ca:	680b      	ldr	r3, [r1, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80096cc:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 80096d0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80096d4:	600b      	str	r3, [r1, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80096d6:	d930      	bls.n	800973a <HAL_SPI_Init+0xc2>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80096d8:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 80096dc:	d143      	bne.n	8009766 <HAL_SPI_Init+0xee>
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80096de:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80096e0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80096e2:	2b00      	cmp	r3, #0
 80096e4:	d13a      	bne.n	800975c <HAL_SPI_Init+0xe4>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80096e6:	2302      	movs	r3, #2
 80096e8:	6323      	str	r3, [r4, #48]	; 0x30
 80096ea:	f04f 0c00 	mov.w	ip, #0
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 80096ee:	e9d4 7604 	ldrd	r7, r6, [r4, #16]
 80096f2:	68a5      	ldr	r5, [r4, #8]
 80096f4:	6863      	ldr	r3, [r4, #4]
 80096f6:	432b      	orrs	r3, r5
 80096f8:	433b      	orrs	r3, r7
 80096fa:	e9d4 7506 	ldrd	r7, r5, [r4, #24]
 80096fe:	4333      	orrs	r3, r6
 8009700:	432b      	orrs	r3, r5
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8009702:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8009704:	9501      	str	r5, [sp, #4]
 8009706:	6a65      	ldr	r5, [r4, #36]	; 0x24
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8009708:	6a26      	ldr	r6, [r4, #32]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 800970a:	432a      	orrs	r2, r5
 800970c:	9d01      	ldr	r5, [sp, #4]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800970e:	4333      	orrs	r3, r6
 8009710:	f407 7600 	and.w	r6, r7, #512	; 0x200
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8009714:	0c3f      	lsrs	r7, r7, #16
 8009716:	f007 0704 	and.w	r7, r7, #4
 800971a:	4315      	orrs	r5, r2
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800971c:	4333      	orrs	r3, r6
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800971e:	2200      	movs	r2, #0
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8009720:	433d      	orrs	r5, r7
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8009722:	4303      	orrs	r3, r0
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8009724:	ea45 050c 	orr.w	r5, r5, ip
  hspi->State     = HAL_SPI_STATE_READY;
 8009728:	2601      	movs	r6, #1
  return HAL_OK;
 800972a:	4610      	mov	r0, r2
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800972c:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 800972e:	604d      	str	r5, [r1, #4]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8009730:	6622      	str	r2, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8009732:	f884 605d 	strb.w	r6, [r4, #93]	; 0x5d
}
 8009736:	b003      	add	sp, #12
 8009738:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800973a:	d007      	beq.n	800974c <HAL_SPI_Init+0xd4>
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800973c:	6b20      	ldr	r0, [r4, #48]	; 0x30
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800973e:	2300      	movs	r3, #0
 8009740:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8009742:	b130      	cbz	r0, 8009752 <HAL_SPI_Init+0xda>
 8009744:	4618      	mov	r0, r3
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8009746:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
 800974a:	e7d0      	b.n	80096ee <HAL_SPI_Init+0x76>
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800974c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800974e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8009750:	b90b      	cbnz	r3, 8009756 <HAL_SPI_Init+0xde>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8009752:	2301      	movs	r3, #1
 8009754:	6323      	str	r3, [r4, #48]	; 0x30
 8009756:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
 800975a:	e7c8      	b.n	80096ee <HAL_SPI_Init+0x76>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800975c:	f04f 0c00 	mov.w	ip, #0
 8009760:	e7c5      	b.n	80096ee <HAL_SPI_Init+0x76>
    return HAL_ERROR;
 8009762:	2001      	movs	r0, #1
}
 8009764:	4770      	bx	lr
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8009766:	6b20      	ldr	r0, [r4, #48]	; 0x30
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009768:	2300      	movs	r3, #0
 800976a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800976c:	2800      	cmp	r0, #0
 800976e:	d0ba      	beq.n	80096e6 <HAL_SPI_Init+0x6e>
 8009770:	4618      	mov	r0, r3
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8009772:	469c      	mov	ip, r3
 8009774:	e7bb      	b.n	80096ee <HAL_SPI_Init+0x76>
      hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
 8009776:	4b0a      	ldr	r3, [pc, #40]	; (80097a0 <HAL_SPI_Init+0x128>)
 8009778:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 800977c:	e79e      	b.n	80096bc <HAL_SPI_Init+0x44>
 800977e:	bf00      	nop
 8009780:	08009365 	.word	0x08009365
 8009784:	08009369 	.word	0x08009369
 8009788:	08009371 	.word	0x08009371
 800978c:	0800937d 	.word	0x0800937d
 8009790:	08009375 	.word	0x08009375
 8009794:	08009379 	.word	0x08009379
 8009798:	08009361 	.word	0x08009361
 800979c:	0800936d 	.word	0x0800936d
 80097a0:	08009329 	.word	0x08009329

080097a4 <HAL_SPI_RegisterCallback>:
  if (pCallback == NULL)
 80097a4:	2a00      	cmp	r2, #0
 80097a6:	d039      	beq.n	800981c <HAL_SPI_RegisterCallback+0x78>
  __HAL_LOCK(hspi);
 80097a8:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 80097ac:	2b01      	cmp	r3, #1
 80097ae:	d03c      	beq.n	800982a <HAL_SPI_RegisterCallback+0x86>
{
 80097b0:	b430      	push	{r4, r5}
  if (HAL_SPI_STATE_READY == hspi->State)
 80097b2:	f890 405d 	ldrb.w	r4, [r0, #93]	; 0x5d
  __HAL_LOCK(hspi);
 80097b6:	2501      	movs	r5, #1
  if (HAL_SPI_STATE_READY == hspi->State)
 80097b8:	42ac      	cmp	r4, r5
 80097ba:	b2e3      	uxtb	r3, r4
  __HAL_LOCK(hspi);
 80097bc:	f880 505c 	strb.w	r5, [r0, #92]	; 0x5c
  if (HAL_SPI_STATE_READY == hspi->State)
 80097c0:	d011      	beq.n	80097e6 <HAL_SPI_RegisterCallback+0x42>
  else if (HAL_SPI_STATE_RESET == hspi->State)
 80097c2:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 80097c6:	b91b      	cbnz	r3, 80097d0 <HAL_SPI_RegisterCallback+0x2c>
    switch (CallbackID)
 80097c8:	2908      	cmp	r1, #8
 80097ca:	d01e      	beq.n	800980a <HAL_SPI_RegisterCallback+0x66>
 80097cc:	2909      	cmp	r1, #9
 80097ce:	d013      	beq.n	80097f8 <HAL_SPI_RegisterCallback+0x54>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
 80097d0:	6e02      	ldr	r2, [r0, #96]	; 0x60
 80097d2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    status =  HAL_ERROR;
 80097d6:	462b      	mov	r3, r5
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
 80097d8:	6602      	str	r2, [r0, #96]	; 0x60
  __HAL_UNLOCK(hspi);
 80097da:	2200      	movs	r2, #0
 80097dc:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
}
 80097e0:	bc30      	pop	{r4, r5}
 80097e2:	4618      	mov	r0, r3
 80097e4:	4770      	bx	lr
    switch (CallbackID)
 80097e6:	2909      	cmp	r1, #9
 80097e8:	d83b      	bhi.n	8009862 <HAL_SPI_RegisterCallback+0xbe>
 80097ea:	e8df f001 	tbb	[pc, r1]
 80097ee:	2e31      	.short	0x2e31
 80097f0:	3725282b 	.word	0x3725282b
 80097f4:	050e2134 	.word	0x050e2134
        hspi->MspDeInitCallback = pCallback;
 80097f8:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  __HAL_UNLOCK(hspi);
 80097fc:	2200      	movs	r2, #0
 80097fe:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
  HAL_StatusTypeDef status = HAL_OK;
 8009802:	2300      	movs	r3, #0
}
 8009804:	4618      	mov	r0, r3
 8009806:	bc30      	pop	{r4, r5}
 8009808:	4770      	bx	lr
        hspi->MspInitCallback = pCallback;
 800980a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  __HAL_UNLOCK(hspi);
 800980e:	2200      	movs	r2, #0
 8009810:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c
  HAL_StatusTypeDef status = HAL_OK;
 8009814:	2300      	movs	r3, #0
}
 8009816:	4618      	mov	r0, r3
 8009818:	bc30      	pop	{r4, r5}
 800981a:	4770      	bx	lr
    hspi->ErrorCode |= HAL_SPI_ERROR_INVALID_CALLBACK;
 800981c:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800981e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009822:	6603      	str	r3, [r0, #96]	; 0x60
    return HAL_ERROR;
 8009824:	2301      	movs	r3, #1
}
 8009826:	4618      	mov	r0, r3
 8009828:	4770      	bx	lr
  __HAL_LOCK(hspi);
 800982a:	2302      	movs	r3, #2
}
 800982c:	4618      	mov	r0, r3
 800982e:	4770      	bx	lr
        hspi->AbortCpltCallback = pCallback;
 8009830:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
  HAL_StatusTypeDef status = HAL_OK;
 8009834:	2300      	movs	r3, #0
        break;
 8009836:	e7d0      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->RxHalfCpltCallback = pCallback;
 8009838:	6742      	str	r2, [r0, #116]	; 0x74
  HAL_StatusTypeDef status = HAL_OK;
 800983a:	2300      	movs	r3, #0
        break;
 800983c:	e7cd      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->TxHalfCpltCallback = pCallback;
 800983e:	6702      	str	r2, [r0, #112]	; 0x70
  HAL_StatusTypeDef status = HAL_OK;
 8009840:	2300      	movs	r3, #0
        break;
 8009842:	e7ca      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->TxRxCpltCallback = pCallback;
 8009844:	66c2      	str	r2, [r0, #108]	; 0x6c
  HAL_StatusTypeDef status = HAL_OK;
 8009846:	2300      	movs	r3, #0
        break;
 8009848:	e7c7      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->RxCpltCallback = pCallback;
 800984a:	6682      	str	r2, [r0, #104]	; 0x68
  HAL_StatusTypeDef status = HAL_OK;
 800984c:	2300      	movs	r3, #0
        break;
 800984e:	e7c4      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->TxCpltCallback = pCallback;
 8009850:	6642      	str	r2, [r0, #100]	; 0x64
  HAL_StatusTypeDef status = HAL_OK;
 8009852:	460b      	mov	r3, r1
        break;
 8009854:	e7c1      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->ErrorCallback = pCallback;
 8009856:	67c2      	str	r2, [r0, #124]	; 0x7c
  HAL_StatusTypeDef status = HAL_OK;
 8009858:	2300      	movs	r3, #0
        break;
 800985a:	e7be      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        hspi->TxRxHalfCpltCallback = pCallback;
 800985c:	6782      	str	r2, [r0, #120]	; 0x78
  HAL_StatusTypeDef status = HAL_OK;
 800985e:	2300      	movs	r3, #0
        break;
 8009860:	e7bb      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
 8009862:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8009864:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009868:	6602      	str	r2, [r0, #96]	; 0x60
        break;
 800986a:	e7b6      	b.n	80097da <HAL_SPI_RegisterCallback+0x36>

0800986c <HAL_SPI_Transmit>:
{
 800986c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009870:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8009872:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8009876:	2801      	cmp	r0, #1
{
 8009878:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 800987a:	d075      	beq.n	8009968 <HAL_SPI_Transmit+0xfc>
 800987c:	461d      	mov	r5, r3
 800987e:	2301      	movs	r3, #1
 8009880:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  tickstart = HAL_GetTick();
 8009884:	4688      	mov	r8, r1
 8009886:	4617      	mov	r7, r2
 8009888:	f7fb f9aa 	bl	8004be0 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 800988c:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 8009890:	2b01      	cmp	r3, #1
  tickstart = HAL_GetTick();
 8009892:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8009894:	b2d8      	uxtb	r0, r3
 8009896:	d009      	beq.n	80098ac <HAL_SPI_Transmit+0x40>
    errorcode = HAL_BUSY;
 8009898:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 800989a:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 800989c:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 800989e:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 80098a2:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 80098a6:	b002      	add	sp, #8
 80098a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 80098ac:	f1b8 0f00 	cmp.w	r8, #0
 80098b0:	d0f3      	beq.n	800989a <HAL_SPI_Transmit+0x2e>
 80098b2:	2f00      	cmp	r7, #0
 80098b4:	d0f1      	beq.n	800989a <HAL_SPI_Transmit+0x2e>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80098b6:	68a2      	ldr	r2, [r4, #8]
    SPI_1LINE_TX(hspi);
 80098b8:	6820      	ldr	r0, [r4, #0]
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 80098ba:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 80098be:	2303      	movs	r3, #3
 80098c0:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80098c4:	2300      	movs	r3, #0
 80098c6:	6623      	str	r3, [r4, #96]	; 0x60
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80098c8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
  hspi->TxXferCount = Size;
 80098cc:	87e7      	strh	r7, [r4, #62]	; 0x3e
  hspi->RxXferCount = 0U;
 80098ce:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;
 80098d2:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 80098d6:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 80098d8:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
    SPI_1LINE_TX(hspi);
 80098dc:	bf08      	it	eq
 80098de:	6803      	ldreq	r3, [r0, #0]
  hspi->TxXferSize  = Size;
 80098e0:	87a7      	strh	r7, [r4, #60]	; 0x3c
    SPI_1LINE_TX(hspi);
 80098e2:	bf04      	itt	eq
 80098e4:	f443 4380 	orreq.w	r3, r3, #16384	; 0x4000
 80098e8:	6003      	streq	r3, [r0, #0]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80098ea:	6802      	ldr	r2, [r0, #0]
 80098ec:	0652      	lsls	r2, r2, #25
    SPI_1LINE_TX(hspi);
 80098ee:	4603      	mov	r3, r0
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80098f0:	d403      	bmi.n	80098fa <HAL_SPI_Transmit+0x8e>
    __HAL_SPI_ENABLE(hspi);
 80098f2:	6802      	ldr	r2, [r0, #0]
 80098f4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80098f8:	6002      	str	r2, [r0, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80098fa:	68e2      	ldr	r2, [r4, #12]
 80098fc:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8009900:	d936      	bls.n	8009970 <HAL_SPI_Transmit+0x104>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8009902:	6862      	ldr	r2, [r4, #4]
 8009904:	2a00      	cmp	r2, #0
 8009906:	f000 8098 	beq.w	8009a3a <HAL_SPI_Transmit+0x1ce>
 800990a:	2f01      	cmp	r7, #1
 800990c:	f000 8095 	beq.w	8009a3a <HAL_SPI_Transmit+0x1ce>
    while (hspi->TxXferCount > 0U)
 8009910:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8009912:	b292      	uxth	r2, r2
 8009914:	b192      	cbz	r2, 800993c <HAL_SPI_Transmit+0xd0>
 8009916:	1c6a      	adds	r2, r5, #1
 8009918:	d15c      	bne.n	80099d4 <HAL_SPI_Transmit+0x168>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 800991a:	6883      	ldr	r3, [r0, #8]
 800991c:	079f      	lsls	r7, r3, #30
 800991e:	f140 8096 	bpl.w	8009a4e <HAL_SPI_Transmit+0x1e2>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8009922:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009924:	f833 2b02 	ldrh.w	r2, [r3], #2
 8009928:	60c2      	str	r2, [r0, #12]
        hspi->TxXferCount--;
 800992a:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 800992c:	63a3      	str	r3, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 800992e:	3a01      	subs	r2, #1
 8009930:	b292      	uxth	r2, r2
 8009932:	87e2      	strh	r2, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8009934:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009936:	b29b      	uxth	r3, r3
 8009938:	2b00      	cmp	r3, #0
 800993a:	d1ee      	bne.n	800991a <HAL_SPI_Transmit+0xae>
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800993c:	4632      	mov	r2, r6
 800993e:	4629      	mov	r1, r5
 8009940:	4620      	mov	r0, r4
 8009942:	f7ff fd1d 	bl	8009380 <SPI_EndRxTxTransaction>
 8009946:	b108      	cbz	r0, 800994c <HAL_SPI_Transmit+0xe0>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8009948:	2320      	movs	r3, #32
 800994a:	6623      	str	r3, [r4, #96]	; 0x60
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800994c:	68a3      	ldr	r3, [r4, #8]
 800994e:	b933      	cbnz	r3, 800995e <HAL_SPI_Transmit+0xf2>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8009950:	6822      	ldr	r2, [r4, #0]
 8009952:	9301      	str	r3, [sp, #4]
 8009954:	68d3      	ldr	r3, [r2, #12]
 8009956:	9301      	str	r3, [sp, #4]
 8009958:	6893      	ldr	r3, [r2, #8]
 800995a:	9301      	str	r3, [sp, #4]
 800995c:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800995e:	6e20      	ldr	r0, [r4, #96]	; 0x60
    errorcode = HAL_BUSY;
 8009960:	3800      	subs	r0, #0
 8009962:	bf18      	it	ne
 8009964:	2001      	movne	r0, #1
error:
 8009966:	e798      	b.n	800989a <HAL_SPI_Transmit+0x2e>
  __HAL_LOCK(hspi);
 8009968:	2002      	movs	r0, #2
}
 800996a:	b002      	add	sp, #8
 800996c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8009970:	6863      	ldr	r3, [r4, #4]
 8009972:	2b00      	cmp	r3, #0
 8009974:	d053      	beq.n	8009a1e <HAL_SPI_Transmit+0x1b2>
 8009976:	2f01      	cmp	r7, #1
 8009978:	d051      	beq.n	8009a1e <HAL_SPI_Transmit+0x1b2>
    while (hspi->TxXferCount > 0U)
 800997a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800997c:	b29b      	uxth	r3, r3
 800997e:	2b00      	cmp	r3, #0
 8009980:	d0dc      	beq.n	800993c <HAL_SPI_Transmit+0xd0>
 8009982:	1c68      	adds	r0, r5, #1
 8009984:	d011      	beq.n	80099aa <HAL_SPI_Transmit+0x13e>
 8009986:	e040      	b.n	8009a0a <HAL_SPI_Transmit+0x19e>
        if (hspi->TxXferCount > 1U)
 8009988:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800998a:	b29b      	uxth	r3, r3
 800998c:	2b01      	cmp	r3, #1
 800998e:	d967      	bls.n	8009a60 <HAL_SPI_Transmit+0x1f4>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8009990:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8009992:	f831 3b02 	ldrh.w	r3, [r1], #2
 8009996:	60d3      	str	r3, [r2, #12]
          hspi->TxXferCount -= 2U;
 8009998:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 800999a:	63a1      	str	r1, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 800999c:	3b02      	subs	r3, #2
 800999e:	b29b      	uxth	r3, r3
 80099a0:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 80099a2:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80099a4:	b292      	uxth	r2, r2
 80099a6:	2a00      	cmp	r2, #0
 80099a8:	d0c8      	beq.n	800993c <HAL_SPI_Transmit+0xd0>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80099aa:	6822      	ldr	r2, [r4, #0]
 80099ac:	6893      	ldr	r3, [r2, #8]
 80099ae:	0799      	lsls	r1, r3, #30
 80099b0:	d4ea      	bmi.n	8009988 <HAL_SPI_Transmit+0x11c>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80099b2:	f7fb f915 	bl	8004be0 <HAL_GetTick>
 80099b6:	e7f4      	b.n	80099a2 <HAL_SPI_Transmit+0x136>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80099b8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80099ba:	f832 1b02 	ldrh.w	r1, [r2], #2
 80099be:	60d9      	str	r1, [r3, #12]
        hspi->TxXferCount--;
 80099c0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 80099c2:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 80099c4:	3b01      	subs	r3, #1
 80099c6:	b29b      	uxth	r3, r3
 80099c8:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 80099ca:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80099cc:	b29b      	uxth	r3, r3
 80099ce:	2b00      	cmp	r3, #0
 80099d0:	d0b4      	beq.n	800993c <HAL_SPI_Transmit+0xd0>
 80099d2:	6823      	ldr	r3, [r4, #0]
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80099d4:	689a      	ldr	r2, [r3, #8]
 80099d6:	0791      	lsls	r1, r2, #30
 80099d8:	d4ee      	bmi.n	80099b8 <HAL_SPI_Transmit+0x14c>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 80099da:	f7fb f901 	bl	8004be0 <HAL_GetTick>
 80099de:	1b80      	subs	r0, r0, r6
 80099e0:	42a8      	cmp	r0, r5
 80099e2:	d3f2      	bcc.n	80099ca <HAL_SPI_Transmit+0x15e>
          errorcode = HAL_TIMEOUT;
 80099e4:	2003      	movs	r0, #3
 80099e6:	e758      	b.n	800989a <HAL_SPI_Transmit+0x2e>
        if (hspi->TxXferCount > 1U)
 80099e8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80099ea:	b29b      	uxth	r3, r3
 80099ec:	2b01      	cmp	r3, #1
 80099ee:	d942      	bls.n	8009a76 <HAL_SPI_Transmit+0x20a>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80099f0:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80099f2:	f831 3b02 	ldrh.w	r3, [r1], #2
 80099f6:	60d3      	str	r3, [r2, #12]
          hspi->TxXferCount -= 2U;
 80099f8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 80099fa:	63a1      	str	r1, [r4, #56]	; 0x38
          hspi->TxXferCount -= 2U;
 80099fc:	3b02      	subs	r3, #2
 80099fe:	b29b      	uxth	r3, r3
 8009a00:	87e3      	strh	r3, [r4, #62]	; 0x3e
    while (hspi->TxXferCount > 0U)
 8009a02:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009a04:	b29b      	uxth	r3, r3
 8009a06:	2b00      	cmp	r3, #0
 8009a08:	d098      	beq.n	800993c <HAL_SPI_Transmit+0xd0>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8009a0a:	6822      	ldr	r2, [r4, #0]
 8009a0c:	6893      	ldr	r3, [r2, #8]
 8009a0e:	079b      	lsls	r3, r3, #30
 8009a10:	d4ea      	bmi.n	80099e8 <HAL_SPI_Transmit+0x17c>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8009a12:	f7fb f8e5 	bl	8004be0 <HAL_GetTick>
 8009a16:	1b80      	subs	r0, r0, r6
 8009a18:	42a8      	cmp	r0, r5
 8009a1a:	d2e3      	bcs.n	80099e4 <HAL_SPI_Transmit+0x178>
 8009a1c:	e7f1      	b.n	8009a02 <HAL_SPI_Transmit+0x196>
      if (hspi->TxXferCount > 1U)
 8009a1e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009a20:	b29b      	uxth	r3, r3
 8009a22:	2b01      	cmp	r3, #1
 8009a24:	d932      	bls.n	8009a8c <HAL_SPI_Transmit+0x220>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8009a26:	4641      	mov	r1, r8
 8009a28:	f831 3b02 	ldrh.w	r3, [r1], #2
 8009a2c:	60c3      	str	r3, [r0, #12]
        hspi->TxXferCount -= 2U;
 8009a2e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8009a30:	63a1      	str	r1, [r4, #56]	; 0x38
        hspi->TxXferCount -= 2U;
 8009a32:	3b02      	subs	r3, #2
 8009a34:	b29b      	uxth	r3, r3
 8009a36:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8009a38:	e79f      	b.n	800997a <HAL_SPI_Transmit+0x10e>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8009a3a:	4641      	mov	r1, r8
 8009a3c:	f831 2b02 	ldrh.w	r2, [r1], #2
 8009a40:	60c2      	str	r2, [r0, #12]
      hspi->TxXferCount--;
 8009a42:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8009a44:	63a1      	str	r1, [r4, #56]	; 0x38
      hspi->TxXferCount--;
 8009a46:	3a01      	subs	r2, #1
 8009a48:	b292      	uxth	r2, r2
 8009a4a:	87e2      	strh	r2, [r4, #62]	; 0x3e
 8009a4c:	e760      	b.n	8009910 <HAL_SPI_Transmit+0xa4>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8009a4e:	f7fb f8c7 	bl	8004be0 <HAL_GetTick>
    while (hspi->TxXferCount > 0U)
 8009a52:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009a54:	b29b      	uxth	r3, r3
 8009a56:	2b00      	cmp	r3, #0
 8009a58:	f43f af70 	beq.w	800993c <HAL_SPI_Transmit+0xd0>
 8009a5c:	6820      	ldr	r0, [r4, #0]
 8009a5e:	e75c      	b.n	800991a <HAL_SPI_Transmit+0xae>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8009a60:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009a62:	781b      	ldrb	r3, [r3, #0]
 8009a64:	7313      	strb	r3, [r2, #12]
          hspi->TxXferCount--;
 8009a66:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 8009a68:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8009a6a:	3b01      	subs	r3, #1
 8009a6c:	b29b      	uxth	r3, r3
          hspi->pTxBuffPtr++;
 8009a6e:	3201      	adds	r2, #1
          hspi->TxXferCount--;
 8009a70:	87e3      	strh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 8009a72:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8009a74:	e795      	b.n	80099a2 <HAL_SPI_Transmit+0x136>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8009a76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009a78:	781b      	ldrb	r3, [r3, #0]
 8009a7a:	7313      	strb	r3, [r2, #12]
          hspi->TxXferCount--;
 8009a7c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 8009a7e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8009a80:	3b01      	subs	r3, #1
 8009a82:	b29b      	uxth	r3, r3
          hspi->pTxBuffPtr++;
 8009a84:	3201      	adds	r2, #1
          hspi->TxXferCount--;
 8009a86:	87e3      	strh	r3, [r4, #62]	; 0x3e
          hspi->pTxBuffPtr++;
 8009a88:	63a2      	str	r2, [r4, #56]	; 0x38
          hspi->TxXferCount--;
 8009a8a:	e7ba      	b.n	8009a02 <HAL_SPI_Transmit+0x196>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8009a8c:	f898 3000 	ldrb.w	r3, [r8]
 8009a90:	7303      	strb	r3, [r0, #12]
        hspi->TxXferCount--;
 8009a92:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr ++;
 8009a94:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8009a96:	3b01      	subs	r3, #1
 8009a98:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr ++;
 8009a9a:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8009a9c:	87e3      	strh	r3, [r4, #62]	; 0x3e
        hspi->pTxBuffPtr ++;
 8009a9e:	63a2      	str	r2, [r4, #56]	; 0x38
        hspi->TxXferCount--;
 8009aa0:	e76b      	b.n	800997a <HAL_SPI_Transmit+0x10e>
 8009aa2:	bf00      	nop

08009aa4 <HAL_SPI_TransmitReceive_DMA>:
{
 8009aa4:	b570      	push	{r4, r5, r6, lr}
 8009aa6:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 8009aa8:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8009aac:	2801      	cmp	r0, #1
 8009aae:	d079      	beq.n	8009ba4 <HAL_SPI_TransmitReceive_DMA+0x100>
  tmp_state           = hspi->State;
 8009ab0:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  __HAL_LOCK(hspi);
 8009ab4:	2501      	movs	r5, #1
  if (!((tmp_state == HAL_SPI_STATE_READY) ||
 8009ab6:	42a8      	cmp	r0, r5
  tmp_state           = hspi->State;
 8009ab8:	b2c6      	uxtb	r6, r0
  __HAL_LOCK(hspi);
 8009aba:	f884 505c 	strb.w	r5, [r4, #92]	; 0x5c
  if (!((tmp_state == HAL_SPI_STATE_READY) ||
 8009abe:	d00d      	beq.n	8009adc <HAL_SPI_TransmitReceive_DMA+0x38>
 8009ac0:	6860      	ldr	r0, [r4, #4]
 8009ac2:	f5b0 7f82 	cmp.w	r0, #260	; 0x104
 8009ac6:	d004      	beq.n	8009ad2 <HAL_SPI_TransmitReceive_DMA+0x2e>
    errorcode = HAL_BUSY;
 8009ac8:	2002      	movs	r0, #2
  __HAL_UNLOCK(hspi);
 8009aca:	2300      	movs	r3, #0
 8009acc:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
 8009ad0:	bd70      	pop	{r4, r5, r6, pc}
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8009ad2:	68a0      	ldr	r0, [r4, #8]
 8009ad4:	2800      	cmp	r0, #0
 8009ad6:	d1f7      	bne.n	8009ac8 <HAL_SPI_TransmitReceive_DMA+0x24>
 8009ad8:	2e04      	cmp	r6, #4
 8009ada:	d1f5      	bne.n	8009ac8 <HAL_SPI_TransmitReceive_DMA+0x24>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8009adc:	2900      	cmp	r1, #0
 8009ade:	d05f      	beq.n	8009ba0 <HAL_SPI_TransmitReceive_DMA+0xfc>
 8009ae0:	2a00      	cmp	r2, #0
 8009ae2:	d05d      	beq.n	8009ba0 <HAL_SPI_TransmitReceive_DMA+0xfc>
 8009ae4:	2b00      	cmp	r3, #0
 8009ae6:	d05b      	beq.n	8009ba0 <HAL_SPI_TransmitReceive_DMA+0xfc>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8009ae8:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8009aec:	6825      	ldr	r5, [r4, #0]
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8009aee:	2804      	cmp	r0, #4
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8009af0:	bf18      	it	ne
 8009af2:	2005      	movne	r0, #5
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009af4:	f04f 0600 	mov.w	r6, #0
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8009af8:	bf18      	it	ne
 8009afa:	f884 005d 	strbne.w	r0, [r4, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8009afe:	6626      	str	r6, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 8009b00:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 8009b02:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8009b06:	6868      	ldr	r0, [r5, #4]
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8009b08:	63a1      	str	r1, [r4, #56]	; 0x38
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8009b0a:	f420 41c0 	bic.w	r1, r0, #24576	; 0x6000
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009b0e:	68e0      	ldr	r0, [r4, #12]
  hspi->TxXferSize  = Size;
 8009b10:	87a3      	strh	r3, [r4, #60]	; 0x3c
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009b12:	f5b0 6fe0 	cmp.w	r0, #1792	; 0x700
  hspi->TxISR       = NULL;
 8009b16:	e9c4 6613 	strd	r6, r6, [r4, #76]	; 0x4c
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8009b1a:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8009b1c:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8009b20:	6069      	str	r1, [r5, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009b22:	d94a      	bls.n	8009bba <HAL_SPI_TransmitReceive_DMA+0x116>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009b24:	686b      	ldr	r3, [r5, #4]
 8009b26:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8009b28:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009b2c:	606b      	str	r3, [r5, #4]
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8009b2e:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 8009b32:	2b04      	cmp	r3, #4
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8009b34:	bf07      	ittee	eq
 8009b36:	4942      	ldreq	r1, [pc, #264]	; (8009c40 <HAL_SPI_TransmitReceive_DMA+0x19c>)
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 8009b38:	4b42      	ldreq	r3, [pc, #264]	; (8009c44 <HAL_SPI_TransmitReceive_DMA+0x1a0>)
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 8009b3a:	4943      	ldrne	r1, [pc, #268]	; (8009c48 <HAL_SPI_TransmitReceive_DMA+0x1a4>)
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 8009b3c:	4b43      	ldrne	r3, [pc, #268]	; (8009c4c <HAL_SPI_TransmitReceive_DMA+0x1a8>)
 8009b3e:	e9c0 310b 	strd	r3, r1, [r0, #44]	; 0x2c
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
 8009b42:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8009b46:	4942      	ldr	r1, [pc, #264]	; (8009c50 <HAL_SPI_TransmitReceive_DMA+0x1ac>)
 8009b48:	6341      	str	r1, [r0, #52]	; 0x34
  hspi->hdmarx->XferAbortCallback = NULL;
 8009b4a:	2600      	movs	r6, #0
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
 8009b4c:	f105 010c 	add.w	r1, r5, #12
 8009b50:	b29b      	uxth	r3, r3
  hspi->hdmarx->XferAbortCallback = NULL;
 8009b52:	6386      	str	r6, [r0, #56]	; 0x38
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount))
 8009b54:	f7fb ffa6 	bl	8005aa4 <HAL_DMA_Start_IT>
 8009b58:	bb30      	cbnz	r0, 8009ba8 <HAL_SPI_TransmitReceive_DMA+0x104>
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8009b5a:	6822      	ldr	r2, [r4, #0]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 8009b5c:	6d65      	ldr	r5, [r4, #84]	; 0x54
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8009b5e:	6853      	ldr	r3, [r2, #4]
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
 8009b60:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8009b62:	f043 0301 	orr.w	r3, r3, #1
 8009b66:	6053      	str	r3, [r2, #4]
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
 8009b68:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 8009b6a:	6328      	str	r0, [r5, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback    = NULL;
 8009b6c:	e9c5 000d 	strd	r0, r0, [r5, #52]	; 0x34
  hspi->hdmatx->XferCpltCallback     = NULL;
 8009b70:	62e8      	str	r0, [r5, #44]	; 0x2c
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount))
 8009b72:	320c      	adds	r2, #12
 8009b74:	b29b      	uxth	r3, r3
 8009b76:	4628      	mov	r0, r5
 8009b78:	f7fb ff94 	bl	8005aa4 <HAL_DMA_Start_IT>
 8009b7c:	b9a0      	cbnz	r0, 8009ba8 <HAL_SPI_TransmitReceive_DMA+0x104>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8009b7e:	6823      	ldr	r3, [r4, #0]
 8009b80:	681a      	ldr	r2, [r3, #0]
 8009b82:	0652      	lsls	r2, r2, #25
 8009b84:	d403      	bmi.n	8009b8e <HAL_SPI_TransmitReceive_DMA+0xea>
    __HAL_SPI_ENABLE(hspi);
 8009b86:	681a      	ldr	r2, [r3, #0]
 8009b88:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009b8c:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8009b8e:	685a      	ldr	r2, [r3, #4]
 8009b90:	f042 0220 	orr.w	r2, r2, #32
 8009b94:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8009b96:	685a      	ldr	r2, [r3, #4]
 8009b98:	f042 0202 	orr.w	r2, r2, #2
 8009b9c:	605a      	str	r2, [r3, #4]
 8009b9e:	e794      	b.n	8009aca <HAL_SPI_TransmitReceive_DMA+0x26>
    errorcode = HAL_ERROR;
 8009ba0:	2001      	movs	r0, #1
 8009ba2:	e792      	b.n	8009aca <HAL_SPI_TransmitReceive_DMA+0x26>
  __HAL_LOCK(hspi);
 8009ba4:	2002      	movs	r0, #2
}
 8009ba6:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8009ba8:	6e23      	ldr	r3, [r4, #96]	; 0x60
    hspi->State = HAL_SPI_STATE_READY;
 8009baa:	2201      	movs	r2, #1
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8009bac:	f043 0310 	orr.w	r3, r3, #16
 8009bb0:	6623      	str	r3, [r4, #96]	; 0x60
    errorcode = HAL_ERROR;
 8009bb2:	4610      	mov	r0, r2
    hspi->State = HAL_SPI_STATE_READY;
 8009bb4:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
    goto error;
 8009bb8:	e787      	b.n	8009aca <HAL_SPI_TransmitReceive_DMA+0x26>
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8009bba:	6d60      	ldr	r0, [r4, #84]	; 0x54
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009bbc:	6869      	ldr	r1, [r5, #4]
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8009bbe:	6980      	ldr	r0, [r0, #24]
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009bc0:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8009bc4:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009bc8:	6069      	str	r1, [r5, #4]
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8009bca:	d018      	beq.n	8009bfe <HAL_SPI_TransmitReceive_DMA+0x15a>
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8009bcc:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8009bce:	6983      	ldr	r3, [r0, #24]
 8009bd0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8009bd4:	d1ab      	bne.n	8009b2e <HAL_SPI_TransmitReceive_DMA+0x8a>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8009bd6:	686b      	ldr	r3, [r5, #4]
 8009bd8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009bdc:	606b      	str	r3, [r5, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 8009bde:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009be2:	f013 0f01 	tst.w	r3, #1
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8009be6:	686b      	ldr	r3, [r5, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 8009be8:	d115      	bne.n	8009c16 <HAL_SPI_TransmitReceive_DMA+0x172>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8009bea:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8009bee:	606b      	str	r3, [r5, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 8009bf0:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009bf4:	f3c3 034e 	ubfx	r3, r3, #1, #15
 8009bf8:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8009bfc:	e797      	b.n	8009b2e <HAL_SPI_TransmitReceive_DMA+0x8a>
      if ((hspi->TxXferSize & 0x1U) == 0x0U)
 8009bfe:	f013 0f01 	tst.w	r3, #1
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8009c02:	686b      	ldr	r3, [r5, #4]
      if ((hspi->TxXferSize & 0x1U) == 0x0U)
 8009c04:	d112      	bne.n	8009c2c <HAL_SPI_TransmitReceive_DMA+0x188>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8009c06:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8009c0a:	606b      	str	r3, [r5, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1U;
 8009c0c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009c0e:	f3c3 034e 	ubfx	r3, r3, #1, #15
 8009c12:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8009c14:	e7da      	b.n	8009bcc <HAL_SPI_TransmitReceive_DMA+0x128>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8009c16:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009c1a:	606b      	str	r3, [r5, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 8009c1c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8009c20:	f3c3 034e 	ubfx	r3, r3, #1, #15
 8009c24:	3301      	adds	r3, #1
 8009c26:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
 8009c2a:	e780      	b.n	8009b2e <HAL_SPI_TransmitReceive_DMA+0x8a>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8009c2c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009c30:	606b      	str	r3, [r5, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8009c32:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8009c34:	f3c3 034e 	ubfx	r3, r3, #1, #15
 8009c38:	3301      	adds	r3, #1
 8009c3a:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8009c3c:	e7c6      	b.n	8009bcc <HAL_SPI_TransmitReceive_DMA+0x128>
 8009c3e:	bf00      	nop
 8009c40:	0800932d 	.word	0x0800932d
 8009c44:	08009621 	.word	0x08009621
 8009c48:	08009335 	.word	0x08009335
 8009c4c:	080094f1 	.word	0x080094f1
 8009c50:	0800933d 	.word	0x0800933d

08009c54 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8009c54:	4770      	bx	lr
 8009c56:	bf00      	nop

08009c58 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8009c58:	2800      	cmp	r0, #0
 8009c5a:	d06b      	beq.n	8009d34 <HAL_TIM_Base_Init+0xdc>
{
 8009c5c:	b538      	push	{r3, r4, r5, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8009c5e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009c62:	4604      	mov	r4, r0
 8009c64:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8009c68:	2b00      	cmp	r3, #0
 8009c6a:	d05b      	beq.n	8009d24 <HAL_TIM_Base_Init+0xcc>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8009c6c:	6822      	ldr	r2, [r4, #0]
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8009c6e:	4932      	ldr	r1, [pc, #200]	; (8009d38 <HAL_TIM_Base_Init+0xe0>)
  htim->State = HAL_TIM_STATE_BUSY;
 8009c70:	2302      	movs	r3, #2
 8009c72:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8009c76:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 8009c78:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8009c7a:	d03f      	beq.n	8009cfc <HAL_TIM_Base_Init+0xa4>
 8009c7c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8009c80:	d025      	beq.n	8009cce <HAL_TIM_Base_Init+0x76>
 8009c82:	f5a1 3194 	sub.w	r1, r1, #75776	; 0x12800
 8009c86:	428a      	cmp	r2, r1
 8009c88:	d021      	beq.n	8009cce <HAL_TIM_Base_Init+0x76>
 8009c8a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8009c8e:	428a      	cmp	r2, r1
 8009c90:	d01d      	beq.n	8009cce <HAL_TIM_Base_Init+0x76>
 8009c92:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8009c96:	428a      	cmp	r2, r1
 8009c98:	d019      	beq.n	8009cce <HAL_TIM_Base_Init+0x76>
 8009c9a:	f501 3194 	add.w	r1, r1, #75776	; 0x12800
 8009c9e:	428a      	cmp	r2, r1
 8009ca0:	d02c      	beq.n	8009cfc <HAL_TIM_Base_Init+0xa4>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8009ca2:	f501 6140 	add.w	r1, r1, #3072	; 0xc00
 8009ca6:	428a      	cmp	r2, r1
 8009ca8:	d041      	beq.n	8009d2e <HAL_TIM_Base_Init+0xd6>
 8009caa:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8009cae:	428a      	cmp	r2, r1
 8009cb0:	d03d      	beq.n	8009d2e <HAL_TIM_Base_Init+0xd6>
 8009cb2:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8009cb6:	428a      	cmp	r2, r1
 8009cb8:	d039      	beq.n	8009d2e <HAL_TIM_Base_Init+0xd6>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009cba:	69a5      	ldr	r5, [r4, #24]

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009cbc:	68e0      	ldr	r0, [r4, #12]

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8009cbe:	6861      	ldr	r1, [r4, #4]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009cc0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009cc4:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8009cc6:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009cc8:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8009cca:	6291      	str	r1, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8009ccc:	e010      	b.n	8009cf0 <HAL_TIM_Base_Init+0x98>
    tmpcr1 |= Structure->CounterMode;
 8009cce:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009cd0:	6925      	ldr	r5, [r4, #16]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009cd2:	68e0      	ldr	r0, [r4, #12]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8009cd4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8009cd8:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 8009cda:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009cde:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009ce0:	432b      	orrs	r3, r5
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009ce2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009ce6:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8009ce8:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8009cea:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009cec:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8009cee:	6291      	str	r1, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8009cf0:	2301      	movs	r3, #1
 8009cf2:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 8009cf4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8009cf8:	2000      	movs	r0, #0
}
 8009cfa:	bd38      	pop	{r3, r4, r5, pc}
    tmpcr1 |= Structure->CounterMode;
 8009cfc:	68a5      	ldr	r5, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009cfe:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009d00:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8009d02:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8009d06:	432b      	orrs	r3, r5
    tmpcr1 &= ~TIM_CR1_CKD;
 8009d08:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009d0c:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009d0e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009d12:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 8009d14:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009d16:	68e3      	ldr	r3, [r4, #12]
 8009d18:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8009d1a:	6863      	ldr	r3, [r4, #4]
 8009d1c:	6293      	str	r3, [r2, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8009d1e:	6963      	ldr	r3, [r4, #20]
 8009d20:	6313      	str	r3, [r2, #48]	; 0x30
 8009d22:	e7e5      	b.n	8009cf0 <HAL_TIM_Base_Init+0x98>
    htim->Lock = HAL_UNLOCKED;
 8009d24:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8009d28:	f7ff ff94 	bl	8009c54 <HAL_TIM_Base_MspInit>
 8009d2c:	e79e      	b.n	8009c6c <HAL_TIM_Base_Init+0x14>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009d2e:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009d30:	69a1      	ldr	r1, [r4, #24]
 8009d32:	e7e9      	b.n	8009d08 <HAL_TIM_Base_Init+0xb0>
    return HAL_ERROR;
 8009d34:	2001      	movs	r0, #1
}
 8009d36:	4770      	bx	lr
 8009d38:	40012c00 	.word	0x40012c00

08009d3c <HAL_TIM_Base_Start>:
  htim->State = HAL_TIM_STATE_BUSY;
 8009d3c:	2302      	movs	r3, #2
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8009d3e:	6802      	ldr	r2, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8009d40:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8009d44:	6891      	ldr	r1, [r2, #8]
 8009d46:	4b08      	ldr	r3, [pc, #32]	; (8009d68 <HAL_TIM_Base_Start+0x2c>)
 8009d48:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8009d4a:	2b06      	cmp	r3, #6
 8009d4c:	d006      	beq.n	8009d5c <HAL_TIM_Base_Start+0x20>
 8009d4e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009d52:	d003      	beq.n	8009d5c <HAL_TIM_Base_Start+0x20>
    __HAL_TIM_ENABLE(htim);
 8009d54:	6813      	ldr	r3, [r2, #0]
 8009d56:	f043 0301 	orr.w	r3, r3, #1
 8009d5a:	6013      	str	r3, [r2, #0]
  htim->State = HAL_TIM_STATE_READY;
 8009d5c:	2301      	movs	r3, #1
 8009d5e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8009d62:	2000      	movs	r0, #0
 8009d64:	4770      	bx	lr
 8009d66:	bf00      	nop
 8009d68:	00010007 	.word	0x00010007

08009d6c <HAL_TIM_Base_Stop>:
  htim->State = HAL_TIM_STATE_BUSY;
 8009d6c:	2202      	movs	r2, #2
  __HAL_TIM_DISABLE(htim);
 8009d6e:	6803      	ldr	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8009d70:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_TIM_DISABLE(htim);
 8009d74:	6a19      	ldr	r1, [r3, #32]
 8009d76:	f241 1211 	movw	r2, #4369	; 0x1111
 8009d7a:	4211      	tst	r1, r2
 8009d7c:	d108      	bne.n	8009d90 <HAL_TIM_Base_Stop+0x24>
 8009d7e:	6a19      	ldr	r1, [r3, #32]
 8009d80:	f240 4244 	movw	r2, #1092	; 0x444
 8009d84:	4211      	tst	r1, r2
 8009d86:	d103      	bne.n	8009d90 <HAL_TIM_Base_Stop+0x24>
 8009d88:	681a      	ldr	r2, [r3, #0]
 8009d8a:	f022 0201 	bic.w	r2, r2, #1
 8009d8e:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 8009d90:	2301      	movs	r3, #1
 8009d92:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
}
 8009d96:	2000      	movs	r0, #0
 8009d98:	4770      	bx	lr
 8009d9a:	bf00      	nop

08009d9c <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8009d9c:	6803      	ldr	r3, [r0, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8009d9e:	4a09      	ldr	r2, [pc, #36]	; (8009dc4 <HAL_TIM_Base_Start_IT+0x28>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8009da0:	68d9      	ldr	r1, [r3, #12]
 8009da2:	f041 0101 	orr.w	r1, r1, #1
 8009da6:	60d9      	str	r1, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8009da8:	6899      	ldr	r1, [r3, #8]
 8009daa:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8009dac:	2a06      	cmp	r2, #6
 8009dae:	d006      	beq.n	8009dbe <HAL_TIM_Base_Start_IT+0x22>
 8009db0:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8009db4:	d003      	beq.n	8009dbe <HAL_TIM_Base_Start_IT+0x22>
    __HAL_TIM_ENABLE(htim);
 8009db6:	681a      	ldr	r2, [r3, #0]
 8009db8:	f042 0201 	orr.w	r2, r2, #1
 8009dbc:	601a      	str	r2, [r3, #0]
}
 8009dbe:	2000      	movs	r0, #0
 8009dc0:	4770      	bx	lr
 8009dc2:	bf00      	nop
 8009dc4:	00010007 	.word	0x00010007

08009dc8 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8009dc8:	6803      	ldr	r3, [r0, #0]
 8009dca:	68da      	ldr	r2, [r3, #12]
 8009dcc:	f022 0201 	bic.w	r2, r2, #1
 8009dd0:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 8009dd2:	6a1a      	ldr	r2, [r3, #32]
 8009dd4:	f241 1111 	movw	r1, #4369	; 0x1111
 8009dd8:	420a      	tst	r2, r1
 8009dda:	d108      	bne.n	8009dee <HAL_TIM_Base_Stop_IT+0x26>
 8009ddc:	6a19      	ldr	r1, [r3, #32]
 8009dde:	f240 4244 	movw	r2, #1092	; 0x444
 8009de2:	4211      	tst	r1, r2
 8009de4:	d103      	bne.n	8009dee <HAL_TIM_Base_Stop_IT+0x26>
 8009de6:	681a      	ldr	r2, [r3, #0]
 8009de8:	f022 0201 	bic.w	r2, r2, #1
 8009dec:	601a      	str	r2, [r3, #0]
}
 8009dee:	2000      	movs	r0, #0
 8009df0:	4770      	bx	lr
 8009df2:	bf00      	nop

08009df4 <HAL_TIM_OC_DelayElapsedCallback>:
 8009df4:	4770      	bx	lr
 8009df6:	bf00      	nop

08009df8 <HAL_TIM_PWM_PulseFinishedCallback>:
 8009df8:	4770      	bx	lr
 8009dfa:	bf00      	nop

08009dfc <HAL_TIM_TriggerCallback>:
 8009dfc:	4770      	bx	lr
 8009dfe:	bf00      	nop

08009e00 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8009e00:	6803      	ldr	r3, [r0, #0]
 8009e02:	691a      	ldr	r2, [r3, #16]
 8009e04:	0791      	lsls	r1, r2, #30
{
 8009e06:	b510      	push	{r4, lr}
 8009e08:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8009e0a:	d502      	bpl.n	8009e12 <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8009e0c:	68da      	ldr	r2, [r3, #12]
 8009e0e:	0792      	lsls	r2, r2, #30
 8009e10:	d468      	bmi.n	8009ee4 <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8009e12:	691a      	ldr	r2, [r3, #16]
 8009e14:	0752      	lsls	r2, r2, #29
 8009e16:	d502      	bpl.n	8009e1e <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8009e18:	68da      	ldr	r2, [r3, #12]
 8009e1a:	0750      	lsls	r0, r2, #29
 8009e1c:	d44f      	bmi.n	8009ebe <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8009e1e:	691a      	ldr	r2, [r3, #16]
 8009e20:	0711      	lsls	r1, r2, #28
 8009e22:	d502      	bpl.n	8009e2a <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8009e24:	68da      	ldr	r2, [r3, #12]
 8009e26:	0712      	lsls	r2, r2, #28
 8009e28:	d437      	bmi.n	8009e9a <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8009e2a:	691a      	ldr	r2, [r3, #16]
 8009e2c:	06d0      	lsls	r0, r2, #27
 8009e2e:	d502      	bpl.n	8009e36 <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8009e30:	68da      	ldr	r2, [r3, #12]
 8009e32:	06d1      	lsls	r1, r2, #27
 8009e34:	d41e      	bmi.n	8009e74 <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8009e36:	691a      	ldr	r2, [r3, #16]
 8009e38:	07d2      	lsls	r2, r2, #31
 8009e3a:	d502      	bpl.n	8009e42 <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8009e3c:	68da      	ldr	r2, [r3, #12]
 8009e3e:	07d0      	lsls	r0, r2, #31
 8009e40:	d469      	bmi.n	8009f16 <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8009e42:	691a      	ldr	r2, [r3, #16]
 8009e44:	0611      	lsls	r1, r2, #24
 8009e46:	d502      	bpl.n	8009e4e <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8009e48:	68da      	ldr	r2, [r3, #12]
 8009e4a:	0612      	lsls	r2, r2, #24
 8009e4c:	d46b      	bmi.n	8009f26 <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8009e4e:	691a      	ldr	r2, [r3, #16]
 8009e50:	05d0      	lsls	r0, r2, #23
 8009e52:	d502      	bpl.n	8009e5a <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8009e54:	68da      	ldr	r2, [r3, #12]
 8009e56:	0611      	lsls	r1, r2, #24
 8009e58:	d46d      	bmi.n	8009f36 <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8009e5a:	691a      	ldr	r2, [r3, #16]
 8009e5c:	0652      	lsls	r2, r2, #25
 8009e5e:	d502      	bpl.n	8009e66 <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8009e60:	68da      	ldr	r2, [r3, #12]
 8009e62:	0650      	lsls	r0, r2, #25
 8009e64:	d46f      	bmi.n	8009f46 <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8009e66:	691a      	ldr	r2, [r3, #16]
 8009e68:	0691      	lsls	r1, r2, #26
 8009e6a:	d502      	bpl.n	8009e72 <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8009e6c:	68da      	ldr	r2, [r3, #12]
 8009e6e:	0692      	lsls	r2, r2, #26
 8009e70:	d449      	bmi.n	8009f06 <HAL_TIM_IRQHandler+0x106>
}
 8009e72:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8009e74:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8009e78:	2208      	movs	r2, #8
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8009e7a:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8009e7c:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8009e7e:	69db      	ldr	r3, [r3, #28]
 8009e80:	f413 7f40 	tst.w	r3, #768	; 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8009e84:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8009e86:	d16f      	bne.n	8009f68 <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009e88:	f7ff ffb4 	bl	8009df4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009e8c:	4620      	mov	r0, r4
 8009e8e:	f7ff ffb3 	bl	8009df8 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009e92:	2200      	movs	r2, #0
 8009e94:	6823      	ldr	r3, [r4, #0]
 8009e96:	7722      	strb	r2, [r4, #28]
 8009e98:	e7cd      	b.n	8009e36 <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8009e9a:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8009e9e:	2204      	movs	r2, #4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8009ea0:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8009ea2:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8009ea4:	69db      	ldr	r3, [r3, #28]
 8009ea6:	079b      	lsls	r3, r3, #30
        HAL_TIM_IC_CaptureCallback(htim);
 8009ea8:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8009eaa:	d15a      	bne.n	8009f62 <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009eac:	f7ff ffa2 	bl	8009df4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009eb0:	4620      	mov	r0, r4
 8009eb2:	f7ff ffa1 	bl	8009df8 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009eb6:	2200      	movs	r2, #0
 8009eb8:	6823      	ldr	r3, [r4, #0]
 8009eba:	7722      	strb	r2, [r4, #28]
 8009ebc:	e7b5      	b.n	8009e2a <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8009ebe:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8009ec2:	2202      	movs	r2, #2
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8009ec4:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8009ec6:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8009ec8:	699b      	ldr	r3, [r3, #24]
 8009eca:	f413 7f40 	tst.w	r3, #768	; 0x300
        HAL_TIM_IC_CaptureCallback(htim);
 8009ece:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8009ed0:	d144      	bne.n	8009f5c <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009ed2:	f7ff ff8f 	bl	8009df4 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009ed6:	4620      	mov	r0, r4
 8009ed8:	f7ff ff8e 	bl	8009df8 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009edc:	2200      	movs	r2, #0
 8009ede:	6823      	ldr	r3, [r4, #0]
 8009ee0:	7722      	strb	r2, [r4, #28]
 8009ee2:	e79c      	b.n	8009e1e <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8009ee4:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009ee8:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8009eea:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009eec:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8009eee:	699b      	ldr	r3, [r3, #24]
 8009ef0:	0799      	lsls	r1, r3, #30
 8009ef2:	d130      	bne.n	8009f56 <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8009ef4:	f7ff ff7e 	bl	8009df4 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009ef8:	4620      	mov	r0, r4
 8009efa:	f7ff ff7d 	bl	8009df8 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009efe:	2200      	movs	r2, #0
 8009f00:	6823      	ldr	r3, [r4, #0]
 8009f02:	7722      	strb	r2, [r4, #28]
 8009f04:	e785      	b.n	8009e12 <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8009f06:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8009f0a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8009f0c:	611a      	str	r2, [r3, #16]
}
 8009f0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 8009f12:	f000 b875 	b.w	800a000 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8009f16:	f06f 0201 	mvn.w	r2, #1
 8009f1a:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8009f1c:	4620      	mov	r0, r4
 8009f1e:	f7fa fc4b 	bl	80047b8 <HAL_TIM_PeriodElapsedCallback>
 8009f22:	6823      	ldr	r3, [r4, #0]
 8009f24:	e78d      	b.n	8009e42 <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8009f26:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8009f2a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8009f2c:	4620      	mov	r0, r4
 8009f2e:	f000 f869 	bl	800a004 <HAL_TIMEx_BreakCallback>
 8009f32:	6823      	ldr	r3, [r4, #0]
 8009f34:	e78b      	b.n	8009e4e <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8009f36:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009f3a:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8009f3c:	4620      	mov	r0, r4
 8009f3e:	f000 f863 	bl	800a008 <HAL_TIMEx_Break2Callback>
 8009f42:	6823      	ldr	r3, [r4, #0]
 8009f44:	e789      	b.n	8009e5a <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8009f46:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009f4a:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8009f4c:	4620      	mov	r0, r4
 8009f4e:	f7ff ff55 	bl	8009dfc <HAL_TIM_TriggerCallback>
 8009f52:	6823      	ldr	r3, [r4, #0]
 8009f54:	e787      	b.n	8009e66 <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 8009f56:	f7fa fcad 	bl	80048b4 <HAL_TIM_IC_CaptureCallback>
 8009f5a:	e7d0      	b.n	8009efe <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 8009f5c:	f7fa fcaa 	bl	80048b4 <HAL_TIM_IC_CaptureCallback>
 8009f60:	e7bc      	b.n	8009edc <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 8009f62:	f7fa fca7 	bl	80048b4 <HAL_TIM_IC_CaptureCallback>
 8009f66:	e7a6      	b.n	8009eb6 <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 8009f68:	f7fa fca4 	bl	80048b4 <HAL_TIM_IC_CaptureCallback>
 8009f6c:	e791      	b.n	8009e92 <HAL_TIM_IRQHandler+0x92>
 8009f6e:	bf00      	nop

08009f70 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8009f70:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009f74:	2b01      	cmp	r3, #1
 8009f76:	d03c      	beq.n	8009ff2 <HAL_TIMEx_MasterConfigSynchronization+0x82>
{
 8009f78:	b470      	push	{r4, r5, r6}

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8009f7a:	6802      	ldr	r2, [r0, #0]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8009f7c:	4c1e      	ldr	r4, [pc, #120]	; (8009ff8 <HAL_TIMEx_MasterConfigSynchronization+0x88>)
  htim->State = HAL_TIM_STATE_BUSY;
 8009f7e:	2302      	movs	r3, #2
 8009f80:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8009f84:	42a2      	cmp	r2, r4
  tmpcr2 = htim->Instance->CR2;
 8009f86:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 8009f88:	6895      	ldr	r5, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8009f8a:	d028      	beq.n	8009fde <HAL_TIMEx_MasterConfigSynchronization+0x6e>
 8009f8c:	f504 6400 	add.w	r4, r4, #2048	; 0x800
 8009f90:	42a2      	cmp	r2, r4
 8009f92:	d024      	beq.n	8009fde <HAL_TIMEx_MasterConfigSynchronization+0x6e>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009f94:	680c      	ldr	r4, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 8009f96:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009f9a:	4323      	orrs	r3, r4

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8009f9c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->Instance->CR2 = tmpcr2;
 8009fa0:	6053      	str	r3, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8009fa2:	d00e      	beq.n	8009fc2 <HAL_TIMEx_MasterConfigSynchronization+0x52>
 8009fa4:	4b15      	ldr	r3, [pc, #84]	; (8009ffc <HAL_TIMEx_MasterConfigSynchronization+0x8c>)
 8009fa6:	429a      	cmp	r2, r3
 8009fa8:	d00b      	beq.n	8009fc2 <HAL_TIMEx_MasterConfigSynchronization+0x52>
 8009faa:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009fae:	429a      	cmp	r2, r3
 8009fb0:	d007      	beq.n	8009fc2 <HAL_TIMEx_MasterConfigSynchronization+0x52>
 8009fb2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009fb6:	429a      	cmp	r2, r3
 8009fb8:	d003      	beq.n	8009fc2 <HAL_TIMEx_MasterConfigSynchronization+0x52>
 8009fba:	f503 339a 	add.w	r3, r3, #78848	; 0x13400
 8009fbe:	429a      	cmp	r2, r3
 8009fc0:	d104      	bne.n	8009fcc <HAL_TIMEx_MasterConfigSynchronization+0x5c>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8009fc2:	688b      	ldr	r3, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 8009fc4:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8009fc8:	431d      	orrs	r5, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8009fca:	6095      	str	r5, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8009fcc:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8009fce:	2201      	movs	r2, #1
 8009fd0:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8009fd4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
}
 8009fd8:	bc70      	pop	{r4, r5, r6}
  return HAL_OK;
 8009fda:	4618      	mov	r0, r3
}
 8009fdc:	4770      	bx	lr
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009fde:	e9d1 4600 	ldrd	r4, r6, [r1]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8009fe2:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8009fe6:	4333      	orrs	r3, r6
  tmpcr2 &= ~TIM_CR2_MMS;
 8009fe8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009fec:	4323      	orrs	r3, r4
  htim->Instance->CR2 = tmpcr2;
 8009fee:	6053      	str	r3, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8009ff0:	e7e7      	b.n	8009fc2 <HAL_TIMEx_MasterConfigSynchronization+0x52>
  __HAL_LOCK(htim);
 8009ff2:	2002      	movs	r0, #2
}
 8009ff4:	4770      	bx	lr
 8009ff6:	bf00      	nop
 8009ff8:	40012c00 	.word	0x40012c00
 8009ffc:	40000400 	.word	0x40000400

0800a000 <HAL_TIMEx_CommutCallback>:
 800a000:	4770      	bx	lr
 800a002:	bf00      	nop

0800a004 <HAL_TIMEx_BreakCallback>:
 800a004:	4770      	bx	lr
 800a006:	bf00      	nop

0800a008 <HAL_TIMEx_Break2Callback>:
 800a008:	4770      	bx	lr
 800a00a:	bf00      	nop

0800a00c <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800a00c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800a00e:	07da      	lsls	r2, r3, #31
{
 800a010:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800a012:	d506      	bpl.n	800a022 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800a014:	6801      	ldr	r1, [r0, #0]
 800a016:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800a018:	684a      	ldr	r2, [r1, #4]
 800a01a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800a01e:	4322      	orrs	r2, r4
 800a020:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800a022:	079c      	lsls	r4, r3, #30
 800a024:	d506      	bpl.n	800a034 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800a026:	6801      	ldr	r1, [r0, #0]
 800a028:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800a02a:	684a      	ldr	r2, [r1, #4]
 800a02c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800a030:	4322      	orrs	r2, r4
 800a032:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800a034:	0759      	lsls	r1, r3, #29
 800a036:	d506      	bpl.n	800a046 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800a038:	6801      	ldr	r1, [r0, #0]
 800a03a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800a03c:	684a      	ldr	r2, [r1, #4]
 800a03e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800a042:	4322      	orrs	r2, r4
 800a044:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800a046:	071a      	lsls	r2, r3, #28
 800a048:	d506      	bpl.n	800a058 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800a04a:	6801      	ldr	r1, [r0, #0]
 800a04c:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800a04e:	684a      	ldr	r2, [r1, #4]
 800a050:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800a054:	4322      	orrs	r2, r4
 800a056:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800a058:	06dc      	lsls	r4, r3, #27
 800a05a:	d506      	bpl.n	800a06a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800a05c:	6801      	ldr	r1, [r0, #0]
 800a05e:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800a060:	688a      	ldr	r2, [r1, #8]
 800a062:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800a066:	4322      	orrs	r2, r4
 800a068:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800a06a:	0699      	lsls	r1, r3, #26
 800a06c:	d506      	bpl.n	800a07c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800a06e:	6801      	ldr	r1, [r0, #0]
 800a070:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800a072:	688a      	ldr	r2, [r1, #8]
 800a074:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a078:	4322      	orrs	r2, r4
 800a07a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800a07c:	065a      	lsls	r2, r3, #25
 800a07e:	d509      	bpl.n	800a094 <UART_AdvFeatureConfig+0x88>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800a080:	6801      	ldr	r1, [r0, #0]
 800a082:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800a084:	684a      	ldr	r2, [r1, #4]
 800a086:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800a08a:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800a08c:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800a090:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800a092:	d00b      	beq.n	800a0ac <UART_AdvFeatureConfig+0xa0>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800a094:	061b      	lsls	r3, r3, #24
 800a096:	d506      	bpl.n	800a0a6 <UART_AdvFeatureConfig+0x9a>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800a098:	6802      	ldr	r2, [r0, #0]
 800a09a:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 800a09c:	6853      	ldr	r3, [r2, #4]
 800a09e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800a0a2:	430b      	orrs	r3, r1
 800a0a4:	6053      	str	r3, [r2, #4]
  }
}
 800a0a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a0aa:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800a0ac:	684a      	ldr	r2, [r1, #4]
 800a0ae:	6c84      	ldr	r4, [r0, #72]	; 0x48
 800a0b0:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 800a0b4:	4322      	orrs	r2, r4
 800a0b6:	604a      	str	r2, [r1, #4]
 800a0b8:	e7ec      	b.n	800a094 <UART_AdvFeatureConfig+0x88>
 800a0ba:	bf00      	nop

0800a0bc <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800a0bc:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a0be:	2300      	movs	r3, #0
{
 800a0c0:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a0c2:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 800a0c6:	f7fa fd8b 	bl	8004be0 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800a0ca:	6823      	ldr	r3, [r4, #0]
 800a0cc:	681a      	ldr	r2, [r3, #0]
 800a0ce:	0711      	lsls	r1, r2, #28
  tickstart = HAL_GetTick();
 800a0d0:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800a0d2:	d40b      	bmi.n	800a0ec <UART_CheckIdleState+0x30>
      return HAL_TIMEOUT;
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800a0d4:	681a      	ldr	r2, [r3, #0]
 800a0d6:	0752      	lsls	r2, r2, #29
 800a0d8:	d42f      	bmi.n	800a13a <UART_CheckIdleState+0x7e>

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
  huart->RxState = HAL_UART_STATE_READY;

  __HAL_UNLOCK(huart);
 800a0da:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 800a0dc:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 800a0de:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
  huart->gState = HAL_UART_STATE_READY;
 800a0e2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 800a0e6:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  return HAL_OK;
}
 800a0ea:	bd38      	pop	{r3, r4, r5, pc}
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800a0ec:	69da      	ldr	r2, [r3, #28]
 800a0ee:	0292      	lsls	r2, r2, #10
 800a0f0:	d4f0      	bmi.n	800a0d4 <UART_CheckIdleState+0x18>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a0f2:	f7fa fd75 	bl	8004be0 <HAL_GetTick>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
#if defined(USART_CR1_FIFOEN)
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800a0f6:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a0f8:	1b40      	subs	r0, r0, r5
 800a0fa:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800a0fe:	681a      	ldr	r2, [r3, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a100:	d22c      	bcs.n	800a15c <UART_CheckIdleState+0xa0>
        __HAL_UNLOCK(huart);

        return HAL_TIMEOUT;
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800a102:	0750      	lsls	r0, r2, #29
 800a104:	d5f2      	bpl.n	800a0ec <UART_CheckIdleState+0x30>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800a106:	69da      	ldr	r2, [r3, #28]
 800a108:	0511      	lsls	r1, r2, #20
 800a10a:	d5ef      	bpl.n	800a0ec <UART_CheckIdleState+0x30>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800a10c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800a110:	621a      	str	r2, [r3, #32]
          
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
#if defined(USART_CR1_FIFOEN)
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800a112:	681a      	ldr	r2, [r3, #0]
 800a114:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800a118:	601a      	str	r2, [r3, #0]
#else
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
#endif
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a11a:	6899      	ldr	r1, [r3, #8]
          huart->gState = HAL_UART_STATE_READY;
          huart->RxState = HAL_UART_STATE_READY;
          huart->ErrorCode = HAL_UART_ERROR_RTO;
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800a11c:	2500      	movs	r5, #0
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a11e:	f021 0101 	bic.w	r1, r1, #1
 800a122:	6099      	str	r1, [r3, #8]
          huart->gState = HAL_UART_STATE_READY;
 800a124:	2220      	movs	r2, #32
          __HAL_UNLOCK(huart);
 800a126:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
          huart->gState = HAL_UART_STATE_READY;
 800a12a:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
      return HAL_TIMEOUT;
 800a12e:	2003      	movs	r0, #3
          huart->RxState = HAL_UART_STATE_READY;
 800a130:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800a134:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
}
 800a138:	bd38      	pop	{r3, r4, r5, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800a13a:	69db      	ldr	r3, [r3, #28]
 800a13c:	0258      	lsls	r0, r3, #9
 800a13e:	d4cc      	bmi.n	800a0da <UART_CheckIdleState+0x1e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a140:	f7fa fd4e 	bl	8004be0 <HAL_GetTick>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800a144:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a146:	1b40      	subs	r0, r0, r5
 800a148:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800a14c:	681a      	ldr	r2, [r3, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a14e:	d205      	bcs.n	800a15c <UART_CheckIdleState+0xa0>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800a150:	0751      	lsls	r1, r2, #29
 800a152:	d5f2      	bpl.n	800a13a <UART_CheckIdleState+0x7e>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800a154:	69da      	ldr	r2, [r3, #28]
 800a156:	0512      	lsls	r2, r2, #20
 800a158:	d5ef      	bpl.n	800a13a <UART_CheckIdleState+0x7e>
 800a15a:	e7d7      	b.n	800a10c <UART_CheckIdleState+0x50>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800a15c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800a160:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a162:	689a      	ldr	r2, [r3, #8]
        __HAL_UNLOCK(huart);
 800a164:	2500      	movs	r5, #0
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a166:	f022 0201 	bic.w	r2, r2, #1
 800a16a:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800a16c:	2120      	movs	r1, #32
        __HAL_UNLOCK(huart);
 800a16e:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
        huart->gState = HAL_UART_STATE_READY;
 800a172:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
      return HAL_TIMEOUT;
 800a176:	2003      	movs	r0, #3
        huart->RxState = HAL_UART_STATE_READY;
 800a178:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
}
 800a17c:	bd38      	pop	{r3, r4, r5, pc}
 800a17e:	bf00      	nop

0800a180 <HAL_UART_Init>:
  if (huart == NULL)
 800a180:	2800      	cmp	r0, #0
 800a182:	f000 824b 	beq.w	800a61c <HAL_UART_Init+0x49c>
{
 800a186:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 800a188:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 800a18c:	4604      	mov	r4, r0
 800a18e:	2b00      	cmp	r3, #0
 800a190:	f000 8095 	beq.w	800a2be <HAL_UART_Init+0x13e>
  __HAL_UART_DISABLE(huart);
 800a194:	6823      	ldr	r3, [r4, #0]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800a196:	48bf      	ldr	r0, [pc, #764]	; (800a494 <HAL_UART_Init+0x314>)
  huart->gState = HAL_UART_STATE_BUSY;
 800a198:	2224      	movs	r2, #36	; 0x24
 800a19a:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a19e:	e9d4 6504 	ldrd	r6, r5, [r4, #16]
  __HAL_UART_DISABLE(huart);
 800a1a2:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a1a4:	68a2      	ldr	r2, [r4, #8]
  __HAL_UART_DISABLE(huart);
 800a1a6:	f021 0101 	bic.w	r1, r1, #1
 800a1aa:	6019      	str	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a1ac:	4332      	orrs	r2, r6
 800a1ae:	69e1      	ldr	r1, [r4, #28]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800a1b0:	681e      	ldr	r6, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a1b2:	432a      	orrs	r2, r5
  tmpreg |= (uint32_t)huart->FifoMode;
 800a1b4:	6e65      	ldr	r5, [r4, #100]	; 0x64
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a1b6:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800a1b8:	4030      	ands	r0, r6
  tmpreg |= (uint32_t)huart->FifoMode;
 800a1ba:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800a1bc:	4302      	orrs	r2, r0
 800a1be:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800a1c0:	685a      	ldr	r2, [r3, #4]
 800a1c2:	68e5      	ldr	r5, [r4, #12]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800a1c4:	48b4      	ldr	r0, [pc, #720]	; (800a498 <HAL_UART_Init+0x318>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800a1c6:	69a6      	ldr	r6, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800a1c8:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 800a1cc:	432a      	orrs	r2, r5
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800a1ce:	4283      	cmp	r3, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800a1d0:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800a1d2:	d079      	beq.n	800a2c8 <HAL_UART_Init+0x148>
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800a1d4:	e9d4 2508 	ldrd	r2, r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800a1d8:	6898      	ldr	r0, [r3, #8]
 800a1da:	f020 406e 	bic.w	r0, r0, #3992977408	; 0xee000000
 800a1de:	f420 6030 	bic.w	r0, r0, #2816	; 0xb00
    tmpreg |= huart->Init.OneBitSampling;
 800a1e2:	4332      	orrs	r2, r6
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800a1e4:	4302      	orrs	r2, r0
 800a1e6:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800a1e8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a1ea:	48ac      	ldr	r0, [pc, #688]	; (800a49c <HAL_UART_Init+0x31c>)
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800a1ec:	f022 020f 	bic.w	r2, r2, #15
 800a1f0:	432a      	orrs	r2, r5
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a1f2:	4283      	cmp	r3, r0
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800a1f4:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a1f6:	d028      	beq.n	800a24a <HAL_UART_Init+0xca>
 800a1f8:	4aa9      	ldr	r2, [pc, #676]	; (800a4a0 <HAL_UART_Init+0x320>)
 800a1fa:	4293      	cmp	r3, r2
 800a1fc:	f000 80fc 	beq.w	800a3f8 <HAL_UART_Init+0x278>
 800a200:	4aa8      	ldr	r2, [pc, #672]	; (800a4a4 <HAL_UART_Init+0x324>)
 800a202:	4293      	cmp	r3, r2
 800a204:	f000 81f8 	beq.w	800a5f8 <HAL_UART_Init+0x478>
 800a208:	4aa7      	ldr	r2, [pc, #668]	; (800a4a8 <HAL_UART_Init+0x328>)
 800a20a:	4293      	cmp	r3, r2
 800a20c:	f000 8182 	beq.w	800a514 <HAL_UART_Init+0x394>
 800a210:	4aa6      	ldr	r2, [pc, #664]	; (800a4ac <HAL_UART_Init+0x32c>)
 800a212:	4293      	cmp	r3, r2
 800a214:	d111      	bne.n	800a23a <HAL_UART_Init+0xba>
 800a216:	4ba6      	ldr	r3, [pc, #664]	; (800a4b0 <HAL_UART_Init+0x330>)
 800a218:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a21c:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800a220:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a224:	f000 818c 	beq.w	800a540 <HAL_UART_Init+0x3c0>
 800a228:	f200 81c4 	bhi.w	800a5b4 <HAL_UART_Init+0x434>
 800a22c:	2b00      	cmp	r3, #0
 800a22e:	f000 81b3 	beq.w	800a598 <HAL_UART_Init+0x418>
 800a232:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a236:	f000 8179 	beq.w	800a52c <HAL_UART_Init+0x3ac>
  huart->RxISR = NULL;
 800a23a:	2300      	movs	r3, #0
 800a23c:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 800a240:	e9c4 231a 	strd	r2, r3, [r4, #104]	; 0x68
  huart->TxISR = NULL;
 800a244:	6723      	str	r3, [r4, #112]	; 0x70
}
 800a246:	2001      	movs	r0, #1
 800a248:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a24a:	4b99      	ldr	r3, [pc, #612]	; (800a4b0 <HAL_UART_Init+0x330>)
 800a24c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a250:	f003 0303 	and.w	r3, r3, #3
 800a254:	3b01      	subs	r3, #1
 800a256:	2b02      	cmp	r3, #2
 800a258:	f240 81a9 	bls.w	800a5ae <HAL_UART_Init+0x42e>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a25c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800a260:	f000 820c 	beq.w	800a67c <HAL_UART_Init+0x4fc>
        pclk = HAL_RCC_GetPCLK2Freq();
 800a264:	f7fd faea 	bl	800783c <HAL_RCC_GetPCLK2Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a268:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a26a:	b303      	cbz	r3, 800a2ae <HAL_UART_Init+0x12e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a26c:	2b01      	cmp	r3, #1
 800a26e:	f000 8371 	beq.w	800a954 <HAL_UART_Init+0x7d4>
 800a272:	2b02      	cmp	r3, #2
 800a274:	f000 836c 	beq.w	800a950 <HAL_UART_Init+0x7d0>
 800a278:	2b03      	cmp	r3, #3
 800a27a:	f000 8366 	beq.w	800a94a <HAL_UART_Init+0x7ca>
 800a27e:	2b04      	cmp	r3, #4
 800a280:	f000 8379 	beq.w	800a976 <HAL_UART_Init+0x7f6>
 800a284:	2b05      	cmp	r3, #5
 800a286:	f000 8373 	beq.w	800a970 <HAL_UART_Init+0x7f0>
 800a28a:	2b06      	cmp	r3, #6
 800a28c:	f000 83aa 	beq.w	800a9e4 <HAL_UART_Init+0x864>
 800a290:	2b07      	cmp	r3, #7
 800a292:	f000 83ca 	beq.w	800aa2a <HAL_UART_Init+0x8aa>
 800a296:	2b08      	cmp	r3, #8
 800a298:	f000 83dc 	beq.w	800aa54 <HAL_UART_Init+0x8d4>
 800a29c:	2b09      	cmp	r3, #9
 800a29e:	f000 83ee 	beq.w	800aa7e <HAL_UART_Init+0x8fe>
 800a2a2:	2b0a      	cmp	r3, #10
 800a2a4:	f000 8411 	beq.w	800aaca <HAL_UART_Init+0x94a>
 800a2a8:	2b0b      	cmp	r3, #11
 800a2aa:	bf08      	it	eq
 800a2ac:	0a00      	lsreq	r0, r0, #8
 800a2ae:	6861      	ldr	r1, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 800a2b0:	2200      	movs	r2, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a2b2:	eb00 0351 	add.w	r3, r0, r1, lsr #1
 800a2b6:	fbb3 f3f1 	udiv	r3, r3, r1
 800a2ba:	b29b      	uxth	r3, r3
        break;
 800a2bc:	e0c2      	b.n	800a444 <HAL_UART_Init+0x2c4>
    huart->Lock = HAL_UNLOCKED;
 800a2be:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    HAL_UART_MspInit(huart);
 800a2c2:	f7f8 f8c1 	bl	8002448 <HAL_UART_MspInit>
 800a2c6:	e765      	b.n	800a194 <HAL_UART_Init+0x14>
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800a2c8:	6899      	ldr	r1, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a2ca:	4879      	ldr	r0, [pc, #484]	; (800a4b0 <HAL_UART_Init+0x330>)
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800a2cc:	f021 416e 	bic.w	r1, r1, #3992977408	; 0xee000000
 800a2d0:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 800a2d4:	4331      	orrs	r1, r6
 800a2d6:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800a2d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a2da:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a2dc:	f022 020f 	bic.w	r2, r2, #15
 800a2e0:	430a      	orrs	r2, r1
 800a2e2:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a2e4:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 800a2e8:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800a2ec:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800a2f0:	f000 82f9 	beq.w	800a8e6 <HAL_UART_Init+0x766>
 800a2f4:	d832      	bhi.n	800a35c <HAL_UART_Init+0x1dc>
 800a2f6:	2b00      	cmp	r3, #0
 800a2f8:	f000 82d1 	beq.w	800a89e <HAL_UART_Init+0x71e>
 800a2fc:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800a300:	d19b      	bne.n	800a23a <HAL_UART_Init+0xba>
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 800a302:	f7fc fe03 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
 800a306:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a308:	b303      	cbz	r3, 800a34c <HAL_UART_Init+0x1cc>
 800a30a:	2b01      	cmp	r3, #1
 800a30c:	f000 8348 	beq.w	800a9a0 <HAL_UART_Init+0x820>
 800a310:	2b02      	cmp	r3, #2
 800a312:	f000 8341 	beq.w	800a998 <HAL_UART_Init+0x818>
 800a316:	2b03      	cmp	r3, #3
 800a318:	f000 833b 	beq.w	800a992 <HAL_UART_Init+0x812>
 800a31c:	2b04      	cmp	r3, #4
 800a31e:	f000 836e 	beq.w	800a9fe <HAL_UART_Init+0x87e>
 800a322:	2b05      	cmp	r3, #5
 800a324:	f000 8368 	beq.w	800a9f8 <HAL_UART_Init+0x878>
 800a328:	2b06      	cmp	r3, #6
 800a32a:	f000 83bb 	beq.w	800aaa4 <HAL_UART_Init+0x924>
 800a32e:	2b07      	cmp	r3, #7
 800a330:	f000 83d6 	beq.w	800aae0 <HAL_UART_Init+0x960>
 800a334:	2b08      	cmp	r3, #8
 800a336:	f000 83f4 	beq.w	800ab22 <HAL_UART_Init+0x9a2>
 800a33a:	2b09      	cmp	r3, #9
 800a33c:	f000 8408 	beq.w	800ab50 <HAL_UART_Init+0x9d0>
 800a340:	2b0a      	cmp	r3, #10
 800a342:	f000 842a 	beq.w	800ab9a <HAL_UART_Init+0xa1a>
 800a346:	2b0b      	cmp	r3, #11
 800a348:	bf08      	it	eq
 800a34a:	0a00      	lsreq	r0, r0, #8
        break;
 800a34c:	2304      	movs	r3, #4
    if (lpuart_ker_ck_pres != 0U)
 800a34e:	bb80      	cbnz	r0, 800a3b2 <HAL_UART_Init+0x232>
  huart->NbRxDataToProcess = 1;
 800a350:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  huart->TxISR = NULL;
 800a354:	e9c4 001b 	strd	r0, r0, [r4, #108]	; 0x6c
  huart->NbRxDataToProcess = 1;
 800a358:	66a3      	str	r3, [r4, #104]	; 0x68
 800a35a:	e085      	b.n	800a468 <HAL_UART_Init+0x2e8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a35c:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800a360:	f47f af6b 	bne.w	800a23a <HAL_UART_Init+0xba>
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 800a364:	2900      	cmp	r1, #0
 800a366:	f000 82f7 	beq.w	800a958 <HAL_UART_Init+0x7d8>
 800a36a:	2901      	cmp	r1, #1
 800a36c:	f000 831a 	beq.w	800a9a4 <HAL_UART_Init+0x824>
 800a370:	2902      	cmp	r1, #2
 800a372:	f000 832b 	beq.w	800a9cc <HAL_UART_Init+0x84c>
 800a376:	2903      	cmp	r1, #3
 800a378:	f000 834a 	beq.w	800aa10 <HAL_UART_Init+0x890>
 800a37c:	2904      	cmp	r1, #4
 800a37e:	f000 835d 	beq.w	800aa3c <HAL_UART_Init+0x8bc>
 800a382:	2905      	cmp	r1, #5
 800a384:	f000 836e 	beq.w	800aa64 <HAL_UART_Init+0x8e4>
 800a388:	2906      	cmp	r1, #6
 800a38a:	f000 837e 	beq.w	800aa8a <HAL_UART_Init+0x90a>
 800a38e:	2907      	cmp	r1, #7
 800a390:	f000 83a3 	beq.w	800aada <HAL_UART_Init+0x95a>
 800a394:	2908      	cmp	r1, #8
 800a396:	f000 83c1 	beq.w	800ab1c <HAL_UART_Init+0x99c>
 800a39a:	2909      	cmp	r1, #9
 800a39c:	f000 83ef 	beq.w	800ab7e <HAL_UART_Init+0x9fe>
 800a3a0:	290a      	cmp	r1, #10
 800a3a2:	f000 83ef 	beq.w	800ab84 <HAL_UART_Init+0xa04>
 800a3a6:	290b      	cmp	r1, #11
 800a3a8:	bf0c      	ite	eq
 800a3aa:	2080      	moveq	r0, #128	; 0x80
 800a3ac:	f44f 4000 	movne.w	r0, #32768	; 0x8000
        break;
 800a3b0:	2308      	movs	r3, #8
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800a3b2:	6862      	ldr	r2, [r4, #4]
 800a3b4:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 800a3b8:	4281      	cmp	r1, r0
 800a3ba:	f63f af3e 	bhi.w	800a23a <HAL_UART_Init+0xba>
 800a3be:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 800a3c2:	f63f af3a 	bhi.w	800a23a <HAL_UART_Init+0xba>
        switch (clocksource)
 800a3c6:	2b08      	cmp	r3, #8
 800a3c8:	f63f af37 	bhi.w	800a23a <HAL_UART_Init+0xba>
 800a3cc:	a101      	add	r1, pc, #4	; (adr r1, 800a3d4 <HAL_UART_Init+0x254>)
 800a3ce:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800a3d2:	bf00      	nop
 800a3d4:	0800a88f 	.word	0x0800a88f
 800a3d8:	0800a23b 	.word	0x0800a23b
 800a3dc:	0800a7b9 	.word	0x0800a7b9
 800a3e0:	0800a23b 	.word	0x0800a23b
 800a3e4:	0800a821 	.word	0x0800a821
 800a3e8:	0800a23b 	.word	0x0800a23b
 800a3ec:	0800a23b 	.word	0x0800a23b
 800a3f0:	0800a23b 	.word	0x0800a23b
 800a3f4:	0800a741 	.word	0x0800a741
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a3f8:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 800a3fc:	4b2d      	ldr	r3, [pc, #180]	; (800a4b4 <HAL_UART_Init+0x334>)
 800a3fe:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a402:	f002 020c 	and.w	r2, r2, #12
 800a406:	4413      	add	r3, r2
 800a408:	791b      	ldrb	r3, [r3, #4]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a40a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800a40e:	f000 80d5 	beq.w	800a5bc <HAL_UART_Init+0x43c>
    switch (clocksource)
 800a412:	2b08      	cmp	r3, #8
 800a414:	d814      	bhi.n	800a440 <HAL_UART_Init+0x2c0>
 800a416:	a201      	add	r2, pc, #4	; (adr r2, 800a41c <HAL_UART_Init+0x29c>)
 800a418:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a41c:	0800a5a1 	.word	0x0800a5a1
 800a420:	0800a265 	.word	0x0800a265
 800a424:	0800a549 	.word	0x0800a549
 800a428:	0800a441 	.word	0x0800a441
 800a42c:	0800a533 	.word	0x0800a533
 800a430:	0800a441 	.word	0x0800a441
 800a434:	0800a441 	.word	0x0800a441
 800a438:	0800a441 	.word	0x0800a441
 800a43c:	0800a4c7 	.word	0x0800a4c7
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a440:	2201      	movs	r2, #1
 800a442:	2300      	movs	r3, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800a444:	f1a3 0010 	sub.w	r0, r3, #16
 800a448:	f64f 71ef 	movw	r1, #65519	; 0xffef
 800a44c:	4288      	cmp	r0, r1
 800a44e:	f63f aef4 	bhi.w	800a23a <HAL_UART_Init+0xba>
      huart->Instance->BRR = usartdiv;
 800a452:	6821      	ldr	r1, [r4, #0]
 800a454:	60cb      	str	r3, [r1, #12]
  huart->RxISR = NULL;
 800a456:	2300      	movs	r3, #0
 800a458:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 800a45c:	e9c4 131a 	strd	r1, r3, [r4, #104]	; 0x68
  huart->TxISR = NULL;
 800a460:	6723      	str	r3, [r4, #112]	; 0x70
  if (UART_SetConfig(huart) == HAL_ERROR)
 800a462:	2a00      	cmp	r2, #0
 800a464:	f47f aeef 	bne.w	800a246 <HAL_UART_Init+0xc6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800a468:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800a46a:	2b00      	cmp	r3, #0
 800a46c:	f040 80c0 	bne.w	800a5f0 <HAL_UART_Init+0x470>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800a470:	6823      	ldr	r3, [r4, #0]
 800a472:	685a      	ldr	r2, [r3, #4]
 800a474:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800a478:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800a47a:	689a      	ldr	r2, [r3, #8]
 800a47c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800a480:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800a482:	681a      	ldr	r2, [r3, #0]
 800a484:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 800a488:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 800a48a:	601a      	str	r2, [r3, #0]
}
 800a48c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return (UART_CheckIdleState(huart));
 800a490:	f7ff be14 	b.w	800a0bc <UART_CheckIdleState>
 800a494:	cfff69f3 	.word	0xcfff69f3
 800a498:	40008000 	.word	0x40008000
 800a49c:	40013800 	.word	0x40013800
 800a4a0:	40004400 	.word	0x40004400
 800a4a4:	40004800 	.word	0x40004800
 800a4a8:	40004c00 	.word	0x40004c00
 800a4ac:	40005000 	.word	0x40005000
 800a4b0:	40021000 	.word	0x40021000
 800a4b4:	0801a184 	.word	0x0801a184
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a4b8:	2b30      	cmp	r3, #48	; 0x30
 800a4ba:	f47f aebe 	bne.w	800a23a <HAL_UART_Init+0xba>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a4be:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800a4c2:	f000 80e1 	beq.w	800a688 <HAL_UART_Init+0x508>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a4c6:	2d00      	cmp	r5, #0
 800a4c8:	f000 823c 	beq.w	800a944 <HAL_UART_Init+0x7c4>
 800a4cc:	2d01      	cmp	r5, #1
 800a4ce:	f000 8258 	beq.w	800a982 <HAL_UART_Init+0x802>
 800a4d2:	2d02      	cmp	r5, #2
 800a4d4:	f000 8272 	beq.w	800a9bc <HAL_UART_Init+0x83c>
 800a4d8:	2d03      	cmp	r5, #3
 800a4da:	f000 8280 	beq.w	800a9de <HAL_UART_Init+0x85e>
 800a4de:	2d04      	cmp	r5, #4
 800a4e0:	f000 8299 	beq.w	800aa16 <HAL_UART_Init+0x896>
 800a4e4:	2d05      	cmp	r5, #5
 800a4e6:	f000 82b2 	beq.w	800aa4e <HAL_UART_Init+0x8ce>
 800a4ea:	2d06      	cmp	r5, #6
 800a4ec:	f000 82c2 	beq.w	800aa74 <HAL_UART_Init+0x8f4>
 800a4f0:	2d07      	cmp	r5, #7
 800a4f2:	f000 82e0 	beq.w	800aab6 <HAL_UART_Init+0x936>
 800a4f6:	2d08      	cmp	r5, #8
 800a4f8:	f000 8305 	beq.w	800ab06 <HAL_UART_Init+0x986>
 800a4fc:	2d09      	cmp	r5, #9
 800a4fe:	f000 8324 	beq.w	800ab4a <HAL_UART_Init+0x9ca>
 800a502:	2d0a      	cmp	r5, #10
 800a504:	f000 832b 	beq.w	800ab5e <HAL_UART_Init+0x9de>
 800a508:	2d0b      	cmp	r5, #11
 800a50a:	bf0c      	ite	eq
 800a50c:	2380      	moveq	r3, #128	; 0x80
 800a50e:	f44f 4300 	movne.w	r3, #32768	; 0x8000
 800a512:	e20f      	b.n	800a934 <HAL_UART_Init+0x7b4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a514:	4bbb      	ldr	r3, [pc, #748]	; (800a804 <HAL_UART_Init+0x684>)
 800a516:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a51a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800a51e:	2b80      	cmp	r3, #128	; 0x80
 800a520:	d00e      	beq.n	800a540 <HAL_UART_Init+0x3c0>
 800a522:	d877      	bhi.n	800a614 <HAL_UART_Init+0x494>
 800a524:	b3c3      	cbz	r3, 800a598 <HAL_UART_Init+0x418>
 800a526:	2b40      	cmp	r3, #64	; 0x40
 800a528:	f47f ae87 	bne.w	800a23a <HAL_UART_Init+0xba>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a52c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800a530:	d076      	beq.n	800a620 <HAL_UART_Init+0x4a0>
        pclk = HAL_RCC_GetSysClockFreq();
 800a532:	f7fc fceb 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a536:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a538:	2b00      	cmp	r3, #0
 800a53a:	f43f aeb8 	beq.w	800a2ae <HAL_UART_Init+0x12e>
 800a53e:	e695      	b.n	800a26c <HAL_UART_Init+0xec>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a540:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800a544:	f000 80cf 	beq.w	800a6e6 <HAL_UART_Init+0x566>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a548:	2d00      	cmp	r5, #0
 800a54a:	f000 81f2 	beq.w	800a932 <HAL_UART_Init+0x7b2>
 800a54e:	2d01      	cmp	r5, #1
 800a550:	f000 8215 	beq.w	800a97e <HAL_UART_Init+0x7fe>
 800a554:	2d02      	cmp	r5, #2
 800a556:	f000 822f 	beq.w	800a9b8 <HAL_UART_Init+0x838>
 800a55a:	2d03      	cmp	r5, #3
 800a55c:	f000 823d 	beq.w	800a9da <HAL_UART_Init+0x85a>
 800a560:	2d04      	cmp	r5, #4
 800a562:	f000 825b 	beq.w	800aa1c <HAL_UART_Init+0x89c>
 800a566:	2d05      	cmp	r5, #5
 800a568:	f000 826f 	beq.w	800aa4a <HAL_UART_Init+0x8ca>
 800a56c:	2d06      	cmp	r5, #6
 800a56e:	f000 8284 	beq.w	800aa7a <HAL_UART_Init+0x8fa>
 800a572:	2d07      	cmp	r5, #7
 800a574:	f000 829d 	beq.w	800aab2 <HAL_UART_Init+0x932>
 800a578:	2d08      	cmp	r5, #8
 800a57a:	f000 82c2 	beq.w	800ab02 <HAL_UART_Init+0x982>
 800a57e:	2d09      	cmp	r5, #9
 800a580:	f000 82e1 	beq.w	800ab46 <HAL_UART_Init+0x9c6>
 800a584:	2d0a      	cmp	r5, #10
 800a586:	f000 82e8 	beq.w	800ab5a <HAL_UART_Init+0x9da>
 800a58a:	4a9f      	ldr	r2, [pc, #636]	; (800a808 <HAL_UART_Init+0x688>)
 800a58c:	f24f 4324 	movw	r3, #62500	; 0xf424
 800a590:	2d0b      	cmp	r5, #11
 800a592:	bf18      	it	ne
 800a594:	4613      	movne	r3, r2
 800a596:	e1cd      	b.n	800a934 <HAL_UART_Init+0x7b4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a598:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800a59c:	f000 80ca 	beq.w	800a734 <HAL_UART_Init+0x5b4>
        pclk = HAL_RCC_GetPCLK1Freq();
 800a5a0:	f7fd f93a 	bl	8007818 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a5a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a5a6:	2b00      	cmp	r3, #0
 800a5a8:	f43f ae81 	beq.w	800a2ae <HAL_UART_Init+0x12e>
 800a5ac:	e65e      	b.n	800a26c <HAL_UART_Init+0xec>
 800a5ae:	4a97      	ldr	r2, [pc, #604]	; (800a80c <HAL_UART_Init+0x68c>)
 800a5b0:	5cd3      	ldrb	r3, [r2, r3]
  if (UART_INSTANCE_LOWPOWER(huart))
 800a5b2:	e72a      	b.n	800a40a <HAL_UART_Init+0x28a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a5b4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800a5b8:	d081      	beq.n	800a4be <HAL_UART_Init+0x33e>
 800a5ba:	e63e      	b.n	800a23a <HAL_UART_Init+0xba>
    switch (clocksource)
 800a5bc:	2b08      	cmp	r3, #8
 800a5be:	d806      	bhi.n	800a5ce <HAL_UART_Init+0x44e>
 800a5c0:	e8df f003 	tbb	[pc, r3]
 800a5c4:	05915cb8 	.word	0x05915cb8
 800a5c8:	0505052e 	.word	0x0505052e
 800a5cc:	62          	.byte	0x62
 800a5cd:	00          	.byte	0x00
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a5ce:	2201      	movs	r2, #1
 800a5d0:	2300      	movs	r3, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800a5d2:	f1a3 0010 	sub.w	r0, r3, #16
 800a5d6:	f64f 71ef 	movw	r1, #65519	; 0xffef
 800a5da:	4288      	cmp	r0, r1
 800a5dc:	f63f ae2d 	bhi.w	800a23a <HAL_UART_Init+0xba>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800a5e0:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 800a5e4:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800a5e6:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 800a5ea:	430b      	orrs	r3, r1
 800a5ec:	60c3      	str	r3, [r0, #12]
 800a5ee:	e732      	b.n	800a456 <HAL_UART_Init+0x2d6>
    UART_AdvFeatureConfig(huart);
 800a5f0:	4620      	mov	r0, r4
 800a5f2:	f7ff fd0b 	bl	800a00c <UART_AdvFeatureConfig>
 800a5f6:	e73b      	b.n	800a470 <HAL_UART_Init+0x2f0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a5f8:	4b82      	ldr	r3, [pc, #520]	; (800a804 <HAL_UART_Init+0x684>)
 800a5fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a5fe:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800a602:	2b20      	cmp	r3, #32
 800a604:	d09c      	beq.n	800a540 <HAL_UART_Init+0x3c0>
 800a606:	f63f af57 	bhi.w	800a4b8 <HAL_UART_Init+0x338>
 800a60a:	2b00      	cmp	r3, #0
 800a60c:	d0c4      	beq.n	800a598 <HAL_UART_Init+0x418>
 800a60e:	2b10      	cmp	r3, #16
 800a610:	d08c      	beq.n	800a52c <HAL_UART_Init+0x3ac>
 800a612:	e612      	b.n	800a23a <HAL_UART_Init+0xba>
 800a614:	2bc0      	cmp	r3, #192	; 0xc0
 800a616:	f43f af52 	beq.w	800a4be <HAL_UART_Init+0x33e>
 800a61a:	e60e      	b.n	800a23a <HAL_UART_Init+0xba>
}
 800a61c:	2001      	movs	r0, #1
 800a61e:	4770      	bx	lr
        pclk = HAL_RCC_GetSysClockFreq();
 800a620:	f7fc fc74 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a624:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a626:	b303      	cbz	r3, 800a66a <HAL_UART_Init+0x4ea>
 800a628:	2b01      	cmp	r3, #1
 800a62a:	f000 819a 	beq.w	800a962 <HAL_UART_Init+0x7e2>
 800a62e:	2b02      	cmp	r3, #2
 800a630:	f000 81a3 	beq.w	800a97a <HAL_UART_Init+0x7fa>
 800a634:	2b03      	cmp	r3, #3
 800a636:	f000 81ba 	beq.w	800a9ae <HAL_UART_Init+0x82e>
 800a63a:	2b04      	cmp	r3, #4
 800a63c:	f000 81cb 	beq.w	800a9d6 <HAL_UART_Init+0x856>
 800a640:	2b05      	cmp	r3, #5
 800a642:	f000 81ed 	beq.w	800aa20 <HAL_UART_Init+0x8a0>
 800a646:	2b06      	cmp	r3, #6
 800a648:	f000 81fb 	beq.w	800aa42 <HAL_UART_Init+0x8c2>
 800a64c:	2b07      	cmp	r3, #7
 800a64e:	f000 820f 	beq.w	800aa70 <HAL_UART_Init+0x8f0>
 800a652:	2b08      	cmp	r3, #8
 800a654:	f000 822b 	beq.w	800aaae <HAL_UART_Init+0x92e>
 800a658:	2b09      	cmp	r3, #9
 800a65a:	f000 8250 	beq.w	800aafe <HAL_UART_Init+0x97e>
 800a65e:	2b0a      	cmp	r3, #10
 800a660:	f000 8268 	beq.w	800ab34 <HAL_UART_Init+0x9b4>
 800a664:	2b0b      	cmp	r3, #11
 800a666:	bf08      	it	eq
 800a668:	0a00      	lsreq	r0, r0, #8
 800a66a:	6861      	ldr	r1, [r4, #4]
 800a66c:	084a      	lsrs	r2, r1, #1
 800a66e:	eb02 0340 	add.w	r3, r2, r0, lsl #1
  HAL_StatusTypeDef ret               = HAL_OK;
 800a672:	2200      	movs	r2, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a674:	fbb3 f3f1 	udiv	r3, r3, r1
 800a678:	b29b      	uxth	r3, r3
        break;
 800a67a:	e7aa      	b.n	800a5d2 <HAL_UART_Init+0x452>
        pclk = HAL_RCC_GetPCLK2Freq();
 800a67c:	f7fd f8de 	bl	800783c <HAL_RCC_GetPCLK2Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a680:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a682:	2b00      	cmp	r3, #0
 800a684:	d0f1      	beq.n	800a66a <HAL_UART_Init+0x4ea>
 800a686:	e7cf      	b.n	800a628 <HAL_UART_Init+0x4a8>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a688:	2d00      	cmp	r5, #0
 800a68a:	f000 816e 	beq.w	800a96a <HAL_UART_Init+0x7ea>
 800a68e:	2d01      	cmp	r5, #1
 800a690:	f000 8197 	beq.w	800a9c2 <HAL_UART_Init+0x842>
 800a694:	2d02      	cmp	r5, #2
 800a696:	f000 81b8 	beq.w	800aa0a <HAL_UART_Init+0x88a>
 800a69a:	2d03      	cmp	r5, #3
 800a69c:	f000 81cb 	beq.w	800aa36 <HAL_UART_Init+0x8b6>
 800a6a0:	2d04      	cmp	r5, #4
 800a6a2:	f000 81e2 	beq.w	800aa6a <HAL_UART_Init+0x8ea>
 800a6a6:	2d05      	cmp	r5, #5
 800a6a8:	f000 81f4 	beq.w	800aa94 <HAL_UART_Init+0x914>
 800a6ac:	2d06      	cmp	r5, #6
 800a6ae:	f000 8211 	beq.w	800aad4 <HAL_UART_Init+0x954>
 800a6b2:	2d07      	cmp	r5, #7
 800a6b4:	f000 823b 	beq.w	800ab2e <HAL_UART_Init+0x9ae>
 800a6b8:	2d08      	cmp	r5, #8
 800a6ba:	f000 8253 	beq.w	800ab64 <HAL_UART_Init+0x9e4>
 800a6be:	2d09      	cmp	r5, #9
 800a6c0:	f000 8266 	beq.w	800ab90 <HAL_UART_Init+0xa10>
 800a6c4:	2d0a      	cmp	r5, #10
 800a6c6:	f000 82c2 	beq.w	800ac4e <HAL_UART_Init+0xace>
 800a6ca:	2d0b      	cmp	r5, #11
 800a6cc:	bf0c      	ite	eq
 800a6ce:	f44f 7380 	moveq.w	r3, #256	; 0x100
 800a6d2:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 800a6d6:	6861      	ldr	r1, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 800a6d8:	2200      	movs	r2, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a6da:	eb03 0351 	add.w	r3, r3, r1, lsr #1
 800a6de:	fbb3 f3f1 	udiv	r3, r3, r1
 800a6e2:	b29b      	uxth	r3, r3
        break;
 800a6e4:	e775      	b.n	800a5d2 <HAL_UART_Init+0x452>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a6e6:	2d00      	cmp	r5, #0
 800a6e8:	f000 813d 	beq.w	800a966 <HAL_UART_Init+0x7e6>
 800a6ec:	2d01      	cmp	r5, #1
 800a6ee:	f000 816b 	beq.w	800a9c8 <HAL_UART_Init+0x848>
 800a6f2:	2d02      	cmp	r5, #2
 800a6f4:	f000 8185 	beq.w	800aa02 <HAL_UART_Init+0x882>
 800a6f8:	2d03      	cmp	r5, #3
 800a6fa:	f000 8198 	beq.w	800aa2e <HAL_UART_Init+0x8ae>
 800a6fe:	2d04      	cmp	r5, #4
 800a700:	f000 81ae 	beq.w	800aa60 <HAL_UART_Init+0x8e0>
 800a704:	2d05      	cmp	r5, #5
 800a706:	f000 81be 	beq.w	800aa86 <HAL_UART_Init+0x906>
 800a70a:	2d06      	cmp	r5, #6
 800a70c:	f000 81ea 	beq.w	800aae4 <HAL_UART_Init+0x964>
 800a710:	2d07      	cmp	r5, #7
 800a712:	f000 8208 	beq.w	800ab26 <HAL_UART_Init+0x9a6>
 800a716:	2d08      	cmp	r5, #8
 800a718:	f000 8227 	beq.w	800ab6a <HAL_UART_Init+0x9ea>
 800a71c:	2d09      	cmp	r5, #9
 800a71e:	f000 823a 	beq.w	800ab96 <HAL_UART_Init+0xa16>
 800a722:	2d0a      	cmp	r5, #10
 800a724:	f000 8296 	beq.w	800ac54 <HAL_UART_Init+0xad4>
 800a728:	4b39      	ldr	r3, [pc, #228]	; (800a810 <HAL_UART_Init+0x690>)
 800a72a:	4a3a      	ldr	r2, [pc, #232]	; (800a814 <HAL_UART_Init+0x694>)
 800a72c:	2d0b      	cmp	r5, #11
 800a72e:	bf18      	it	ne
 800a730:	4613      	movne	r3, r2
 800a732:	e7d0      	b.n	800a6d6 <HAL_UART_Init+0x556>
        pclk = HAL_RCC_GetPCLK1Freq();
 800a734:	f7fd f870 	bl	8007818 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a738:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a73a:	2b00      	cmp	r3, #0
 800a73c:	d095      	beq.n	800a66a <HAL_UART_Init+0x4ea>
 800a73e:	e773      	b.n	800a628 <HAL_UART_Init+0x4a8>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a740:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a742:	b303      	cbz	r3, 800a786 <HAL_UART_Init+0x606>
 800a744:	2b01      	cmp	r3, #1
 800a746:	f000 81b9 	beq.w	800aabc <HAL_UART_Init+0x93c>
 800a74a:	2b02      	cmp	r3, #2
 800a74c:	f000 81de 	beq.w	800ab0c <HAL_UART_Init+0x98c>
 800a750:	2b03      	cmp	r3, #3
 800a752:	f000 81f5 	beq.w	800ab40 <HAL_UART_Init+0x9c0>
 800a756:	2b04      	cmp	r3, #4
 800a758:	f000 8227 	beq.w	800abaa <HAL_UART_Init+0xa2a>
 800a75c:	2b05      	cmp	r3, #5
 800a75e:	f000 8214 	beq.w	800ab8a <HAL_UART_Init+0xa0a>
 800a762:	2b06      	cmp	r3, #6
 800a764:	f000 8265 	beq.w	800ac32 <HAL_UART_Init+0xab2>
 800a768:	2b07      	cmp	r3, #7
 800a76a:	f000 826c 	beq.w	800ac46 <HAL_UART_Init+0xac6>
 800a76e:	2b08      	cmp	r3, #8
 800a770:	f000 827b 	beq.w	800ac6a <HAL_UART_Init+0xaea>
 800a774:	2b09      	cmp	r3, #9
 800a776:	f000 8280 	beq.w	800ac7a <HAL_UART_Init+0xafa>
 800a77a:	2b0a      	cmp	r3, #10
 800a77c:	f000 8279 	beq.w	800ac72 <HAL_UART_Init+0xaf2>
 800a780:	2b0b      	cmp	r3, #11
 800a782:	f000 827e 	beq.w	800ac82 <HAL_UART_Init+0xb02>
 800a786:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 800a78a:	2100      	movs	r1, #0
 800a78c:	0853      	lsrs	r3, r2, #1
 800a78e:	18c0      	adds	r0, r0, r3
 800a790:	f141 0100 	adc.w	r1, r1, #0
 800a794:	2300      	movs	r3, #0
 800a796:	f7f6 fa9f 	bl	8000cd8 <__aeabi_uldivmod>
            break;
 800a79a:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800a79e:	4b1e      	ldr	r3, [pc, #120]	; (800a818 <HAL_UART_Init+0x698>)
 800a7a0:	429a      	cmp	r2, r3
 800a7a2:	f63f ad4a 	bhi.w	800a23a <HAL_UART_Init+0xba>
          huart->Instance->BRR = usartdiv;
 800a7a6:	6821      	ldr	r1, [r4, #0]
  huart->RxISR = NULL;
 800a7a8:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 800a7aa:	f04f 1201 	mov.w	r2, #65537	; 0x10001
          huart->Instance->BRR = usartdiv;
 800a7ae:	60c8      	str	r0, [r1, #12]
  huart->RxISR = NULL;
 800a7b0:	e9c4 231a 	strd	r2, r3, [r4, #104]	; 0x68
  huart->TxISR = NULL;
 800a7b4:	6723      	str	r3, [r4, #112]	; 0x70
  return ret;
 800a7b6:	e657      	b.n	800a468 <HAL_UART_Init+0x2e8>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a7b8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a7ba:	b303      	cbz	r3, 800a7fe <HAL_UART_Init+0x67e>
 800a7bc:	2b01      	cmp	r3, #1
 800a7be:	f000 8181 	beq.w	800aac4 <HAL_UART_Init+0x944>
 800a7c2:	2b02      	cmp	r3, #2
 800a7c4:	f000 8198 	beq.w	800aaf8 <HAL_UART_Init+0x978>
 800a7c8:	2b03      	cmp	r3, #3
 800a7ca:	f000 81b5 	beq.w	800ab38 <HAL_UART_Init+0x9b8>
 800a7ce:	2b04      	cmp	r3, #4
 800a7d0:	f000 81e8 	beq.w	800aba4 <HAL_UART_Init+0xa24>
 800a7d4:	2b05      	cmp	r3, #5
 800a7d6:	f000 8225 	beq.w	800ac24 <HAL_UART_Init+0xaa4>
 800a7da:	2b06      	cmp	r3, #6
 800a7dc:	f000 822c 	beq.w	800ac38 <HAL_UART_Init+0xab8>
 800a7e0:	2b07      	cmp	r3, #7
 800a7e2:	f000 822d 	beq.w	800ac40 <HAL_UART_Init+0xac0>
 800a7e6:	2b08      	cmp	r3, #8
 800a7e8:	f000 823c 	beq.w	800ac64 <HAL_UART_Init+0xae4>
 800a7ec:	2b09      	cmp	r3, #9
 800a7ee:	f000 8252 	beq.w	800ac96 <HAL_UART_Init+0xb16>
 800a7f2:	2b0a      	cmp	r3, #10
 800a7f4:	f000 824c 	beq.w	800ac90 <HAL_UART_Init+0xb10>
 800a7f8:	2b0b      	cmp	r3, #11
 800a7fa:	f000 8246 	beq.w	800ac8a <HAL_UART_Init+0xb0a>
 800a7fe:	4807      	ldr	r0, [pc, #28]	; (800a81c <HAL_UART_Init+0x69c>)
 800a800:	2100      	movs	r1, #0
 800a802:	e7c3      	b.n	800a78c <HAL_UART_Init+0x60c>
 800a804:	40021000 	.word	0x40021000
 800a808:	00f42400 	.word	0x00f42400
 800a80c:	0801a184 	.word	0x0801a184
 800a810:	0001e848 	.word	0x0001e848
 800a814:	01e84800 	.word	0x01e84800
 800a818:	000ffcff 	.word	0x000ffcff
 800a81c:	f4240000 	.word	0xf4240000
            pclk = HAL_RCC_GetSysClockFreq();
 800a820:	f7fc fb74 	bl	8006f0c <HAL_RCC_GetSysClockFreq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a824:	6a62      	ldr	r2, [r4, #36]	; 0x24
            pclk = HAL_RCC_GetSysClockFreq();
 800a826:	4603      	mov	r3, r0
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a828:	2100      	movs	r1, #0
 800a82a:	b30a      	cbz	r2, 800a870 <HAL_UART_Init+0x6f0>
 800a82c:	2a01      	cmp	r2, #1
 800a82e:	f000 8113 	beq.w	800aa58 <HAL_UART_Init+0x8d8>
 800a832:	2a02      	cmp	r2, #2
 800a834:	f000 8125 	beq.w	800aa82 <HAL_UART_Init+0x902>
 800a838:	2a03      	cmp	r2, #3
 800a83a:	f000 8157 	beq.w	800aaec <HAL_UART_Init+0x96c>
 800a83e:	2a04      	cmp	r2, #4
 800a840:	f000 816a 	beq.w	800ab18 <HAL_UART_Init+0x998>
 800a844:	2a05      	cmp	r2, #5
 800a846:	f000 8192 	beq.w	800ab6e <HAL_UART_Init+0x9ee>
 800a84a:	2a06      	cmp	r2, #6
 800a84c:	f000 81b1 	beq.w	800abb2 <HAL_UART_Init+0xa32>
 800a850:	2a07      	cmp	r2, #7
 800a852:	f000 81ec 	beq.w	800ac2e <HAL_UART_Init+0xaae>
 800a856:	2a08      	cmp	r2, #8
 800a858:	f000 81e7 	beq.w	800ac2a <HAL_UART_Init+0xaaa>
 800a85c:	2a09      	cmp	r2, #9
 800a85e:	f000 81fb 	beq.w	800ac58 <HAL_UART_Init+0xad8>
 800a862:	2a0a      	cmp	r2, #10
 800a864:	f000 81fb 	beq.w	800ac5e <HAL_UART_Init+0xade>
 800a868:	2a0b      	cmp	r2, #11
 800a86a:	bf04      	itt	eq
 800a86c:	0a1b      	lsreq	r3, r3, #8
 800a86e:	2100      	moveq	r1, #0
 800a870:	6862      	ldr	r2, [r4, #4]
 800a872:	020f      	lsls	r7, r1, #8
 800a874:	0850      	lsrs	r0, r2, #1
 800a876:	021e      	lsls	r6, r3, #8
 800a878:	ea47 6713 	orr.w	r7, r7, r3, lsr #24
 800a87c:	1830      	adds	r0, r6, r0
 800a87e:	f147 0100 	adc.w	r1, r7, #0
 800a882:	2300      	movs	r3, #0
 800a884:	f7f6 fa28 	bl	8000cd8 <__aeabi_uldivmod>
            break;
 800a888:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
 800a88c:	e787      	b.n	800a79e <HAL_UART_Init+0x61e>
            pclk = HAL_RCC_GetPCLK1Freq();
 800a88e:	f7fc ffc3 	bl	8007818 <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a892:	6a62      	ldr	r2, [r4, #36]	; 0x24
            pclk = HAL_RCC_GetPCLK1Freq();
 800a894:	4603      	mov	r3, r0
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a896:	2100      	movs	r1, #0
 800a898:	2a00      	cmp	r2, #0
 800a89a:	d0e9      	beq.n	800a870 <HAL_UART_Init+0x6f0>
 800a89c:	e7c6      	b.n	800a82c <HAL_UART_Init+0x6ac>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 800a89e:	f7fc ffbb 	bl	8007818 <HAL_RCC_GetPCLK1Freq>
 800a8a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a8a4:	b1eb      	cbz	r3, 800a8e2 <HAL_UART_Init+0x762>
 800a8a6:	2b01      	cmp	r3, #1
 800a8a8:	d078      	beq.n	800a99c <HAL_UART_Init+0x81c>
 800a8aa:	2b02      	cmp	r3, #2
 800a8ac:	d06f      	beq.n	800a98e <HAL_UART_Init+0x80e>
 800a8ae:	2b03      	cmp	r3, #3
 800a8b0:	d06a      	beq.n	800a988 <HAL_UART_Init+0x808>
 800a8b2:	2b04      	cmp	r3, #4
 800a8b4:	f000 809e 	beq.w	800a9f4 <HAL_UART_Init+0x874>
 800a8b8:	2b05      	cmp	r3, #5
 800a8ba:	f000 8098 	beq.w	800a9ee <HAL_UART_Init+0x86e>
 800a8be:	2b06      	cmp	r3, #6
 800a8c0:	f000 80eb 	beq.w	800aa9a <HAL_UART_Init+0x91a>
 800a8c4:	2b07      	cmp	r3, #7
 800a8c6:	f000 810f 	beq.w	800aae8 <HAL_UART_Init+0x968>
 800a8ca:	2b08      	cmp	r3, #8
 800a8cc:	f000 812d 	beq.w	800ab2a <HAL_UART_Init+0x9aa>
 800a8d0:	2b09      	cmp	r3, #9
 800a8d2:	f000 8140 	beq.w	800ab56 <HAL_UART_Init+0x9d6>
 800a8d6:	2b0a      	cmp	r3, #10
 800a8d8:	f000 8162 	beq.w	800aba0 <HAL_UART_Init+0xa20>
 800a8dc:	2b0b      	cmp	r3, #11
 800a8de:	bf08      	it	eq
 800a8e0:	0a00      	lsreq	r0, r0, #8
        break;
 800a8e2:	2300      	movs	r3, #0
 800a8e4:	e533      	b.n	800a34e <HAL_UART_Init+0x1ce>
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 800a8e6:	2900      	cmp	r1, #0
 800a8e8:	d039      	beq.n	800a95e <HAL_UART_Init+0x7de>
 800a8ea:	2901      	cmp	r1, #1
 800a8ec:	d05d      	beq.n	800a9aa <HAL_UART_Init+0x82a>
 800a8ee:	2902      	cmp	r1, #2
 800a8f0:	d06f      	beq.n	800a9d2 <HAL_UART_Init+0x852>
 800a8f2:	2903      	cmp	r1, #3
 800a8f4:	f000 8087 	beq.w	800aa06 <HAL_UART_Init+0x886>
 800a8f8:	2904      	cmp	r1, #4
 800a8fa:	f000 809a 	beq.w	800aa32 <HAL_UART_Init+0x8b2>
 800a8fe:	2905      	cmp	r1, #5
 800a900:	f000 80ac 	beq.w	800aa5c <HAL_UART_Init+0x8dc>
 800a904:	2906      	cmp	r1, #6
 800a906:	f000 80c3 	beq.w	800aa90 <HAL_UART_Init+0x910>
 800a90a:	2907      	cmp	r1, #7
 800a90c:	f000 80e0 	beq.w	800aad0 <HAL_UART_Init+0x950>
 800a910:	2908      	cmp	r1, #8
 800a912:	f000 80ff 	beq.w	800ab14 <HAL_UART_Init+0x994>
 800a916:	2909      	cmp	r1, #9
 800a918:	f000 812f 	beq.w	800ab7a <HAL_UART_Init+0x9fa>
 800a91c:	290a      	cmp	r1, #10
 800a91e:	f000 814e 	beq.w	800abbe <HAL_UART_Init+0xa3e>
 800a922:	4bab      	ldr	r3, [pc, #684]	; (800abd0 <HAL_UART_Init+0xa50>)
 800a924:	f24f 4024 	movw	r0, #62500	; 0xf424
 800a928:	290b      	cmp	r1, #11
 800a92a:	bf18      	it	ne
 800a92c:	4618      	movne	r0, r3
        break;
 800a92e:	2302      	movs	r3, #2
 800a930:	e53f      	b.n	800a3b2 <HAL_UART_Init+0x232>
 800a932:	4ba7      	ldr	r3, [pc, #668]	; (800abd0 <HAL_UART_Init+0xa50>)
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a934:	6861      	ldr	r1, [r4, #4]
  HAL_StatusTypeDef ret               = HAL_OK;
 800a936:	2200      	movs	r2, #0
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800a938:	eb03 0351 	add.w	r3, r3, r1, lsr #1
 800a93c:	fbb3 f3f1 	udiv	r3, r3, r1
 800a940:	b29b      	uxth	r3, r3
        break;
 800a942:	e57f      	b.n	800a444 <HAL_UART_Init+0x2c4>
 800a944:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800a948:	e7f4      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a94a:	4ba2      	ldr	r3, [pc, #648]	; (800abd4 <HAL_UART_Init+0xa54>)
 800a94c:	fba3 3000 	umull	r3, r0, r3, r0
 800a950:	0880      	lsrs	r0, r0, #2
 800a952:	e4ac      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800a954:	0840      	lsrs	r0, r0, #1
 800a956:	e4aa      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800a958:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800a95c:	e528      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800a95e:	489c      	ldr	r0, [pc, #624]	; (800abd0 <HAL_UART_Init+0xa50>)
 800a960:	e7e5      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800a962:	0840      	lsrs	r0, r0, #1
 800a964:	e681      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800a966:	4b9c      	ldr	r3, [pc, #624]	; (800abd8 <HAL_UART_Init+0xa58>)
 800a968:	e6b5      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800a96a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a96e:	e6b2      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800a970:	4b9a      	ldr	r3, [pc, #616]	; (800abdc <HAL_UART_Init+0xa5c>)
 800a972:	fba3 3000 	umull	r3, r0, r3, r0
 800a976:	08c0      	lsrs	r0, r0, #3
 800a978:	e499      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800a97a:	0880      	lsrs	r0, r0, #2
 800a97c:	e675      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800a97e:	4b98      	ldr	r3, [pc, #608]	; (800abe0 <HAL_UART_Init+0xa60>)
 800a980:	e7d8      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a982:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800a986:	e7d5      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a988:	4b92      	ldr	r3, [pc, #584]	; (800abd4 <HAL_UART_Init+0xa54>)
 800a98a:	fba3 3000 	umull	r3, r0, r3, r0
 800a98e:	0880      	lsrs	r0, r0, #2
 800a990:	e7a7      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800a992:	4b90      	ldr	r3, [pc, #576]	; (800abd4 <HAL_UART_Init+0xa54>)
 800a994:	fba3 3000 	umull	r3, r0, r3, r0
 800a998:	0880      	lsrs	r0, r0, #2
 800a99a:	e4d7      	b.n	800a34c <HAL_UART_Init+0x1cc>
 800a99c:	0840      	lsrs	r0, r0, #1
 800a99e:	e7a0      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800a9a0:	0840      	lsrs	r0, r0, #1
 800a9a2:	e4d3      	b.n	800a34c <HAL_UART_Init+0x1cc>
 800a9a4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800a9a8:	e502      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800a9aa:	488d      	ldr	r0, [pc, #564]	; (800abe0 <HAL_UART_Init+0xa60>)
 800a9ac:	e7bf      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800a9ae:	4b89      	ldr	r3, [pc, #548]	; (800abd4 <HAL_UART_Init+0xa54>)
 800a9b0:	fba3 2300 	umull	r2, r3, r3, r0
 800a9b4:	0898      	lsrs	r0, r3, #2
 800a9b6:	e658      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800a9b8:	4b8a      	ldr	r3, [pc, #552]	; (800abe4 <HAL_UART_Init+0xa64>)
 800a9ba:	e7bb      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a9bc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800a9c0:	e7b8      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a9c2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800a9c6:	e686      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800a9c8:	4b81      	ldr	r3, [pc, #516]	; (800abd0 <HAL_UART_Init+0xa50>)
 800a9ca:	e684      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800a9cc:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800a9d0:	e4ee      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800a9d2:	4884      	ldr	r0, [pc, #528]	; (800abe4 <HAL_UART_Init+0xa64>)
 800a9d4:	e7ab      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800a9d6:	08c0      	lsrs	r0, r0, #3
 800a9d8:	e647      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800a9da:	4b83      	ldr	r3, [pc, #524]	; (800abe8 <HAL_UART_Init+0xa68>)
 800a9dc:	e7aa      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a9de:	f241 5355 	movw	r3, #5461	; 0x1555
 800a9e2:	e7a7      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800a9e4:	4b7b      	ldr	r3, [pc, #492]	; (800abd4 <HAL_UART_Init+0xa54>)
 800a9e6:	fba3 3000 	umull	r3, r0, r3, r0
 800a9ea:	08c0      	lsrs	r0, r0, #3
 800a9ec:	e45f      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800a9ee:	4b7b      	ldr	r3, [pc, #492]	; (800abdc <HAL_UART_Init+0xa5c>)
 800a9f0:	fba3 3000 	umull	r3, r0, r3, r0
 800a9f4:	08c0      	lsrs	r0, r0, #3
 800a9f6:	e774      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800a9f8:	4b78      	ldr	r3, [pc, #480]	; (800abdc <HAL_UART_Init+0xa5c>)
 800a9fa:	fba3 3000 	umull	r3, r0, r3, r0
 800a9fe:	08c0      	lsrs	r0, r0, #3
 800aa00:	e4a4      	b.n	800a34c <HAL_UART_Init+0x1cc>
 800aa02:	4b77      	ldr	r3, [pc, #476]	; (800abe0 <HAL_UART_Init+0xa60>)
 800aa04:	e667      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa06:	4878      	ldr	r0, [pc, #480]	; (800abe8 <HAL_UART_Init+0xa68>)
 800aa08:	e791      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800aa0a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800aa0e:	e662      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa10:	f241 5055 	movw	r0, #5461	; 0x1555
 800aa14:	e4cc      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800aa16:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800aa1a:	e78b      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aa1c:	4b73      	ldr	r3, [pc, #460]	; (800abec <HAL_UART_Init+0xa6c>)
 800aa1e:	e789      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aa20:	4b6e      	ldr	r3, [pc, #440]	; (800abdc <HAL_UART_Init+0xa5c>)
 800aa22:	fba3 2300 	umull	r2, r3, r3, r0
 800aa26:	08d8      	lsrs	r0, r3, #3
 800aa28:	e61f      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800aa2a:	0900      	lsrs	r0, r0, #4
 800aa2c:	e43f      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800aa2e:	4b70      	ldr	r3, [pc, #448]	; (800abf0 <HAL_UART_Init+0xa70>)
 800aa30:	e651      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa32:	486e      	ldr	r0, [pc, #440]	; (800abec <HAL_UART_Init+0xa6c>)
 800aa34:	e77b      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800aa36:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 800aa3a:	e64c      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa3c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800aa40:	e4b6      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800aa42:	230c      	movs	r3, #12
 800aa44:	fbb0 f0f3 	udiv	r0, r0, r3
 800aa48:	e60f      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800aa4a:	4b6a      	ldr	r3, [pc, #424]	; (800abf4 <HAL_UART_Init+0xa74>)
 800aa4c:	e772      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aa4e:	f640 43cc 	movw	r3, #3276	; 0xccc
 800aa52:	e76f      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aa54:	0940      	lsrs	r0, r0, #5
 800aa56:	e42a      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800aa58:	085b      	lsrs	r3, r3, #1
 800aa5a:	e709      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800aa5c:	4865      	ldr	r0, [pc, #404]	; (800abf4 <HAL_UART_Init+0xa74>)
 800aa5e:	e766      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800aa60:	4b60      	ldr	r3, [pc, #384]	; (800abe4 <HAL_UART_Init+0xa64>)
 800aa62:	e638      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa64:	f640 40cc 	movw	r0, #3276	; 0xccc
 800aa68:	e4a2      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800aa6a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800aa6e:	e632      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa70:	0900      	lsrs	r0, r0, #4
 800aa72:	e5fa      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800aa74:	f640 23aa 	movw	r3, #2730	; 0xaaa
 800aa78:	e75c      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aa7a:	4b5f      	ldr	r3, [pc, #380]	; (800abf8 <HAL_UART_Init+0xa78>)
 800aa7c:	e75a      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aa7e:	0980      	lsrs	r0, r0, #6
 800aa80:	e415      	b.n	800a2ae <HAL_UART_Init+0x12e>
 800aa82:	089b      	lsrs	r3, r3, #2
 800aa84:	e6f4      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800aa86:	4b5d      	ldr	r3, [pc, #372]	; (800abfc <HAL_UART_Init+0xa7c>)
 800aa88:	e625      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa8a:	f640 20aa 	movw	r0, #2730	; 0xaaa
 800aa8e:	e48f      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800aa90:	4859      	ldr	r0, [pc, #356]	; (800abf8 <HAL_UART_Init+0xa78>)
 800aa92:	e74c      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800aa94:	f641 1398 	movw	r3, #6552	; 0x1998
 800aa98:	e61d      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aa9a:	4b4e      	ldr	r3, [pc, #312]	; (800abd4 <HAL_UART_Init+0xa54>)
 800aa9c:	fba3 3000 	umull	r3, r0, r3, r0
 800aaa0:	08c0      	lsrs	r0, r0, #3
 800aaa2:	e71e      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800aaa4:	4b4b      	ldr	r3, [pc, #300]	; (800abd4 <HAL_UART_Init+0xa54>)
 800aaa6:	fba3 3000 	umull	r3, r0, r3, r0
 800aaaa:	08c0      	lsrs	r0, r0, #3
 800aaac:	e44e      	b.n	800a34c <HAL_UART_Init+0x1cc>
 800aaae:	0940      	lsrs	r0, r0, #5
 800aab0:	e5db      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800aab2:	4b53      	ldr	r3, [pc, #332]	; (800ac00 <HAL_UART_Init+0xa80>)
 800aab4:	e73e      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aab6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800aaba:	e73b      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800aabc:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800aac0:	2100      	movs	r1, #0
 800aac2:	e663      	b.n	800a78c <HAL_UART_Init+0x60c>
 800aac4:	484f      	ldr	r0, [pc, #316]	; (800ac04 <HAL_UART_Init+0xa84>)
 800aac6:	2100      	movs	r1, #0
 800aac8:	e660      	b.n	800a78c <HAL_UART_Init+0x60c>
 800aaca:	09c0      	lsrs	r0, r0, #7
 800aacc:	f7ff bbef 	b.w	800a2ae <HAL_UART_Init+0x12e>
 800aad0:	484b      	ldr	r0, [pc, #300]	; (800ac00 <HAL_UART_Init+0xa80>)
 800aad2:	e72c      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800aad4:	f241 5354 	movw	r3, #5460	; 0x1554
 800aad8:	e5fd      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aada:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800aade:	e467      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800aae0:	0900      	lsrs	r0, r0, #4
 800aae2:	e433      	b.n	800a34c <HAL_UART_Init+0x1cc>
 800aae4:	4b40      	ldr	r3, [pc, #256]	; (800abe8 <HAL_UART_Init+0xa68>)
 800aae6:	e5f6      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800aae8:	0900      	lsrs	r0, r0, #4
 800aaea:	e6fa      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800aaec:	2300      	movs	r3, #0
 800aaee:	2206      	movs	r2, #6
 800aaf0:	f7f6 f8f2 	bl	8000cd8 <__aeabi_uldivmod>
 800aaf4:	4603      	mov	r3, r0
 800aaf6:	e6bb      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800aaf8:	4843      	ldr	r0, [pc, #268]	; (800ac08 <HAL_UART_Init+0xa88>)
 800aafa:	2100      	movs	r1, #0
 800aafc:	e646      	b.n	800a78c <HAL_UART_Init+0x60c>
 800aafe:	0980      	lsrs	r0, r0, #6
 800ab00:	e5b3      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800ab02:	4b42      	ldr	r3, [pc, #264]	; (800ac0c <HAL_UART_Init+0xa8c>)
 800ab04:	e716      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800ab06:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ab0a:	e713      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800ab0c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800ab10:	2100      	movs	r1, #0
 800ab12:	e63b      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ab14:	483d      	ldr	r0, [pc, #244]	; (800ac0c <HAL_UART_Init+0xa8c>)
 800ab16:	e70a      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800ab18:	08db      	lsrs	r3, r3, #3
 800ab1a:	e6a9      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800ab1c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800ab20:	e446      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800ab22:	0940      	lsrs	r0, r0, #5
 800ab24:	e412      	b.n	800a34c <HAL_UART_Init+0x1cc>
 800ab26:	4b31      	ldr	r3, [pc, #196]	; (800abec <HAL_UART_Init+0xa6c>)
 800ab28:	e5d5      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ab2a:	0940      	lsrs	r0, r0, #5
 800ab2c:	e6d9      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800ab2e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ab32:	e5d0      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ab34:	09c0      	lsrs	r0, r0, #7
 800ab36:	e598      	b.n	800a66a <HAL_UART_Init+0x4ea>
 800ab38:	a123      	add	r1, pc, #140	; (adr r1, 800abc8 <HAL_UART_Init+0xa48>)
 800ab3a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800ab3e:	e625      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ab40:	4833      	ldr	r0, [pc, #204]	; (800ac10 <HAL_UART_Init+0xa90>)
 800ab42:	2100      	movs	r1, #0
 800ab44:	e622      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ab46:	4b33      	ldr	r3, [pc, #204]	; (800ac14 <HAL_UART_Init+0xa94>)
 800ab48:	e6f4      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800ab4a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ab4e:	e6f1      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800ab50:	0980      	lsrs	r0, r0, #6
 800ab52:	f7ff bbfb 	b.w	800a34c <HAL_UART_Init+0x1cc>
 800ab56:	0980      	lsrs	r0, r0, #6
 800ab58:	e6c3      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800ab5a:	4b2f      	ldr	r3, [pc, #188]	; (800ac18 <HAL_UART_Init+0xa98>)
 800ab5c:	e6ea      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800ab5e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ab62:	e6e7      	b.n	800a934 <HAL_UART_Init+0x7b4>
 800ab64:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ab68:	e5b5      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ab6a:	4b25      	ldr	r3, [pc, #148]	; (800ac00 <HAL_UART_Init+0xa80>)
 800ab6c:	e5b3      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ab6e:	2300      	movs	r3, #0
 800ab70:	220a      	movs	r2, #10
 800ab72:	f7f6 f8b1 	bl	8000cd8 <__aeabi_uldivmod>
 800ab76:	4603      	mov	r3, r0
 800ab78:	e67a      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800ab7a:	4826      	ldr	r0, [pc, #152]	; (800ac14 <HAL_UART_Init+0xa94>)
 800ab7c:	e6d7      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800ab7e:	f44f 7000 	mov.w	r0, #512	; 0x200
 800ab82:	e415      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800ab84:	f44f 7080 	mov.w	r0, #256	; 0x100
 800ab88:	e412      	b.n	800a3b0 <HAL_UART_Init+0x230>
 800ab8a:	4824      	ldr	r0, [pc, #144]	; (800ac1c <HAL_UART_Init+0xa9c>)
 800ab8c:	2100      	movs	r1, #0
 800ab8e:	e5fd      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ab90:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ab94:	e59f      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ab96:	4b1d      	ldr	r3, [pc, #116]	; (800ac0c <HAL_UART_Init+0xa8c>)
 800ab98:	e59d      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ab9a:	09c0      	lsrs	r0, r0, #7
 800ab9c:	f7ff bbd6 	b.w	800a34c <HAL_UART_Init+0x1cc>
 800aba0:	09c0      	lsrs	r0, r0, #7
 800aba2:	e69e      	b.n	800a8e2 <HAL_UART_Init+0x762>
 800aba4:	481e      	ldr	r0, [pc, #120]	; (800ac20 <HAL_UART_Init+0xaa0>)
 800aba6:	2100      	movs	r1, #0
 800aba8:	e5f0      	b.n	800a78c <HAL_UART_Init+0x60c>
 800abaa:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800abae:	2100      	movs	r1, #0
 800abb0:	e5ec      	b.n	800a78c <HAL_UART_Init+0x60c>
 800abb2:	2300      	movs	r3, #0
 800abb4:	220c      	movs	r2, #12
 800abb6:	f7f6 f88f 	bl	8000cd8 <__aeabi_uldivmod>
 800abba:	4603      	mov	r3, r0
 800abbc:	e658      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800abbe:	4816      	ldr	r0, [pc, #88]	; (800ac18 <HAL_UART_Init+0xa98>)
 800abc0:	e6b5      	b.n	800a92e <HAL_UART_Init+0x7ae>
 800abc2:	bf00      	nop
 800abc4:	f3af 8000 	nop.w
 800abc8:	28b0aa00 	.word	0x28b0aa00
 800abcc:	00000000 	.word	0x00000000
 800abd0:	00f42400 	.word	0x00f42400
 800abd4:	aaaaaaab 	.word	0xaaaaaaab
 800abd8:	01e84800 	.word	0x01e84800
 800abdc:	cccccccd 	.word	0xcccccccd
 800abe0:	007a1200 	.word	0x007a1200
 800abe4:	003d0900 	.word	0x003d0900
 800abe8:	0028b0aa 	.word	0x0028b0aa
 800abec:	001e8480 	.word	0x001e8480
 800abf0:	00516154 	.word	0x00516154
 800abf4:	00186a00 	.word	0x00186a00
 800abf8:	00145855 	.word	0x00145855
 800abfc:	0030d400 	.word	0x0030d400
 800ac00:	000f4240 	.word	0x000f4240
 800ac04:	7a120000 	.word	0x7a120000
 800ac08:	3d090000 	.word	0x3d090000
 800ac0c:	0007a120 	.word	0x0007a120
 800ac10:	00155500 	.word	0x00155500
 800ac14:	0003d090 	.word	0x0003d090
 800ac18:	0001e848 	.word	0x0001e848
 800ac1c:	000ccc00 	.word	0x000ccc00
 800ac20:	1e848000 	.word	0x1e848000
 800ac24:	4820      	ldr	r0, [pc, #128]	; (800aca8 <HAL_UART_Init+0xb28>)
 800ac26:	2100      	movs	r1, #0
 800ac28:	e5b0      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac2a:	095b      	lsrs	r3, r3, #5
 800ac2c:	e620      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800ac2e:	091b      	lsrs	r3, r3, #4
 800ac30:	e61e      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800ac32:	481e      	ldr	r0, [pc, #120]	; (800acac <HAL_UART_Init+0xb2c>)
 800ac34:	2100      	movs	r1, #0
 800ac36:	e5a9      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac38:	a119      	add	r1, pc, #100	; (adr r1, 800aca0 <HAL_UART_Init+0xb20>)
 800ac3a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800ac3e:	e5a5      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac40:	481b      	ldr	r0, [pc, #108]	; (800acb0 <HAL_UART_Init+0xb30>)
 800ac42:	2100      	movs	r1, #0
 800ac44:	e5a2      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac46:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800ac4a:	2100      	movs	r1, #0
 800ac4c:	e59e      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac4e:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ac52:	e540      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ac54:	4b17      	ldr	r3, [pc, #92]	; (800acb4 <HAL_UART_Init+0xb34>)
 800ac56:	e53e      	b.n	800a6d6 <HAL_UART_Init+0x556>
 800ac58:	099b      	lsrs	r3, r3, #6
 800ac5a:	2100      	movs	r1, #0
 800ac5c:	e608      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800ac5e:	09db      	lsrs	r3, r3, #7
 800ac60:	2100      	movs	r1, #0
 800ac62:	e605      	b.n	800a870 <HAL_UART_Init+0x6f0>
 800ac64:	4814      	ldr	r0, [pc, #80]	; (800acb8 <HAL_UART_Init+0xb38>)
 800ac66:	2100      	movs	r1, #0
 800ac68:	e590      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac6a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800ac6e:	2100      	movs	r1, #0
 800ac70:	e58c      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac72:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800ac76:	2100      	movs	r1, #0
 800ac78:	e588      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac7a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800ac7e:	2100      	movs	r1, #0
 800ac80:	e584      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac82:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800ac86:	2100      	movs	r1, #0
 800ac88:	e580      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac8a:	480c      	ldr	r0, [pc, #48]	; (800acbc <HAL_UART_Init+0xb3c>)
 800ac8c:	2100      	movs	r1, #0
 800ac8e:	e57d      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac90:	480b      	ldr	r0, [pc, #44]	; (800acc0 <HAL_UART_Init+0xb40>)
 800ac92:	2100      	movs	r1, #0
 800ac94:	e57a      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac96:	480b      	ldr	r0, [pc, #44]	; (800acc4 <HAL_UART_Init+0xb44>)
 800ac98:	2100      	movs	r1, #0
 800ac9a:	e577      	b.n	800a78c <HAL_UART_Init+0x60c>
 800ac9c:	f3af 8000 	nop.w
 800aca0:	14585500 	.word	0x14585500
 800aca4:	00000000 	.word	0x00000000
 800aca8:	186a0000 	.word	0x186a0000
 800acac:	000aaa00 	.word	0x000aaa00
 800acb0:	0f424000 	.word	0x0f424000
 800acb4:	0003d090 	.word	0x0003d090
 800acb8:	07a12000 	.word	0x07a12000
 800acbc:	00f42400 	.word	0x00f42400
 800acc0:	01e84800 	.word	0x01e84800
 800acc4:	03d09000 	.word	0x03d09000

0800acc8 <UART_WaitOnFlagUntilTimeout>:
{
 800acc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800accc:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800acd0:	6804      	ldr	r4, [r0, #0]
 800acd2:	4607      	mov	r7, r0
 800acd4:	460e      	mov	r6, r1
 800acd6:	4615      	mov	r5, r2
 800acd8:	4699      	mov	r9, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800acda:	f1b8 3fff 	cmp.w	r8, #4294967295
 800acde:	d10a      	bne.n	800acf6 <UART_WaitOnFlagUntilTimeout+0x2e>
 800ace0:	69e3      	ldr	r3, [r4, #28]
 800ace2:	ea36 0303 	bics.w	r3, r6, r3
 800ace6:	bf0c      	ite	eq
 800ace8:	2301      	moveq	r3, #1
 800acea:	2300      	movne	r3, #0
 800acec:	429d      	cmp	r5, r3
 800acee:	d0f7      	beq.n	800ace0 <UART_WaitOnFlagUntilTimeout+0x18>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 800acf0:	2000      	movs	r0, #0
}
 800acf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800acf6:	69e3      	ldr	r3, [r4, #28]
 800acf8:	ea36 0303 	bics.w	r3, r6, r3
 800acfc:	bf0c      	ite	eq
 800acfe:	2301      	moveq	r3, #1
 800ad00:	2300      	movne	r3, #0
 800ad02:	429d      	cmp	r5, r3
 800ad04:	d1f4      	bne.n	800acf0 <UART_WaitOnFlagUntilTimeout+0x28>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ad06:	f7f9 ff6b 	bl	8004be0 <HAL_GetTick>
 800ad0a:	eba0 0009 	sub.w	r0, r0, r9
 800ad0e:	4540      	cmp	r0, r8
 800ad10:	d820      	bhi.n	800ad54 <UART_WaitOnFlagUntilTimeout+0x8c>
 800ad12:	f1b8 0f00 	cmp.w	r8, #0
 800ad16:	d01d      	beq.n	800ad54 <UART_WaitOnFlagUntilTimeout+0x8c>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800ad18:	683c      	ldr	r4, [r7, #0]
 800ad1a:	6823      	ldr	r3, [r4, #0]
 800ad1c:	075a      	lsls	r2, r3, #29
 800ad1e:	d5dc      	bpl.n	800acda <UART_WaitOnFlagUntilTimeout+0x12>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800ad20:	69e3      	ldr	r3, [r4, #28]
 800ad22:	051b      	lsls	r3, r3, #20
 800ad24:	d5d9      	bpl.n	800acda <UART_WaitOnFlagUntilTimeout+0x12>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800ad26:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ad2a:	6223      	str	r3, [r4, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800ad2c:	6823      	ldr	r3, [r4, #0]
 800ad2e:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800ad32:	6023      	str	r3, [r4, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ad34:	68a2      	ldr	r2, [r4, #8]
          huart->gState = HAL_UART_STATE_READY;
 800ad36:	2320      	movs	r3, #32
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ad38:	f022 0201 	bic.w	r2, r2, #1
          __HAL_UNLOCK(huart);
 800ad3c:	2100      	movs	r1, #0
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ad3e:	60a2      	str	r2, [r4, #8]
          return HAL_TIMEOUT;
 800ad40:	2003      	movs	r0, #3
          huart->gState = HAL_UART_STATE_READY;
 800ad42:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
          __HAL_UNLOCK(huart);
 800ad46:	f887 107c 	strb.w	r1, [r7, #124]	; 0x7c
          huart->RxState = HAL_UART_STATE_READY;
 800ad4a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800ad4e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
          return HAL_TIMEOUT;
 800ad52:	e7ce      	b.n	800acf2 <UART_WaitOnFlagUntilTimeout+0x2a>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800ad54:	683b      	ldr	r3, [r7, #0]
 800ad56:	681a      	ldr	r2, [r3, #0]
 800ad58:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800ad5c:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ad5e:	689a      	ldr	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800ad60:	2120      	movs	r1, #32
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ad62:	f022 0201 	bic.w	r2, r2, #1
        __HAL_UNLOCK(huart);
 800ad66:	2400      	movs	r4, #0
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ad68:	609a      	str	r2, [r3, #8]
        __HAL_UNLOCK(huart);
 800ad6a:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 800ad6c:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
        __HAL_UNLOCK(huart);
 800ad70:	f887 407c 	strb.w	r4, [r7, #124]	; 0x7c
        huart->RxState = HAL_UART_STATE_READY;
 800ad74:	f8c7 1084 	str.w	r1, [r7, #132]	; 0x84
        return HAL_TIMEOUT;
 800ad78:	e7bb      	b.n	800acf2 <UART_WaitOnFlagUntilTimeout+0x2a>
 800ad7a:	bf00      	nop

0800ad7c <HAL_UART_Transmit>:
{
 800ad7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ad80:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 800ad82:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800ad86:	2820      	cmp	r0, #32
{
 800ad88:	b083      	sub	sp, #12
  if (huart->gState == HAL_UART_STATE_READY)
 800ad8a:	d17b      	bne.n	800ae84 <HAL_UART_Transmit+0x108>
    if ((pData == NULL) || (Size == 0U))
 800ad8c:	4688      	mov	r8, r1
 800ad8e:	2900      	cmp	r1, #0
 800ad90:	d048      	beq.n	800ae24 <HAL_UART_Transmit+0xa8>
 800ad92:	4617      	mov	r7, r2
 800ad94:	2a00      	cmp	r2, #0
 800ad96:	d045      	beq.n	800ae24 <HAL_UART_Transmit+0xa8>
 800ad98:	461d      	mov	r5, r3
    __HAL_LOCK(huart);
 800ad9a:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
 800ad9e:	2b01      	cmp	r3, #1
 800ada0:	d070      	beq.n	800ae84 <HAL_UART_Transmit+0x108>
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800ada2:	2321      	movs	r3, #33	; 0x21
    __HAL_LOCK(huart);
 800ada4:	2201      	movs	r2, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ada6:	f04f 0900 	mov.w	r9, #0
 800adaa:	f8c4 9088 	str.w	r9, [r4, #136]	; 0x88
    __HAL_LOCK(huart);
 800adae:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800adb2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    tickstart = HAL_GetTick();
 800adb6:	f7f9 ff13 	bl	8004be0 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800adba:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
 800adbc:	f8a4 7054 	strh.w	r7, [r4, #84]	; 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800adc0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 800adc4:	4606      	mov	r6, r0
    huart->TxXferCount = Size;
 800adc6:	f8a4 7056 	strh.w	r7, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800adca:	d05f      	beq.n	800ae8c <HAL_UART_Transmit+0x110>
      pdata16bits = NULL;
 800adcc:	464f      	mov	r7, r9
    while (huart->TxXferCount > 0U)
 800adce:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    __HAL_UNLOCK(huart);
 800add2:	2200      	movs	r2, #0
    while (huart->TxXferCount > 0U)
 800add4:	b29b      	uxth	r3, r3
    __HAL_UNLOCK(huart);
 800add6:	f884 207c 	strb.w	r2, [r4, #124]	; 0x7c
    while (huart->TxXferCount > 0U)
 800adda:	b1b3      	cbz	r3, 800ae0a <HAL_UART_Transmit+0x8e>
 800addc:	6822      	ldr	r2, [r4, #0]
 800adde:	1c69      	adds	r1, r5, #1
 800ade0:	d124      	bne.n	800ae2c <HAL_UART_Transmit+0xb0>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ade2:	69d3      	ldr	r3, [r2, #28]
 800ade4:	061b      	lsls	r3, r3, #24
 800ade6:	d5fc      	bpl.n	800ade2 <HAL_UART_Transmit+0x66>
      if (pdata8bits == NULL)
 800ade8:	f1b8 0f00 	cmp.w	r8, #0
 800adec:	d045      	beq.n	800ae7a <HAL_UART_Transmit+0xfe>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800adee:	f818 3b01 	ldrb.w	r3, [r8], #1
 800adf2:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 800adf4:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 800adf8:	3b01      	subs	r3, #1
 800adfa:	b29b      	uxth	r3, r3
 800adfc:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 800ae00:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 800ae04:	b29b      	uxth	r3, r3
 800ae06:	2b00      	cmp	r3, #0
 800ae08:	d1e9      	bne.n	800adde <HAL_UART_Transmit+0x62>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800ae0a:	9500      	str	r5, [sp, #0]
 800ae0c:	4633      	mov	r3, r6
 800ae0e:	2200      	movs	r2, #0
 800ae10:	2140      	movs	r1, #64	; 0x40
 800ae12:	4620      	mov	r0, r4
 800ae14:	f7ff ff58 	bl	800acc8 <UART_WaitOnFlagUntilTimeout>
 800ae18:	2800      	cmp	r0, #0
 800ae1a:	d152      	bne.n	800aec2 <HAL_UART_Transmit+0x146>
    huart->gState = HAL_UART_STATE_READY;
 800ae1c:	2320      	movs	r3, #32
 800ae1e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    return HAL_OK;
 800ae22:	e000      	b.n	800ae26 <HAL_UART_Transmit+0xaa>
      return  HAL_ERROR;
 800ae24:	2001      	movs	r0, #1
}
 800ae26:	b003      	add	sp, #12
 800ae28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ae2c:	69d3      	ldr	r3, [r2, #28]
 800ae2e:	f013 0980 	ands.w	r9, r3, #128	; 0x80
 800ae32:	d1d9      	bne.n	800ade8 <HAL_UART_Transmit+0x6c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ae34:	f7f9 fed4 	bl	8004be0 <HAL_GetTick>
 800ae38:	1b80      	subs	r0, r0, r6
 800ae3a:	4285      	cmp	r5, r0
 800ae3c:	d32c      	bcc.n	800ae98 <HAL_UART_Transmit+0x11c>
 800ae3e:	b35d      	cbz	r5, 800ae98 <HAL_UART_Transmit+0x11c>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800ae40:	6822      	ldr	r2, [r4, #0]
 800ae42:	6813      	ldr	r3, [r2, #0]
 800ae44:	075b      	lsls	r3, r3, #29
 800ae46:	d5ca      	bpl.n	800adde <HAL_UART_Transmit+0x62>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800ae48:	69d3      	ldr	r3, [r2, #28]
 800ae4a:	0518      	lsls	r0, r3, #20
 800ae4c:	d5c7      	bpl.n	800adde <HAL_UART_Transmit+0x62>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800ae4e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ae52:	6213      	str	r3, [r2, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800ae54:	6813      	ldr	r3, [r2, #0]
 800ae56:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800ae5a:	6013      	str	r3, [r2, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ae5c:	6891      	ldr	r1, [r2, #8]
          huart->gState = HAL_UART_STATE_READY;
 800ae5e:	2320      	movs	r3, #32
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ae60:	f021 0101 	bic.w	r1, r1, #1
 800ae64:	6091      	str	r1, [r2, #8]
        return HAL_TIMEOUT;
 800ae66:	2003      	movs	r0, #3
          huart->gState = HAL_UART_STATE_READY;
 800ae68:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
          __HAL_UNLOCK(huart);
 800ae6c:	f884 907c 	strb.w	r9, [r4, #124]	; 0x7c
          huart->RxState = HAL_UART_STATE_READY;
 800ae70:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800ae74:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          return HAL_TIMEOUT;
 800ae78:	e7d5      	b.n	800ae26 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800ae7a:	f837 3b02 	ldrh.w	r3, [r7], #2
 800ae7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ae82:	e7b6      	b.n	800adf2 <HAL_UART_Transmit+0x76>
    return HAL_BUSY;
 800ae84:	2002      	movs	r0, #2
}
 800ae86:	b003      	add	sp, #12
 800ae88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800ae8c:	6923      	ldr	r3, [r4, #16]
 800ae8e:	2b00      	cmp	r3, #0
 800ae90:	d19c      	bne.n	800adcc <HAL_UART_Transmit+0x50>
 800ae92:	4647      	mov	r7, r8
      pdata8bits  = NULL;
 800ae94:	4698      	mov	r8, r3
 800ae96:	e79a      	b.n	800adce <HAL_UART_Transmit+0x52>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 800ae98:	6823      	ldr	r3, [r4, #0]
 800ae9a:	681a      	ldr	r2, [r3, #0]
 800ae9c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800aea0:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800aea2:	689a      	ldr	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800aea4:	2120      	movs	r1, #32
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800aea6:	f022 0201 	bic.w	r2, r2, #1
        __HAL_UNLOCK(huart);
 800aeaa:	2500      	movs	r5, #0
        return HAL_TIMEOUT;
 800aeac:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800aeae:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800aeb0:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
        __HAL_UNLOCK(huart);
 800aeb4:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
        huart->RxState = HAL_UART_STATE_READY;
 800aeb8:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
}
 800aebc:	b003      	add	sp, #12
 800aebe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      return HAL_TIMEOUT;
 800aec2:	2003      	movs	r0, #3
 800aec4:	e7af      	b.n	800ae26 <HAL_UART_Transmit+0xaa>
 800aec6:	bf00      	nop

0800aec8 <HAL_UARTEx_DisableFifoMode>:

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 800aec8:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 800aecc:	2a01      	cmp	r2, #1
 800aece:	d017      	beq.n	800af00 <HAL_UARTEx_DisableFifoMode+0x38>

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800aed0:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800aed2:	2124      	movs	r1, #36	; 0x24
{
 800aed4:	b430      	push	{r4, r5}
  huart->gState = HAL_UART_STATE_BUSY;
 800aed6:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 800aeda:	4603      	mov	r3, r0
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800aedc:	6810      	ldr	r0, [r2, #0]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800aede:	6814      	ldr	r4, [r2, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800aee0:	2100      	movs	r1, #0
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 800aee2:	f020 5000 	bic.w	r0, r0, #536870912	; 0x20000000
  __HAL_UART_DISABLE(huart);
 800aee6:	f024 0401 	bic.w	r4, r4, #1
 800aeea:	6014      	str	r4, [r2, #0]

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);

  huart->gState = HAL_UART_STATE_READY;
 800aeec:	2520      	movs	r5, #32
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800aeee:	6659      	str	r1, [r3, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800aef0:	6010      	str	r0, [r2, #0]

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800aef2:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c

  return HAL_OK;
 800aef6:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 800aef8:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
}
 800aefc:	bc30      	pop	{r4, r5}
 800aefe:	4770      	bx	lr
  __HAL_LOCK(huart);
 800af00:	2002      	movs	r0, #2
}
 800af02:	4770      	bx	lr

0800af04 <HAL_UARTEx_SetTxFifoThreshold>:
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800af04:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 800af08:	2a01      	cmp	r2, #1
 800af0a:	d046      	beq.n	800af9a <HAL_UARTEx_SetTxFifoThreshold+0x96>
{
 800af0c:	b4f0      	push	{r4, r5, r6, r7}

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800af0e:	6802      	ldr	r2, [r0, #0]
  uint8_t rx_fifo_depth;
  uint8_t tx_fifo_depth;
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800af10:	4f23      	ldr	r7, [pc, #140]	; (800afa0 <HAL_UARTEx_SetTxFifoThreshold+0x9c>)
 800af12:	460c      	mov	r4, r1
  huart->gState = HAL_UART_STATE_BUSY;
 800af14:	2124      	movs	r1, #36	; 0x24
 800af16:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800af1a:	6816      	ldr	r6, [r2, #0]
  __HAL_UART_DISABLE(huart);
 800af1c:	6811      	ldr	r1, [r2, #0]
 800af1e:	f021 0101 	bic.w	r1, r1, #1
 800af22:	6011      	str	r1, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800af24:	4603      	mov	r3, r0
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800af26:	481f      	ldr	r0, [pc, #124]	; (800afa4 <HAL_UARTEx_SetTxFifoThreshold+0xa0>)
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800af28:	6895      	ldr	r5, [r2, #8]
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800af2a:	c803      	ldmia	r0, {r0, r1}
{
 800af2c:	b084      	sub	sp, #16
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800af2e:	f025 4560 	bic.w	r5, r5, #3758096384	; 0xe0000000
 800af32:	432c      	orrs	r4, r5
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800af34:	466d      	mov	r5, sp
 800af36:	e885 0003 	stmia.w	r5, {r0, r1}
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800af3a:	e897 0003 	ldmia.w	r7, {r0, r1}

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800af3e:	6e5d      	ldr	r5, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800af40:	6094      	str	r4, [r2, #8]
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800af42:	ac04      	add	r4, sp, #16
 800af44:	e904 0003 	stmdb	r4, {r0, r1}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800af48:	b325      	cbz	r5, 800af94 <HAL_UARTEx_SetTxFifoThreshold+0x90>
  }
  else
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 800af4a:	6894      	ldr	r4, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 800af4c:	6895      	ldr	r5, [r2, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800af4e:	a904      	add	r1, sp, #16
 800af50:	f3c4 6442 	ubfx	r4, r4, #25, #3
 800af54:	440c      	add	r4, r1
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800af56:	eb01 7555 	add.w	r5, r1, r5, lsr #29
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800af5a:	f814 1c10 	ldrb.w	r1, [r4, #-16]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800af5e:	f815 0c10 	ldrb.w	r0, [r5, #-16]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800af62:	f814 7c08 	ldrb.w	r7, [r4, #-8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800af66:	f815 4c08 	ldrb.w	r4, [r5, #-8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800af6a:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800af6c:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800af6e:	fbb1 f1f7 	udiv	r1, r1, r7
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800af72:	fbb0 f0f4 	udiv	r0, r0, r4
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800af76:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  __HAL_UNLOCK(huart);
 800af7a:	2100      	movs	r1, #0
 800af7c:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  huart->gState = HAL_UART_STATE_READY;
 800af80:	2420      	movs	r4, #32
  return HAL_OK;
 800af82:	4608      	mov	r0, r1
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800af84:	6016      	str	r6, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
 800af86:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
  __HAL_UNLOCK(huart);
 800af8a:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
}
 800af8e:	b004      	add	sp, #16
 800af90:	bcf0      	pop	{r4, r5, r6, r7}
 800af92:	4770      	bx	lr
    huart->NbRxDataToProcess = 1U;
 800af94:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 800af96:	4608      	mov	r0, r1
 800af98:	e7ed      	b.n	800af76 <HAL_UARTEx_SetTxFifoThreshold+0x72>
  __HAL_LOCK(huart);
 800af9a:	2002      	movs	r0, #2
}
 800af9c:	4770      	bx	lr
 800af9e:	bf00      	nop
 800afa0:	0801aaa4 	.word	0x0801aaa4
 800afa4:	0801a198 	.word	0x0801a198

0800afa8 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 800afa8:	f890 207c 	ldrb.w	r2, [r0, #124]	; 0x7c
 800afac:	2a01      	cmp	r2, #1
 800afae:	d046      	beq.n	800b03e <HAL_UARTEx_SetRxFifoThreshold+0x96>
{
 800afb0:	b4f0      	push	{r4, r5, r6, r7}
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800afb2:	6802      	ldr	r2, [r0, #0]
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800afb4:	4f23      	ldr	r7, [pc, #140]	; (800b044 <HAL_UARTEx_SetRxFifoThreshold+0x9c>)
 800afb6:	460c      	mov	r4, r1
  huart->gState = HAL_UART_STATE_BUSY;
 800afb8:	2124      	movs	r1, #36	; 0x24
 800afba:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800afbe:	6816      	ldr	r6, [r2, #0]
  __HAL_UART_DISABLE(huart);
 800afc0:	6811      	ldr	r1, [r2, #0]
 800afc2:	f021 0101 	bic.w	r1, r1, #1
 800afc6:	6011      	str	r1, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800afc8:	4603      	mov	r3, r0
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800afca:	481f      	ldr	r0, [pc, #124]	; (800b048 <HAL_UARTEx_SetRxFifoThreshold+0xa0>)
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800afcc:	6895      	ldr	r5, [r2, #8]
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800afce:	c803      	ldmia	r0, {r0, r1}
{
 800afd0:	b084      	sub	sp, #16
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800afd2:	f025 6560 	bic.w	r5, r5, #234881024	; 0xe000000
 800afd6:	432c      	orrs	r4, r5
  uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
 800afd8:	466d      	mov	r5, sp
 800afda:	e885 0003 	stmia.w	r5, {r0, r1}
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800afde:	e897 0003 	ldmia.w	r7, {r0, r1}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800afe2:	6e5d      	ldr	r5, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800afe4:	6094      	str	r4, [r2, #8]
  uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};
 800afe6:	ac04      	add	r4, sp, #16
 800afe8:	e904 0003 	stmdb	r4, {r0, r1}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800afec:	b325      	cbz	r5, 800b038 <HAL_UARTEx_SetRxFifoThreshold+0x90>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 800afee:	6894      	ldr	r4, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 800aff0:	6895      	ldr	r5, [r2, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800aff2:	a904      	add	r1, sp, #16
 800aff4:	f3c4 6442 	ubfx	r4, r4, #25, #3
 800aff8:	440c      	add	r4, r1
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800affa:	eb01 7555 	add.w	r5, r1, r5, lsr #29
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800affe:	f814 1c10 	ldrb.w	r1, [r4, #-16]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800b002:	f815 0c10 	ldrb.w	r0, [r5, #-16]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800b006:	f814 7c08 	ldrb.w	r7, [r4, #-8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800b00a:	f815 4c08 	ldrb.w	r4, [r5, #-8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800b00e:	00c9      	lsls	r1, r1, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800b010:	00c0      	lsls	r0, r0, #3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800b012:	fbb1 f1f7 	udiv	r1, r1, r7
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) / (uint16_t)denominator[tx_fifo_threshold];
 800b016:	fbb0 f0f4 	udiv	r0, r0, r4
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) / (uint16_t)denominator[rx_fifo_threshold];
 800b01a:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  __HAL_UNLOCK(huart);
 800b01e:	2100      	movs	r1, #0
 800b020:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  huart->gState = HAL_UART_STATE_READY;
 800b024:	2420      	movs	r4, #32
  return HAL_OK;
 800b026:	4608      	mov	r0, r1
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800b028:	6016      	str	r6, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
 800b02a:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
  __HAL_UNLOCK(huart);
 800b02e:	f883 107c 	strb.w	r1, [r3, #124]	; 0x7c
}
 800b032:	b004      	add	sp, #16
 800b034:	bcf0      	pop	{r4, r5, r6, r7}
 800b036:	4770      	bx	lr
    huart->NbRxDataToProcess = 1U;
 800b038:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 800b03a:	4608      	mov	r0, r1
 800b03c:	e7ed      	b.n	800b01a <HAL_UARTEx_SetRxFifoThreshold+0x72>
  __HAL_LOCK(huart);
 800b03e:	2002      	movs	r0, #2
}
 800b040:	4770      	bx	lr
 800b042:	bf00      	nop
 800b044:	0801aaa4 	.word	0x0801aaa4
 800b048:	0801a198 	.word	0x0801a198

0800b04c <SDMMC_Init>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Init SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 800b04c:	b084      	sub	sp, #16
 800b04e:	b430      	push	{r4, r5}
 800b050:	ac03      	add	r4, sp, #12
 800b052:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  /* Set SDMMC configuration parameters */
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  tmpreg |= Init.ClockBypass;
#endif
  tmpreg |= (Init.ClockEdge           |\
             Init.ClockPowerSave      |\
 800b056:	e9dd 5204 	ldrd	r5, r2, [sp, #16]
  tmpreg |= (Init.ClockEdge           |\
 800b05a:	460b      	mov	r3, r1
 800b05c:	432b      	orrs	r3, r5
             Init.BusWide             |\
             Init.HardwareFlowControl |\
 800b05e:	e9dd 4106 	ldrd	r4, r1, [sp, #24]
             Init.ClockDiv
             );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800b062:	6845      	ldr	r5, [r0, #4]
             Init.ClockPowerSave      |\
 800b064:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800b066:	4a05      	ldr	r2, [pc, #20]	; (800b07c <SDMMC_Init+0x30>)
             Init.BusWide             |\
 800b068:	4323      	orrs	r3, r4
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800b06a:	402a      	ands	r2, r5

  return HAL_OK;
}
 800b06c:	bc30      	pop	{r4, r5}
             Init.HardwareFlowControl |\
 800b06e:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800b070:	4313      	orrs	r3, r2
 800b072:	6043      	str	r3, [r0, #4]
}
 800b074:	b004      	add	sp, #16
 800b076:	2000      	movs	r0, #0
 800b078:	4770      	bx	lr
 800b07a:	bf00      	nop
 800b07c:	ffc02c00 	.word	0xffc02c00

0800b080 <SDMMC_ReadFIFO>:
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx)
{
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
 800b080:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 800b084:	4770      	bx	lr
 800b086:	bf00      	nop

0800b088 <SDMMC_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
 800b088:	680b      	ldr	r3, [r1, #0]
 800b08a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 800b08e:	2000      	movs	r0, #0
 800b090:	4770      	bx	lr
 800b092:	bf00      	nop

0800b094 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
 800b094:	b508      	push	{r3, lr}
 800b096:	4603      	mov	r3, r0
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* 1ms: required power up waiting time before starting the SD initialization
  sequence */
  HAL_Delay(2);
 800b098:	2002      	movs	r0, #2
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 800b09a:	681a      	ldr	r2, [r3, #0]
 800b09c:	f042 0203 	orr.w	r2, r2, #3
 800b0a0:	601a      	str	r2, [r3, #0]
  HAL_Delay(2);
 800b0a2:	f7f9 fda3 	bl	8004bec <HAL_Delay>

  return HAL_OK;
}
 800b0a6:	2000      	movs	r0, #0
 800b0a8:	bd08      	pop	{r3, pc}
 800b0aa:	bf00      	nop

0800b0ac <SDMMC_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 800b0ac:	6800      	ldr	r0, [r0, #0]
}
 800b0ae:	f000 0003 	and.w	r0, r0, #3
 800b0b2:	4770      	bx	lr

0800b0b4 <SDMMC_GetResponse>:

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 800b0b4:	3014      	adds	r0, #20

  return (*(__IO uint32_t *) tmp);
 800b0b6:	5840      	ldr	r0, [r0, r1]
}
 800b0b8:	4770      	bx	lr
 800b0ba:	bf00      	nop

0800b0bc <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data)
{
 800b0bc:	b430      	push	{r4, r5}

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 800b0be:	e9d1 4200 	ldrd	r4, r2, [r1]

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 800b0c2:	e9d1 3502 	ldrd	r3, r5, [r1, #8]
  SDMMCx->DTIMER = Data->DataTimeOut;
 800b0c6:	6244      	str	r4, [r0, #36]	; 0x24
                       Data->TransferDir   |\
 800b0c8:	690c      	ldr	r4, [r1, #16]
  SDMMCx->DLEN = Data->DataLength;
 800b0ca:	6282      	str	r2, [r0, #40]	; 0x28
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800b0cc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
                       Data->TransferMode  |\
 800b0ce:	6949      	ldr	r1, [r1, #20]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 800b0d0:	432b      	orrs	r3, r5
                       Data->TransferDir   |\
 800b0d2:	4323      	orrs	r3, r4
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800b0d4:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
                       Data->TransferMode  |\
 800b0d8:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800b0da:	4313      	orrs	r3, r2
 800b0dc:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
 800b0de:	bc30      	pop	{r4, r5}
 800b0e0:	2000      	movs	r0, #0
 800b0e2:	4770      	bx	lr

0800b0e4 <SDMMC_CmdBlockLength>:
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b0e4:	4a4d      	ldr	r2, [pc, #308]	; (800b21c <SDMMC_CmdBlockLength+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b0e6:	4b4e      	ldr	r3, [pc, #312]	; (800b220 <SDMMC_CmdBlockLength+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b0e8:	6812      	ldr	r2, [r2, #0]
{
 800b0ea:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800b0ec:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b0ee:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b0f0:	494c      	ldr	r1, [pc, #304]	; (800b224 <SDMMC_CmdBlockLength+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b0f2:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b0f4:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b0f8:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b0fc:	0a52      	lsrs	r2, r2, #9
 800b0fe:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b102:	f043 0310 	orr.w	r3, r3, #16
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b106:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b10a:	60c3      	str	r3, [r0, #12]

  do
  {
    if (count-- == 0U)
 800b10c:	b152      	cbz	r2, 800b124 <SDMMC_CmdBlockLength+0x40>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b10e:	4946      	ldr	r1, [pc, #280]	; (800b228 <SDMMC_CmdBlockLength+0x144>)
 800b110:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800b112:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b114:	420a      	tst	r2, r1
    if (count-- == 0U)
 800b116:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b11a:	d001      	beq.n	800b120 <SDMMC_CmdBlockLength+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b11c:	0492      	lsls	r2, r2, #18
 800b11e:	d507      	bpl.n	800b130 <SDMMC_CmdBlockLength+0x4c>
    if (count-- == 0U)
 800b120:	1c5c      	adds	r4, r3, #1
 800b122:	d1f6      	bne.n	800b112 <SDMMC_CmdBlockLength+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800b124:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800b128:	4618      	mov	r0, r3
 800b12a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b12e:	4770      	bx	lr
#else
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b130:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b132:	075c      	lsls	r4, r3, #29
 800b134:	d43d      	bmi.n	800b1b2 <SDMMC_CmdBlockLength+0xce>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b136:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b138:	f013 0301 	ands.w	r3, r3, #1
 800b13c:	d134      	bne.n	800b1a8 <SDMMC_CmdBlockLength+0xc4>
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b13e:	4b3b      	ldr	r3, [pc, #236]	; (800b22c <SDMMC_CmdBlockLength+0x148>)
 800b140:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b142:	6903      	ldr	r3, [r0, #16]

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b144:	b2db      	uxtb	r3, r3
 800b146:	2b10      	cmp	r3, #16
 800b148:	d131      	bne.n	800b1ae <SDMMC_CmdBlockLength+0xca>
  return (*(__IO uint32_t *) tmp);
 800b14a:	6942      	ldr	r2, [r0, #20]
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b14c:	4b38      	ldr	r3, [pc, #224]	; (800b230 <SDMMC_CmdBlockLength+0x14c>)
 800b14e:	4013      	ands	r3, r2
 800b150:	2b00      	cmp	r3, #0
 800b152:	d0e9      	beq.n	800b128 <SDMMC_CmdBlockLength+0x44>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b154:	2a00      	cmp	r2, #0
 800b156:	db2f      	blt.n	800b1b8 <SDMMC_CmdBlockLength+0xd4>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b158:	0051      	lsls	r1, r2, #1
 800b15a:	d430      	bmi.n	800b1be <SDMMC_CmdBlockLength+0xda>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b15c:	0094      	lsls	r4, r2, #2
 800b15e:	d430      	bmi.n	800b1c2 <SDMMC_CmdBlockLength+0xde>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b160:	00d0      	lsls	r0, r2, #3
 800b162:	d430      	bmi.n	800b1c6 <SDMMC_CmdBlockLength+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b164:	0111      	lsls	r1, r2, #4
 800b166:	d431      	bmi.n	800b1cc <SDMMC_CmdBlockLength+0xe8>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b168:	0154      	lsls	r4, r2, #5
 800b16a:	d432      	bmi.n	800b1d2 <SDMMC_CmdBlockLength+0xee>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b16c:	01d0      	lsls	r0, r2, #7
 800b16e:	d433      	bmi.n	800b1d8 <SDMMC_CmdBlockLength+0xf4>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b170:	0211      	lsls	r1, r2, #8
 800b172:	d434      	bmi.n	800b1de <SDMMC_CmdBlockLength+0xfa>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b174:	0254      	lsls	r4, r2, #9
 800b176:	d435      	bmi.n	800b1e4 <SDMMC_CmdBlockLength+0x100>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b178:	0290      	lsls	r0, r2, #10
 800b17a:	d436      	bmi.n	800b1ea <SDMMC_CmdBlockLength+0x106>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b17c:	02d1      	lsls	r1, r2, #11
 800b17e:	d437      	bmi.n	800b1f0 <SDMMC_CmdBlockLength+0x10c>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b180:	0354      	lsls	r4, r2, #13
 800b182:	d438      	bmi.n	800b1f6 <SDMMC_CmdBlockLength+0x112>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b184:	0390      	lsls	r0, r2, #14
 800b186:	d439      	bmi.n	800b1fc <SDMMC_CmdBlockLength+0x118>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b188:	03d1      	lsls	r1, r2, #15
 800b18a:	d43a      	bmi.n	800b202 <SDMMC_CmdBlockLength+0x11e>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b18c:	0414      	lsls	r4, r2, #16
 800b18e:	d43b      	bmi.n	800b208 <SDMMC_CmdBlockLength+0x124>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b190:	0450      	lsls	r0, r2, #17
 800b192:	d43f      	bmi.n	800b214 <SDMMC_CmdBlockLength+0x130>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b194:	0491      	lsls	r1, r2, #18
 800b196:	d43a      	bmi.n	800b20e <SDMMC_CmdBlockLength+0x12a>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b198:	f012 0f08 	tst.w	r2, #8
 800b19c:	bf14      	ite	ne
 800b19e:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800b1a2:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800b1a6:	e7bf      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b1a8:	2201      	movs	r2, #1
 800b1aa:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b1ac:	e7bc      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b1ae:	2301      	movs	r3, #1
 800b1b0:	e7ba      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b1b2:	2304      	movs	r3, #4
 800b1b4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b1b6:	e7b7      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b1b8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b1bc:	e7b4      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b1be:	2340      	movs	r3, #64	; 0x40
 800b1c0:	e7b2      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b1c2:	2380      	movs	r3, #128	; 0x80
 800b1c4:	e7b0      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b1c6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b1ca:	e7ad      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b1cc:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b1d0:	e7aa      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b1d2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b1d6:	e7a7      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b1d8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b1dc:	e7a4      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b1de:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b1e2:	e7a1      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b1e4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b1e8:	e79e      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b1ea:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b1ee:	e79b      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CC_ERR;
 800b1f0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b1f4:	e798      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b1f6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800b1fa:	e795      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b1fc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b200:	e792      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b202:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800b206:	e78f      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800b208:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b20c:	e78c      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800b20e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b212:	e789      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800b214:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800b218:	e786      	b.n	800b128 <SDMMC_CmdBlockLength+0x44>
 800b21a:	bf00      	nop
 800b21c:	20000124 	.word	0x20000124
 800b220:	fffee0c0 	.word	0xfffee0c0
 800b224:	10624dd3 	.word	0x10624dd3
 800b228:	00200045 	.word	0x00200045
 800b22c:	002000c5 	.word	0x002000c5
 800b230:	fdffe008 	.word	0xfdffe008

0800b234 <SDMMC_CmdReadSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b234:	4a4d      	ldr	r2, [pc, #308]	; (800b36c <SDMMC_CmdReadSingleBlock+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b236:	4b4e      	ldr	r3, [pc, #312]	; (800b370 <SDMMC_CmdReadSingleBlock+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b238:	6812      	ldr	r2, [r2, #0]
{
 800b23a:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800b23c:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b23e:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b240:	494c      	ldr	r1, [pc, #304]	; (800b374 <SDMMC_CmdReadSingleBlock+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b242:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b244:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b248:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b24c:	0a52      	lsrs	r2, r2, #9
 800b24e:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b252:	f043 0311 	orr.w	r3, r3, #17
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b256:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b25a:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800b25c:	b152      	cbz	r2, 800b274 <SDMMC_CmdReadSingleBlock+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b25e:	4946      	ldr	r1, [pc, #280]	; (800b378 <SDMMC_CmdReadSingleBlock+0x144>)
 800b260:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800b262:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b264:	420a      	tst	r2, r1
    if (count-- == 0U)
 800b266:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b26a:	d001      	beq.n	800b270 <SDMMC_CmdReadSingleBlock+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b26c:	0492      	lsls	r2, r2, #18
 800b26e:	d507      	bpl.n	800b280 <SDMMC_CmdReadSingleBlock+0x4c>
    if (count-- == 0U)
 800b270:	1c5c      	adds	r4, r3, #1
 800b272:	d1f6      	bne.n	800b262 <SDMMC_CmdReadSingleBlock+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800b274:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800b278:	4618      	mov	r0, r3
 800b27a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b27e:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b280:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b282:	075c      	lsls	r4, r3, #29
 800b284:	d43d      	bmi.n	800b302 <SDMMC_CmdReadSingleBlock+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b286:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b288:	f013 0301 	ands.w	r3, r3, #1
 800b28c:	d134      	bne.n	800b2f8 <SDMMC_CmdReadSingleBlock+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b28e:	4b3b      	ldr	r3, [pc, #236]	; (800b37c <SDMMC_CmdReadSingleBlock+0x148>)
 800b290:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b292:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b294:	b2db      	uxtb	r3, r3
 800b296:	2b11      	cmp	r3, #17
 800b298:	d131      	bne.n	800b2fe <SDMMC_CmdReadSingleBlock+0xca>
  return (*(__IO uint32_t *) tmp);
 800b29a:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b29c:	4b38      	ldr	r3, [pc, #224]	; (800b380 <SDMMC_CmdReadSingleBlock+0x14c>)
 800b29e:	4013      	ands	r3, r2
 800b2a0:	2b00      	cmp	r3, #0
 800b2a2:	d0e9      	beq.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b2a4:	2a00      	cmp	r2, #0
 800b2a6:	db2f      	blt.n	800b308 <SDMMC_CmdReadSingleBlock+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b2a8:	0051      	lsls	r1, r2, #1
 800b2aa:	d430      	bmi.n	800b30e <SDMMC_CmdReadSingleBlock+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b2ac:	0094      	lsls	r4, r2, #2
 800b2ae:	d430      	bmi.n	800b312 <SDMMC_CmdReadSingleBlock+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b2b0:	00d0      	lsls	r0, r2, #3
 800b2b2:	d430      	bmi.n	800b316 <SDMMC_CmdReadSingleBlock+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b2b4:	0111      	lsls	r1, r2, #4
 800b2b6:	d431      	bmi.n	800b31c <SDMMC_CmdReadSingleBlock+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b2b8:	0154      	lsls	r4, r2, #5
 800b2ba:	d432      	bmi.n	800b322 <SDMMC_CmdReadSingleBlock+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b2bc:	01d0      	lsls	r0, r2, #7
 800b2be:	d433      	bmi.n	800b328 <SDMMC_CmdReadSingleBlock+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b2c0:	0211      	lsls	r1, r2, #8
 800b2c2:	d434      	bmi.n	800b32e <SDMMC_CmdReadSingleBlock+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b2c4:	0254      	lsls	r4, r2, #9
 800b2c6:	d435      	bmi.n	800b334 <SDMMC_CmdReadSingleBlock+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b2c8:	0290      	lsls	r0, r2, #10
 800b2ca:	d436      	bmi.n	800b33a <SDMMC_CmdReadSingleBlock+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b2cc:	02d1      	lsls	r1, r2, #11
 800b2ce:	d437      	bmi.n	800b340 <SDMMC_CmdReadSingleBlock+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b2d0:	0354      	lsls	r4, r2, #13
 800b2d2:	d438      	bmi.n	800b346 <SDMMC_CmdReadSingleBlock+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b2d4:	0390      	lsls	r0, r2, #14
 800b2d6:	d439      	bmi.n	800b34c <SDMMC_CmdReadSingleBlock+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b2d8:	03d1      	lsls	r1, r2, #15
 800b2da:	d43a      	bmi.n	800b352 <SDMMC_CmdReadSingleBlock+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b2dc:	0414      	lsls	r4, r2, #16
 800b2de:	d43b      	bmi.n	800b358 <SDMMC_CmdReadSingleBlock+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b2e0:	0450      	lsls	r0, r2, #17
 800b2e2:	d43f      	bmi.n	800b364 <SDMMC_CmdReadSingleBlock+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b2e4:	0491      	lsls	r1, r2, #18
 800b2e6:	d43a      	bmi.n	800b35e <SDMMC_CmdReadSingleBlock+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b2e8:	f012 0f08 	tst.w	r2, #8
 800b2ec:	bf14      	ite	ne
 800b2ee:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800b2f2:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800b2f6:	e7bf      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b2f8:	2201      	movs	r2, #1
 800b2fa:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b2fc:	e7bc      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b2fe:	2301      	movs	r3, #1
 800b300:	e7ba      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b302:	2304      	movs	r3, #4
 800b304:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b306:	e7b7      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b308:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b30c:	e7b4      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b30e:	2340      	movs	r3, #64	; 0x40
 800b310:	e7b2      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b312:	2380      	movs	r3, #128	; 0x80
 800b314:	e7b0      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b316:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b31a:	e7ad      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b31c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b320:	e7aa      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b322:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b326:	e7a7      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b328:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b32c:	e7a4      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b32e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b332:	e7a1      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b334:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b338:	e79e      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b33a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b33e:	e79b      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_CC_ERR;
 800b340:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b344:	e798      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b346:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800b34a:	e795      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b34c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b350:	e792      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b352:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800b356:	e78f      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800b358:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b35c:	e78c      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800b35e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b362:	e789      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800b364:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800b368:	e786      	b.n	800b278 <SDMMC_CmdReadSingleBlock+0x44>
 800b36a:	bf00      	nop
 800b36c:	20000124 	.word	0x20000124
 800b370:	fffee0c0 	.word	0xfffee0c0
 800b374:	10624dd3 	.word	0x10624dd3
 800b378:	00200045 	.word	0x00200045
 800b37c:	002000c5 	.word	0x002000c5
 800b380:	fdffe008 	.word	0xfdffe008

0800b384 <SDMMC_CmdReadMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b384:	4a4d      	ldr	r2, [pc, #308]	; (800b4bc <SDMMC_CmdReadMultiBlock+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b386:	4b4e      	ldr	r3, [pc, #312]	; (800b4c0 <SDMMC_CmdReadMultiBlock+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b388:	6812      	ldr	r2, [r2, #0]
{
 800b38a:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800b38c:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b38e:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b390:	494c      	ldr	r1, [pc, #304]	; (800b4c4 <SDMMC_CmdReadMultiBlock+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b392:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b394:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b398:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b39c:	0a52      	lsrs	r2, r2, #9
 800b39e:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b3a2:	f043 0312 	orr.w	r3, r3, #18
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b3a6:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b3aa:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800b3ac:	b152      	cbz	r2, 800b3c4 <SDMMC_CmdReadMultiBlock+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b3ae:	4946      	ldr	r1, [pc, #280]	; (800b4c8 <SDMMC_CmdReadMultiBlock+0x144>)
 800b3b0:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800b3b2:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b3b4:	420a      	tst	r2, r1
    if (count-- == 0U)
 800b3b6:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b3ba:	d001      	beq.n	800b3c0 <SDMMC_CmdReadMultiBlock+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b3bc:	0492      	lsls	r2, r2, #18
 800b3be:	d507      	bpl.n	800b3d0 <SDMMC_CmdReadMultiBlock+0x4c>
    if (count-- == 0U)
 800b3c0:	1c5c      	adds	r4, r3, #1
 800b3c2:	d1f6      	bne.n	800b3b2 <SDMMC_CmdReadMultiBlock+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800b3c4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800b3c8:	4618      	mov	r0, r3
 800b3ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b3ce:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b3d0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b3d2:	075c      	lsls	r4, r3, #29
 800b3d4:	d43d      	bmi.n	800b452 <SDMMC_CmdReadMultiBlock+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b3d6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b3d8:	f013 0301 	ands.w	r3, r3, #1
 800b3dc:	d134      	bne.n	800b448 <SDMMC_CmdReadMultiBlock+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b3de:	4b3b      	ldr	r3, [pc, #236]	; (800b4cc <SDMMC_CmdReadMultiBlock+0x148>)
 800b3e0:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b3e2:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b3e4:	b2db      	uxtb	r3, r3
 800b3e6:	2b12      	cmp	r3, #18
 800b3e8:	d131      	bne.n	800b44e <SDMMC_CmdReadMultiBlock+0xca>
  return (*(__IO uint32_t *) tmp);
 800b3ea:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b3ec:	4b38      	ldr	r3, [pc, #224]	; (800b4d0 <SDMMC_CmdReadMultiBlock+0x14c>)
 800b3ee:	4013      	ands	r3, r2
 800b3f0:	2b00      	cmp	r3, #0
 800b3f2:	d0e9      	beq.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b3f4:	2a00      	cmp	r2, #0
 800b3f6:	db2f      	blt.n	800b458 <SDMMC_CmdReadMultiBlock+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b3f8:	0051      	lsls	r1, r2, #1
 800b3fa:	d430      	bmi.n	800b45e <SDMMC_CmdReadMultiBlock+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b3fc:	0094      	lsls	r4, r2, #2
 800b3fe:	d430      	bmi.n	800b462 <SDMMC_CmdReadMultiBlock+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b400:	00d0      	lsls	r0, r2, #3
 800b402:	d430      	bmi.n	800b466 <SDMMC_CmdReadMultiBlock+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b404:	0111      	lsls	r1, r2, #4
 800b406:	d431      	bmi.n	800b46c <SDMMC_CmdReadMultiBlock+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b408:	0154      	lsls	r4, r2, #5
 800b40a:	d432      	bmi.n	800b472 <SDMMC_CmdReadMultiBlock+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b40c:	01d0      	lsls	r0, r2, #7
 800b40e:	d433      	bmi.n	800b478 <SDMMC_CmdReadMultiBlock+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b410:	0211      	lsls	r1, r2, #8
 800b412:	d434      	bmi.n	800b47e <SDMMC_CmdReadMultiBlock+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b414:	0254      	lsls	r4, r2, #9
 800b416:	d435      	bmi.n	800b484 <SDMMC_CmdReadMultiBlock+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b418:	0290      	lsls	r0, r2, #10
 800b41a:	d436      	bmi.n	800b48a <SDMMC_CmdReadMultiBlock+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b41c:	02d1      	lsls	r1, r2, #11
 800b41e:	d437      	bmi.n	800b490 <SDMMC_CmdReadMultiBlock+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b420:	0354      	lsls	r4, r2, #13
 800b422:	d438      	bmi.n	800b496 <SDMMC_CmdReadMultiBlock+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b424:	0390      	lsls	r0, r2, #14
 800b426:	d439      	bmi.n	800b49c <SDMMC_CmdReadMultiBlock+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b428:	03d1      	lsls	r1, r2, #15
 800b42a:	d43a      	bmi.n	800b4a2 <SDMMC_CmdReadMultiBlock+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b42c:	0414      	lsls	r4, r2, #16
 800b42e:	d43b      	bmi.n	800b4a8 <SDMMC_CmdReadMultiBlock+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b430:	0450      	lsls	r0, r2, #17
 800b432:	d43f      	bmi.n	800b4b4 <SDMMC_CmdReadMultiBlock+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b434:	0491      	lsls	r1, r2, #18
 800b436:	d43a      	bmi.n	800b4ae <SDMMC_CmdReadMultiBlock+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b438:	f012 0f08 	tst.w	r2, #8
 800b43c:	bf14      	ite	ne
 800b43e:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800b442:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800b446:	e7bf      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b448:	2201      	movs	r2, #1
 800b44a:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b44c:	e7bc      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b44e:	2301      	movs	r3, #1
 800b450:	e7ba      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b452:	2304      	movs	r3, #4
 800b454:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b456:	e7b7      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b458:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b45c:	e7b4      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b45e:	2340      	movs	r3, #64	; 0x40
 800b460:	e7b2      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b462:	2380      	movs	r3, #128	; 0x80
 800b464:	e7b0      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b466:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b46a:	e7ad      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b46c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b470:	e7aa      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b472:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b476:	e7a7      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b478:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b47c:	e7a4      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b47e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b482:	e7a1      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b484:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b488:	e79e      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b48a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b48e:	e79b      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_CC_ERR;
 800b490:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b494:	e798      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b496:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800b49a:	e795      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b49c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b4a0:	e792      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b4a2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800b4a6:	e78f      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800b4a8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b4ac:	e78c      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800b4ae:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b4b2:	e789      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800b4b4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800b4b8:	e786      	b.n	800b3c8 <SDMMC_CmdReadMultiBlock+0x44>
 800b4ba:	bf00      	nop
 800b4bc:	20000124 	.word	0x20000124
 800b4c0:	fffee0c0 	.word	0xfffee0c0
 800b4c4:	10624dd3 	.word	0x10624dd3
 800b4c8:	00200045 	.word	0x00200045
 800b4cc:	002000c5 	.word	0x002000c5
 800b4d0:	fdffe008 	.word	0xfdffe008

0800b4d4 <SDMMC_CmdWriteSingleBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b4d4:	4a4d      	ldr	r2, [pc, #308]	; (800b60c <SDMMC_CmdWriteSingleBlock+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b4d6:	4b4e      	ldr	r3, [pc, #312]	; (800b610 <SDMMC_CmdWriteSingleBlock+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b4d8:	6812      	ldr	r2, [r2, #0]
{
 800b4da:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800b4dc:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b4de:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b4e0:	494c      	ldr	r1, [pc, #304]	; (800b614 <SDMMC_CmdWriteSingleBlock+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b4e2:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b4e4:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b4e8:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b4ec:	0a52      	lsrs	r2, r2, #9
 800b4ee:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b4f2:	f043 0318 	orr.w	r3, r3, #24
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b4f6:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b4fa:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800b4fc:	b152      	cbz	r2, 800b514 <SDMMC_CmdWriteSingleBlock+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b4fe:	4946      	ldr	r1, [pc, #280]	; (800b618 <SDMMC_CmdWriteSingleBlock+0x144>)
 800b500:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800b502:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b504:	420a      	tst	r2, r1
    if (count-- == 0U)
 800b506:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b50a:	d001      	beq.n	800b510 <SDMMC_CmdWriteSingleBlock+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b50c:	0492      	lsls	r2, r2, #18
 800b50e:	d507      	bpl.n	800b520 <SDMMC_CmdWriteSingleBlock+0x4c>
    if (count-- == 0U)
 800b510:	1c5c      	adds	r4, r3, #1
 800b512:	d1f6      	bne.n	800b502 <SDMMC_CmdWriteSingleBlock+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800b514:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800b518:	4618      	mov	r0, r3
 800b51a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b51e:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b520:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b522:	075c      	lsls	r4, r3, #29
 800b524:	d43d      	bmi.n	800b5a2 <SDMMC_CmdWriteSingleBlock+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b526:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b528:	f013 0301 	ands.w	r3, r3, #1
 800b52c:	d134      	bne.n	800b598 <SDMMC_CmdWriteSingleBlock+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b52e:	4b3b      	ldr	r3, [pc, #236]	; (800b61c <SDMMC_CmdWriteSingleBlock+0x148>)
 800b530:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b532:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b534:	b2db      	uxtb	r3, r3
 800b536:	2b18      	cmp	r3, #24
 800b538:	d131      	bne.n	800b59e <SDMMC_CmdWriteSingleBlock+0xca>
  return (*(__IO uint32_t *) tmp);
 800b53a:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b53c:	4b38      	ldr	r3, [pc, #224]	; (800b620 <SDMMC_CmdWriteSingleBlock+0x14c>)
 800b53e:	4013      	ands	r3, r2
 800b540:	2b00      	cmp	r3, #0
 800b542:	d0e9      	beq.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b544:	2a00      	cmp	r2, #0
 800b546:	db2f      	blt.n	800b5a8 <SDMMC_CmdWriteSingleBlock+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b548:	0051      	lsls	r1, r2, #1
 800b54a:	d430      	bmi.n	800b5ae <SDMMC_CmdWriteSingleBlock+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b54c:	0094      	lsls	r4, r2, #2
 800b54e:	d430      	bmi.n	800b5b2 <SDMMC_CmdWriteSingleBlock+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b550:	00d0      	lsls	r0, r2, #3
 800b552:	d430      	bmi.n	800b5b6 <SDMMC_CmdWriteSingleBlock+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b554:	0111      	lsls	r1, r2, #4
 800b556:	d431      	bmi.n	800b5bc <SDMMC_CmdWriteSingleBlock+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b558:	0154      	lsls	r4, r2, #5
 800b55a:	d432      	bmi.n	800b5c2 <SDMMC_CmdWriteSingleBlock+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b55c:	01d0      	lsls	r0, r2, #7
 800b55e:	d433      	bmi.n	800b5c8 <SDMMC_CmdWriteSingleBlock+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b560:	0211      	lsls	r1, r2, #8
 800b562:	d434      	bmi.n	800b5ce <SDMMC_CmdWriteSingleBlock+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b564:	0254      	lsls	r4, r2, #9
 800b566:	d435      	bmi.n	800b5d4 <SDMMC_CmdWriteSingleBlock+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b568:	0290      	lsls	r0, r2, #10
 800b56a:	d436      	bmi.n	800b5da <SDMMC_CmdWriteSingleBlock+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b56c:	02d1      	lsls	r1, r2, #11
 800b56e:	d437      	bmi.n	800b5e0 <SDMMC_CmdWriteSingleBlock+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b570:	0354      	lsls	r4, r2, #13
 800b572:	d438      	bmi.n	800b5e6 <SDMMC_CmdWriteSingleBlock+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b574:	0390      	lsls	r0, r2, #14
 800b576:	d439      	bmi.n	800b5ec <SDMMC_CmdWriteSingleBlock+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b578:	03d1      	lsls	r1, r2, #15
 800b57a:	d43a      	bmi.n	800b5f2 <SDMMC_CmdWriteSingleBlock+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b57c:	0414      	lsls	r4, r2, #16
 800b57e:	d43b      	bmi.n	800b5f8 <SDMMC_CmdWriteSingleBlock+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b580:	0450      	lsls	r0, r2, #17
 800b582:	d43f      	bmi.n	800b604 <SDMMC_CmdWriteSingleBlock+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b584:	0491      	lsls	r1, r2, #18
 800b586:	d43a      	bmi.n	800b5fe <SDMMC_CmdWriteSingleBlock+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b588:	f012 0f08 	tst.w	r2, #8
 800b58c:	bf14      	ite	ne
 800b58e:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800b592:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800b596:	e7bf      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b598:	2201      	movs	r2, #1
 800b59a:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b59c:	e7bc      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b59e:	2301      	movs	r3, #1
 800b5a0:	e7ba      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b5a2:	2304      	movs	r3, #4
 800b5a4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b5a6:	e7b7      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b5a8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b5ac:	e7b4      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b5ae:	2340      	movs	r3, #64	; 0x40
 800b5b0:	e7b2      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b5b2:	2380      	movs	r3, #128	; 0x80
 800b5b4:	e7b0      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b5b6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b5ba:	e7ad      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b5bc:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b5c0:	e7aa      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b5c2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b5c6:	e7a7      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b5c8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b5cc:	e7a4      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b5ce:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b5d2:	e7a1      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b5d4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b5d8:	e79e      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b5da:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b5de:	e79b      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CC_ERR;
 800b5e0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b5e4:	e798      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b5e6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800b5ea:	e795      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b5ec:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b5f0:	e792      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b5f2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800b5f6:	e78f      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800b5f8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b5fc:	e78c      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800b5fe:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b602:	e789      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800b604:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800b608:	e786      	b.n	800b518 <SDMMC_CmdWriteSingleBlock+0x44>
 800b60a:	bf00      	nop
 800b60c:	20000124 	.word	0x20000124
 800b610:	fffee0c0 	.word	0xfffee0c0
 800b614:	10624dd3 	.word	0x10624dd3
 800b618:	00200045 	.word	0x00200045
 800b61c:	002000c5 	.word	0x002000c5
 800b620:	fdffe008 	.word	0xfdffe008

0800b624 <SDMMC_CmdWriteMultiBlock>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b624:	4a4d      	ldr	r2, [pc, #308]	; (800b75c <SDMMC_CmdWriteMultiBlock+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b626:	4b4e      	ldr	r3, [pc, #312]	; (800b760 <SDMMC_CmdWriteMultiBlock+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b628:	6812      	ldr	r2, [r2, #0]
{
 800b62a:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800b62c:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b62e:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b630:	494c      	ldr	r1, [pc, #304]	; (800b764 <SDMMC_CmdWriteMultiBlock+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b632:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b634:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b638:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b63c:	0a52      	lsrs	r2, r2, #9
 800b63e:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b642:	f043 0319 	orr.w	r3, r3, #25
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b646:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b64a:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800b64c:	b152      	cbz	r2, 800b664 <SDMMC_CmdWriteMultiBlock+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b64e:	4946      	ldr	r1, [pc, #280]	; (800b768 <SDMMC_CmdWriteMultiBlock+0x144>)
 800b650:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800b652:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b654:	420a      	tst	r2, r1
    if (count-- == 0U)
 800b656:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b65a:	d001      	beq.n	800b660 <SDMMC_CmdWriteMultiBlock+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b65c:	0492      	lsls	r2, r2, #18
 800b65e:	d507      	bpl.n	800b670 <SDMMC_CmdWriteMultiBlock+0x4c>
    if (count-- == 0U)
 800b660:	1c5c      	adds	r4, r3, #1
 800b662:	d1f6      	bne.n	800b652 <SDMMC_CmdWriteMultiBlock+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800b664:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800b668:	4618      	mov	r0, r3
 800b66a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b66e:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b670:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b672:	075c      	lsls	r4, r3, #29
 800b674:	d43d      	bmi.n	800b6f2 <SDMMC_CmdWriteMultiBlock+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b676:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b678:	f013 0301 	ands.w	r3, r3, #1
 800b67c:	d134      	bne.n	800b6e8 <SDMMC_CmdWriteMultiBlock+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b67e:	4b3b      	ldr	r3, [pc, #236]	; (800b76c <SDMMC_CmdWriteMultiBlock+0x148>)
 800b680:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b682:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b684:	b2db      	uxtb	r3, r3
 800b686:	2b19      	cmp	r3, #25
 800b688:	d131      	bne.n	800b6ee <SDMMC_CmdWriteMultiBlock+0xca>
  return (*(__IO uint32_t *) tmp);
 800b68a:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b68c:	4b38      	ldr	r3, [pc, #224]	; (800b770 <SDMMC_CmdWriteMultiBlock+0x14c>)
 800b68e:	4013      	ands	r3, r2
 800b690:	2b00      	cmp	r3, #0
 800b692:	d0e9      	beq.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b694:	2a00      	cmp	r2, #0
 800b696:	db2f      	blt.n	800b6f8 <SDMMC_CmdWriteMultiBlock+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b698:	0051      	lsls	r1, r2, #1
 800b69a:	d430      	bmi.n	800b6fe <SDMMC_CmdWriteMultiBlock+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b69c:	0094      	lsls	r4, r2, #2
 800b69e:	d430      	bmi.n	800b702 <SDMMC_CmdWriteMultiBlock+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b6a0:	00d0      	lsls	r0, r2, #3
 800b6a2:	d430      	bmi.n	800b706 <SDMMC_CmdWriteMultiBlock+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b6a4:	0111      	lsls	r1, r2, #4
 800b6a6:	d431      	bmi.n	800b70c <SDMMC_CmdWriteMultiBlock+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b6a8:	0154      	lsls	r4, r2, #5
 800b6aa:	d432      	bmi.n	800b712 <SDMMC_CmdWriteMultiBlock+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b6ac:	01d0      	lsls	r0, r2, #7
 800b6ae:	d433      	bmi.n	800b718 <SDMMC_CmdWriteMultiBlock+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b6b0:	0211      	lsls	r1, r2, #8
 800b6b2:	d434      	bmi.n	800b71e <SDMMC_CmdWriteMultiBlock+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b6b4:	0254      	lsls	r4, r2, #9
 800b6b6:	d435      	bmi.n	800b724 <SDMMC_CmdWriteMultiBlock+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b6b8:	0290      	lsls	r0, r2, #10
 800b6ba:	d436      	bmi.n	800b72a <SDMMC_CmdWriteMultiBlock+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b6bc:	02d1      	lsls	r1, r2, #11
 800b6be:	d437      	bmi.n	800b730 <SDMMC_CmdWriteMultiBlock+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b6c0:	0354      	lsls	r4, r2, #13
 800b6c2:	d438      	bmi.n	800b736 <SDMMC_CmdWriteMultiBlock+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b6c4:	0390      	lsls	r0, r2, #14
 800b6c6:	d439      	bmi.n	800b73c <SDMMC_CmdWriteMultiBlock+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b6c8:	03d1      	lsls	r1, r2, #15
 800b6ca:	d43a      	bmi.n	800b742 <SDMMC_CmdWriteMultiBlock+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b6cc:	0414      	lsls	r4, r2, #16
 800b6ce:	d43b      	bmi.n	800b748 <SDMMC_CmdWriteMultiBlock+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b6d0:	0450      	lsls	r0, r2, #17
 800b6d2:	d43f      	bmi.n	800b754 <SDMMC_CmdWriteMultiBlock+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b6d4:	0491      	lsls	r1, r2, #18
 800b6d6:	d43a      	bmi.n	800b74e <SDMMC_CmdWriteMultiBlock+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b6d8:	f012 0f08 	tst.w	r2, #8
 800b6dc:	bf14      	ite	ne
 800b6de:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800b6e2:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800b6e6:	e7bf      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b6e8:	2201      	movs	r2, #1
 800b6ea:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b6ec:	e7bc      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b6ee:	2301      	movs	r3, #1
 800b6f0:	e7ba      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b6f2:	2304      	movs	r3, #4
 800b6f4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b6f6:	e7b7      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b6f8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b6fc:	e7b4      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b6fe:	2340      	movs	r3, #64	; 0x40
 800b700:	e7b2      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b702:	2380      	movs	r3, #128	; 0x80
 800b704:	e7b0      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b706:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b70a:	e7ad      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b70c:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b710:	e7aa      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b712:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b716:	e7a7      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b718:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b71c:	e7a4      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b71e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b722:	e7a1      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b724:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b728:	e79e      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b72a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b72e:	e79b      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_CC_ERR;
 800b730:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b734:	e798      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b736:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800b73a:	e795      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b73c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b740:	e792      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b742:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800b746:	e78f      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800b748:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800b74c:	e78c      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800b74e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800b752:	e789      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800b754:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800b758:	e786      	b.n	800b668 <SDMMC_CmdWriteMultiBlock+0x44>
 800b75a:	bf00      	nop
 800b75c:	20000124 	.word	0x20000124
 800b760:	fffee0c0 	.word	0xfffee0c0
 800b764:	10624dd3 	.word	0x10624dd3
 800b768:	00200045 	.word	0x00200045
 800b76c:	002000c5 	.word	0x002000c5
 800b770:	fdffe008 	.word	0xfdffe008

0800b774 <SDMMC_CmdStopTransfer>:
{
 800b774:	4603      	mov	r3, r0
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800b776:	68c0      	ldr	r0, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b778:	4951      	ldr	r1, [pc, #324]	; (800b8c0 <SDMMC_CmdStopTransfer+0x14c>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b77a:	4a52      	ldr	r2, [pc, #328]	; (800b8c4 <SDMMC_CmdStopTransfer+0x150>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b77c:	6809      	ldr	r1, [r1, #0]
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800b77e:	f040 0080 	orr.w	r0, r0, #128	; 0x80
{
 800b782:	b430      	push	{r4, r5}
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800b784:	60d8      	str	r0, [r3, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800b786:	68d8      	ldr	r0, [r3, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b788:	4c4f      	ldr	r4, [pc, #316]	; (800b8c8 <SDMMC_CmdStopTransfer+0x154>)
  SDMMCx->ARG = Command->Argument;
 800b78a:	2500      	movs	r5, #0
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800b78c:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800b790:	60d8      	str	r0, [r3, #12]
  SDMMCx->ARG = Command->Argument;
 800b792:	609d      	str	r5, [r3, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b794:	68dd      	ldr	r5, [r3, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b796:	484d      	ldr	r0, [pc, #308]	; (800b8cc <SDMMC_CmdStopTransfer+0x158>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b798:	402a      	ands	r2, r5
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b79a:	fba4 4101 	umull	r4, r1, r4, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b79e:	f442 5288 	orr.w	r2, r2, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b7a2:	0a49      	lsrs	r1, r1, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b7a4:	f042 020c 	orr.w	r2, r2, #12
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b7a8:	fb00 f101 	mul.w	r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b7ac:	60da      	str	r2, [r3, #12]
    if (count-- == 0U)
 800b7ae:	b151      	cbz	r1, 800b7c6 <SDMMC_CmdStopTransfer+0x52>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b7b0:	4847      	ldr	r0, [pc, #284]	; (800b8d0 <SDMMC_CmdStopTransfer+0x15c>)
 800b7b2:	1e4a      	subs	r2, r1, #1
    sta_reg = SDMMCx->STA;
 800b7b4:	6b59      	ldr	r1, [r3, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b7b6:	4201      	tst	r1, r0
    if (count-- == 0U)
 800b7b8:	f102 32ff 	add.w	r2, r2, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b7bc:	d001      	beq.n	800b7c2 <SDMMC_CmdStopTransfer+0x4e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b7be:	048c      	lsls	r4, r1, #18
 800b7c0:	d509      	bpl.n	800b7d6 <SDMMC_CmdStopTransfer+0x62>
    if (count-- == 0U)
 800b7c2:	1c55      	adds	r5, r2, #1
 800b7c4:	d1f6      	bne.n	800b7b4 <SDMMC_CmdStopTransfer+0x40>
      return SDMMC_ERROR_TIMEOUT;
 800b7c6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800b7ca:	68da      	ldr	r2, [r3, #12]
 800b7cc:	f022 0280 	bic.w	r2, r2, #128	; 0x80
}
 800b7d0:	bc30      	pop	{r4, r5}
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800b7d2:	60da      	str	r2, [r3, #12]
}
 800b7d4:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b7d6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800b7d8:	0750      	lsls	r0, r2, #29
 800b7da:	d43d      	bmi.n	800b858 <SDMMC_CmdStopTransfer+0xe4>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b7dc:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800b7de:	f010 0001 	ands.w	r0, r0, #1
 800b7e2:	d134      	bne.n	800b84e <SDMMC_CmdStopTransfer+0xda>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b7e4:	4a3b      	ldr	r2, [pc, #236]	; (800b8d4 <SDMMC_CmdStopTransfer+0x160>)
 800b7e6:	639a      	str	r2, [r3, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b7e8:	691a      	ldr	r2, [r3, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b7ea:	b2d2      	uxtb	r2, r2
 800b7ec:	2a0c      	cmp	r2, #12
 800b7ee:	d131      	bne.n	800b854 <SDMMC_CmdStopTransfer+0xe0>
  return (*(__IO uint32_t *) tmp);
 800b7f0:	695a      	ldr	r2, [r3, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b7f2:	4839      	ldr	r0, [pc, #228]	; (800b8d8 <SDMMC_CmdStopTransfer+0x164>)
 800b7f4:	4010      	ands	r0, r2
 800b7f6:	2800      	cmp	r0, #0
 800b7f8:	d0e7      	beq.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b7fa:	2a00      	cmp	r2, #0
 800b7fc:	db2f      	blt.n	800b85e <SDMMC_CmdStopTransfer+0xea>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b7fe:	0051      	lsls	r1, r2, #1
 800b800:	d430      	bmi.n	800b864 <SDMMC_CmdStopTransfer+0xf0>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b802:	0095      	lsls	r5, r2, #2
 800b804:	d430      	bmi.n	800b868 <SDMMC_CmdStopTransfer+0xf4>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b806:	00d4      	lsls	r4, r2, #3
 800b808:	d430      	bmi.n	800b86c <SDMMC_CmdStopTransfer+0xf8>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b80a:	0111      	lsls	r1, r2, #4
 800b80c:	d431      	bmi.n	800b872 <SDMMC_CmdStopTransfer+0xfe>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b80e:	0155      	lsls	r5, r2, #5
 800b810:	d432      	bmi.n	800b878 <SDMMC_CmdStopTransfer+0x104>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b812:	01d4      	lsls	r4, r2, #7
 800b814:	d433      	bmi.n	800b87e <SDMMC_CmdStopTransfer+0x10a>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b816:	0211      	lsls	r1, r2, #8
 800b818:	d434      	bmi.n	800b884 <SDMMC_CmdStopTransfer+0x110>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b81a:	0255      	lsls	r5, r2, #9
 800b81c:	d435      	bmi.n	800b88a <SDMMC_CmdStopTransfer+0x116>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b81e:	0294      	lsls	r4, r2, #10
 800b820:	d436      	bmi.n	800b890 <SDMMC_CmdStopTransfer+0x11c>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b822:	02d1      	lsls	r1, r2, #11
 800b824:	d437      	bmi.n	800b896 <SDMMC_CmdStopTransfer+0x122>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b826:	0355      	lsls	r5, r2, #13
 800b828:	d438      	bmi.n	800b89c <SDMMC_CmdStopTransfer+0x128>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b82a:	0394      	lsls	r4, r2, #14
 800b82c:	d439      	bmi.n	800b8a2 <SDMMC_CmdStopTransfer+0x12e>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b82e:	03d1      	lsls	r1, r2, #15
 800b830:	d43a      	bmi.n	800b8a8 <SDMMC_CmdStopTransfer+0x134>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b832:	0415      	lsls	r5, r2, #16
 800b834:	d43b      	bmi.n	800b8ae <SDMMC_CmdStopTransfer+0x13a>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b836:	0454      	lsls	r4, r2, #17
 800b838:	d43f      	bmi.n	800b8ba <SDMMC_CmdStopTransfer+0x146>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b83a:	0491      	lsls	r1, r2, #18
 800b83c:	d43a      	bmi.n	800b8b4 <SDMMC_CmdStopTransfer+0x140>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b83e:	f012 0f08 	tst.w	r2, #8
 800b842:	bf14      	ite	ne
 800b844:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 800b848:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800b84c:	e7bd      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b84e:	2201      	movs	r2, #1
 800b850:	639a      	str	r2, [r3, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b852:	e7ba      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b854:	2001      	movs	r0, #1
 800b856:	e7b8      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b858:	2004      	movs	r0, #4
 800b85a:	6398      	str	r0, [r3, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b85c:	e7b5      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b85e:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800b862:	e7b2      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b864:	2040      	movs	r0, #64	; 0x40
 800b866:	e7b0      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b868:	2080      	movs	r0, #128	; 0x80
 800b86a:	e7ae      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b86c:	f44f 7080 	mov.w	r0, #256	; 0x100
 800b870:	e7ab      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b872:	f44f 7000 	mov.w	r0, #512	; 0x200
 800b876:	e7a8      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b878:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800b87c:	e7a5      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b87e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800b882:	e7a2      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b884:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800b888:	e79f      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b88a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800b88e:	e79c      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b890:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800b894:	e799      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_CC_ERR;
 800b896:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800b89a:	e796      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b89c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800b8a0:	e793      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b8a2:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800b8a6:	e790      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b8a8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800b8ac:	e78d      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800b8ae:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800b8b2:	e78a      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_ERASE_RESET;
 800b8b4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800b8b8:	e787      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800b8ba:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800b8be:	e784      	b.n	800b7ca <SDMMC_CmdStopTransfer+0x56>
 800b8c0:	20000124 	.word	0x20000124
 800b8c4:	fffee0c0 	.word	0xfffee0c0
 800b8c8:	10624dd3 	.word	0x10624dd3
 800b8cc:	05f5e100 	.word	0x05f5e100
 800b8d0:	00200045 	.word	0x00200045
 800b8d4:	002000c5 	.word	0x002000c5
 800b8d8:	fdffe008 	.word	0xfdffe008

0800b8dc <SDMMC_CmdSelDesel>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b8dc:	494d      	ldr	r1, [pc, #308]	; (800ba14 <SDMMC_CmdSelDesel+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b8de:	4b4e      	ldr	r3, [pc, #312]	; (800ba18 <SDMMC_CmdSelDesel+0x13c>)
{
 800b8e0:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800b8e2:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b8e4:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b8e6:	680a      	ldr	r2, [r1, #0]
 800b8e8:	494c      	ldr	r1, [pc, #304]	; (800ba1c <SDMMC_CmdSelDesel+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b8ea:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b8ec:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b8f0:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b8f4:	0a52      	lsrs	r2, r2, #9
 800b8f6:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b8fa:	f043 0307 	orr.w	r3, r3, #7
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800b8fe:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800b902:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800b904:	b152      	cbz	r2, 800b91c <SDMMC_CmdSelDesel+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b906:	4946      	ldr	r1, [pc, #280]	; (800ba20 <SDMMC_CmdSelDesel+0x144>)
 800b908:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800b90a:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b90c:	420a      	tst	r2, r1
    if (count-- == 0U)
 800b90e:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800b912:	d001      	beq.n	800b918 <SDMMC_CmdSelDesel+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800b914:	0492      	lsls	r2, r2, #18
 800b916:	d507      	bpl.n	800b928 <SDMMC_CmdSelDesel+0x4c>
    if (count-- == 0U)
 800b918:	1c5c      	adds	r4, r3, #1
 800b91a:	d1f6      	bne.n	800b90a <SDMMC_CmdSelDesel+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800b91c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800b920:	4618      	mov	r0, r3
 800b922:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b926:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800b928:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b92a:	075c      	lsls	r4, r3, #29
 800b92c:	d43d      	bmi.n	800b9aa <SDMMC_CmdSelDesel+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800b92e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800b930:	f013 0301 	ands.w	r3, r3, #1
 800b934:	d134      	bne.n	800b9a0 <SDMMC_CmdSelDesel+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800b936:	4b3b      	ldr	r3, [pc, #236]	; (800ba24 <SDMMC_CmdSelDesel+0x148>)
 800b938:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800b93a:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800b93c:	b2db      	uxtb	r3, r3
 800b93e:	2b07      	cmp	r3, #7
 800b940:	d131      	bne.n	800b9a6 <SDMMC_CmdSelDesel+0xca>
  return (*(__IO uint32_t *) tmp);
 800b942:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800b944:	4b38      	ldr	r3, [pc, #224]	; (800ba28 <SDMMC_CmdSelDesel+0x14c>)
 800b946:	4013      	ands	r3, r2
 800b948:	2b00      	cmp	r3, #0
 800b94a:	d0e9      	beq.n	800b920 <SDMMC_CmdSelDesel+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800b94c:	2a00      	cmp	r2, #0
 800b94e:	db2f      	blt.n	800b9b0 <SDMMC_CmdSelDesel+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800b950:	0051      	lsls	r1, r2, #1
 800b952:	d430      	bmi.n	800b9b6 <SDMMC_CmdSelDesel+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800b954:	0094      	lsls	r4, r2, #2
 800b956:	d430      	bmi.n	800b9ba <SDMMC_CmdSelDesel+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800b958:	00d0      	lsls	r0, r2, #3
 800b95a:	d430      	bmi.n	800b9be <SDMMC_CmdSelDesel+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800b95c:	0111      	lsls	r1, r2, #4
 800b95e:	d431      	bmi.n	800b9c4 <SDMMC_CmdSelDesel+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800b960:	0154      	lsls	r4, r2, #5
 800b962:	d432      	bmi.n	800b9ca <SDMMC_CmdSelDesel+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800b964:	01d0      	lsls	r0, r2, #7
 800b966:	d433      	bmi.n	800b9d0 <SDMMC_CmdSelDesel+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800b968:	0211      	lsls	r1, r2, #8
 800b96a:	d434      	bmi.n	800b9d6 <SDMMC_CmdSelDesel+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800b96c:	0254      	lsls	r4, r2, #9
 800b96e:	d435      	bmi.n	800b9dc <SDMMC_CmdSelDesel+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800b970:	0290      	lsls	r0, r2, #10
 800b972:	d436      	bmi.n	800b9e2 <SDMMC_CmdSelDesel+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800b974:	02d1      	lsls	r1, r2, #11
 800b976:	d437      	bmi.n	800b9e8 <SDMMC_CmdSelDesel+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800b978:	0354      	lsls	r4, r2, #13
 800b97a:	d438      	bmi.n	800b9ee <SDMMC_CmdSelDesel+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800b97c:	0390      	lsls	r0, r2, #14
 800b97e:	d439      	bmi.n	800b9f4 <SDMMC_CmdSelDesel+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800b980:	03d1      	lsls	r1, r2, #15
 800b982:	d43a      	bmi.n	800b9fa <SDMMC_CmdSelDesel+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800b984:	0414      	lsls	r4, r2, #16
 800b986:	d43b      	bmi.n	800ba00 <SDMMC_CmdSelDesel+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800b988:	0450      	lsls	r0, r2, #17
 800b98a:	d43f      	bmi.n	800ba0c <SDMMC_CmdSelDesel+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800b98c:	0491      	lsls	r1, r2, #18
 800b98e:	d43a      	bmi.n	800ba06 <SDMMC_CmdSelDesel+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800b990:	f012 0f08 	tst.w	r2, #8
 800b994:	bf14      	ite	ne
 800b996:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800b99a:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800b99e:	e7bf      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800b9a0:	2201      	movs	r2, #1
 800b9a2:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b9a4:	e7bc      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800b9a6:	2301      	movs	r3, #1
 800b9a8:	e7ba      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800b9aa:	2304      	movs	r3, #4
 800b9ac:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800b9ae:	e7b7      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800b9b0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b9b4:	e7b4      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800b9b6:	2340      	movs	r3, #64	; 0x40
 800b9b8:	e7b2      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800b9ba:	2380      	movs	r3, #128	; 0x80
 800b9bc:	e7b0      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800b9be:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b9c2:	e7ad      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800b9c4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800b9c8:	e7aa      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800b9ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b9ce:	e7a7      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800b9d0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800b9d4:	e7a4      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800b9d6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b9da:	e7a1      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800b9dc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800b9e0:	e79e      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800b9e2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b9e6:	e79b      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_CC_ERR;
 800b9e8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800b9ec:	e798      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800b9ee:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800b9f2:	e795      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800b9f4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800b9f8:	e792      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800b9fa:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800b9fe:	e78f      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800ba00:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800ba04:	e78c      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800ba06:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800ba0a:	e789      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800ba0c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800ba10:	e786      	b.n	800b920 <SDMMC_CmdSelDesel+0x44>
 800ba12:	bf00      	nop
 800ba14:	20000124 	.word	0x20000124
 800ba18:	fffee0c0 	.word	0xfffee0c0
 800ba1c:	10624dd3 	.word	0x10624dd3
 800ba20:	00200045 	.word	0x00200045
 800ba24:	002000c5 	.word	0x002000c5
 800ba28:	fdffe008 	.word	0xfdffe008

0800ba2c <SDMMC_CmdGoIdleState>:
  SDMMCx->ARG = Command->Argument;
 800ba2c:	2200      	movs	r2, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba2e:	4b11      	ldr	r3, [pc, #68]	; (800ba74 <SDMMC_CmdGoIdleState+0x48>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba30:	4911      	ldr	r1, [pc, #68]	; (800ba78 <SDMMC_CmdGoIdleState+0x4c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba32:	681b      	ldr	r3, [r3, #0]
{
 800ba34:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800ba36:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba38:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba3a:	4a10      	ldr	r2, [pc, #64]	; (800ba7c <SDMMC_CmdGoIdleState+0x50>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba3c:	4021      	ands	r1, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba3e:	fba2 2303 	umull	r2, r3, r2, r3
 800ba42:	0a5a      	lsrs	r2, r3, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba44:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba48:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba4c:	60c1      	str	r1, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba4e:	fb03 f302 	mul.w	r3, r3, r2
 800ba52:	e002      	b.n	800ba5a <SDMMC_CmdGoIdleState+0x2e>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 800ba54:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800ba56:	0612      	lsls	r2, r2, #24
 800ba58:	d406      	bmi.n	800ba68 <SDMMC_CmdGoIdleState+0x3c>
    if (count-- == 0U)
 800ba5a:	3b01      	subs	r3, #1
 800ba5c:	d2fa      	bcs.n	800ba54 <SDMMC_CmdGoIdleState+0x28>
      return SDMMC_ERROR_TIMEOUT;
 800ba5e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800ba62:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ba66:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800ba68:	4b05      	ldr	r3, [pc, #20]	; (800ba80 <SDMMC_CmdGoIdleState+0x54>)
 800ba6a:	6383      	str	r3, [r0, #56]	; 0x38
}
 800ba6c:	f85d 4b04 	ldr.w	r4, [sp], #4
  return SDMMC_ERROR_NONE;
 800ba70:	2000      	movs	r0, #0
}
 800ba72:	4770      	bx	lr
 800ba74:	20000124 	.word	0x20000124
 800ba78:	fffee0c0 	.word	0xfffee0c0
 800ba7c:	10624dd3 	.word	0x10624dd3
 800ba80:	002000c5 	.word	0x002000c5

0800ba84 <SDMMC_CmdOperCond>:
  SDMMCx->ARG = Command->Argument;
 800ba84:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba88:	491c      	ldr	r1, [pc, #112]	; (800bafc <SDMMC_CmdOperCond+0x78>)
{
 800ba8a:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800ba8c:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba8e:	68c4      	ldr	r4, [r0, #12]
 800ba90:	4b1b      	ldr	r3, [pc, #108]	; (800bb00 <SDMMC_CmdOperCond+0x7c>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba92:	6809      	ldr	r1, [r1, #0]
{
 800ba94:	4602      	mov	r2, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba96:	481b      	ldr	r0, [pc, #108]	; (800bb04 <SDMMC_CmdOperCond+0x80>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba98:	4023      	ands	r3, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ba9a:	fba0 0101 	umull	r0, r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ba9e:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800baa2:	0a49      	lsrs	r1, r1, #9
 800baa4:	f241 3088 	movw	r0, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800baa8:	f043 0308 	orr.w	r3, r3, #8
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800baac:	fb00 f101 	mul.w	r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bab0:	60d3      	str	r3, [r2, #12]

  do
  {
    if (count-- == 0U)
 800bab2:	1e4b      	subs	r3, r1, #1
 800bab4:	b149      	cbz	r1, 800baca <SDMMC_CmdOperCond+0x46>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800bab6:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bab8:	f011 0f45 	tst.w	r1, #69	; 0x45
    if (count-- == 0U)
 800babc:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bac0:	d001      	beq.n	800bac6 <SDMMC_CmdOperCond+0x42>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800bac2:	0488      	lsls	r0, r1, #18
 800bac4:	d506      	bpl.n	800bad4 <SDMMC_CmdOperCond+0x50>
    if (count-- == 0U)
 800bac6:	1c5c      	adds	r4, r3, #1
 800bac8:	d1f5      	bne.n	800bab6 <SDMMC_CmdOperCond+0x32>
      return SDMMC_ERROR_TIMEOUT;
 800baca:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800bace:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bad2:	4770      	bx	lr

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800bad4:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bad6:	0759      	lsls	r1, r3, #29
 800bad8:	d40c      	bmi.n	800baf4 <SDMMC_CmdOperCond+0x70>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800bada:	6b50      	ldr	r0, [r2, #52]	; 0x34
 800badc:	f010 0001 	ands.w	r0, r0, #1
 800bae0:	d105      	bne.n	800baee <SDMMC_CmdOperCond+0x6a>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 800bae2:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bae4:	065b      	lsls	r3, r3, #25
 800bae6:	d5f2      	bpl.n	800bace <SDMMC_CmdOperCond+0x4a>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800bae8:	2340      	movs	r3, #64	; 0x40
 800baea:	6393      	str	r3, [r2, #56]	; 0x38
 800baec:	e7ef      	b.n	800bace <SDMMC_CmdOperCond+0x4a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800baee:	2301      	movs	r3, #1
 800baf0:	6393      	str	r3, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800baf2:	e7ec      	b.n	800bace <SDMMC_CmdOperCond+0x4a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800baf4:	2004      	movs	r0, #4
 800baf6:	6390      	str	r0, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800baf8:	e7e9      	b.n	800bace <SDMMC_CmdOperCond+0x4a>
 800bafa:	bf00      	nop
 800bafc:	20000124 	.word	0x20000124
 800bb00:	fffee0c0 	.word	0xfffee0c0
 800bb04:	10624dd3 	.word	0x10624dd3

0800bb08 <SDMMC_CmdAppCommand>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bb08:	4a4d      	ldr	r2, [pc, #308]	; (800bc40 <SDMMC_CmdAppCommand+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bb0a:	4b4e      	ldr	r3, [pc, #312]	; (800bc44 <SDMMC_CmdAppCommand+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bb0c:	6812      	ldr	r2, [r2, #0]
{
 800bb0e:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800bb10:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bb12:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bb14:	494c      	ldr	r1, [pc, #304]	; (800bc48 <SDMMC_CmdAppCommand+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bb16:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bb18:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bb1c:	f443 5389 	orr.w	r3, r3, #4384	; 0x1120
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bb20:	0a52      	lsrs	r2, r2, #9
 800bb22:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bb26:	f043 0317 	orr.w	r3, r3, #23
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bb2a:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bb2e:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800bb30:	b152      	cbz	r2, 800bb48 <SDMMC_CmdAppCommand+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800bb32:	4946      	ldr	r1, [pc, #280]	; (800bc4c <SDMMC_CmdAppCommand+0x144>)
 800bb34:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800bb36:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bb38:	420a      	tst	r2, r1
    if (count-- == 0U)
 800bb3a:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bb3e:	d001      	beq.n	800bb44 <SDMMC_CmdAppCommand+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800bb40:	0492      	lsls	r2, r2, #18
 800bb42:	d507      	bpl.n	800bb54 <SDMMC_CmdAppCommand+0x4c>
    if (count-- == 0U)
 800bb44:	1c5c      	adds	r4, r3, #1
 800bb46:	d1f6      	bne.n	800bb36 <SDMMC_CmdAppCommand+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800bb48:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800bb4c:	4618      	mov	r0, r3
 800bb4e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bb52:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800bb54:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bb56:	075c      	lsls	r4, r3, #29
 800bb58:	d43d      	bmi.n	800bbd6 <SDMMC_CmdAppCommand+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800bb5a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bb5c:	f013 0301 	ands.w	r3, r3, #1
 800bb60:	d134      	bne.n	800bbcc <SDMMC_CmdAppCommand+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800bb62:	4b3b      	ldr	r3, [pc, #236]	; (800bc50 <SDMMC_CmdAppCommand+0x148>)
 800bb64:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800bb66:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800bb68:	b2db      	uxtb	r3, r3
 800bb6a:	2b37      	cmp	r3, #55	; 0x37
 800bb6c:	d131      	bne.n	800bbd2 <SDMMC_CmdAppCommand+0xca>
  return (*(__IO uint32_t *) tmp);
 800bb6e:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800bb70:	4b38      	ldr	r3, [pc, #224]	; (800bc54 <SDMMC_CmdAppCommand+0x14c>)
 800bb72:	4013      	ands	r3, r2
 800bb74:	2b00      	cmp	r3, #0
 800bb76:	d0e9      	beq.n	800bb4c <SDMMC_CmdAppCommand+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800bb78:	2a00      	cmp	r2, #0
 800bb7a:	db2f      	blt.n	800bbdc <SDMMC_CmdAppCommand+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800bb7c:	0051      	lsls	r1, r2, #1
 800bb7e:	d430      	bmi.n	800bbe2 <SDMMC_CmdAppCommand+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800bb80:	0094      	lsls	r4, r2, #2
 800bb82:	d430      	bmi.n	800bbe6 <SDMMC_CmdAppCommand+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800bb84:	00d0      	lsls	r0, r2, #3
 800bb86:	d430      	bmi.n	800bbea <SDMMC_CmdAppCommand+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800bb88:	0111      	lsls	r1, r2, #4
 800bb8a:	d431      	bmi.n	800bbf0 <SDMMC_CmdAppCommand+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800bb8c:	0154      	lsls	r4, r2, #5
 800bb8e:	d432      	bmi.n	800bbf6 <SDMMC_CmdAppCommand+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800bb90:	01d0      	lsls	r0, r2, #7
 800bb92:	d433      	bmi.n	800bbfc <SDMMC_CmdAppCommand+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800bb94:	0211      	lsls	r1, r2, #8
 800bb96:	d434      	bmi.n	800bc02 <SDMMC_CmdAppCommand+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800bb98:	0254      	lsls	r4, r2, #9
 800bb9a:	d435      	bmi.n	800bc08 <SDMMC_CmdAppCommand+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800bb9c:	0290      	lsls	r0, r2, #10
 800bb9e:	d436      	bmi.n	800bc0e <SDMMC_CmdAppCommand+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800bba0:	02d1      	lsls	r1, r2, #11
 800bba2:	d437      	bmi.n	800bc14 <SDMMC_CmdAppCommand+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800bba4:	0354      	lsls	r4, r2, #13
 800bba6:	d438      	bmi.n	800bc1a <SDMMC_CmdAppCommand+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800bba8:	0390      	lsls	r0, r2, #14
 800bbaa:	d439      	bmi.n	800bc20 <SDMMC_CmdAppCommand+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800bbac:	03d1      	lsls	r1, r2, #15
 800bbae:	d43a      	bmi.n	800bc26 <SDMMC_CmdAppCommand+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800bbb0:	0414      	lsls	r4, r2, #16
 800bbb2:	d43b      	bmi.n	800bc2c <SDMMC_CmdAppCommand+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800bbb4:	0450      	lsls	r0, r2, #17
 800bbb6:	d43f      	bmi.n	800bc38 <SDMMC_CmdAppCommand+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800bbb8:	0491      	lsls	r1, r2, #18
 800bbba:	d43a      	bmi.n	800bc32 <SDMMC_CmdAppCommand+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800bbbc:	f012 0f08 	tst.w	r2, #8
 800bbc0:	bf14      	ite	ne
 800bbc2:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800bbc6:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800bbca:	e7bf      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800bbcc:	2201      	movs	r2, #1
 800bbce:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800bbd0:	e7bc      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800bbd2:	2301      	movs	r3, #1
 800bbd4:	e7ba      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800bbd6:	2304      	movs	r3, #4
 800bbd8:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800bbda:	e7b7      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800bbdc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800bbe0:	e7b4      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800bbe2:	2340      	movs	r3, #64	; 0x40
 800bbe4:	e7b2      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800bbe6:	2380      	movs	r3, #128	; 0x80
 800bbe8:	e7b0      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800bbea:	f44f 7380 	mov.w	r3, #256	; 0x100
 800bbee:	e7ad      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800bbf0:	f44f 7300 	mov.w	r3, #512	; 0x200
 800bbf4:	e7aa      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800bbf6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bbfa:	e7a7      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800bbfc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800bc00:	e7a4      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800bc02:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bc06:	e7a1      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800bc08:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800bc0c:	e79e      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800bc0e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800bc12:	e79b      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_CC_ERR;
 800bc14:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800bc18:	e798      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800bc1a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800bc1e:	e795      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800bc20:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800bc24:	e792      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800bc26:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800bc2a:	e78f      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800bc2c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bc30:	e78c      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800bc32:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800bc36:	e789      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800bc38:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800bc3c:	e786      	b.n	800bb4c <SDMMC_CmdAppCommand+0x44>
 800bc3e:	bf00      	nop
 800bc40:	20000124 	.word	0x20000124
 800bc44:	fffee0c0 	.word	0xfffee0c0
 800bc48:	10624dd3 	.word	0x10624dd3
 800bc4c:	00200045 	.word	0x00200045
 800bc50:	002000c5 	.word	0x002000c5
 800bc54:	fdffe008 	.word	0xfdffe008

0800bc58 <SDMMC_CmdAppOperCommand>:
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bc58:	4a18      	ldr	r2, [pc, #96]	; (800bcbc <SDMMC_CmdAppOperCommand+0x64>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bc5a:	4b19      	ldr	r3, [pc, #100]	; (800bcc0 <SDMMC_CmdAppOperCommand+0x68>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bc5c:	6812      	ldr	r2, [r2, #0]
{
 800bc5e:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800bc60:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bc62:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bc64:	4917      	ldr	r1, [pc, #92]	; (800bcc4 <SDMMC_CmdAppOperCommand+0x6c>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bc66:	4023      	ands	r3, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bc68:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bc6c:	f443 5389 	orr.w	r3, r3, #4384	; 0x1120
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bc70:	0a52      	lsrs	r2, r2, #9
 800bc72:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bc76:	f043 0309 	orr.w	r3, r3, #9
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bc7a:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bc7e:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800bc80:	1e53      	subs	r3, r2, #1
 800bc82:	b14a      	cbz	r2, 800bc98 <SDMMC_CmdAppOperCommand+0x40>
    sta_reg = SDMMCx->STA;
 800bc84:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bc86:	f012 0f45 	tst.w	r2, #69	; 0x45
    if (count-- == 0U)
 800bc8a:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bc8e:	d001      	beq.n	800bc94 <SDMMC_CmdAppOperCommand+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800bc90:	0492      	lsls	r2, r2, #18
 800bc92:	d507      	bpl.n	800bca4 <SDMMC_CmdAppOperCommand+0x4c>
    if (count-- == 0U)
 800bc94:	1c59      	adds	r1, r3, #1
 800bc96:	d1f5      	bne.n	800bc84 <SDMMC_CmdAppOperCommand+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 800bc98:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800bc9c:	4618      	mov	r0, r3
 800bc9e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bca2:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800bca4:	6b43      	ldr	r3, [r0, #52]	; 0x34
}
 800bca6:	f85d 4b04 	ldr.w	r4, [sp], #4
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800bcaa:	f013 0304 	ands.w	r3, r3, #4
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800bcae:	bf15      	itete	ne
 800bcb0:	2304      	movne	r3, #4
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800bcb2:	4a05      	ldreq	r2, [pc, #20]	; (800bcc8 <SDMMC_CmdAppOperCommand+0x70>)
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800bcb4:	6383      	strne	r3, [r0, #56]	; 0x38
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800bcb6:	6382      	streq	r2, [r0, #56]	; 0x38
}
 800bcb8:	4618      	mov	r0, r3
 800bcba:	4770      	bx	lr
 800bcbc:	20000124 	.word	0x20000124
 800bcc0:	fffee0c0 	.word	0xfffee0c0
 800bcc4:	10624dd3 	.word	0x10624dd3
 800bcc8:	002000c5 	.word	0x002000c5

0800bccc <SDMMC_CmdBusWidth>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bccc:	4a4d      	ldr	r2, [pc, #308]	; (800be04 <SDMMC_CmdBusWidth+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bcce:	4b4e      	ldr	r3, [pc, #312]	; (800be08 <SDMMC_CmdBusWidth+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bcd0:	6812      	ldr	r2, [r2, #0]
{
 800bcd2:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800bcd4:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bcd6:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bcd8:	494c      	ldr	r1, [pc, #304]	; (800be0c <SDMMC_CmdBusWidth+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bcda:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bcdc:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bce0:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bce4:	0a52      	lsrs	r2, r2, #9
 800bce6:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bcea:	f043 0306 	orr.w	r3, r3, #6
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800bcee:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bcf2:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800bcf4:	b152      	cbz	r2, 800bd0c <SDMMC_CmdBusWidth+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800bcf6:	4946      	ldr	r1, [pc, #280]	; (800be10 <SDMMC_CmdBusWidth+0x144>)
 800bcf8:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800bcfa:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bcfc:	420a      	tst	r2, r1
    if (count-- == 0U)
 800bcfe:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bd02:	d001      	beq.n	800bd08 <SDMMC_CmdBusWidth+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800bd04:	0492      	lsls	r2, r2, #18
 800bd06:	d507      	bpl.n	800bd18 <SDMMC_CmdBusWidth+0x4c>
    if (count-- == 0U)
 800bd08:	1c5c      	adds	r4, r3, #1
 800bd0a:	d1f6      	bne.n	800bcfa <SDMMC_CmdBusWidth+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800bd0c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800bd10:	4618      	mov	r0, r3
 800bd12:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bd16:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800bd18:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd1a:	075c      	lsls	r4, r3, #29
 800bd1c:	d43d      	bmi.n	800bd9a <SDMMC_CmdBusWidth+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800bd1e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd20:	f013 0301 	ands.w	r3, r3, #1
 800bd24:	d134      	bne.n	800bd90 <SDMMC_CmdBusWidth+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800bd26:	4b3b      	ldr	r3, [pc, #236]	; (800be14 <SDMMC_CmdBusWidth+0x148>)
 800bd28:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800bd2a:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800bd2c:	b2db      	uxtb	r3, r3
 800bd2e:	2b06      	cmp	r3, #6
 800bd30:	d131      	bne.n	800bd96 <SDMMC_CmdBusWidth+0xca>
  return (*(__IO uint32_t *) tmp);
 800bd32:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800bd34:	4b38      	ldr	r3, [pc, #224]	; (800be18 <SDMMC_CmdBusWidth+0x14c>)
 800bd36:	4013      	ands	r3, r2
 800bd38:	2b00      	cmp	r3, #0
 800bd3a:	d0e9      	beq.n	800bd10 <SDMMC_CmdBusWidth+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800bd3c:	2a00      	cmp	r2, #0
 800bd3e:	db2f      	blt.n	800bda0 <SDMMC_CmdBusWidth+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800bd40:	0051      	lsls	r1, r2, #1
 800bd42:	d430      	bmi.n	800bda6 <SDMMC_CmdBusWidth+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800bd44:	0094      	lsls	r4, r2, #2
 800bd46:	d430      	bmi.n	800bdaa <SDMMC_CmdBusWidth+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800bd48:	00d0      	lsls	r0, r2, #3
 800bd4a:	d430      	bmi.n	800bdae <SDMMC_CmdBusWidth+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800bd4c:	0111      	lsls	r1, r2, #4
 800bd4e:	d431      	bmi.n	800bdb4 <SDMMC_CmdBusWidth+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800bd50:	0154      	lsls	r4, r2, #5
 800bd52:	d432      	bmi.n	800bdba <SDMMC_CmdBusWidth+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800bd54:	01d0      	lsls	r0, r2, #7
 800bd56:	d433      	bmi.n	800bdc0 <SDMMC_CmdBusWidth+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800bd58:	0211      	lsls	r1, r2, #8
 800bd5a:	d434      	bmi.n	800bdc6 <SDMMC_CmdBusWidth+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800bd5c:	0254      	lsls	r4, r2, #9
 800bd5e:	d435      	bmi.n	800bdcc <SDMMC_CmdBusWidth+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800bd60:	0290      	lsls	r0, r2, #10
 800bd62:	d436      	bmi.n	800bdd2 <SDMMC_CmdBusWidth+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800bd64:	02d1      	lsls	r1, r2, #11
 800bd66:	d437      	bmi.n	800bdd8 <SDMMC_CmdBusWidth+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800bd68:	0354      	lsls	r4, r2, #13
 800bd6a:	d438      	bmi.n	800bdde <SDMMC_CmdBusWidth+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800bd6c:	0390      	lsls	r0, r2, #14
 800bd6e:	d439      	bmi.n	800bde4 <SDMMC_CmdBusWidth+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800bd70:	03d1      	lsls	r1, r2, #15
 800bd72:	d43a      	bmi.n	800bdea <SDMMC_CmdBusWidth+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800bd74:	0414      	lsls	r4, r2, #16
 800bd76:	d43b      	bmi.n	800bdf0 <SDMMC_CmdBusWidth+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800bd78:	0450      	lsls	r0, r2, #17
 800bd7a:	d43f      	bmi.n	800bdfc <SDMMC_CmdBusWidth+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800bd7c:	0491      	lsls	r1, r2, #18
 800bd7e:	d43a      	bmi.n	800bdf6 <SDMMC_CmdBusWidth+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800bd80:	f012 0f08 	tst.w	r2, #8
 800bd84:	bf14      	ite	ne
 800bd86:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800bd8a:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800bd8e:	e7bf      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800bd90:	2201      	movs	r2, #1
 800bd92:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800bd94:	e7bc      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800bd96:	2301      	movs	r3, #1
 800bd98:	e7ba      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800bd9a:	2304      	movs	r3, #4
 800bd9c:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800bd9e:	e7b7      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800bda0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800bda4:	e7b4      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800bda6:	2340      	movs	r3, #64	; 0x40
 800bda8:	e7b2      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800bdaa:	2380      	movs	r3, #128	; 0x80
 800bdac:	e7b0      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800bdae:	f44f 7380 	mov.w	r3, #256	; 0x100
 800bdb2:	e7ad      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800bdb4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800bdb8:	e7aa      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800bdba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bdbe:	e7a7      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800bdc0:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800bdc4:	e7a4      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800bdc6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bdca:	e7a1      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800bdcc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800bdd0:	e79e      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800bdd2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800bdd6:	e79b      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_CC_ERR;
 800bdd8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800bddc:	e798      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800bdde:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800bde2:	e795      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800bde4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800bde8:	e792      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800bdea:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800bdee:	e78f      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800bdf0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bdf4:	e78c      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800bdf6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800bdfa:	e789      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800bdfc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800be00:	e786      	b.n	800bd10 <SDMMC_CmdBusWidth+0x44>
 800be02:	bf00      	nop
 800be04:	20000124 	.word	0x20000124
 800be08:	fffee0c0 	.word	0xfffee0c0
 800be0c:	10624dd3 	.word	0x10624dd3
 800be10:	00200045 	.word	0x00200045
 800be14:	002000c5 	.word	0x002000c5
 800be18:	fdffe008 	.word	0xfdffe008

0800be1c <SDMMC_CmdSendSCR>:
  SDMMCx->ARG = Command->Argument;
 800be1c:	2300      	movs	r3, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800be1e:	4a4d      	ldr	r2, [pc, #308]	; (800bf54 <SDMMC_CmdSendSCR+0x138>)
 800be20:	494d      	ldr	r1, [pc, #308]	; (800bf58 <SDMMC_CmdSendSCR+0x13c>)
 800be22:	6812      	ldr	r2, [r2, #0]
{
 800be24:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800be26:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800be28:	68c4      	ldr	r4, [r0, #12]
 800be2a:	4b4c      	ldr	r3, [pc, #304]	; (800bf5c <SDMMC_CmdSendSCR+0x140>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800be2c:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800be30:	4023      	ands	r3, r4
 800be32:	f443 5389 	orr.w	r3, r3, #4384	; 0x1120
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800be36:	0a52      	lsrs	r2, r2, #9
 800be38:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800be3c:	f043 0313 	orr.w	r3, r3, #19
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800be40:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800be44:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800be46:	b152      	cbz	r2, 800be5e <SDMMC_CmdSendSCR+0x42>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800be48:	4945      	ldr	r1, [pc, #276]	; (800bf60 <SDMMC_CmdSendSCR+0x144>)
 800be4a:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800be4c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800be4e:	420a      	tst	r2, r1
    if (count-- == 0U)
 800be50:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800be54:	d001      	beq.n	800be5a <SDMMC_CmdSendSCR+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800be56:	0492      	lsls	r2, r2, #18
 800be58:	d507      	bpl.n	800be6a <SDMMC_CmdSendSCR+0x4e>
    if (count-- == 0U)
 800be5a:	1c5c      	adds	r4, r3, #1
 800be5c:	d1f6      	bne.n	800be4c <SDMMC_CmdSendSCR+0x30>
      return SDMMC_ERROR_TIMEOUT;
 800be5e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800be62:	4618      	mov	r0, r3
 800be64:	f85d 4b04 	ldr.w	r4, [sp], #4
 800be68:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800be6a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800be6c:	075c      	lsls	r4, r3, #29
 800be6e:	d43d      	bmi.n	800beec <SDMMC_CmdSendSCR+0xd0>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800be70:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800be72:	f013 0301 	ands.w	r3, r3, #1
 800be76:	d134      	bne.n	800bee2 <SDMMC_CmdSendSCR+0xc6>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800be78:	4b3a      	ldr	r3, [pc, #232]	; (800bf64 <SDMMC_CmdSendSCR+0x148>)
 800be7a:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800be7c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800be7e:	b2db      	uxtb	r3, r3
 800be80:	2b33      	cmp	r3, #51	; 0x33
 800be82:	d131      	bne.n	800bee8 <SDMMC_CmdSendSCR+0xcc>
  return (*(__IO uint32_t *) tmp);
 800be84:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800be86:	4b38      	ldr	r3, [pc, #224]	; (800bf68 <SDMMC_CmdSendSCR+0x14c>)
 800be88:	4013      	ands	r3, r2
 800be8a:	2b00      	cmp	r3, #0
 800be8c:	d0e9      	beq.n	800be62 <SDMMC_CmdSendSCR+0x46>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800be8e:	2a00      	cmp	r2, #0
 800be90:	db2f      	blt.n	800bef2 <SDMMC_CmdSendSCR+0xd6>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800be92:	0051      	lsls	r1, r2, #1
 800be94:	d430      	bmi.n	800bef8 <SDMMC_CmdSendSCR+0xdc>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800be96:	0094      	lsls	r4, r2, #2
 800be98:	d430      	bmi.n	800befc <SDMMC_CmdSendSCR+0xe0>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800be9a:	00d0      	lsls	r0, r2, #3
 800be9c:	d430      	bmi.n	800bf00 <SDMMC_CmdSendSCR+0xe4>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800be9e:	0111      	lsls	r1, r2, #4
 800bea0:	d431      	bmi.n	800bf06 <SDMMC_CmdSendSCR+0xea>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800bea2:	0154      	lsls	r4, r2, #5
 800bea4:	d432      	bmi.n	800bf0c <SDMMC_CmdSendSCR+0xf0>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800bea6:	01d0      	lsls	r0, r2, #7
 800bea8:	d433      	bmi.n	800bf12 <SDMMC_CmdSendSCR+0xf6>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800beaa:	0211      	lsls	r1, r2, #8
 800beac:	d434      	bmi.n	800bf18 <SDMMC_CmdSendSCR+0xfc>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800beae:	0254      	lsls	r4, r2, #9
 800beb0:	d435      	bmi.n	800bf1e <SDMMC_CmdSendSCR+0x102>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800beb2:	0290      	lsls	r0, r2, #10
 800beb4:	d436      	bmi.n	800bf24 <SDMMC_CmdSendSCR+0x108>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800beb6:	02d1      	lsls	r1, r2, #11
 800beb8:	d437      	bmi.n	800bf2a <SDMMC_CmdSendSCR+0x10e>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800beba:	0354      	lsls	r4, r2, #13
 800bebc:	d438      	bmi.n	800bf30 <SDMMC_CmdSendSCR+0x114>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800bebe:	0390      	lsls	r0, r2, #14
 800bec0:	d439      	bmi.n	800bf36 <SDMMC_CmdSendSCR+0x11a>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800bec2:	03d1      	lsls	r1, r2, #15
 800bec4:	d43a      	bmi.n	800bf3c <SDMMC_CmdSendSCR+0x120>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800bec6:	0414      	lsls	r4, r2, #16
 800bec8:	d43b      	bmi.n	800bf42 <SDMMC_CmdSendSCR+0x126>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800beca:	0450      	lsls	r0, r2, #17
 800becc:	d43f      	bmi.n	800bf4e <SDMMC_CmdSendSCR+0x132>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800bece:	0491      	lsls	r1, r2, #18
 800bed0:	d43a      	bmi.n	800bf48 <SDMMC_CmdSendSCR+0x12c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800bed2:	f012 0f08 	tst.w	r2, #8
 800bed6:	bf14      	ite	ne
 800bed8:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800bedc:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800bee0:	e7bf      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800bee2:	2201      	movs	r2, #1
 800bee4:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800bee6:	e7bc      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800bee8:	2301      	movs	r3, #1
 800beea:	e7ba      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800beec:	2304      	movs	r3, #4
 800beee:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800bef0:	e7b7      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800bef2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800bef6:	e7b4      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800bef8:	2340      	movs	r3, #64	; 0x40
 800befa:	e7b2      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800befc:	2380      	movs	r3, #128	; 0x80
 800befe:	e7b0      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800bf00:	f44f 7380 	mov.w	r3, #256	; 0x100
 800bf04:	e7ad      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800bf06:	f44f 7300 	mov.w	r3, #512	; 0x200
 800bf0a:	e7aa      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800bf0c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800bf10:	e7a7      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800bf12:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800bf16:	e7a4      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800bf18:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bf1c:	e7a1      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800bf1e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800bf22:	e79e      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800bf24:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800bf28:	e79b      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_CC_ERR;
 800bf2a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800bf2e:	e798      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800bf30:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800bf34:	e795      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800bf36:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800bf3a:	e792      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800bf3c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800bf40:	e78f      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800bf42:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800bf46:	e78c      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_ERASE_RESET;
 800bf48:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800bf4c:	e789      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800bf4e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800bf52:	e786      	b.n	800be62 <SDMMC_CmdSendSCR+0x46>
 800bf54:	20000124 	.word	0x20000124
 800bf58:	10624dd3 	.word	0x10624dd3
 800bf5c:	fffee0c0 	.word	0xfffee0c0
 800bf60:	00200045 	.word	0x00200045
 800bf64:	002000c5 	.word	0x002000c5
 800bf68:	fdffe008 	.word	0xfdffe008

0800bf6c <SDMMC_CmdSendCID>:
  SDMMCx->ARG = Command->Argument;
 800bf6c:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bf6e:	491b      	ldr	r1, [pc, #108]	; (800bfdc <SDMMC_CmdSendCID+0x70>)
{
 800bf70:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800bf72:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bf74:	68c4      	ldr	r4, [r0, #12]
 800bf76:	4b1a      	ldr	r3, [pc, #104]	; (800bfe0 <SDMMC_CmdSendCID+0x74>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bf78:	6809      	ldr	r1, [r1, #0]
{
 800bf7a:	4602      	mov	r2, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bf7c:	4819      	ldr	r0, [pc, #100]	; (800bfe4 <SDMMC_CmdSendCID+0x78>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bf7e:	4023      	ands	r3, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bf80:	fba0 0101 	umull	r0, r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bf84:	f443 5398 	orr.w	r3, r3, #4864	; 0x1300
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bf88:	0a49      	lsrs	r1, r1, #9
 800bf8a:	f241 3088 	movw	r0, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bf8e:	f043 0302 	orr.w	r3, r3, #2
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bf92:	fb00 f101 	mul.w	r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bf96:	60d3      	str	r3, [r2, #12]
    if (count-- == 0U)
 800bf98:	1e4b      	subs	r3, r1, #1
 800bf9a:	b149      	cbz	r1, 800bfb0 <SDMMC_CmdSendCID+0x44>
    sta_reg = SDMMCx->STA;
 800bf9c:	6b51      	ldr	r1, [r2, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bf9e:	f011 0f45 	tst.w	r1, #69	; 0x45
    if (count-- == 0U)
 800bfa2:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800bfa6:	d001      	beq.n	800bfac <SDMMC_CmdSendCID+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800bfa8:	0489      	lsls	r1, r1, #18
 800bfaa:	d506      	bpl.n	800bfba <SDMMC_CmdSendCID+0x4e>
    if (count-- == 0U)
 800bfac:	1c58      	adds	r0, r3, #1
 800bfae:	d1f5      	bne.n	800bf9c <SDMMC_CmdSendCID+0x30>
      return SDMMC_ERROR_TIMEOUT;
 800bfb0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800bfb4:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bfb8:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800bfba:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bfbc:	075b      	lsls	r3, r3, #29
 800bfbe:	d409      	bmi.n	800bfd4 <SDMMC_CmdSendCID+0x68>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800bfc0:	6b50      	ldr	r0, [r2, #52]	; 0x34
}
 800bfc2:	f85d 4b04 	ldr.w	r4, [sp], #4
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800bfc6:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800bfca:	bf0c      	ite	eq
 800bfcc:	4b06      	ldreq	r3, [pc, #24]	; (800bfe8 <SDMMC_CmdSendCID+0x7c>)
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800bfce:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800bfd0:	6393      	str	r3, [r2, #56]	; 0x38
}
 800bfd2:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800bfd4:	2004      	movs	r0, #4
 800bfd6:	6390      	str	r0, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800bfd8:	e7ec      	b.n	800bfb4 <SDMMC_CmdSendCID+0x48>
 800bfda:	bf00      	nop
 800bfdc:	20000124 	.word	0x20000124
 800bfe0:	fffee0c0 	.word	0xfffee0c0
 800bfe4:	10624dd3 	.word	0x10624dd3
 800bfe8:	002000c5 	.word	0x002000c5

0800bfec <SDMMC_CmdSendCSD>:
{
 800bfec:	4602      	mov	r2, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bfee:	481a      	ldr	r0, [pc, #104]	; (800c058 <SDMMC_CmdSendCSD+0x6c>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bff0:	4b1a      	ldr	r3, [pc, #104]	; (800c05c <SDMMC_CmdSendCSD+0x70>)
{
 800bff2:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800bff4:	6091      	str	r1, [r2, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bff6:	68d4      	ldr	r4, [r2, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bff8:	6801      	ldr	r1, [r0, #0]
 800bffa:	4819      	ldr	r0, [pc, #100]	; (800c060 <SDMMC_CmdSendCSD+0x74>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800bffc:	4023      	ands	r3, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800bffe:	fba0 0101 	umull	r0, r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c002:	f443 5398 	orr.w	r3, r3, #4864	; 0x1300
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c006:	0a49      	lsrs	r1, r1, #9
 800c008:	f241 3088 	movw	r0, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c00c:	f043 0309 	orr.w	r3, r3, #9
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c010:	fb00 f101 	mul.w	r1, r0, r1
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c014:	60d3      	str	r3, [r2, #12]
    if (count-- == 0U)
 800c016:	1e4b      	subs	r3, r1, #1
 800c018:	b149      	cbz	r1, 800c02e <SDMMC_CmdSendCSD+0x42>
    sta_reg = SDMMCx->STA;
 800c01a:	6b51      	ldr	r1, [r2, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c01c:	f011 0f45 	tst.w	r1, #69	; 0x45
    if (count-- == 0U)
 800c020:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c024:	d001      	beq.n	800c02a <SDMMC_CmdSendCSD+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800c026:	0489      	lsls	r1, r1, #18
 800c028:	d506      	bpl.n	800c038 <SDMMC_CmdSendCSD+0x4c>
    if (count-- == 0U)
 800c02a:	1c58      	adds	r0, r3, #1
 800c02c:	d1f5      	bne.n	800c01a <SDMMC_CmdSendCSD+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800c02e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800c032:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c036:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800c038:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800c03a:	075b      	lsls	r3, r3, #29
 800c03c:	d409      	bmi.n	800c052 <SDMMC_CmdSendCSD+0x66>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800c03e:	6b50      	ldr	r0, [r2, #52]	; 0x34
}
 800c040:	f85d 4b04 	ldr.w	r4, [sp], #4
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800c044:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800c048:	bf0c      	ite	eq
 800c04a:	4b06      	ldreq	r3, [pc, #24]	; (800c064 <SDMMC_CmdSendCSD+0x78>)
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800c04c:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800c04e:	6393      	str	r3, [r2, #56]	; 0x38
}
 800c050:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800c052:	2004      	movs	r0, #4
 800c054:	6390      	str	r0, [r2, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800c056:	e7ec      	b.n	800c032 <SDMMC_CmdSendCSD+0x46>
 800c058:	20000124 	.word	0x20000124
 800c05c:	fffee0c0 	.word	0xfffee0c0
 800c060:	10624dd3 	.word	0x10624dd3
 800c064:	002000c5 	.word	0x002000c5

0800c068 <SDMMC_CmdSetRelAdd>:
  SDMMCx->ARG = Command->Argument;
 800c068:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c06a:	4a27      	ldr	r2, [pc, #156]	; (800c108 <SDMMC_CmdSetRelAdd+0xa0>)
{
 800c06c:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 800c06e:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c070:	68c5      	ldr	r5, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c072:	4c26      	ldr	r4, [pc, #152]	; (800c10c <SDMMC_CmdSetRelAdd+0xa4>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c074:	4b26      	ldr	r3, [pc, #152]	; (800c110 <SDMMC_CmdSetRelAdd+0xa8>)
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c076:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c078:	402b      	ands	r3, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c07a:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c07e:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c082:	0a52      	lsrs	r2, r2, #9
 800c084:	f241 3488 	movw	r4, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c088:	f043 0303 	orr.w	r3, r3, #3
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800c08c:	fb04 f202 	mul.w	r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c090:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800c092:	1e53      	subs	r3, r2, #1
 800c094:	b14a      	cbz	r2, 800c0aa <SDMMC_CmdSetRelAdd+0x42>
    sta_reg = SDMMCx->STA;
 800c096:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c098:	f012 0f45 	tst.w	r2, #69	; 0x45
    if (count-- == 0U)
 800c09c:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c0a0:	d001      	beq.n	800c0a6 <SDMMC_CmdSetRelAdd+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800c0a2:	0495      	lsls	r5, r2, #18
 800c0a4:	d506      	bpl.n	800c0b4 <SDMMC_CmdSetRelAdd+0x4c>
    if (count-- == 0U)
 800c0a6:	1c5a      	adds	r2, r3, #1
 800c0a8:	d1f5      	bne.n	800c096 <SDMMC_CmdSetRelAdd+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800c0aa:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800c0ae:	4618      	mov	r0, r3
 800c0b0:	bc30      	pop	{r4, r5}
 800c0b2:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800c0b4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c0b6:	075c      	lsls	r4, r3, #29
 800c0b8:	d41c      	bmi.n	800c0f4 <SDMMC_CmdSetRelAdd+0x8c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800c0ba:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c0bc:	f013 0301 	ands.w	r3, r3, #1
 800c0c0:	d113      	bne.n	800c0ea <SDMMC_CmdSetRelAdd+0x82>
  return (uint8_t)(SDMMCx->RESPCMD);
 800c0c2:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800c0c4:	b2db      	uxtb	r3, r3
 800c0c6:	2b03      	cmp	r3, #3
 800c0c8:	d112      	bne.n	800c0f0 <SDMMC_CmdSetRelAdd+0x88>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800c0ca:	4b12      	ldr	r3, [pc, #72]	; (800c114 <SDMMC_CmdSetRelAdd+0xac>)
 800c0cc:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
 800c0ce:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 800c0d0:	f412 4360 	ands.w	r3, r2, #57344	; 0xe000
 800c0d4:	d014      	beq.n	800c100 <SDMMC_CmdSetRelAdd+0x98>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 800c0d6:	0451      	lsls	r1, r2, #17
 800c0d8:	d40f      	bmi.n	800c0fa <SDMMC_CmdSetRelAdd+0x92>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800c0da:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 800c0de:	bf14      	ite	ne
 800c0e0:	f44f 5380 	movne.w	r3, #4096	; 0x1000
 800c0e4:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800c0e8:	e7e1      	b.n	800c0ae <SDMMC_CmdSetRelAdd+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800c0ea:	2201      	movs	r2, #1
 800c0ec:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c0ee:	e7de      	b.n	800c0ae <SDMMC_CmdSetRelAdd+0x46>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c0f0:	2301      	movs	r3, #1
 800c0f2:	e7dc      	b.n	800c0ae <SDMMC_CmdSetRelAdd+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800c0f4:	2304      	movs	r3, #4
 800c0f6:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800c0f8:	e7d9      	b.n	800c0ae <SDMMC_CmdSetRelAdd+0x46>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800c0fa:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c0fe:	e7d6      	b.n	800c0ae <SDMMC_CmdSetRelAdd+0x46>
    *pRCA = (uint16_t) (response_r1 >> 16);
 800c100:	0c12      	lsrs	r2, r2, #16
 800c102:	800a      	strh	r2, [r1, #0]
    return SDMMC_ERROR_NONE;
 800c104:	e7d3      	b.n	800c0ae <SDMMC_CmdSetRelAdd+0x46>
 800c106:	bf00      	nop
 800c108:	20000124 	.word	0x20000124
 800c10c:	10624dd3 	.word	0x10624dd3
 800c110:	fffee0c0 	.word	0xfffee0c0
 800c114:	002000c5 	.word	0x002000c5

0800c118 <SDMMC_CmdSendStatus>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c118:	4a4d      	ldr	r2, [pc, #308]	; (800c250 <SDMMC_CmdSendStatus+0x138>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c11a:	4b4e      	ldr	r3, [pc, #312]	; (800c254 <SDMMC_CmdSendStatus+0x13c>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c11c:	6812      	ldr	r2, [r2, #0]
{
 800c11e:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800c120:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c122:	68c4      	ldr	r4, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c124:	494c      	ldr	r1, [pc, #304]	; (800c258 <SDMMC_CmdSendStatus+0x140>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c126:	4023      	ands	r3, r4
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c128:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c12c:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c130:	0a52      	lsrs	r2, r2, #9
 800c132:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c136:	f043 030d 	orr.w	r3, r3, #13
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c13a:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c13e:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800c140:	b152      	cbz	r2, 800c158 <SDMMC_CmdSendStatus+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800c142:	4946      	ldr	r1, [pc, #280]	; (800c25c <SDMMC_CmdSendStatus+0x144>)
 800c144:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800c146:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c148:	420a      	tst	r2, r1
    if (count-- == 0U)
 800c14a:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c14e:	d001      	beq.n	800c154 <SDMMC_CmdSendStatus+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800c150:	0492      	lsls	r2, r2, #18
 800c152:	d507      	bpl.n	800c164 <SDMMC_CmdSendStatus+0x4c>
    if (count-- == 0U)
 800c154:	1c5c      	adds	r4, r3, #1
 800c156:	d1f6      	bne.n	800c146 <SDMMC_CmdSendStatus+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 800c158:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800c15c:	4618      	mov	r0, r3
 800c15e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c162:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800c164:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c166:	075c      	lsls	r4, r3, #29
 800c168:	d43d      	bmi.n	800c1e6 <SDMMC_CmdSendStatus+0xce>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800c16a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c16c:	f013 0301 	ands.w	r3, r3, #1
 800c170:	d134      	bne.n	800c1dc <SDMMC_CmdSendStatus+0xc4>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800c172:	4b3b      	ldr	r3, [pc, #236]	; (800c260 <SDMMC_CmdSendStatus+0x148>)
 800c174:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800c176:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800c178:	b2db      	uxtb	r3, r3
 800c17a:	2b0d      	cmp	r3, #13
 800c17c:	d131      	bne.n	800c1e2 <SDMMC_CmdSendStatus+0xca>
  return (*(__IO uint32_t *) tmp);
 800c17e:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800c180:	4b38      	ldr	r3, [pc, #224]	; (800c264 <SDMMC_CmdSendStatus+0x14c>)
 800c182:	4013      	ands	r3, r2
 800c184:	2b00      	cmp	r3, #0
 800c186:	d0e9      	beq.n	800c15c <SDMMC_CmdSendStatus+0x44>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800c188:	2a00      	cmp	r2, #0
 800c18a:	db2f      	blt.n	800c1ec <SDMMC_CmdSendStatus+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800c18c:	0051      	lsls	r1, r2, #1
 800c18e:	d430      	bmi.n	800c1f2 <SDMMC_CmdSendStatus+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800c190:	0094      	lsls	r4, r2, #2
 800c192:	d430      	bmi.n	800c1f6 <SDMMC_CmdSendStatus+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800c194:	00d0      	lsls	r0, r2, #3
 800c196:	d430      	bmi.n	800c1fa <SDMMC_CmdSendStatus+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800c198:	0111      	lsls	r1, r2, #4
 800c19a:	d431      	bmi.n	800c200 <SDMMC_CmdSendStatus+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800c19c:	0154      	lsls	r4, r2, #5
 800c19e:	d432      	bmi.n	800c206 <SDMMC_CmdSendStatus+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800c1a0:	01d0      	lsls	r0, r2, #7
 800c1a2:	d433      	bmi.n	800c20c <SDMMC_CmdSendStatus+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800c1a4:	0211      	lsls	r1, r2, #8
 800c1a6:	d434      	bmi.n	800c212 <SDMMC_CmdSendStatus+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800c1a8:	0254      	lsls	r4, r2, #9
 800c1aa:	d435      	bmi.n	800c218 <SDMMC_CmdSendStatus+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800c1ac:	0290      	lsls	r0, r2, #10
 800c1ae:	d436      	bmi.n	800c21e <SDMMC_CmdSendStatus+0x106>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800c1b0:	02d1      	lsls	r1, r2, #11
 800c1b2:	d437      	bmi.n	800c224 <SDMMC_CmdSendStatus+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800c1b4:	0354      	lsls	r4, r2, #13
 800c1b6:	d438      	bmi.n	800c22a <SDMMC_CmdSendStatus+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800c1b8:	0390      	lsls	r0, r2, #14
 800c1ba:	d439      	bmi.n	800c230 <SDMMC_CmdSendStatus+0x118>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800c1bc:	03d1      	lsls	r1, r2, #15
 800c1be:	d43a      	bmi.n	800c236 <SDMMC_CmdSendStatus+0x11e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800c1c0:	0414      	lsls	r4, r2, #16
 800c1c2:	d43b      	bmi.n	800c23c <SDMMC_CmdSendStatus+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800c1c4:	0450      	lsls	r0, r2, #17
 800c1c6:	d43f      	bmi.n	800c248 <SDMMC_CmdSendStatus+0x130>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800c1c8:	0491      	lsls	r1, r2, #18
 800c1ca:	d43a      	bmi.n	800c242 <SDMMC_CmdSendStatus+0x12a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800c1cc:	f012 0f08 	tst.w	r2, #8
 800c1d0:	bf14      	ite	ne
 800c1d2:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800c1d6:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800c1da:	e7bf      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800c1dc:	2201      	movs	r2, #1
 800c1de:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c1e0:	e7bc      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c1e2:	2301      	movs	r3, #1
 800c1e4:	e7ba      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800c1e6:	2304      	movs	r3, #4
 800c1e8:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800c1ea:	e7b7      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800c1ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800c1f0:	e7b4      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800c1f2:	2340      	movs	r3, #64	; 0x40
 800c1f4:	e7b2      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800c1f6:	2380      	movs	r3, #128	; 0x80
 800c1f8:	e7b0      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800c1fa:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c1fe:	e7ad      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800c200:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c204:	e7aa      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800c206:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c20a:	e7a7      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800c20c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c210:	e7a4      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800c212:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c216:	e7a1      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800c218:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c21c:	e79e      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800c21e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800c222:	e79b      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_CC_ERR;
 800c224:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800c228:	e798      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800c22a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800c22e:	e795      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800c230:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800c234:	e792      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800c236:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800c23a:	e78f      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800c23c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c240:	e78c      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_ERASE_RESET;
 800c242:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800c246:	e789      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800c248:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c24c:	e786      	b.n	800c15c <SDMMC_CmdSendStatus+0x44>
 800c24e:	bf00      	nop
 800c250:	20000124 	.word	0x20000124
 800c254:	fffee0c0 	.word	0xfffee0c0
 800c258:	10624dd3 	.word	0x10624dd3
 800c25c:	00200045 	.word	0x00200045
 800c260:	002000c5 	.word	0x002000c5
 800c264:	fdffe008 	.word	0xfdffe008

0800c268 <SDMMC_CmdStatusRegister>:
  SDMMCx->ARG = Command->Argument;
 800c268:	2300      	movs	r3, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c26a:	4a4d      	ldr	r2, [pc, #308]	; (800c3a0 <SDMMC_CmdStatusRegister+0x138>)
 800c26c:	494d      	ldr	r1, [pc, #308]	; (800c3a4 <SDMMC_CmdStatusRegister+0x13c>)
 800c26e:	6812      	ldr	r2, [r2, #0]
{
 800c270:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800c272:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c274:	68c4      	ldr	r4, [r0, #12]
 800c276:	4b4c      	ldr	r3, [pc, #304]	; (800c3a8 <SDMMC_CmdStatusRegister+0x140>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c278:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c27c:	4023      	ands	r3, r4
 800c27e:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c282:	0a52      	lsrs	r2, r2, #9
 800c284:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c288:	f043 030d 	orr.w	r3, r3, #13
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c28c:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c290:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800c292:	b152      	cbz	r2, 800c2aa <SDMMC_CmdStatusRegister+0x42>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800c294:	4945      	ldr	r1, [pc, #276]	; (800c3ac <SDMMC_CmdStatusRegister+0x144>)
 800c296:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800c298:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c29a:	420a      	tst	r2, r1
    if (count-- == 0U)
 800c29c:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c2a0:	d001      	beq.n	800c2a6 <SDMMC_CmdStatusRegister+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800c2a2:	0492      	lsls	r2, r2, #18
 800c2a4:	d507      	bpl.n	800c2b6 <SDMMC_CmdStatusRegister+0x4e>
    if (count-- == 0U)
 800c2a6:	1c5c      	adds	r4, r3, #1
 800c2a8:	d1f6      	bne.n	800c298 <SDMMC_CmdStatusRegister+0x30>
      return SDMMC_ERROR_TIMEOUT;
 800c2aa:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800c2ae:	4618      	mov	r0, r3
 800c2b0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c2b4:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800c2b6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c2b8:	075c      	lsls	r4, r3, #29
 800c2ba:	d43d      	bmi.n	800c338 <SDMMC_CmdStatusRegister+0xd0>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800c2bc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c2be:	f013 0301 	ands.w	r3, r3, #1
 800c2c2:	d134      	bne.n	800c32e <SDMMC_CmdStatusRegister+0xc6>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800c2c4:	4b3a      	ldr	r3, [pc, #232]	; (800c3b0 <SDMMC_CmdStatusRegister+0x148>)
 800c2c6:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800c2c8:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800c2ca:	b2db      	uxtb	r3, r3
 800c2cc:	2b0d      	cmp	r3, #13
 800c2ce:	d131      	bne.n	800c334 <SDMMC_CmdStatusRegister+0xcc>
  return (*(__IO uint32_t *) tmp);
 800c2d0:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800c2d2:	4b38      	ldr	r3, [pc, #224]	; (800c3b4 <SDMMC_CmdStatusRegister+0x14c>)
 800c2d4:	4013      	ands	r3, r2
 800c2d6:	2b00      	cmp	r3, #0
 800c2d8:	d0e9      	beq.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800c2da:	2a00      	cmp	r2, #0
 800c2dc:	db2f      	blt.n	800c33e <SDMMC_CmdStatusRegister+0xd6>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800c2de:	0051      	lsls	r1, r2, #1
 800c2e0:	d430      	bmi.n	800c344 <SDMMC_CmdStatusRegister+0xdc>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800c2e2:	0094      	lsls	r4, r2, #2
 800c2e4:	d430      	bmi.n	800c348 <SDMMC_CmdStatusRegister+0xe0>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800c2e6:	00d0      	lsls	r0, r2, #3
 800c2e8:	d430      	bmi.n	800c34c <SDMMC_CmdStatusRegister+0xe4>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800c2ea:	0111      	lsls	r1, r2, #4
 800c2ec:	d431      	bmi.n	800c352 <SDMMC_CmdStatusRegister+0xea>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800c2ee:	0154      	lsls	r4, r2, #5
 800c2f0:	d432      	bmi.n	800c358 <SDMMC_CmdStatusRegister+0xf0>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800c2f2:	01d0      	lsls	r0, r2, #7
 800c2f4:	d433      	bmi.n	800c35e <SDMMC_CmdStatusRegister+0xf6>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800c2f6:	0211      	lsls	r1, r2, #8
 800c2f8:	d434      	bmi.n	800c364 <SDMMC_CmdStatusRegister+0xfc>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800c2fa:	0254      	lsls	r4, r2, #9
 800c2fc:	d435      	bmi.n	800c36a <SDMMC_CmdStatusRegister+0x102>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800c2fe:	0290      	lsls	r0, r2, #10
 800c300:	d436      	bmi.n	800c370 <SDMMC_CmdStatusRegister+0x108>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800c302:	02d1      	lsls	r1, r2, #11
 800c304:	d437      	bmi.n	800c376 <SDMMC_CmdStatusRegister+0x10e>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800c306:	0354      	lsls	r4, r2, #13
 800c308:	d438      	bmi.n	800c37c <SDMMC_CmdStatusRegister+0x114>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800c30a:	0390      	lsls	r0, r2, #14
 800c30c:	d439      	bmi.n	800c382 <SDMMC_CmdStatusRegister+0x11a>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800c30e:	03d1      	lsls	r1, r2, #15
 800c310:	d43a      	bmi.n	800c388 <SDMMC_CmdStatusRegister+0x120>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800c312:	0414      	lsls	r4, r2, #16
 800c314:	d43b      	bmi.n	800c38e <SDMMC_CmdStatusRegister+0x126>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800c316:	0450      	lsls	r0, r2, #17
 800c318:	d43f      	bmi.n	800c39a <SDMMC_CmdStatusRegister+0x132>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800c31a:	0491      	lsls	r1, r2, #18
 800c31c:	d43a      	bmi.n	800c394 <SDMMC_CmdStatusRegister+0x12c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800c31e:	f012 0f08 	tst.w	r2, #8
 800c322:	bf14      	ite	ne
 800c324:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800c328:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800c32c:	e7bf      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800c32e:	2201      	movs	r2, #1
 800c330:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c332:	e7bc      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c334:	2301      	movs	r3, #1
 800c336:	e7ba      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800c338:	2304      	movs	r3, #4
 800c33a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800c33c:	e7b7      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800c33e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800c342:	e7b4      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800c344:	2340      	movs	r3, #64	; 0x40
 800c346:	e7b2      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800c348:	2380      	movs	r3, #128	; 0x80
 800c34a:	e7b0      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800c34c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c350:	e7ad      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800c352:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c356:	e7aa      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800c358:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c35c:	e7a7      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800c35e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c362:	e7a4      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800c364:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c368:	e7a1      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800c36a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c36e:	e79e      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800c370:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800c374:	e79b      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_CC_ERR;
 800c376:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800c37a:	e798      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800c37c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800c380:	e795      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800c382:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800c386:	e792      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800c388:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800c38c:	e78f      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800c38e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c392:	e78c      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_ERASE_RESET;
 800c394:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800c398:	e789      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800c39a:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c39e:	e786      	b.n	800c2ae <SDMMC_CmdStatusRegister+0x46>
 800c3a0:	20000124 	.word	0x20000124
 800c3a4:	10624dd3 	.word	0x10624dd3
 800c3a8:	fffee0c0 	.word	0xfffee0c0
 800c3ac:	00200045 	.word	0x00200045
 800c3b0:	002000c5 	.word	0x002000c5
 800c3b4:	fdffe008 	.word	0xfdffe008

0800c3b8 <SDMMC_CmdVoltageSwitch>:
  SDMMCx->ARG = Command->Argument;
 800c3b8:	2300      	movs	r3, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c3ba:	4a4d      	ldr	r2, [pc, #308]	; (800c4f0 <SDMMC_CmdVoltageSwitch+0x138>)
 800c3bc:	494d      	ldr	r1, [pc, #308]	; (800c4f4 <SDMMC_CmdVoltageSwitch+0x13c>)
 800c3be:	6812      	ldr	r2, [r2, #0]
{
 800c3c0:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 800c3c2:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c3c4:	68c4      	ldr	r4, [r0, #12]
 800c3c6:	4b4c      	ldr	r3, [pc, #304]	; (800c4f8 <SDMMC_CmdVoltageSwitch+0x140>)
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c3c8:	fba1 1202 	umull	r1, r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c3cc:	4023      	ands	r3, r4
 800c3ce:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c3d2:	0a52      	lsrs	r2, r2, #9
 800c3d4:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c3d8:	f043 030b 	orr.w	r3, r3, #11
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800c3dc:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800c3e0:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800c3e2:	b152      	cbz	r2, 800c3fa <SDMMC_CmdVoltageSwitch+0x42>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800c3e4:	4945      	ldr	r1, [pc, #276]	; (800c4fc <SDMMC_CmdVoltageSwitch+0x144>)
 800c3e6:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800c3e8:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c3ea:	420a      	tst	r2, r1
    if (count-- == 0U)
 800c3ec:	f103 33ff 	add.w	r3, r3, #4294967295
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800c3f0:	d001      	beq.n	800c3f6 <SDMMC_CmdVoltageSwitch+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800c3f2:	0492      	lsls	r2, r2, #18
 800c3f4:	d507      	bpl.n	800c406 <SDMMC_CmdVoltageSwitch+0x4e>
    if (count-- == 0U)
 800c3f6:	1c5c      	adds	r4, r3, #1
 800c3f8:	d1f6      	bne.n	800c3e8 <SDMMC_CmdVoltageSwitch+0x30>
      return SDMMC_ERROR_TIMEOUT;
 800c3fa:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 800c3fe:	4618      	mov	r0, r3
 800c400:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c404:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800c406:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c408:	075c      	lsls	r4, r3, #29
 800c40a:	d43d      	bmi.n	800c488 <SDMMC_CmdVoltageSwitch+0xd0>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800c40c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c40e:	f013 0301 	ands.w	r3, r3, #1
 800c412:	d134      	bne.n	800c47e <SDMMC_CmdVoltageSwitch+0xc6>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800c414:	4b3a      	ldr	r3, [pc, #232]	; (800c500 <SDMMC_CmdVoltageSwitch+0x148>)
 800c416:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800c418:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800c41a:	b2db      	uxtb	r3, r3
 800c41c:	2b0b      	cmp	r3, #11
 800c41e:	d131      	bne.n	800c484 <SDMMC_CmdVoltageSwitch+0xcc>
  return (*(__IO uint32_t *) tmp);
 800c420:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800c422:	4b38      	ldr	r3, [pc, #224]	; (800c504 <SDMMC_CmdVoltageSwitch+0x14c>)
 800c424:	4013      	ands	r3, r2
 800c426:	2b00      	cmp	r3, #0
 800c428:	d0e9      	beq.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800c42a:	2a00      	cmp	r2, #0
 800c42c:	db2f      	blt.n	800c48e <SDMMC_CmdVoltageSwitch+0xd6>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800c42e:	0051      	lsls	r1, r2, #1
 800c430:	d430      	bmi.n	800c494 <SDMMC_CmdVoltageSwitch+0xdc>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800c432:	0094      	lsls	r4, r2, #2
 800c434:	d430      	bmi.n	800c498 <SDMMC_CmdVoltageSwitch+0xe0>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800c436:	00d0      	lsls	r0, r2, #3
 800c438:	d430      	bmi.n	800c49c <SDMMC_CmdVoltageSwitch+0xe4>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800c43a:	0111      	lsls	r1, r2, #4
 800c43c:	d431      	bmi.n	800c4a2 <SDMMC_CmdVoltageSwitch+0xea>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800c43e:	0154      	lsls	r4, r2, #5
 800c440:	d432      	bmi.n	800c4a8 <SDMMC_CmdVoltageSwitch+0xf0>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800c442:	01d0      	lsls	r0, r2, #7
 800c444:	d433      	bmi.n	800c4ae <SDMMC_CmdVoltageSwitch+0xf6>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800c446:	0211      	lsls	r1, r2, #8
 800c448:	d434      	bmi.n	800c4b4 <SDMMC_CmdVoltageSwitch+0xfc>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800c44a:	0254      	lsls	r4, r2, #9
 800c44c:	d435      	bmi.n	800c4ba <SDMMC_CmdVoltageSwitch+0x102>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800c44e:	0290      	lsls	r0, r2, #10
 800c450:	d436      	bmi.n	800c4c0 <SDMMC_CmdVoltageSwitch+0x108>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800c452:	02d1      	lsls	r1, r2, #11
 800c454:	d437      	bmi.n	800c4c6 <SDMMC_CmdVoltageSwitch+0x10e>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800c456:	0354      	lsls	r4, r2, #13
 800c458:	d438      	bmi.n	800c4cc <SDMMC_CmdVoltageSwitch+0x114>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800c45a:	0390      	lsls	r0, r2, #14
 800c45c:	d439      	bmi.n	800c4d2 <SDMMC_CmdVoltageSwitch+0x11a>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800c45e:	03d1      	lsls	r1, r2, #15
 800c460:	d43a      	bmi.n	800c4d8 <SDMMC_CmdVoltageSwitch+0x120>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800c462:	0414      	lsls	r4, r2, #16
 800c464:	d43b      	bmi.n	800c4de <SDMMC_CmdVoltageSwitch+0x126>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800c466:	0450      	lsls	r0, r2, #17
 800c468:	d43f      	bmi.n	800c4ea <SDMMC_CmdVoltageSwitch+0x132>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800c46a:	0491      	lsls	r1, r2, #18
 800c46c:	d43a      	bmi.n	800c4e4 <SDMMC_CmdVoltageSwitch+0x12c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800c46e:	f012 0f08 	tst.w	r2, #8
 800c472:	bf14      	ite	ne
 800c474:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800c478:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800c47c:	e7bf      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800c47e:	2201      	movs	r2, #1
 800c480:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c482:	e7bc      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800c484:	2301      	movs	r3, #1
 800c486:	e7ba      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800c488:	2304      	movs	r3, #4
 800c48a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800c48c:	e7b7      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800c48e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800c492:	e7b4      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800c494:	2340      	movs	r3, #64	; 0x40
 800c496:	e7b2      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800c498:	2380      	movs	r3, #128	; 0x80
 800c49a:	e7b0      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800c49c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c4a0:	e7ad      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800c4a2:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c4a6:	e7aa      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800c4a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800c4ac:	e7a7      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800c4ae:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800c4b2:	e7a4      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800c4b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800c4b8:	e7a1      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800c4ba:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800c4be:	e79e      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800c4c0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800c4c4:	e79b      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_CC_ERR;
 800c4c6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800c4ca:	e798      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800c4cc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800c4d0:	e795      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800c4d2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800c4d6:	e792      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800c4d8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800c4dc:	e78f      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800c4de:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800c4e2:	e78c      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_ERASE_RESET;
 800c4e4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800c4e8:	e789      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800c4ea:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800c4ee:	e786      	b.n	800c3fe <SDMMC_CmdVoltageSwitch+0x46>
 800c4f0:	20000124 	.word	0x20000124
 800c4f4:	10624dd3 	.word	0x10624dd3
 800c4f8:	fffee0c0 	.word	0xfffee0c0
 800c4fc:	00200045 	.word	0x00200045
 800c500:	002000c5 	.word	0x002000c5
 800c504:	fdffe008 	.word	0xfdffe008

0800c508 <USB_SetTurnaroundTime>:

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 800c508:	2a02      	cmp	r2, #2
 800c50a:	d00a      	beq.n	800c522 <USB_SetTurnaroundTime+0x1a>
 800c50c:	f44f 5110 	mov.w	r1, #9216	; 0x2400
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 800c510:	68c2      	ldr	r2, [r0, #12]
 800c512:	f422 5270 	bic.w	r2, r2, #15360	; 0x3c00
 800c516:	60c2      	str	r2, [r0, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 800c518:	68c3      	ldr	r3, [r0, #12]
 800c51a:	430b      	orrs	r3, r1
 800c51c:	60c3      	str	r3, [r0, #12]

  return HAL_OK;
}
 800c51e:	2000      	movs	r0, #0
 800c520:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 800c522:	4b26      	ldr	r3, [pc, #152]	; (800c5bc <USB_SetTurnaroundTime+0xb4>)
 800c524:	4a26      	ldr	r2, [pc, #152]	; (800c5c0 <USB_SetTurnaroundTime+0xb8>)
 800c526:	440b      	add	r3, r1
 800c528:	4293      	cmp	r3, r2
 800c52a:	d932      	bls.n	800c592 <USB_SetTurnaroundTime+0x8a>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 800c52c:	4b25      	ldr	r3, [pc, #148]	; (800c5c4 <USB_SetTurnaroundTime+0xbc>)
 800c52e:	4a26      	ldr	r2, [pc, #152]	; (800c5c8 <USB_SetTurnaroundTime+0xc0>)
 800c530:	440b      	add	r3, r1
 800c532:	4293      	cmp	r3, r2
 800c534:	d930      	bls.n	800c598 <USB_SetTurnaroundTime+0x90>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 800c536:	4a25      	ldr	r2, [pc, #148]	; (800c5cc <USB_SetTurnaroundTime+0xc4>)
 800c538:	f5a1 0374 	sub.w	r3, r1, #15990784	; 0xf40000
 800c53c:	f5a3 5310 	sub.w	r3, r3, #9216	; 0x2400
 800c540:	4293      	cmp	r3, r2
 800c542:	d92c      	bls.n	800c59e <USB_SetTurnaroundTime+0x96>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 800c544:	4a22      	ldr	r2, [pc, #136]	; (800c5d0 <USB_SetTurnaroundTime+0xc8>)
 800c546:	f1a1 7383 	sub.w	r3, r1, #17170432	; 0x1060000
 800c54a:	f5a3 43e7 	sub.w	r3, r3, #29568	; 0x7380
 800c54e:	4293      	cmp	r3, r2
 800c550:	d328      	bcc.n	800c5a4 <USB_SetTurnaroundTime+0x9c>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 800c552:	4b20      	ldr	r3, [pc, #128]	; (800c5d4 <USB_SetTurnaroundTime+0xcc>)
 800c554:	4a20      	ldr	r2, [pc, #128]	; (800c5d8 <USB_SetTurnaroundTime+0xd0>)
 800c556:	440b      	add	r3, r1
 800c558:	4293      	cmp	r3, r2
 800c55a:	d926      	bls.n	800c5aa <USB_SetTurnaroundTime+0xa2>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 800c55c:	4b1f      	ldr	r3, [pc, #124]	; (800c5dc <USB_SetTurnaroundTime+0xd4>)
 800c55e:	4a20      	ldr	r2, [pc, #128]	; (800c5e0 <USB_SetTurnaroundTime+0xd8>)
 800c560:	440b      	add	r3, r1
 800c562:	4293      	cmp	r3, r2
 800c564:	d324      	bcc.n	800c5b0 <USB_SetTurnaroundTime+0xa8>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 800c566:	4b1f      	ldr	r3, [pc, #124]	; (800c5e4 <USB_SetTurnaroundTime+0xdc>)
 800c568:	4a1f      	ldr	r2, [pc, #124]	; (800c5e8 <USB_SetTurnaroundTime+0xe0>)
 800c56a:	440b      	add	r3, r1
 800c56c:	4293      	cmp	r3, r2
 800c56e:	d3cd      	bcc.n	800c50c <USB_SetTurnaroundTime+0x4>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 800c570:	4a1e      	ldr	r2, [pc, #120]	; (800c5ec <USB_SetTurnaroundTime+0xe4>)
 800c572:	f1a1 73b7 	sub.w	r3, r1, #23986176	; 0x16e0000
 800c576:	f5a3 5358 	sub.w	r3, r3, #13824	; 0x3600
 800c57a:	4293      	cmp	r3, r2
 800c57c:	d31b      	bcc.n	800c5b6 <USB_SetTurnaroundTime+0xae>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 800c57e:	4b1c      	ldr	r3, [pc, #112]	; (800c5f0 <USB_SetTurnaroundTime+0xe8>)
 800c580:	4a1c      	ldr	r2, [pc, #112]	; (800c5f4 <USB_SetTurnaroundTime+0xec>)
 800c582:	440b      	add	r3, r1
 800c584:	4293      	cmp	r3, r2
 800c586:	bf34      	ite	cc
 800c588:	f44f 51e0 	movcc.w	r1, #7168	; 0x1c00
 800c58c:	f44f 51c0 	movcs.w	r1, #6144	; 0x1800
 800c590:	e7be      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c592:	f44f 5170 	mov.w	r1, #15360	; 0x3c00
 800c596:	e7bb      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c598:	f44f 5160 	mov.w	r1, #14336	; 0x3800
 800c59c:	e7b8      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c59e:	f44f 5150 	mov.w	r1, #13312	; 0x3400
 800c5a2:	e7b5      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c5a4:	f44f 5140 	mov.w	r1, #12288	; 0x3000
 800c5a8:	e7b2      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c5aa:	f44f 5130 	mov.w	r1, #11264	; 0x2c00
 800c5ae:	e7af      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c5b0:	f44f 5120 	mov.w	r1, #10240	; 0x2800
 800c5b4:	e7ac      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c5b6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800c5ba:	e7a9      	b.n	800c510 <USB_SetTurnaroundTime+0x8>
 800c5bc:	ff275340 	.word	0xff275340
 800c5c0:	000c34ff 	.word	0x000c34ff
 800c5c4:	ff1b1e40 	.word	0xff1b1e40
 800c5c8:	000f423f 	.word	0x000f423f
 800c5cc:	00124f7f 	.word	0x00124f7f
 800c5d0:	0013d620 	.word	0x0013d620
 800c5d4:	fee5b660 	.word	0xfee5b660
 800c5d8:	0016e35f 	.word	0x0016e35f
 800c5dc:	feced300 	.word	0xfeced300
 800c5e0:	001b7740 	.word	0x001b7740
 800c5e4:	feb35bc0 	.word	0xfeb35bc0
 800c5e8:	002191c0 	.word	0x002191c0
 800c5ec:	00387520 	.word	0x00387520
 800c5f0:	fe5954e0 	.word	0xfe5954e0
 800c5f4:	00419ce0 	.word	0x00419ce0

0800c5f8 <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
  uint32_t count = 0U;

  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800c5f8:	0189      	lsls	r1, r1, #6
 800c5fa:	f041 0120 	orr.w	r1, r1, #32
 800c5fe:	4a06      	ldr	r2, [pc, #24]	; (800c618 <USB_FlushTxFifo+0x20>)
 800c600:	6101      	str	r1, [r0, #16]

  do
  {
    if (++count > 200000U)
 800c602:	e001      	b.n	800c608 <USB_FlushTxFifo+0x10>
 800c604:	3a01      	subs	r2, #1
 800c606:	d005      	beq.n	800c614 <USB_FlushTxFifo+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800c608:	6903      	ldr	r3, [r0, #16]
 800c60a:	f013 0320 	ands.w	r3, r3, #32
 800c60e:	d1f9      	bne.n	800c604 <USB_FlushTxFifo+0xc>

  return HAL_OK;
 800c610:	4618      	mov	r0, r3
 800c612:	4770      	bx	lr
      return HAL_TIMEOUT;
 800c614:	2003      	movs	r0, #3
}
 800c616:	4770      	bx	lr
 800c618:	00030d40 	.word	0x00030d40

0800c61c <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 800c61c:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808

  if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 800c620:	f013 0f02 	tst.w	r3, #2
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 800c624:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  {
    speed = 0xFU;
  }

  return speed;
}
 800c628:	bf14      	ite	ne
 800c62a:	2002      	movne	r0, #2
 800c62c:	200f      	moveq	r0, #15
 800c62e:	4770      	bx	lr

0800c630 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800c630:	b470      	push	{r4, r5, r6}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;

  if (ep->is_in == 1U)
 800c632:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 800c634:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 800c636:	2b01      	cmp	r3, #1
 800c638:	d022      	beq.n	800c680 <USB_ActivateEndpoint+0x50>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 800c63a:	f002 050f 	and.w	r5, r2, #15
 800c63e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800c642:	40ab      	lsls	r3, r5
 800c644:	f8d0 581c 	ldr.w	r5, [r0, #2076]	; 0x81c
 800c648:	f500 6400 	add.w	r4, r0, #2048	; 0x800
 800c64c:	432b      	orrs	r3, r5

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800c64e:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 800c652:	61e3      	str	r3, [r4, #28]
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800c654:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800c658:	041b      	lsls	r3, r3, #16
 800c65a:	d40e      	bmi.n	800c67a <USB_ActivateEndpoint+0x4a>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 800c65c:	688b      	ldr	r3, [r1, #8]
 800c65e:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	; 0xb00
                                    ((uint32_t)ep->type << 18) |
 800c662:	78ca      	ldrb	r2, [r1, #3]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 800c664:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800c668:	4323      	orrs	r3, r4
 800c66a:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 800c66e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c672:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800c676:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
}
 800c67a:	2000      	movs	r0, #0
 800c67c:	bc70      	pop	{r4, r5, r6}
 800c67e:	4770      	bx	lr
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 800c680:	f8d0 681c 	ldr.w	r6, [r0, #2076]	; 0x81c
 800c684:	f002 040f 	and.w	r4, r2, #15
 800c688:	f500 6500 	add.w	r5, r0, #2048	; 0x800
 800c68c:	40a3      	lsls	r3, r4
 800c68e:	4333      	orrs	r3, r6
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800c690:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 800c694:	61eb      	str	r3, [r5, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800c696:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800c69a:	041c      	lsls	r4, r3, #16
 800c69c:	d4ed      	bmi.n	800c67a <USB_ActivateEndpoint+0x4a>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800c69e:	688b      	ldr	r3, [r1, #8]
 800c6a0:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 800c6a4:	78c9      	ldrb	r1, [r1, #3]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800c6a6:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800c6aa:	4323      	orrs	r3, r4
 800c6ac:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 800c6b0:	ea43 5282 	orr.w	r2, r3, r2, lsl #22
 800c6b4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800c6b8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800c6bc:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
}
 800c6c0:	bc70      	pop	{r4, r5, r6}
 800c6c2:	2000      	movs	r0, #0
 800c6c4:	4770      	bx	lr
 800c6c6:	bf00      	nop

0800c6c8 <USB_EPStartXfer>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800c6c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 800c6cc:	784e      	ldrb	r6, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 800c6ce:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 800c6d0:	2e01      	cmp	r6, #1
 800c6d2:	d049      	beq.n	800c768 <USB_EPStartXfer+0xa0>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800c6d4:	eb00 1342 	add.w	r3, r0, r2, lsl #5
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);

    if (ep->xfer_len == 0U)
 800c6d8:	694a      	ldr	r2, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800c6da:	f8d3 4b10 	ldr.w	r4, [r3, #2832]	; 0xb10
 800c6de:	0ce4      	lsrs	r4, r4, #19
 800c6e0:	04e4      	lsls	r4, r4, #19
 800c6e2:	f8c3 4b10 	str.w	r4, [r3, #2832]	; 0xb10
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800c6e6:	f8d3 4b10 	ldr.w	r4, [r3, #2832]	; 0xb10
 800c6ea:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800c6ee:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800c6f2:	f503 6530 	add.w	r5, r3, #2816	; 0xb00
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800c6f6:	612c      	str	r4, [r5, #16]
    if (ep->xfer_len == 0U)
 800c6f8:	b35a      	cbz	r2, 800c752 <USB_EPStartXfer+0x8a>
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
    }
    else
    {
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 800c6fa:	688c      	ldr	r4, [r1, #8]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 800c6fc:	4e5e      	ldr	r6, [pc, #376]	; (800c878 <USB_EPStartXfer+0x1b0>)
 800c6fe:	692f      	ldr	r7, [r5, #16]
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 800c700:	4422      	add	r2, r4
 800c702:	3a01      	subs	r2, #1
 800c704:	fbb2 f2f4 	udiv	r2, r2, r4
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 800c708:	ea06 46c2 	and.w	r6, r6, r2, lsl #19
 800c70c:	433e      	orrs	r6, r7
 800c70e:	612e      	str	r6, [r5, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 800c710:	b292      	uxth	r2, r2
 800c712:	fb04 f202 	mul.w	r2, r4, r2
 800c716:	692c      	ldr	r4, [r5, #16]
 800c718:	f3c2 0212 	ubfx	r2, r2, #0, #19
 800c71c:	4322      	orrs	r2, r4
 800c71e:	612a      	str	r2, [r5, #16]
    }

    if (ep->type == EP_TYPE_ISOC)
 800c720:	78ca      	ldrb	r2, [r1, #3]
 800c722:	2a01      	cmp	r2, #1
 800c724:	d10c      	bne.n	800c740 <USB_EPStartXfer+0x78>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800c726:	f8d0 2808 	ldr.w	r2, [r0, #2056]	; 0x808
 800c72a:	f412 7f80 	tst.w	r2, #256	; 0x100
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800c72e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800c732:	bf0c      	ite	eq
 800c734:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800c738:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 800c73c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800c740:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800c744:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 800c748:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  }

  return HAL_OK;
}
 800c74c:	2000      	movs	r0, #0
 800c74e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800c752:	688a      	ldr	r2, [r1, #8]
 800c754:	692c      	ldr	r4, [r5, #16]
 800c756:	f3c2 0212 	ubfx	r2, r2, #0, #19
 800c75a:	4322      	orrs	r2, r4
 800c75c:	612a      	str	r2, [r5, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800c75e:	692a      	ldr	r2, [r5, #16]
 800c760:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800c764:	612a      	str	r2, [r5, #16]
 800c766:	e7db      	b.n	800c720 <USB_EPStartXfer+0x58>
    if (ep->xfer_len == 0U)
 800c768:	694d      	ldr	r5, [r1, #20]
 800c76a:	2d00      	cmp	r5, #0
 800c76c:	d138      	bne.n	800c7e0 <USB_EPStartXfer+0x118>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800c76e:	eb00 1642 	add.w	r6, r0, r2, lsl #5
 800c772:	f506 6410 	add.w	r4, r6, #2304	; 0x900
 800c776:	6923      	ldr	r3, [r4, #16]
 800c778:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800c77c:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 800c780:	6123      	str	r3, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800c782:	6923      	ldr	r3, [r4, #16]
 800c784:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800c788:	6123      	str	r3, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c78a:	6923      	ldr	r3, [r4, #16]
 800c78c:	0cdb      	lsrs	r3, r3, #19
 800c78e:	04db      	lsls	r3, r3, #19
 800c790:	6123      	str	r3, [r4, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800c792:	f8d6 3900 	ldr.w	r3, [r6, #2304]	; 0x900
 800c796:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c79a:	f8c6 3900 	str.w	r3, [r6, #2304]	; 0x900
    if (ep->type != EP_TYPE_ISOC)
 800c79e:	78cb      	ldrb	r3, [r1, #3]
 800c7a0:	2b01      	cmp	r3, #1
 800c7a2:	d1d3      	bne.n	800c74c <USB_EPStartXfer+0x84>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800c7a4:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
      (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len);
 800c7a8:	68c9      	ldr	r1, [r1, #12]
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800c7aa:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800c7ae:	6823      	ldr	r3, [r4, #0]
 800c7b0:	bf0c      	ite	eq
 800c7b2:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800c7b6:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 800c7ba:	6023      	str	r3, [r4, #0]
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t *pSrc = (uint32_t *)src;
  uint32_t count32b, i;

  count32b = ((uint32_t)len + 3U) / 4U;
 800c7bc:	b2ac      	uxth	r4, r5
 800c7be:	3403      	adds	r4, #3
  for (i = 0U; i < count32b; i++)
 800c7c0:	08a4      	lsrs	r4, r4, #2
 800c7c2:	d0c3      	beq.n	800c74c <USB_EPStartXfer+0x84>
  {
    USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800c7c4:	eb00 3302 	add.w	r3, r0, r2, lsl #12
 800c7c8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 800c7cc:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 800c7d0:	f851 5b04 	ldr.w	r5, [r1], #4
 800c7d4:	601d      	str	r5, [r3, #0]
  for (i = 0U; i < count32b; i++)
 800c7d6:	42a1      	cmp	r1, r4
 800c7d8:	d1fa      	bne.n	800c7d0 <USB_EPStartXfer+0x108>
}
 800c7da:	2000      	movs	r0, #0
 800c7dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c7e0:	eb00 1c42 	add.w	ip, r0, r2, lsl #5
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800c7e4:	f8d1 e008 	ldr.w	lr, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c7e8:	f8dc 7910 	ldr.w	r7, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800c7ec:	4b22      	ldr	r3, [pc, #136]	; (800c878 <USB_EPStartXfer+0x1b0>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c7ee:	0cff      	lsrs	r7, r7, #19
 800c7f0:	04ff      	lsls	r7, r7, #19
 800c7f2:	f8cc 7910 	str.w	r7, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800c7f6:	f8dc 7910 	ldr.w	r7, [ip, #2320]	; 0x910
 800c7fa:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 800c7fe:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 800c802:	f8cc 7910 	str.w	r7, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800c806:	f8dc 8910 	ldr.w	r8, [ip, #2320]	; 0x910
 800c80a:	eb05 070e 	add.w	r7, r5, lr
 800c80e:	3f01      	subs	r7, #1
 800c810:	fbb7 f7fe 	udiv	r7, r7, lr
 800c814:	ea03 43c7 	and.w	r3, r3, r7, lsl #19
 800c818:	ea43 0308 	orr.w	r3, r3, r8
 800c81c:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800c820:	f8dc 7910 	ldr.w	r7, [ip, #2320]	; 0x910
 800c824:	f3c5 0312 	ubfx	r3, r5, #0, #19
 800c828:	433b      	orrs	r3, r7
 800c82a:	f8cc 3910 	str.w	r3, [ip, #2320]	; 0x910
      if (ep->type == EP_TYPE_ISOC)
 800c82e:	78cb      	ldrb	r3, [r1, #3]
 800c830:	2b01      	cmp	r3, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c832:	f50c 6410 	add.w	r4, ip, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 800c836:	d010      	beq.n	800c85a <USB_EPStartXfer+0x192>
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800c838:	f8dc 3900 	ldr.w	r3, [ip, #2304]	; 0x900
 800c83c:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c840:	f8cc 3900 	str.w	r3, [ip, #2304]	; 0x900
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800c844:	f002 030f 	and.w	r3, r2, #15
 800c848:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 800c84c:	409e      	lsls	r6, r3
 800c84e:	4316      	orrs	r6, r2
 800c850:	f8c0 6834 	str.w	r6, [r0, #2100]	; 0x834
}
 800c854:	2000      	movs	r0, #0
 800c856:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 800c85a:	6923      	ldr	r3, [r4, #16]
 800c85c:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800c860:	6123      	str	r3, [r4, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800c862:	6923      	ldr	r3, [r4, #16]
 800c864:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800c868:	6123      	str	r3, [r4, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800c86a:	f8dc 3900 	ldr.w	r3, [ip, #2304]	; 0x900
 800c86e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c872:	f8cc 3900 	str.w	r3, [ip, #2304]	; 0x900
    if (ep->type != EP_TYPE_ISOC)
 800c876:	e795      	b.n	800c7a4 <USB_EPStartXfer+0xdc>
 800c878:	1ff80000 	.word	0x1ff80000

0800c87c <USB_EP0StartXfer>:
{
 800c87c:	b4f0      	push	{r4, r5, r6, r7}
  if (ep->is_in == 1U)
 800c87e:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 800c880:	780e      	ldrb	r6, [r1, #0]
  if (ep->is_in == 1U)
 800c882:	2b01      	cmp	r3, #1
 800c884:	d027      	beq.n	800c8d6 <USB_EP0StartXfer+0x5a>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800c886:	eb00 1046 	add.w	r0, r0, r6, lsl #5
    if (ep->xfer_len > 0U)
 800c88a:	694c      	ldr	r4, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800c88c:	f8d0 2b10 	ldr.w	r2, [r0, #2832]	; 0xb10
 800c890:	0cd2      	lsrs	r2, r2, #19
 800c892:	04d2      	lsls	r2, r2, #19
 800c894:	f8c0 2b10 	str.w	r2, [r0, #2832]	; 0xb10
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800c898:	f8d0 2b10 	ldr.w	r2, [r0, #2832]	; 0xb10
 800c89c:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 800c8a0:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800c8a4:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800c8a8:	611a      	str	r2, [r3, #16]
      ep->xfer_len = ep->maxpacket;
 800c8aa:	688a      	ldr	r2, [r1, #8]
    if (ep->xfer_len > 0U)
 800c8ac:	b98c      	cbnz	r4, 800c8d2 <USB_EP0StartXfer+0x56>
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800c8ae:	6919      	ldr	r1, [r3, #16]
 800c8b0:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 800c8b4:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 800c8b6:	6919      	ldr	r1, [r3, #16]
 800c8b8:	f3c2 0212 	ubfx	r2, r2, #0, #19
 800c8bc:	430a      	orrs	r2, r1
 800c8be:	611a      	str	r2, [r3, #16]
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800c8c0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800c8c4:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c8c8:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 800c8cc:	2000      	movs	r0, #0
 800c8ce:	bcf0      	pop	{r4, r5, r6, r7}
 800c8d0:	4770      	bx	lr
      ep->xfer_len = ep->maxpacket;
 800c8d2:	614a      	str	r2, [r1, #20]
 800c8d4:	e7eb      	b.n	800c8ae <USB_EP0StartXfer+0x32>
    if (ep->xfer_len == 0U)
 800c8d6:	694a      	ldr	r2, [r1, #20]
 800c8d8:	b38a      	cbz	r2, 800c93e <USB_EP0StartXfer+0xc2>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c8da:	eb00 1546 	add.w	r5, r0, r6, lsl #5
      if (ep->xfer_len > ep->maxpacket)
 800c8de:	688f      	ldr	r7, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c8e0:	f8d5 4910 	ldr.w	r4, [r5, #2320]	; 0x910
 800c8e4:	0ce4      	lsrs	r4, r4, #19
 800c8e6:	04e4      	lsls	r4, r4, #19
 800c8e8:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800c8ec:	f8d5 4910 	ldr.w	r4, [r5, #2320]	; 0x910
 800c8f0:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 800c8f4:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
      if (ep->xfer_len > ep->maxpacket)
 800c8f8:	42ba      	cmp	r2, r7
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c8fa:	f505 6310 	add.w	r3, r5, #2304	; 0x900
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800c8fe:	611c      	str	r4, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 800c900:	d93c      	bls.n	800c97c <USB_EP0StartXfer+0x100>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800c902:	691a      	ldr	r2, [r3, #16]
        ep->xfer_len = ep->maxpacket;
 800c904:	614f      	str	r7, [r1, #20]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800c906:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800c90a:	611a      	str	r2, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800c90c:	6919      	ldr	r1, [r3, #16]
 800c90e:	f3c7 0212 	ubfx	r2, r7, #0, #19
 800c912:	430a      	orrs	r2, r1
 800c914:	611a      	str	r2, [r3, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800c916:	f8d5 3900 	ldr.w	r3, [r5, #2304]	; 0x900
 800c91a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c91e:	f8c5 3900 	str.w	r3, [r5, #2304]	; 0x900
    if (ep->xfer_len > 0U)
 800c922:	2f00      	cmp	r7, #0
 800c924:	d0d2      	beq.n	800c8cc <USB_EP0StartXfer+0x50>
      USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800c926:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 800c92a:	2301      	movs	r3, #1
 800c92c:	f006 000f 	and.w	r0, r6, #15
 800c930:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800c932:	4083      	lsls	r3, r0
 800c934:	430b      	orrs	r3, r1
}
 800c936:	2000      	movs	r0, #0
 800c938:	bcf0      	pop	{r4, r5, r6, r7}
      USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800c93a:	6353      	str	r3, [r2, #52]	; 0x34
}
 800c93c:	4770      	bx	lr
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800c93e:	eb00 1046 	add.w	r0, r0, r6, lsl #5
}
 800c942:	bcf0      	pop	{r4, r5, r6, r7}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800c944:	f8d0 2910 	ldr.w	r2, [r0, #2320]	; 0x910
 800c948:	f022 52ff 	bic.w	r2, r2, #534773760	; 0x1fe00000
 800c94c:	f422 12c0 	bic.w	r2, r2, #1572864	; 0x180000
 800c950:	f8c0 2910 	str.w	r2, [r0, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800c954:	f8d0 2910 	ldr.w	r2, [r0, #2320]	; 0x910
 800c958:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800c95c:	f8c0 2910 	str.w	r2, [r0, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800c960:	f8d0 2910 	ldr.w	r2, [r0, #2320]	; 0x910
 800c964:	0cd2      	lsrs	r2, r2, #19
 800c966:	04d2      	lsls	r2, r2, #19
 800c968:	f8c0 2910 	str.w	r2, [r0, #2320]	; 0x910
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800c96c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800c970:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c974:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800c978:	2000      	movs	r0, #0
 800c97a:	4770      	bx	lr
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800c97c:	6919      	ldr	r1, [r3, #16]
 800c97e:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 800c982:	6119      	str	r1, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800c984:	6919      	ldr	r1, [r3, #16]
 800c986:	f3c2 0212 	ubfx	r2, r2, #0, #19
 800c98a:	430a      	orrs	r2, r1
 800c98c:	611a      	str	r2, [r3, #16]
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800c98e:	f8d5 3900 	ldr.w	r3, [r5, #2304]	; 0x900
 800c992:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800c996:	f8c5 3900 	str.w	r3, [r5, #2304]	; 0x900
    if (ep->xfer_len > 0U)
 800c99a:	e7c4      	b.n	800c926 <USB_EP0StartXfer+0xaa>

0800c99c <USB_WritePacket>:
  count32b = ((uint32_t)len + 3U) / 4U;
 800c99c:	3303      	adds	r3, #3
  for (i = 0U; i < count32b; i++)
 800c99e:	089b      	lsrs	r3, r3, #2
 800c9a0:	d009      	beq.n	800c9b6 <USB_WritePacket+0x1a>
    USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 800c9a2:	3201      	adds	r2, #1
 800c9a4:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 800c9a8:	eb01 0283 	add.w	r2, r1, r3, lsl #2
 800c9ac:	f851 3b04 	ldr.w	r3, [r1], #4
 800c9b0:	6003      	str	r3, [r0, #0]
  for (i = 0U; i < count32b; i++)
 800c9b2:	428a      	cmp	r2, r1
 800c9b4:	d1fa      	bne.n	800c9ac <USB_WritePacket+0x10>
    pSrc++;
  }

  return HAL_OK;
}
 800c9b6:	2000      	movs	r0, #0
 800c9b8:	4770      	bx	lr
 800c9ba:	bf00      	nop

0800c9bc <USB_ReadPacket>:
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t *pDest = (uint32_t *)dest;
  uint32_t i;
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 800c9bc:	3203      	adds	r2, #3

  for (i = 0U; i < count32b; i++)
 800c9be:	0892      	lsrs	r2, r2, #2
 800c9c0:	d00c      	beq.n	800c9dc <USB_ReadPacket+0x20>
{
 800c9c2:	b410      	push	{r4}
 800c9c4:	f500 5480 	add.w	r4, r0, #4096	; 0x1000
 800c9c8:	eb01 0082 	add.w	r0, r1, r2, lsl #2
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 800c9cc:	6823      	ldr	r3, [r4, #0]
 800c9ce:	f841 3b04 	str.w	r3, [r1], #4
  for (i = 0U; i < count32b; i++)
 800c9d2:	4288      	cmp	r0, r1
 800c9d4:	d1fa      	bne.n	800c9cc <USB_ReadPacket+0x10>
    pDest++;
  }

  return ((void *)pDest);
}
 800c9d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800c9da:	4770      	bx	lr
  uint32_t *pDest = (uint32_t *)dest;
 800c9dc:	4608      	mov	r0, r1
}
 800c9de:	4770      	bx	lr

0800c9e0 <USB_EPSetStall>:
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;

  if (ep->is_in == 1U)
 800c9e0:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 800c9e2:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800c9e4:	2a01      	cmp	r2, #1
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800c9e6:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 800c9ea:	d00c      	beq.n	800ca06 <USB_EPSetStall+0x26>
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 800c9ec:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 800c9f0:	2a00      	cmp	r2, #0
 800c9f2:	db00      	blt.n	800c9f6 <USB_EPSetStall+0x16>
 800c9f4:	b9d3      	cbnz	r3, 800ca2c <USB_EPSetStall+0x4c>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 800c9f6:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800c9fa:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800c9fe:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
  }

  return HAL_OK;
}
 800ca02:	2000      	movs	r0, #0
 800ca04:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800ca06:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 800ca0a:	2a00      	cmp	r2, #0
 800ca0c:	db06      	blt.n	800ca1c <USB_EPSetStall+0x3c>
 800ca0e:	b12b      	cbz	r3, 800ca1c <USB_EPSetStall+0x3c>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 800ca10:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800ca14:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800ca18:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 800ca1c:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800ca20:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800ca24:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800ca28:	2000      	movs	r0, #0
 800ca2a:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 800ca2c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800ca30:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800ca34:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 800ca38:	e7dd      	b.n	800c9f6 <USB_EPSetStall+0x16>
 800ca3a:	bf00      	nop

0800ca3c <USB_EPClearStall>:
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t epnum = (uint32_t)ep->num;

  if (ep->is_in == 1U)
 800ca3c:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 800ca3e:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 800ca40:	2a01      	cmp	r2, #1
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800ca42:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 800ca46:	d013      	beq.n	800ca70 <USB_EPClearStall+0x34>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800ca48:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800ca4c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800ca50:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800ca54:	78cb      	ldrb	r3, [r1, #3]
 800ca56:	3b02      	subs	r3, #2
 800ca58:	2b01      	cmp	r3, #1
 800ca5a:	d901      	bls.n	800ca60 <USB_EPClearStall+0x24>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }
  }
  return HAL_OK;
}
 800ca5c:	2000      	movs	r0, #0
 800ca5e:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800ca60:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800ca64:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800ca68:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 800ca6c:	2000      	movs	r0, #0
 800ca6e:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800ca70:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800ca74:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800ca78:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800ca7c:	78cb      	ldrb	r3, [r1, #3]
 800ca7e:	3b02      	subs	r3, #2
 800ca80:	2b01      	cmp	r3, #1
 800ca82:	d8eb      	bhi.n	800ca5c <USB_EPClearStall+0x20>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800ca84:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800ca88:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800ca8c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800ca90:	2000      	movs	r0, #0
 800ca92:	4770      	bx	lr

0800ca94 <USB_SetDevAddress>:
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 800ca94:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800ca98:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800ca9c:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 800caa0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 800caa4:	0109      	lsls	r1, r1, #4
 800caa6:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 800caaa:	4319      	orrs	r1, r3
 800caac:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800

  return HAL_OK;
}
 800cab0:	2000      	movs	r0, #0
 800cab2:	4770      	bx	lr

0800cab4 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 800cab4:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 800cab6:	6980      	ldr	r0, [r0, #24]

  return tmpreg;
}
 800cab8:	4010      	ands	r0, r2
 800caba:	4770      	bx	lr

0800cabc <USB_ReadDevAllOutEpInterrupt>:
uint32_t USB_ReadDevAllOutEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 800cabc:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 800cac0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 800cac4:	69c0      	ldr	r0, [r0, #28]
 800cac6:	4018      	ands	r0, r3

  return ((tmpreg & 0xffff0000U) >> 16);
}
 800cac8:	0c00      	lsrs	r0, r0, #16
 800caca:	4770      	bx	lr

0800cacc <USB_ReadDevAllInEpInterrupt>:
uint32_t USB_ReadDevAllInEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 800cacc:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 800cad0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 800cad4:	69c0      	ldr	r0, [r0, #28]
 800cad6:	4018      	ands	r0, r3

  return ((tmpreg & 0xFFFFU));
}
 800cad8:	b280      	uxth	r0, r0
 800cada:	4770      	bx	lr

0800cadc <USB_ReadDevOutEPInterrupt>:
uint32_t USB_ReadDevOutEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 800cadc:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 800cae0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 800cae4:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 800cae8:	6940      	ldr	r0, [r0, #20]

  return tmpreg;
}
 800caea:	4010      	ands	r0, r2
 800caec:	4770      	bx	lr
 800caee:	bf00      	nop

0800caf0 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 800caf0:	b410      	push	{r4}
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t tmpreg, msk, emp;

  msk = USBx_DEVICE->DIEPMSK;
 800caf2:	f8d0 4810 	ldr.w	r4, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 800caf6:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800cafa:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800cafe:	f001 010f 	and.w	r1, r1, #15
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800cb02:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800cb06:	40cb      	lsrs	r3, r1
 800cb08:	01db      	lsls	r3, r3, #7
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800cb0a:	6880      	ldr	r0, [r0, #8]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800cb0c:	b2db      	uxtb	r3, r3
 800cb0e:	4323      	orrs	r3, r4

  return tmpreg;
}
 800cb10:	4018      	ands	r0, r3
 800cb12:	f85d 4b04 	ldr.w	r4, [sp], #4
 800cb16:	4770      	bx	lr

0800cb18 <USB_GetMode>:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS) & 0x1U);
 800cb18:	6940      	ldr	r0, [r0, #20]
}
 800cb1a:	f000 0001 	and.w	r0, r0, #1
 800cb1e:	4770      	bx	lr

0800cb20 <USB_ActivateSetup>:
HAL_StatusTypeDef  USB_ActivateSetup(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800cb20:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800cb24:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800cb28:	f023 0307 	bic.w	r3, r3, #7
 800cb2c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 800cb30:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 800cb34:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800cb38:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804

  return HAL_OK;
}
 800cb3c:	2000      	movs	r0, #0
 800cb3e:	4770      	bx	lr

0800cb40 <USB_EP0_OutStart>:
{
  UNUSED(psetup);
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 800cb40:	4b0e      	ldr	r3, [pc, #56]	; (800cb7c <USB_EP0_OutStart+0x3c>)
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800cb42:	6c02      	ldr	r2, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 800cb44:	429a      	cmp	r2, r3
 800cb46:	d811      	bhi.n	800cb6c <USB_EP0_OutStart+0x2c>
 800cb48:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
    {
      return HAL_OK;
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800cb4c:	2300      	movs	r3, #0
 800cb4e:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800cb50:	6903      	ldr	r3, [r0, #16]
 800cb52:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800cb56:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 800cb58:	6903      	ldr	r3, [r0, #16]
 800cb5a:	f043 0318 	orr.w	r3, r3, #24
 800cb5e:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 800cb60:	6903      	ldr	r3, [r0, #16]
 800cb62:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 800cb66:	6103      	str	r3, [r0, #16]

  return HAL_OK;
}
 800cb68:	2000      	movs	r0, #0
 800cb6a:	4770      	bx	lr
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800cb6c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800cb70:	2b00      	cmp	r3, #0
 800cb72:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 800cb76:	dae9      	bge.n	800cb4c <USB_EP0_OutStart+0xc>
}
 800cb78:	2000      	movs	r0, #0
 800cb7a:	4770      	bx	lr
 800cb7c:	4f54300a 	.word	0x4f54300a

0800cb80 <USBD_WCID_STREAMING_FillTxDataBuffer>:
* @param  size: length of data in bytes
* @param  pdev: device instance
* @retval status
*/
uint8_t USBD_WCID_STREAMING_FillTxDataBuffer(USBD_HandleTypeDef *pdev, uint8_t ch_number, uint8_t* buf, uint32_t size)
{
 800cb80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    USBD_WCID_STREAMING_HandleTypeDef   *hwcid = (USBD_WCID_STREAMING_HandleTypeDef*) pdev->pClassData;
 800cb84:	f8d0 42b8 	ldr.w	r4, [r0, #696]	; 0x2b8

   uint8_t ** TxBuffer = hwcid->TxBuffer;
   __IO uint8_t * TxBuffStatus = hwcid->TxBuffStatus;
   uint32_t * TxBuffIdx = hwcid->TxBuffIdx;
   uint16_t * USB_DataSizePerEp = hwcid->USB_DataSizePerEp;
   __IO uint8_t * TxBuffReset = hwcid->TxBuffReset;
 800cb88:	f204 1765 	addw	r7, r4, #357	; 0x165
   
  uint32_t i;   
  uint8_t * txBuffptr = (uint8_t*)TxBuffer[ch_number];  
 800cb8c:	eb04 0081 	add.w	r0, r4, r1, lsl #2
  
  if(TxBuffReset[ch_number] == 1)
 800cb90:	5c7d      	ldrb	r5, [r7, r1]
  uint8_t * txBuffptr = (uint8_t*)TxBuffer[ch_number];  
 800cb92:	f8d0 6180 	ldr.w	r6, [r0, #384]	; 0x180
  if(TxBuffReset[ch_number] == 1)
 800cb96:	2d01      	cmp	r5, #1
   __IO uint8_t * TxBuffStatus = hwcid->TxBuffStatus;
 800cb98:	f504 7eae 	add.w	lr, r4, #348	; 0x15c
   uint32_t * TxBuffIdx = hwcid->TxBuffIdx;
 800cb9c:	f504 709c 	add.w	r0, r4, #312	; 0x138
   uint16_t * USB_DataSizePerEp = hwcid->USB_DataSizePerEp;
 800cba0:	f504 78b7 	add.w	r8, r4, #366	; 0x16e
  uint8_t * txBuffptr = (uint8_t*)TxBuffer[ch_number];  
 800cba4:	ea4f 0c81 	mov.w	ip, r1, lsl #2
 800cba8:	b20c      	sxth	r4, r1
  if(TxBuffReset[ch_number] == 1)
 800cbaa:	d04a      	beq.n	800cc42 <USBD_WCID_STREAMING_FillTxDataBuffer+0xc2>
 800cbac:	4484      	add	ip, r0
      
    }
    TxBuffReset[ch_number] = 0;
  }
  
  uint32_t txBuffIdx = TxBuffIdx[ch_number];  
 800cbae:	f8dc 0000 	ldr.w	r0, [ip]
  
  for (i = 0; i < size; i++)
 800cbb2:	b30b      	cbz	r3, 800cbf8 <USBD_WCID_STREAMING_FillTxDataBuffer+0x78>
 800cbb4:	2903      	cmp	r1, #3
  {
    txBuffptr[txBuffIdx] = buf[i];    
    txBuffIdx = (txBuffIdx + 1) %  (USB_DataSizePerEp[ch_number]);
 800cbb6:	eb08 0444 	add.w	r4, r8, r4, lsl #1
 800cbba:	4413      	add	r3, r2
 800cbbc:	d821      	bhi.n	800cc02 <USBD_WCID_STREAMING_FillTxDataBuffer+0x82>
    
    if(txBuffIdx == (USB_DataSizePerEp[ch_number]/2))
    {
      TxBuffStatus[ch_number] = 1;
 800cbbe:	4471      	add	r1, lr
 800cbc0:	1e5f      	subs	r7, r3, #1
 800cbc2:	3a01      	subs	r2, #1
 800cbc4:	f04f 0e01 	mov.w	lr, #1
        txBuffIdx = (txBuffIdx + 1); 
      }
    }
    else if (txBuffIdx == 0)
    {
      TxBuffStatus[ch_number] = 2;
 800cbc8:	f04f 0802 	mov.w	r8, #2
 800cbcc:	e004      	b.n	800cbd8 <USBD_WCID_STREAMING_FillTxDataBuffer+0x58>
    else if (txBuffIdx == 0)
 800cbce:	b908      	cbnz	r0, 800cbd4 <USBD_WCID_STREAMING_FillTxDataBuffer+0x54>
      TxBuffStatus[ch_number] = 2;
 800cbd0:	f881 8000 	strb.w	r8, [r1]
  for (i = 0; i < size; i++)
 800cbd4:	4297      	cmp	r7, r2
 800cbd6:	d00f      	beq.n	800cbf8 <USBD_WCID_STREAMING_FillTxDataBuffer+0x78>
    txBuffptr[txBuffIdx] = buf[i];    
 800cbd8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800cbdc:	5433      	strb	r3, [r6, r0]
    txBuffIdx = (txBuffIdx + 1) %  (USB_DataSizePerEp[ch_number]);
 800cbde:	8823      	ldrh	r3, [r4, #0]
 800cbe0:	3001      	adds	r0, #1
 800cbe2:	fbb0 f5f3 	udiv	r5, r0, r3
 800cbe6:	fb03 0015 	mls	r0, r3, r5, r0
    if(txBuffIdx == (USB_DataSizePerEp[ch_number]/2))
 800cbea:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
 800cbee:	d1ee      	bne.n	800cbce <USBD_WCID_STREAMING_FillTxDataBuffer+0x4e>
  for (i = 0; i < size; i++)
 800cbf0:	4297      	cmp	r7, r2
      TxBuffStatus[ch_number] = 1;
 800cbf2:	f881 e000 	strb.w	lr, [r1]
  for (i = 0; i < size; i++)
 800cbf6:	d1ef      	bne.n	800cbd8 <USBD_WCID_STREAMING_FillTxDataBuffer+0x58>
        txBuffptr[txBuffIdx] = ch_number;    
        txBuffIdx = (txBuffIdx + 1); 
      }
    }
  }  
  TxBuffIdx[ch_number] = txBuffIdx;  
 800cbf8:	f8cc 0000 	str.w	r0, [ip]
  return USBD_OK;
}
 800cbfc:	2000      	movs	r0, #0
 800cbfe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800cc02:	1e5d      	subs	r5, r3, #1
 800cc04:	3a01      	subs	r2, #1
      TxBuffStatus[ch_number] = 2;
 800cc06:	448e      	add	lr, r1
 800cc08:	f04f 0902 	mov.w	r9, #2
      TxBuffStatus[ch_number] = 1;
 800cc0c:	f04f 0801 	mov.w	r8, #1
 800cc10:	e006      	b.n	800cc20 <USBD_WCID_STREAMING_FillTxDataBuffer+0xa0>
    else if (txBuffIdx == 0)
 800cc12:	b918      	cbnz	r0, 800cc1c <USBD_WCID_STREAMING_FillTxDataBuffer+0x9c>
      TxBuffStatus[ch_number] = 2;
 800cc14:	f88e 9000 	strb.w	r9, [lr]
        txBuffIdx = (txBuffIdx + 1); 
 800cc18:	2001      	movs	r0, #1
        txBuffptr[txBuffIdx] = ch_number;    
 800cc1a:	7031      	strb	r1, [r6, #0]
  for (i = 0; i < size; i++)
 800cc1c:	4295      	cmp	r5, r2
 800cc1e:	d0eb      	beq.n	800cbf8 <USBD_WCID_STREAMING_FillTxDataBuffer+0x78>
    txBuffptr[txBuffIdx] = buf[i];    
 800cc20:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800cc24:	5433      	strb	r3, [r6, r0]
    txBuffIdx = (txBuffIdx + 1) %  (USB_DataSizePerEp[ch_number]);
 800cc26:	8823      	ldrh	r3, [r4, #0]
 800cc28:	3001      	adds	r0, #1
 800cc2a:	fbb0 f7f3 	udiv	r7, r0, r3
 800cc2e:	fb03 0017 	mls	r0, r3, r7, r0
    if(txBuffIdx == (USB_DataSizePerEp[ch_number]/2))
 800cc32:	ebb0 0f53 	cmp.w	r0, r3, lsr #1
 800cc36:	d1ec      	bne.n	800cc12 <USBD_WCID_STREAMING_FillTxDataBuffer+0x92>
      TxBuffStatus[ch_number] = 1;
 800cc38:	f88e 8000 	strb.w	r8, [lr]
        txBuffptr[txBuffIdx] = ch_number;    
 800cc3c:	5431      	strb	r1, [r6, r0]
        txBuffIdx = (txBuffIdx + 1); 
 800cc3e:	3001      	adds	r0, #1
 800cc40:	e7ec      	b.n	800cc1c <USBD_WCID_STREAMING_FillTxDataBuffer+0x9c>
    if(ch_number >= (N_IN_ENDPOINTS-1))
 800cc42:	2903      	cmp	r1, #3
 800cc44:	d808      	bhi.n	800cc58 <USBD_WCID_STREAMING_FillTxDataBuffer+0xd8>
      TxBuffIdx[ch_number] = 0;
 800cc46:	2500      	movs	r5, #0
 800cc48:	f840 5024 	str.w	r5, [r0, r4, lsl #2]
      TxBuffStatus[ch_number] = 0;
 800cc4c:	f80e 5001 	strb.w	r5, [lr, r1]
      TxBuffIdx[ch_number] = 0;
 800cc50:	4484      	add	ip, r0
    TxBuffReset[ch_number] = 0;
 800cc52:	2000      	movs	r0, #0
 800cc54:	5478      	strb	r0, [r7, r1]
 800cc56:	e7aa      	b.n	800cbae <USBD_WCID_STREAMING_FillTxDataBuffer+0x2e>
 800cc58:	fa5f f985 	uxtb.w	r9, r5
      TxBuffStatus[ch_number] = 0;
 800cc5c:	2500      	movs	r5, #0
      txBuffptr[0] = ch_number;
 800cc5e:	7031      	strb	r1, [r6, #0]
      TxBuffIdx[ch_number] = 1;
 800cc60:	4484      	add	ip, r0
 800cc62:	f840 9024 	str.w	r9, [r0, r4, lsl #2]
      TxBuffStatus[ch_number] = 0;
 800cc66:	f80e 5001 	strb.w	r5, [lr, r1]
 800cc6a:	e7f2      	b.n	800cc52 <USBD_WCID_STREAMING_FillTxDataBuffer+0xd2>

0800cc6c <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800cc6c:	b508      	push	{r3, lr}
  USBD_StatusTypeDef ret = USBD_FAIL;

  if (pdev->pClass != NULL)
 800cc6e:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800cc72:	b11b      	cbz	r3, 800cc7c <USBD_SetClassConfig+0x10>
  {
    /* Set configuration  and Start the Class*/
    if (pdev->pClass->Init(pdev, cfgidx) == 0U)
 800cc74:	681b      	ldr	r3, [r3, #0]
 800cc76:	4798      	blx	r3
 800cc78:	b900      	cbnz	r0, 800cc7c <USBD_SetClassConfig+0x10>
      ret = USBD_OK;
    }
  }

  return ret;
}
 800cc7a:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef ret = USBD_FAIL;
 800cc7c:	2002      	movs	r0, #2
}
 800cc7e:	bd08      	pop	{r3, pc}

0800cc80 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800cc80:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 800cc82:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800cc86:	685b      	ldr	r3, [r3, #4]
 800cc88:	4798      	blx	r3

  return USBD_OK;
}
 800cc8a:	2000      	movs	r0, #0
 800cc8c:	bd08      	pop	{r3, pc}
 800cc8e:	bf00      	nop

0800cc90 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800cc90:	b538      	push	{r3, r4, r5, lr}
 800cc92:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 800cc94:	f500 752a 	add.w	r5, r0, #680	; 0x2a8
 800cc98:	4628      	mov	r0, r5
 800cc9a:	f000 fb71 	bl	800d380 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 800cc9e:	f894 12a8 	ldrb.w	r1, [r4, #680]	; 0x2a8
  pdev->ep0_data_len = pdev->request.wLength;
 800cca2:	f8b4 32ae 	ldrh.w	r3, [r4, #686]	; 0x2ae
 800cca6:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
  pdev->ep0_state = USBD_EP0_SETUP;
 800ccaa:	2201      	movs	r2, #1
 800ccac:	f001 031f 	and.w	r3, r1, #31
  switch (pdev->request.bmRequest & 0x1FU)
 800ccb0:	4293      	cmp	r3, r2
  pdev->ep0_state = USBD_EP0_SETUP;
 800ccb2:	f8c4 2294 	str.w	r2, [r4, #660]	; 0x294
  switch (pdev->request.bmRequest & 0x1FU)
 800ccb6:	d009      	beq.n	800cccc <USBD_LL_SetupStage+0x3c>
 800ccb8:	2b02      	cmp	r3, #2
 800ccba:	d013      	beq.n	800cce4 <USBD_LL_SetupStage+0x54>
 800ccbc:	b163      	cbz	r3, 800ccd8 <USBD_LL_SetupStage+0x48>
    case USB_REQ_RECIPIENT_ENDPOINT:
      USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800ccbe:	f001 0180 	and.w	r1, r1, #128	; 0x80
 800ccc2:	4620      	mov	r0, r4
 800ccc4:	f7f7 f982 	bl	8003fcc <USBD_LL_StallEP>
      break;
  }

  return USBD_OK;
}
 800ccc8:	2000      	movs	r0, #0
 800ccca:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdItfReq(pdev, &pdev->request);
 800cccc:	4629      	mov	r1, r5
 800ccce:	4620      	mov	r0, r4
 800ccd0:	f000 fa8c 	bl	800d1ec <USBD_StdItfReq>
}
 800ccd4:	2000      	movs	r0, #0
 800ccd6:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdDevReq(pdev, &pdev->request);
 800ccd8:	4629      	mov	r1, r5
 800ccda:	4620      	mov	r0, r4
 800ccdc:	f000 f908 	bl	800cef0 <USBD_StdDevReq>
}
 800cce0:	2000      	movs	r0, #0
 800cce2:	bd38      	pop	{r3, r4, r5, pc}
      USBD_StdEPReq(pdev, &pdev->request);
 800cce4:	4629      	mov	r1, r5
 800cce6:	4620      	mov	r0, r4
 800cce8:	f000 fab4 	bl	800d254 <USBD_StdEPReq>
}
 800ccec:	2000      	movs	r0, #0
 800ccee:	bd38      	pop	{r3, r4, r5, pc}

0800ccf0 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800ccf0:	b538      	push	{r3, r4, r5, lr}
 800ccf2:	4605      	mov	r5, r0
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 800ccf4:	b969      	cbnz	r1, 800cd12 <USBD_LL_DataOutStage+0x22>
 800ccf6:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 800ccf8:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 800ccfc:	2a03      	cmp	r2, #3
 800ccfe:	d015      	beq.n	800cd2c <USBD_LL_DataOutStage+0x3c>
        USBD_CtlSendStatus(pdev);
      }
    }
    else
    {
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 800cd00:	2a05      	cmp	r2, #5
 800cd02:	460c      	mov	r4, r1
 800cd04:	d10e      	bne.n	800cd24 <USBD_LL_DataOutStage+0x34>
      {
        /*
         * STATUS PHASE completed, update ep0_state to idle
         */
        pdev->ep0_state = USBD_EP0_IDLE;
 800cd06:	f8c5 1294 	str.w	r1, [r5, #660]	; 0x294
        USBD_LL_StallEP(pdev, 0U);
 800cd0a:	f7f7 f95f 	bl	8003fcc <USBD_LL_StallEP>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 800cd0e:	4620      	mov	r0, r4
}
 800cd10:	bd38      	pop	{r3, r4, r5, pc}
  else if ((pdev->pClass->DataOut != NULL) &&
 800cd12:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800cd16:	699b      	ldr	r3, [r3, #24]
 800cd18:	b133      	cbz	r3, 800cd28 <USBD_LL_DataOutStage+0x38>
 800cd1a:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800cd1e:	2a03      	cmp	r2, #3
 800cd20:	d102      	bne.n	800cd28 <USBD_LL_DataOutStage+0x38>
    pdev->pClass->DataOut(pdev, epnum);
 800cd22:	4798      	blx	r3
  return USBD_OK;
 800cd24:	2000      	movs	r0, #0
}
 800cd26:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 800cd28:	2002      	movs	r0, #2
}
 800cd2a:	bd38      	pop	{r3, r4, r5, pc}
      if (pep->rem_length > pep->maxpacket)
 800cd2c:	e9d0 1258 	ldrd	r1, r2, [r0, #352]	; 0x160
 800cd30:	4291      	cmp	r1, r2
 800cd32:	d90c      	bls.n	800cd4e <USBD_LL_DataOutStage+0x5e>
        pep->rem_length -= pep->maxpacket;
 800cd34:	1a89      	subs	r1, r1, r2
        USBD_CtlContinueRx(pdev, pdata,
 800cd36:	428a      	cmp	r2, r1
 800cd38:	bf88      	it	hi
 800cd3a:	b28a      	uxthhi	r2, r1
        pep->rem_length -= pep->maxpacket;
 800cd3c:	f8c0 1160 	str.w	r1, [r0, #352]	; 0x160
        USBD_CtlContinueRx(pdev, pdata,
 800cd40:	bf98      	it	ls
 800cd42:	b292      	uxthls	r2, r2
 800cd44:	4619      	mov	r1, r3
 800cd46:	f000 fb45 	bl	800d3d4 <USBD_CtlContinueRx>
  return USBD_OK;
 800cd4a:	2000      	movs	r0, #0
}
 800cd4c:	bd38      	pop	{r3, r4, r5, pc}
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 800cd4e:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800cd52:	691b      	ldr	r3, [r3, #16]
 800cd54:	b11b      	cbz	r3, 800cd5e <USBD_LL_DataOutStage+0x6e>
 800cd56:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800cd5a:	2a03      	cmp	r2, #3
 800cd5c:	d004      	beq.n	800cd68 <USBD_LL_DataOutStage+0x78>
        USBD_CtlSendStatus(pdev);
 800cd5e:	4628      	mov	r0, r5
 800cd60:	f000 fb40 	bl	800d3e4 <USBD_CtlSendStatus>
  return USBD_OK;
 800cd64:	2000      	movs	r0, #0
}
 800cd66:	bd38      	pop	{r3, r4, r5, pc}
          pdev->pClass->EP0_RxReady(pdev);
 800cd68:	4798      	blx	r3
 800cd6a:	e7f8      	b.n	800cd5e <USBD_LL_DataOutStage+0x6e>

0800cd6c <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 800cd6c:	b570      	push	{r4, r5, r6, lr}
 800cd6e:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 800cd70:	b989      	cbnz	r1, 800cd96 <USBD_LL_DataInStage+0x2a>
 800cd72:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800cd74:	f8d0 2294 	ldr.w	r2, [r0, #660]	; 0x294
 800cd78:	2a02      	cmp	r2, #2
 800cd7a:	d01c      	beq.n	800cdb6 <USBD_LL_DataInStage+0x4a>
        }
      }
    }
    else
    {
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 800cd7c:	f032 0304 	bics.w	r3, r2, #4
 800cd80:	d102      	bne.n	800cd88 <USBD_LL_DataInStage+0x1c>
          (pdev->ep0_state == USBD_EP0_IDLE))
      {
        USBD_LL_StallEP(pdev, 0x80U);
 800cd82:	2180      	movs	r1, #128	; 0x80
 800cd84:	f7f7 f922 	bl	8003fcc <USBD_LL_StallEP>
      }
    }

    if (pdev->dev_test_mode == 1U)
 800cd88:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 800cd8c:	2b01      	cmp	r3, #1
    {
      USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 800cd8e:	f04f 0000 	mov.w	r0, #0
    if (pdev->dev_test_mode == 1U)
 800cd92:	d00d      	beq.n	800cdb0 <USBD_LL_DataInStage+0x44>
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
}
 800cd94:	bd70      	pop	{r4, r5, r6, pc}
  else if ((pdev->pClass->DataIn != NULL) &&
 800cd96:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800cd9a:	695b      	ldr	r3, [r3, #20]
 800cd9c:	b133      	cbz	r3, 800cdac <USBD_LL_DataInStage+0x40>
 800cd9e:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800cda2:	2a03      	cmp	r2, #3
 800cda4:	d102      	bne.n	800cdac <USBD_LL_DataInStage+0x40>
    pdev->pClass->DataIn(pdev, epnum);
 800cda6:	4798      	blx	r3
  return USBD_OK;
 800cda8:	2000      	movs	r0, #0
}
 800cdaa:	bd70      	pop	{r4, r5, r6, pc}
    return USBD_FAIL;
 800cdac:	2002      	movs	r0, #2
}
 800cdae:	bd70      	pop	{r4, r5, r6, pc}
      pdev->dev_test_mode = 0U;
 800cdb0:	f884 02a0 	strb.w	r0, [r4, #672]	; 0x2a0
}
 800cdb4:	bd70      	pop	{r4, r5, r6, pc}
      if (pep->rem_length > pep->maxpacket)
 800cdb6:	e9d0 2608 	ldrd	r2, r6, [r0, #32]
 800cdba:	42b2      	cmp	r2, r6
 800cdbc:	d827      	bhi.n	800ce0e <USBD_LL_DataInStage+0xa2>
        if ((pep->total_length % pep->maxpacket == 0U) &&
 800cdbe:	69c3      	ldr	r3, [r0, #28]
 800cdc0:	fbb3 f5f6 	udiv	r5, r3, r6
 800cdc4:	fb06 3515 	mls	r5, r6, r5, r3
 800cdc8:	b95d      	cbnz	r5, 800cde2 <USBD_LL_DataInStage+0x76>
 800cdca:	429e      	cmp	r6, r3
 800cdcc:	d809      	bhi.n	800cde2 <USBD_LL_DataInStage+0x76>
            (pep->total_length >= pep->maxpacket) &&
 800cdce:	f8d0 2298 	ldr.w	r2, [r0, #664]	; 0x298
 800cdd2:	4293      	cmp	r3, r2
 800cdd4:	d205      	bcs.n	800cde2 <USBD_LL_DataInStage+0x76>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 800cdd6:	462a      	mov	r2, r5
 800cdd8:	f000 faf4 	bl	800d3c4 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 800cddc:	f8c4 5298 	str.w	r5, [r4, #664]	; 0x298
 800cde0:	e01c      	b.n	800ce1c <USBD_LL_DataInStage+0xb0>
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 800cde2:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 800cde6:	68db      	ldr	r3, [r3, #12]
 800cde8:	b11b      	cbz	r3, 800cdf2 <USBD_LL_DataInStage+0x86>
 800cdea:	f894 229c 	ldrb.w	r2, [r4, #668]	; 0x29c
 800cdee:	2a03      	cmp	r2, #3
 800cdf0:	d01b      	beq.n	800ce2a <USBD_LL_DataInStage+0xbe>
          USBD_LL_StallEP(pdev, 0x80U);
 800cdf2:	2180      	movs	r1, #128	; 0x80
 800cdf4:	4620      	mov	r0, r4
 800cdf6:	f7f7 f8e9 	bl	8003fcc <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 800cdfa:	4620      	mov	r0, r4
 800cdfc:	f000 fafe 	bl	800d3fc <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode == 1U)
 800ce00:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 800ce04:	2b01      	cmp	r3, #1
      pdev->dev_test_mode = 0U;
 800ce06:	f04f 0000 	mov.w	r0, #0
    if (pdev->dev_test_mode == 1U)
 800ce0a:	d1c3      	bne.n	800cd94 <USBD_LL_DataInStage+0x28>
 800ce0c:	e7d0      	b.n	800cdb0 <USBD_LL_DataInStage+0x44>
        pep->rem_length -= pep->maxpacket;
 800ce0e:	1b92      	subs	r2, r2, r6
 800ce10:	460d      	mov	r5, r1
 800ce12:	6202      	str	r2, [r0, #32]
        USBD_CtlContinueSendData(pdev, pdata, (uint16_t)pep->rem_length);
 800ce14:	4619      	mov	r1, r3
 800ce16:	b292      	uxth	r2, r2
 800ce18:	f000 fad4 	bl	800d3c4 <USBD_CtlContinueSendData>
          USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800ce1c:	462b      	mov	r3, r5
 800ce1e:	462a      	mov	r2, r5
 800ce20:	4629      	mov	r1, r5
 800ce22:	4620      	mov	r0, r4
 800ce24:	f7f7 f906 	bl	8004034 <USBD_LL_PrepareReceive>
 800ce28:	e7ae      	b.n	800cd88 <USBD_LL_DataInStage+0x1c>
            pdev->pClass->EP0_TxSent(pdev);
 800ce2a:	4620      	mov	r0, r4
 800ce2c:	4798      	blx	r3
 800ce2e:	e7e0      	b.n	800cdf2 <USBD_LL_DataInStage+0x86>

0800ce30 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 800ce30:	b570      	push	{r4, r5, r6, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800ce32:	2200      	movs	r2, #0
{
 800ce34:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800ce36:	2340      	movs	r3, #64	; 0x40
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800ce38:	461e      	mov	r6, r3
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800ce3a:	4611      	mov	r1, r2
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800ce3c:	2501      	movs	r5, #1
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800ce3e:	f7f7 f8bb 	bl	8003fb8 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800ce42:	4633      	mov	r3, r6
 800ce44:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800ce46:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800ce4a:	f8c4 6164 	str.w	r6, [r4, #356]	; 0x164
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800ce4e:	4620      	mov	r0, r4
 800ce50:	2200      	movs	r2, #0
 800ce52:	f7f7 f8b1 	bl	8003fb8 <USBD_LL_OpenEP>
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
  pdev->dev_config = 0U;
  pdev->dev_remote_wakeup = 0U;

  if (pdev->pClassData)
 800ce56:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 800ce5a:	61a5      	str	r5, [r4, #24]
  pdev->ep0_state = USBD_EP0_IDLE;
 800ce5c:	2100      	movs	r1, #0
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800ce5e:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 800ce60:	f884 529c 	strb.w	r5, [r4, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 800ce64:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
  pdev->dev_config = 0U;
 800ce68:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 800ce6a:	f8c4 12a4 	str.w	r1, [r4, #676]	; 0x2a4
  if (pdev->pClassData)
 800ce6e:	b123      	cbz	r3, 800ce7a <USBD_LL_Reset+0x4a>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800ce70:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 800ce74:	4620      	mov	r0, r4
 800ce76:	685b      	ldr	r3, [r3, #4]
 800ce78:	4798      	blx	r3
  }

  return USBD_OK;
}
 800ce7a:	2000      	movs	r0, #0
 800ce7c:	bd70      	pop	{r4, r5, r6, pc}
 800ce7e:	bf00      	nop

0800ce80 <USBD_LL_SetSpeed>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 800ce80:	7401      	strb	r1, [r0, #16]

  return USBD_OK;
}
 800ce82:	2000      	movs	r0, #0
 800ce84:	4770      	bx	lr
 800ce86:	bf00      	nop

0800ce88 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 800ce88:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800ce8c:	f880 229d 	strb.w	r2, [r0, #669]	; 0x29d
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 800ce90:	2304      	movs	r3, #4
 800ce92:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c

  return USBD_OK;
}
 800ce96:	2000      	movs	r0, #0
 800ce98:	4770      	bx	lr
 800ce9a:	bf00      	nop

0800ce9c <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 800ce9c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800cea0:	2b04      	cmp	r3, #4
  {
    pdev->dev_state = pdev->dev_old_state;
 800cea2:	bf04      	itt	eq
 800cea4:	f890 329d 	ldrbeq.w	r3, [r0, #669]	; 0x29d
 800cea8:	f880 329c 	strbeq.w	r3, [r0, #668]	; 0x29c
  }

  return USBD_OK;
}
 800ceac:	2000      	movs	r0, #0
 800ceae:	4770      	bx	lr

0800ceb0 <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800ceb0:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 800ceb4:	2a03      	cmp	r2, #3
 800ceb6:	d001      	beq.n	800cebc <USBD_LL_SOF+0xc>
      pdev->pClass->SOF(pdev);
    }
  }

  return USBD_OK;
}
 800ceb8:	2000      	movs	r0, #0
 800ceba:	4770      	bx	lr
{
 800cebc:	b508      	push	{r3, lr}
    if (pdev->pClass->SOF != NULL)
 800cebe:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800cec2:	69db      	ldr	r3, [r3, #28]
 800cec4:	b103      	cbz	r3, 800cec8 <USBD_LL_SOF+0x18>
      pdev->pClass->SOF(pdev);
 800cec6:	4798      	blx	r3
}
 800cec8:	2000      	movs	r0, #0
 800ceca:	bd08      	pop	{r3, pc}

0800cecc <USBD_LL_IsoINIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 800cecc:	2000      	movs	r0, #0
 800cece:	4770      	bx	lr

0800ced0 <USBD_LL_IsoOUTIncomplete>:
 800ced0:	2000      	movs	r0, #0
 800ced2:	4770      	bx	lr

0800ced4 <USBD_LL_DevConnected>:
 800ced4:	2000      	movs	r0, #0
 800ced6:	4770      	bx	lr

0800ced8 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 800ced8:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800ceda:	f8d0 22b4 	ldr.w	r2, [r0, #692]	; 0x2b4
  pdev->dev_state = USBD_STATE_DEFAULT;
 800cede:	2101      	movs	r1, #1
 800cee0:	f880 129c 	strb.w	r1, [r0, #668]	; 0x29c
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800cee4:	6852      	ldr	r2, [r2, #4]
 800cee6:	7901      	ldrb	r1, [r0, #4]
 800cee8:	4790      	blx	r2

  return USBD_OK;
}
 800ceea:	2000      	movs	r0, #0
 800ceec:	bd08      	pop	{r3, pc}
 800ceee:	bf00      	nop

0800cef0 <USBD_StdDevReq>:
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq(USBD_HandleTypeDef *pdev,
                                   USBD_SetupReqTypedef *req)
{
 800cef0:	b530      	push	{r4, r5, lr}
 800cef2:	780b      	ldrb	r3, [r1, #0]
 800cef4:	f003 0360 	and.w	r3, r3, #96	; 0x60
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800cef8:	2b20      	cmp	r3, #32
{
 800cefa:	b083      	sub	sp, #12
 800cefc:	460d      	mov	r5, r1
 800cefe:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800cf00:	d00d      	beq.n	800cf1e <USBD_StdDevReq+0x2e>
 800cf02:	2b40      	cmp	r3, #64	; 0x40
 800cf04:	d00b      	beq.n	800cf1e <USBD_StdDevReq+0x2e>
 800cf06:	b19b      	cbz	r3, 800cf30 <USBD_StdDevReq+0x40>
*/

void USBD_CtlError(USBD_HandleTypeDef *pdev,
                   USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev, 0x80U);
 800cf08:	2180      	movs	r1, #128	; 0x80
 800cf0a:	4620      	mov	r0, r4
 800cf0c:	f7f7 f85e 	bl	8003fcc <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800cf10:	4620      	mov	r0, r4
 800cf12:	2100      	movs	r1, #0
 800cf14:	f7f7 f85a 	bl	8003fcc <USBD_LL_StallEP>
}
 800cf18:	2000      	movs	r0, #0
 800cf1a:	b003      	add	sp, #12
 800cf1c:	bd30      	pop	{r4, r5, pc}
      pdev->pClass->Setup(pdev, req);
 800cf1e:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 800cf22:	4629      	mov	r1, r5
 800cf24:	689b      	ldr	r3, [r3, #8]
 800cf26:	4620      	mov	r0, r4
 800cf28:	4798      	blx	r3
}
 800cf2a:	2000      	movs	r0, #0
 800cf2c:	b003      	add	sp, #12
 800cf2e:	bd30      	pop	{r4, r5, pc}
      switch (req->bRequest)
 800cf30:	784b      	ldrb	r3, [r1, #1]
 800cf32:	2b09      	cmp	r3, #9
 800cf34:	d8e8      	bhi.n	800cf08 <USBD_StdDevReq+0x18>
 800cf36:	a201      	add	r2, pc, #4	; (adr r2, 800cf3c <USBD_StdDevReq+0x4c>)
 800cf38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800cf3c:	0800cf97 	.word	0x0800cf97
 800cf40:	0800cfc3 	.word	0x0800cfc3
 800cf44:	0800cf09 	.word	0x0800cf09
 800cf48:	0800cfe1 	.word	0x0800cfe1
 800cf4c:	0800cf09 	.word	0x0800cf09
 800cf50:	0800cfe9 	.word	0x0800cfe9
 800cf54:	0800d021 	.word	0x0800d021
 800cf58:	0800cf09 	.word	0x0800cf09
 800cf5c:	0800d055 	.word	0x0800d055
 800cf60:	0800cf65 	.word	0x0800cf65
  cfgidx = (uint8_t)(req->wValue);
 800cf64:	7889      	ldrb	r1, [r1, #2]
 800cf66:	4da0      	ldr	r5, [pc, #640]	; (800d1e8 <USBD_StdDevReq+0x2f8>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800cf68:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 800cf6a:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800cf6c:	d8cc      	bhi.n	800cf08 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 800cf6e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800cf72:	2b02      	cmp	r3, #2
 800cf74:	f000 8108 	beq.w	800d188 <USBD_StdDevReq+0x298>
 800cf78:	2b03      	cmp	r3, #3
 800cf7a:	f000 80f4 	beq.w	800d166 <USBD_StdDevReq+0x276>
  USBD_LL_StallEP(pdev, 0x80U);
 800cf7e:	2180      	movs	r1, #128	; 0x80
 800cf80:	f7f7 f824 	bl	8003fcc <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800cf84:	2100      	movs	r1, #0
 800cf86:	4620      	mov	r0, r4
 800cf88:	f7f7 f820 	bl	8003fcc <USBD_LL_StallEP>
        USBD_ClrClassConfig(pdev, cfgidx);
 800cf8c:	7829      	ldrb	r1, [r5, #0]
 800cf8e:	4620      	mov	r0, r4
 800cf90:	f7ff fe76 	bl	800cc80 <USBD_ClrClassConfig>
        break;
 800cf94:	e7c0      	b.n	800cf18 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 800cf96:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800cf9a:	3b01      	subs	r3, #1
 800cf9c:	2b02      	cmp	r3, #2
 800cf9e:	d8b3      	bhi.n	800cf08 <USBD_StdDevReq+0x18>
      if (req->wLength != 0x2U)
 800cfa0:	88cb      	ldrh	r3, [r1, #6]
 800cfa2:	2b02      	cmp	r3, #2
 800cfa4:	d1b0      	bne.n	800cf08 <USBD_StdDevReq+0x18>
      if (pdev->dev_remote_wakeup)
 800cfa6:	f8d0 32a4 	ldr.w	r3, [r0, #676]	; 0x2a4
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 800cfaa:	2201      	movs	r2, #1
 800cfac:	60c2      	str	r2, [r0, #12]
      if (pdev->dev_remote_wakeup)
 800cfae:	b10b      	cbz	r3, 800cfb4 <USBD_StdDevReq+0xc4>
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 800cfb0:	2303      	movs	r3, #3
 800cfb2:	60c3      	str	r3, [r0, #12]
      USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 800cfb4:	2202      	movs	r2, #2
 800cfb6:	f104 010c 	add.w	r1, r4, #12
 800cfba:	4620      	mov	r0, r4
 800cfbc:	f000 f9f4 	bl	800d3a8 <USBD_CtlSendData>
      break;
 800cfc0:	e7aa      	b.n	800cf18 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 800cfc2:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800cfc6:	3b01      	subs	r3, #1
 800cfc8:	2b02      	cmp	r3, #2
 800cfca:	d89d      	bhi.n	800cf08 <USBD_StdDevReq+0x18>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800cfcc:	884b      	ldrh	r3, [r1, #2]
 800cfce:	2b01      	cmp	r3, #1
 800cfd0:	d1a2      	bne.n	800cf18 <USBD_StdDevReq+0x28>
        pdev->dev_remote_wakeup = 0U;
 800cfd2:	2300      	movs	r3, #0
 800cfd4:	f8c4 32a4 	str.w	r3, [r4, #676]	; 0x2a4
        USBD_CtlSendStatus(pdev);
 800cfd8:	4620      	mov	r0, r4
 800cfda:	f000 fa03 	bl	800d3e4 <USBD_CtlSendStatus>
 800cfde:	e79b      	b.n	800cf18 <USBD_StdDevReq+0x28>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800cfe0:	884b      	ldrh	r3, [r1, #2]
 800cfe2:	2b01      	cmp	r3, #1
 800cfe4:	d198      	bne.n	800cf18 <USBD_StdDevReq+0x28>
 800cfe6:	e7f5      	b.n	800cfd4 <USBD_StdDevReq+0xe4>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 800cfe8:	888b      	ldrh	r3, [r1, #4]
 800cfea:	2b00      	cmp	r3, #0
 800cfec:	d18c      	bne.n	800cf08 <USBD_StdDevReq+0x18>
 800cfee:	88cb      	ldrh	r3, [r1, #6]
 800cff0:	2b00      	cmp	r3, #0
 800cff2:	d189      	bne.n	800cf08 <USBD_StdDevReq+0x18>
 800cff4:	884d      	ldrh	r5, [r1, #2]
 800cff6:	2d7f      	cmp	r5, #127	; 0x7f
 800cff8:	d886      	bhi.n	800cf08 <USBD_StdDevReq+0x18>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800cffa:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800cffe:	2b03      	cmp	r3, #3
 800d000:	d082      	beq.n	800cf08 <USBD_StdDevReq+0x18>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 800d002:	b2e9      	uxtb	r1, r5
      pdev->dev_address = dev_addr;
 800d004:	f880 129e 	strb.w	r1, [r0, #670]	; 0x29e
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 800d008:	f7f7 f804 	bl	8004014 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 800d00c:	4620      	mov	r0, r4
 800d00e:	f000 f9e9 	bl	800d3e4 <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 800d012:	2d00      	cmp	r5, #0
 800d014:	f000 80d9 	beq.w	800d1ca <USBD_StdDevReq+0x2da>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800d018:	2302      	movs	r3, #2
 800d01a:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800d01e:	e77b      	b.n	800cf18 <USBD_StdDevReq+0x28>
          USBD_GetDescriptor(pdev, req);
 800d020:	884a      	ldrh	r2, [r1, #2]
  uint16_t len = 0U;
 800d022:	0a13      	lsrs	r3, r2, #8
 800d024:	2100      	movs	r1, #0
 800d026:	3b01      	subs	r3, #1
 800d028:	f8ad 1006 	strh.w	r1, [sp, #6]
  switch (req->wValue >> 8)
 800d02c:	2b06      	cmp	r3, #6
 800d02e:	f63f af6b 	bhi.w	800cf08 <USBD_StdDevReq+0x18>
 800d032:	a101      	add	r1, pc, #4	; (adr r1, 800d038 <USBD_StdDevReq+0x148>)
 800d034:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800d038:	0800d0f7 	.word	0x0800d0f7
 800d03c:	0800d0df 	.word	0x0800d0df
 800d040:	0800d0cf 	.word	0x0800d0cf
 800d044:	0800cf09 	.word	0x0800cf09
 800d048:	0800cf09 	.word	0x0800cf09
 800d04c:	0800d0b9 	.word	0x0800d0b9
 800d050:	0800d079 	.word	0x0800d079
  if (req->wLength != 1U)
 800d054:	88ca      	ldrh	r2, [r1, #6]
 800d056:	2a01      	cmp	r2, #1
 800d058:	f47f af56 	bne.w	800cf08 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 800d05c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800d060:	2b02      	cmp	r3, #2
 800d062:	d879      	bhi.n	800d158 <USBD_StdDevReq+0x268>
 800d064:	2b00      	cmp	r3, #0
 800d066:	f43f af4f 	beq.w	800cf08 <USBD_StdDevReq+0x18>
        pdev->dev_default_config = 0U;
 800d06a:	4601      	mov	r1, r0
 800d06c:	2300      	movs	r3, #0
 800d06e:	f841 3f08 	str.w	r3, [r1, #8]!
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 800d072:	f000 f999 	bl	800d3a8 <USBD_CtlSendData>
        break;
 800d076:	e74f      	b.n	800cf18 <USBD_StdDevReq+0x28>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800d078:	7c03      	ldrb	r3, [r0, #16]
 800d07a:	2b00      	cmp	r3, #0
 800d07c:	f47f af44 	bne.w	800cf08 <USBD_StdDevReq+0x18>
        pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 800d080:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800d084:	f10d 0006 	add.w	r0, sp, #6
 800d088:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d08a:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800d08c:	2307      	movs	r3, #7
 800d08e:	7043      	strb	r3, [r0, #1]
    if ((len != 0U) && (req->wLength != 0U))
 800d090:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 800d094:	b15a      	cbz	r2, 800d0ae <USBD_StdDevReq+0x1be>
 800d096:	88eb      	ldrh	r3, [r5, #6]
 800d098:	2b00      	cmp	r3, #0
 800d09a:	d09d      	beq.n	800cfd8 <USBD_StdDevReq+0xe8>
      len = MIN(len, req->wLength);
 800d09c:	429a      	cmp	r2, r3
 800d09e:	bf28      	it	cs
 800d0a0:	461a      	movcs	r2, r3
      (void)USBD_CtlSendData(pdev, pbuf, len);
 800d0a2:	4601      	mov	r1, r0
 800d0a4:	4620      	mov	r0, r4
      len = MIN(len, req->wLength);
 800d0a6:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 800d0aa:	f000 f97d 	bl	800d3a8 <USBD_CtlSendData>
    if (req->wLength == 0U)
 800d0ae:	88eb      	ldrh	r3, [r5, #6]
 800d0b0:	2b00      	cmp	r3, #0
 800d0b2:	f47f af31 	bne.w	800cf18 <USBD_StdDevReq+0x28>
 800d0b6:	e78f      	b.n	800cfd8 <USBD_StdDevReq+0xe8>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800d0b8:	7c03      	ldrb	r3, [r0, #16]
 800d0ba:	2b00      	cmp	r3, #0
 800d0bc:	f47f af24 	bne.w	800cf08 <USBD_StdDevReq+0x18>
        pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 800d0c0:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800d0c4:	f10d 0006 	add.w	r0, sp, #6
 800d0c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d0ca:	4798      	blx	r3
  if (err != 0U)
 800d0cc:	e7e0      	b.n	800d090 <USBD_StdDevReq+0x1a0>
      switch ((uint8_t)(req->wValue))
 800d0ce:	b2d1      	uxtb	r1, r2
 800d0d0:	2905      	cmp	r1, #5
 800d0d2:	d87e      	bhi.n	800d1d2 <USBD_StdDevReq+0x2e2>
 800d0d4:	e8df f001 	tbb	[pc, r1]
 800d0d8:	222e343a 	.word	0x222e343a
 800d0dc:	2817      	.short	0x2817
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800d0de:	7c03      	ldrb	r3, [r0, #16]
 800d0e0:	2b00      	cmp	r3, #0
 800d0e2:	d15f      	bne.n	800d1a4 <USBD_StdDevReq+0x2b4>
        pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 800d0e4:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800d0e8:	f10d 0006 	add.w	r0, sp, #6
 800d0ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d0ee:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800d0f0:	2302      	movs	r3, #2
 800d0f2:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800d0f4:	e7cc      	b.n	800d090 <USBD_StdDevReq+0x1a0>
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800d0f6:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d0fa:	7c00      	ldrb	r0, [r0, #16]
 800d0fc:	681b      	ldr	r3, [r3, #0]
 800d0fe:	f10d 0106 	add.w	r1, sp, #6
 800d102:	4798      	blx	r3
  if (err != 0U)
 800d104:	e7c4      	b.n	800d090 <USBD_StdDevReq+0x1a0>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 800d106:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d10a:	695b      	ldr	r3, [r3, #20]
 800d10c:	2b00      	cmp	r3, #0
 800d10e:	f43f aefb 	beq.w	800cf08 <USBD_StdDevReq+0x18>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 800d112:	7c20      	ldrb	r0, [r4, #16]
 800d114:	f10d 0106 	add.w	r1, sp, #6
 800d118:	4798      	blx	r3
  if (err != 0U)
 800d11a:	e7b9      	b.n	800d090 <USBD_StdDevReq+0x1a0>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 800d11c:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d120:	691b      	ldr	r3, [r3, #16]
 800d122:	2b00      	cmp	r3, #0
 800d124:	d1f5      	bne.n	800d112 <USBD_StdDevReq+0x222>
 800d126:	e6ef      	b.n	800cf08 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 800d128:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d12c:	699b      	ldr	r3, [r3, #24]
 800d12e:	2b00      	cmp	r3, #0
 800d130:	d1ef      	bne.n	800d112 <USBD_StdDevReq+0x222>
 800d132:	e6e9      	b.n	800cf08 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 800d134:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d138:	68db      	ldr	r3, [r3, #12]
 800d13a:	2b00      	cmp	r3, #0
 800d13c:	d1e9      	bne.n	800d112 <USBD_StdDevReq+0x222>
 800d13e:	e6e3      	b.n	800cf08 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 800d140:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d144:	689b      	ldr	r3, [r3, #8]
 800d146:	2b00      	cmp	r3, #0
 800d148:	d1e3      	bne.n	800d112 <USBD_StdDevReq+0x222>
 800d14a:	e6dd      	b.n	800cf08 <USBD_StdDevReq+0x18>
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 800d14c:	f8d0 32b0 	ldr.w	r3, [r0, #688]	; 0x2b0
 800d150:	685b      	ldr	r3, [r3, #4]
 800d152:	2b00      	cmp	r3, #0
 800d154:	d1dd      	bne.n	800d112 <USBD_StdDevReq+0x222>
 800d156:	e6d7      	b.n	800cf08 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 800d158:	2b03      	cmp	r3, #3
 800d15a:	f47f aed5 	bne.w	800cf08 <USBD_StdDevReq+0x18>
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 800d15e:	1d01      	adds	r1, r0, #4
 800d160:	f000 f922 	bl	800d3a8 <USBD_CtlSendData>
        break;
 800d164:	e6d8      	b.n	800cf18 <USBD_StdDevReq+0x28>
        if (cfgidx == 0U)
 800d166:	b331      	cbz	r1, 800d1b6 <USBD_StdDevReq+0x2c6>
        else if (cfgidx != pdev->dev_config)
 800d168:	6841      	ldr	r1, [r0, #4]
 800d16a:	2901      	cmp	r1, #1
 800d16c:	f43f af34 	beq.w	800cfd8 <USBD_StdDevReq+0xe8>
          USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800d170:	b2c9      	uxtb	r1, r1
 800d172:	f7ff fd85 	bl	800cc80 <USBD_ClrClassConfig>
          pdev->dev_config = cfgidx;
 800d176:	7829      	ldrb	r1, [r5, #0]
 800d178:	6061      	str	r1, [r4, #4]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 800d17a:	4620      	mov	r0, r4
 800d17c:	f7ff fd76 	bl	800cc6c <USBD_SetClassConfig>
 800d180:	2802      	cmp	r0, #2
 800d182:	f47f af29 	bne.w	800cfd8 <USBD_StdDevReq+0xe8>
 800d186:	e6bf      	b.n	800cf08 <USBD_StdDevReq+0x18>
        if (cfgidx)
 800d188:	2900      	cmp	r1, #0
 800d18a:	f43f af25 	beq.w	800cfd8 <USBD_StdDevReq+0xe8>
          pdev->dev_config = cfgidx;
 800d18e:	2101      	movs	r1, #1
          pdev->dev_state = USBD_STATE_CONFIGURED;
 800d190:	2303      	movs	r3, #3
          pdev->dev_config = cfgidx;
 800d192:	6041      	str	r1, [r0, #4]
          pdev->dev_state = USBD_STATE_CONFIGURED;
 800d194:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 800d198:	f7ff fd68 	bl	800cc6c <USBD_SetClassConfig>
 800d19c:	2802      	cmp	r0, #2
 800d19e:	f47f af1b 	bne.w	800cfd8 <USBD_StdDevReq+0xe8>
 800d1a2:	e6b1      	b.n	800cf08 <USBD_StdDevReq+0x18>
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 800d1a4:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800d1a8:	f10d 0006 	add.w	r0, sp, #6
 800d1ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d1ae:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800d1b0:	2302      	movs	r3, #2
 800d1b2:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800d1b4:	e76c      	b.n	800d090 <USBD_StdDevReq+0x1a0>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 800d1b6:	2302      	movs	r3, #2
          pdev->dev_config = cfgidx;
 800d1b8:	6041      	str	r1, [r0, #4]
          pdev->dev_state = USBD_STATE_ADDRESSED;
 800d1ba:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
          USBD_ClrClassConfig(pdev, cfgidx);
 800d1be:	f7ff fd5f 	bl	800cc80 <USBD_ClrClassConfig>
          USBD_CtlSendStatus(pdev);
 800d1c2:	4620      	mov	r0, r4
 800d1c4:	f000 f90e 	bl	800d3e4 <USBD_CtlSendStatus>
 800d1c8:	e6a6      	b.n	800cf18 <USBD_StdDevReq+0x28>
        pdev->dev_state = USBD_STATE_DEFAULT;
 800d1ca:	2301      	movs	r3, #1
 800d1cc:	f884 329c 	strb.w	r3, [r4, #668]	; 0x29c
 800d1d0:	e6a2      	b.n	800cf18 <USBD_StdDevReq+0x28>
          if (pdev->pClass->GetUsrStrDescriptor != NULL)
 800d1d2:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 800d1d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d1d8:	2b00      	cmp	r3, #0
 800d1da:	f43f ae95 	beq.w	800cf08 <USBD_StdDevReq+0x18>
            pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue), &len);
 800d1de:	f10d 0206 	add.w	r2, sp, #6
 800d1e2:	4798      	blx	r3
  if (err != 0U)
 800d1e4:	e754      	b.n	800d090 <USBD_StdDevReq+0x1a0>
 800d1e6:	bf00      	nop
 800d1e8:	200018bf 	.word	0x200018bf

0800d1ec <USBD_StdItfReq>:
{
 800d1ec:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800d1ee:	780b      	ldrb	r3, [r1, #0]
 800d1f0:	f003 0260 	and.w	r2, r3, #96	; 0x60
 800d1f4:	2a40      	cmp	r2, #64	; 0x40
{
 800d1f6:	460d      	mov	r5, r1
 800d1f8:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800d1fa:	d00a      	beq.n	800d212 <USBD_StdItfReq+0x26>
 800d1fc:	065b      	lsls	r3, r3, #25
 800d1fe:	d508      	bpl.n	800d212 <USBD_StdItfReq+0x26>
  USBD_LL_StallEP(pdev, 0x80U);
 800d200:	2180      	movs	r1, #128	; 0x80
 800d202:	f7f6 fee3 	bl	8003fcc <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800d206:	4620      	mov	r0, r4
 800d208:	2100      	movs	r1, #0
 800d20a:	f7f6 fedf 	bl	8003fcc <USBD_LL_StallEP>
}
 800d20e:	2000      	movs	r0, #0
 800d210:	bd38      	pop	{r3, r4, r5, pc}
      switch (pdev->dev_state)
 800d212:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 800d216:	3b01      	subs	r3, #1
 800d218:	2b02      	cmp	r3, #2
 800d21a:	d811      	bhi.n	800d240 <USBD_StdItfReq+0x54>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 800d21c:	792b      	ldrb	r3, [r5, #4]
 800d21e:	2b01      	cmp	r3, #1
 800d220:	d80e      	bhi.n	800d240 <USBD_StdItfReq+0x54>
            ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 800d222:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 800d226:	4629      	mov	r1, r5
 800d228:	689b      	ldr	r3, [r3, #8]
 800d22a:	4620      	mov	r0, r4
 800d22c:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 800d22e:	88eb      	ldrh	r3, [r5, #6]
 800d230:	2b00      	cmp	r3, #0
 800d232:	d1ec      	bne.n	800d20e <USBD_StdItfReq+0x22>
 800d234:	2800      	cmp	r0, #0
 800d236:	d1ea      	bne.n	800d20e <USBD_StdItfReq+0x22>
              USBD_CtlSendStatus(pdev);
 800d238:	4620      	mov	r0, r4
 800d23a:	f000 f8d3 	bl	800d3e4 <USBD_CtlSendStatus>
 800d23e:	e7e6      	b.n	800d20e <USBD_StdItfReq+0x22>
  USBD_LL_StallEP(pdev, 0x80U);
 800d240:	2180      	movs	r1, #128	; 0x80
 800d242:	4620      	mov	r0, r4
 800d244:	f7f6 fec2 	bl	8003fcc <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800d248:	4620      	mov	r0, r4
 800d24a:	2100      	movs	r1, #0
 800d24c:	f7f6 febe 	bl	8003fcc <USBD_LL_StallEP>
}
 800d250:	2000      	movs	r0, #0
 800d252:	bd38      	pop	{r3, r4, r5, pc}

0800d254 <USBD_StdEPReq>:
{
 800d254:	b570      	push	{r4, r5, r6, lr}
 800d256:	780b      	ldrb	r3, [r1, #0]
 800d258:	f003 0360 	and.w	r3, r3, #96	; 0x60
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800d25c:	2b20      	cmp	r3, #32
{
 800d25e:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800d260:	d00c      	beq.n	800d27c <USBD_StdEPReq+0x28>
 800d262:	2b40      	cmp	r3, #64	; 0x40
 800d264:	d00a      	beq.n	800d27c <USBD_StdEPReq+0x28>
 800d266:	b183      	cbz	r3, 800d28a <USBD_StdEPReq+0x36>
  USBD_LL_StallEP(pdev, 0x80U);
 800d268:	2180      	movs	r1, #128	; 0x80
 800d26a:	4620      	mov	r0, r4
 800d26c:	f7f6 feae 	bl	8003fcc <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800d270:	4620      	mov	r0, r4
 800d272:	2100      	movs	r1, #0
 800d274:	f7f6 feaa 	bl	8003fcc <USBD_LL_StallEP>
}
 800d278:	2000      	movs	r0, #0
 800d27a:	bd70      	pop	{r4, r5, r6, pc}
      pdev->pClass->Setup(pdev, req);
 800d27c:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
 800d280:	4620      	mov	r0, r4
 800d282:	689b      	ldr	r3, [r3, #8]
 800d284:	4798      	blx	r3
}
 800d286:	2000      	movs	r0, #0
 800d288:	bd70      	pop	{r4, r5, r6, pc}
      switch (req->bRequest)
 800d28a:	784b      	ldrb	r3, [r1, #1]
  ep_addr  = LOBYTE(req->wIndex);
 800d28c:	888a      	ldrh	r2, [r1, #4]
 800d28e:	2b01      	cmp	r3, #1
 800d290:	b2d5      	uxtb	r5, r2
      switch (req->bRequest)
 800d292:	d03c      	beq.n	800d30e <USBD_StdEPReq+0xba>
 800d294:	2b03      	cmp	r3, #3
 800d296:	d029      	beq.n	800d2ec <USBD_StdEPReq+0x98>
 800d298:	2b00      	cmp	r3, #0
 800d29a:	d1e5      	bne.n	800d268 <USBD_StdEPReq+0x14>
          switch (pdev->dev_state)
 800d29c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800d2a0:	2b02      	cmp	r3, #2
 800d2a2:	d04d      	beq.n	800d340 <USBD_StdEPReq+0xec>
 800d2a4:	2b03      	cmp	r3, #3
 800d2a6:	d1df      	bne.n	800d268 <USBD_StdEPReq+0x14>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800d2a8:	f005 030f 	and.w	r3, r5, #15
 800d2ac:	eb03 0383 	add.w	r3, r3, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 800d2b0:	0612      	lsls	r2, r2, #24
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800d2b2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 800d2b6:	d452      	bmi.n	800d35e <USBD_StdEPReq+0x10a>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 800d2b8:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 800d2bc:	2b00      	cmp	r3, #0
 800d2be:	d0d3      	beq.n	800d268 <USBD_StdEPReq+0x14>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800d2c0:	f005 037f 	and.w	r3, r5, #127	; 0x7f
 800d2c4:	2614      	movs	r6, #20
 800d2c6:	fb06 0603 	mla	r6, r6, r3, r0
 800d2ca:	f506 76aa 	add.w	r6, r6, #340	; 0x154
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 800d2ce:	b133      	cbz	r3, 800d2de <USBD_StdEPReq+0x8a>
              else if (USBD_LL_IsStallEP(pdev, ep_addr))
 800d2d0:	4629      	mov	r1, r5
 800d2d2:	4620      	mov	r0, r4
 800d2d4:	f7f6 fe8a 	bl	8003fec <USBD_LL_IsStallEP>
 800d2d8:	2800      	cmp	r0, #0
 800d2da:	d04b      	beq.n	800d374 <USBD_StdEPReq+0x120>
                pep->status = 0x0001U;
 800d2dc:	2301      	movs	r3, #1
 800d2de:	6033      	str	r3, [r6, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800d2e0:	4631      	mov	r1, r6
 800d2e2:	4620      	mov	r0, r4
 800d2e4:	2202      	movs	r2, #2
 800d2e6:	f000 f85f 	bl	800d3a8 <USBD_CtlSendData>
              break;
 800d2ea:	e7c5      	b.n	800d278 <USBD_StdEPReq+0x24>
          switch (pdev->dev_state)
 800d2ec:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800d2f0:	2b02      	cmp	r3, #2
 800d2f2:	d01b      	beq.n	800d32c <USBD_StdEPReq+0xd8>
 800d2f4:	2b03      	cmp	r3, #3
 800d2f6:	d1b7      	bne.n	800d268 <USBD_StdEPReq+0x14>
              if (req->wValue == USB_FEATURE_EP_HALT)
 800d2f8:	884b      	ldrh	r3, [r1, #2]
 800d2fa:	b923      	cbnz	r3, 800d306 <USBD_StdEPReq+0xb2>
                if ((ep_addr != 0x00U) &&
 800d2fc:	066a      	lsls	r2, r5, #25
 800d2fe:	d002      	beq.n	800d306 <USBD_StdEPReq+0xb2>
                    (ep_addr != 0x80U) && (req->wLength == 0x00U))
 800d300:	88cb      	ldrh	r3, [r1, #6]
 800d302:	2b00      	cmp	r3, #0
 800d304:	d038      	beq.n	800d378 <USBD_StdEPReq+0x124>
              USBD_CtlSendStatus(pdev);
 800d306:	4620      	mov	r0, r4
 800d308:	f000 f86c 	bl	800d3e4 <USBD_CtlSendStatus>
              break;
 800d30c:	e7b4      	b.n	800d278 <USBD_StdEPReq+0x24>
          switch (pdev->dev_state)
 800d30e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 800d312:	2b02      	cmp	r3, #2
 800d314:	d00a      	beq.n	800d32c <USBD_StdEPReq+0xd8>
 800d316:	2b03      	cmp	r3, #3
 800d318:	d1a6      	bne.n	800d268 <USBD_StdEPReq+0x14>
              if (req->wValue == USB_FEATURE_EP_HALT)
 800d31a:	884b      	ldrh	r3, [r1, #2]
 800d31c:	2b00      	cmp	r3, #0
 800d31e:	d1ab      	bne.n	800d278 <USBD_StdEPReq+0x24>
                if ((ep_addr & 0x7FU) != 0x00U)
 800d320:	066e      	lsls	r6, r5, #25
 800d322:	d0f0      	beq.n	800d306 <USBD_StdEPReq+0xb2>
                  USBD_LL_ClearStallEP(pdev, ep_addr);
 800d324:	4629      	mov	r1, r5
 800d326:	f7f6 fe59 	bl	8003fdc <USBD_LL_ClearStallEP>
 800d32a:	e7ec      	b.n	800d306 <USBD_StdEPReq+0xb2>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800d32c:	066b      	lsls	r3, r5, #25
 800d32e:	d09b      	beq.n	800d268 <USBD_StdEPReq+0x14>
                USBD_LL_StallEP(pdev, ep_addr);
 800d330:	4629      	mov	r1, r5
 800d332:	f7f6 fe4b 	bl	8003fcc <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 800d336:	4620      	mov	r0, r4
 800d338:	2180      	movs	r1, #128	; 0x80
 800d33a:	f7f6 fe47 	bl	8003fcc <USBD_LL_StallEP>
 800d33e:	e79b      	b.n	800d278 <USBD_StdEPReq+0x24>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800d340:	0668      	lsls	r0, r5, #25
 800d342:	d191      	bne.n	800d268 <USBD_StdEPReq+0x14>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800d344:	0611      	lsls	r1, r2, #24
 800d346:	bf4c      	ite	mi
 800d348:	f104 0114 	addmi.w	r1, r4, #20
 800d34c:	f504 71aa 	addpl.w	r1, r4, #340	; 0x154
              pep->status = 0x0000U;
 800d350:	2300      	movs	r3, #0
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800d352:	4620      	mov	r0, r4
              pep->status = 0x0000U;
 800d354:	600b      	str	r3, [r1, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800d356:	2202      	movs	r2, #2
 800d358:	f000 f826 	bl	800d3a8 <USBD_CtlSendData>
              break;
 800d35c:	e78c      	b.n	800d278 <USBD_StdEPReq+0x24>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800d35e:	699b      	ldr	r3, [r3, #24]
 800d360:	2b00      	cmp	r3, #0
 800d362:	d081      	beq.n	800d268 <USBD_StdEPReq+0x14>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800d364:	f005 037f 	and.w	r3, r5, #127	; 0x7f
 800d368:	1c5e      	adds	r6, r3, #1
 800d36a:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 800d36e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 800d372:	e7ac      	b.n	800d2ce <USBD_StdEPReq+0x7a>
                pep->status = 0x0000U;
 800d374:	6030      	str	r0, [r6, #0]
 800d376:	e7b3      	b.n	800d2e0 <USBD_StdEPReq+0x8c>
                  USBD_LL_StallEP(pdev, ep_addr);
 800d378:	4629      	mov	r1, r5
 800d37a:	f7f6 fe27 	bl	8003fcc <USBD_LL_StallEP>
 800d37e:	e7c2      	b.n	800d306 <USBD_StdEPReq+0xb2>

0800d380 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pdata);
 800d380:	780b      	ldrb	r3, [r1, #0]
 800d382:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pdata + 1U);
 800d384:	784b      	ldrb	r3, [r1, #1]
 800d386:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pdata + 2U);
 800d388:	78ca      	ldrb	r2, [r1, #3]
 800d38a:	788b      	ldrb	r3, [r1, #2]
 800d38c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800d390:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pdata + 4U);
 800d392:	794a      	ldrb	r2, [r1, #5]
 800d394:	790b      	ldrb	r3, [r1, #4]
 800d396:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800d39a:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pdata + 6U);
 800d39c:	79ca      	ldrb	r2, [r1, #7]
 800d39e:	798b      	ldrb	r3, [r1, #6]
 800d3a0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800d3a4:	80c3      	strh	r3, [r0, #6]
}
 800d3a6:	4770      	bx	lr

0800d3a8 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint16_t len)
{
 800d3a8:	b538      	push	{r3, r4, r5, lr}
 800d3aa:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800d3ac:	2502      	movs	r5, #2
{
 800d3ae:	460a      	mov	r2, r1
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 800d3b0:	e9c0 3307 	strd	r3, r3, [r0, #28]
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800d3b4:	f8c0 5294 	str.w	r5, [r0, #660]	; 0x294

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800d3b8:	2100      	movs	r1, #0
 800d3ba:	f7f6 fe33 	bl	8004024 <USBD_LL_Transmit>

  return USBD_OK;
}
 800d3be:	2000      	movs	r0, #0
 800d3c0:	bd38      	pop	{r3, r4, r5, pc}
 800d3c2:	bf00      	nop

0800d3c4 <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint16_t len)
{
 800d3c4:	b508      	push	{r3, lr}
 800d3c6:	4613      	mov	r3, r2
  /* Start the next transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800d3c8:	460a      	mov	r2, r1
 800d3ca:	2100      	movs	r1, #0
 800d3cc:	f7f6 fe2a 	bl	8004024 <USBD_LL_Transmit>

  return USBD_OK;
}
 800d3d0:	2000      	movs	r0, #0
 800d3d2:	bd08      	pop	{r3, pc}

0800d3d4 <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint16_t len)
{
 800d3d4:	b508      	push	{r3, lr}
 800d3d6:	4613      	mov	r3, r2
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800d3d8:	460a      	mov	r2, r1
 800d3da:	2100      	movs	r1, #0
 800d3dc:	f7f6 fe2a 	bl	8004034 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800d3e0:	2000      	movs	r0, #0
 800d3e2:	bd08      	pop	{r3, pc}

0800d3e4 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 800d3e4:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800d3e6:	2204      	movs	r2, #4

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 800d3e8:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800d3ea:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 800d3ee:	4619      	mov	r1, r3
 800d3f0:	461a      	mov	r2, r3
 800d3f2:	f7f6 fe17 	bl	8004024 <USBD_LL_Transmit>

  return USBD_OK;
}
 800d3f6:	2000      	movs	r0, #0
 800d3f8:	bd08      	pop	{r3, pc}
 800d3fa:	bf00      	nop

0800d3fc <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 800d3fc:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 800d3fe:	2205      	movs	r2, #5

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800d400:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 800d402:	f8c0 2294 	str.w	r2, [r0, #660]	; 0x294
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800d406:	4619      	mov	r1, r3
 800d408:	461a      	mov	r2, r3
 800d40a:	f7f6 fe13 	bl	8004034 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800d40e:	2000      	movs	r0, #0
 800d410:	bd08      	pop	{r3, pc}
 800d412:	bf00      	nop

0800d414 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 800d414:	4b03      	ldr	r3, [pc, #12]	; (800d424 <disk_status+0x10>)
 800d416:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 800d41a:	4418      	add	r0, r3
 800d41c:	6853      	ldr	r3, [r2, #4]
 800d41e:	7a00      	ldrb	r0, [r0, #8]
 800d420:	685b      	ldr	r3, [r3, #4]
 800d422:	4718      	bx	r3
 800d424:	20001c08 	.word	0x20001c08

0800d428 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 800d428:	4b06      	ldr	r3, [pc, #24]	; (800d444 <disk_initialize+0x1c>)
 800d42a:	5c1a      	ldrb	r2, [r3, r0]
 800d42c:	b942      	cbnz	r2, 800d440 <disk_initialize+0x18>
  {
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800d42e:	eb03 0280 	add.w	r2, r3, r0, lsl #2
    disk.is_initialized[pdrv] = 1;
 800d432:	2101      	movs	r1, #1
 800d434:	5419      	strb	r1, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 800d436:	6852      	ldr	r2, [r2, #4]
 800d438:	4418      	add	r0, r3
 800d43a:	6813      	ldr	r3, [r2, #0]
 800d43c:	7a00      	ldrb	r0, [r0, #8]
 800d43e:	4718      	bx	r3
  }
  return stat;
}
 800d440:	2000      	movs	r0, #0
 800d442:	4770      	bx	lr
 800d444:	20001c08 	.word	0x20001c08

0800d448 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 800d448:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800d44a:	4c05      	ldr	r4, [pc, #20]	; (800d460 <disk_read+0x18>)
 800d44c:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 800d450:	4420      	add	r0, r4
 800d452:	686c      	ldr	r4, [r5, #4]
 800d454:	7a00      	ldrb	r0, [r0, #8]
 800d456:	68a4      	ldr	r4, [r4, #8]
 800d458:	46a4      	mov	ip, r4
  return res;
}
 800d45a:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 800d45c:	4760      	bx	ip
 800d45e:	bf00      	nop
 800d460:	20001c08 	.word	0x20001c08

0800d464 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 800d464:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 800d466:	4c05      	ldr	r4, [pc, #20]	; (800d47c <disk_write+0x18>)
 800d468:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 800d46c:	4420      	add	r0, r4
 800d46e:	686c      	ldr	r4, [r5, #4]
 800d470:	7a00      	ldrb	r0, [r0, #8]
 800d472:	68e4      	ldr	r4, [r4, #12]
 800d474:	46a4      	mov	ip, r4
  return res;
}
 800d476:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 800d478:	4760      	bx	ip
 800d47a:	bf00      	nop
 800d47c:	20001c08 	.word	0x20001c08

0800d480 <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800d480:	4b05      	ldr	r3, [pc, #20]	; (800d498 <disk_ioctl+0x18>)
{
 800d482:	b410      	push	{r4}
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800d484:	eb03 0480 	add.w	r4, r3, r0, lsl #2
 800d488:	4418      	add	r0, r3
 800d48a:	6863      	ldr	r3, [r4, #4]
 800d48c:	7a00      	ldrb	r0, [r0, #8]
 800d48e:	691b      	ldr	r3, [r3, #16]
  return res;
}
 800d490:	f85d 4b04 	ldr.w	r4, [sp], #4
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 800d494:	4718      	bx	r3
 800d496:	bf00      	nop
 800d498:	20001c08 	.word	0x20001c08

0800d49c <get_fattime>:
  * @retval Time in DWORD
  */
__weak DWORD get_fattime (void)
{
  return 0;
}
 800d49c:	2000      	movs	r0, #0
 800d49e:	4770      	bx	lr

0800d4a0 <pattern_matching>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	int skip,			/* Number of pre-skip chars (number of ?s) */
	int inf				/* Infinite search (* specified) */
)
{
 800d4a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800d4a4:	4d36      	ldr	r5, [pc, #216]	; (800d580 <pattern_matching+0xe0>)
{
 800d4a6:	460c      	mov	r4, r1
 800d4a8:	4606      	mov	r6, r0
 800d4aa:	440a      	add	r2, r1
 800d4ac:	461f      	mov	r7, r3
	const TCHAR *pp, *np;
	WCHAR pc, nc;
	int nm, nx;


	while (skip--) {				/* Pre-skip name chars */
 800d4ae:	42a2      	cmp	r2, r4
 800d4b0:	d010      	beq.n	800d4d4 <pattern_matching+0x34>
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800d4b2:	f814 3b01 	ldrb.w	r3, [r4], #1
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d4b6:	f1a3 0061 	sub.w	r0, r3, #97	; 0x61
 800d4ba:	2819      	cmp	r0, #25
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800d4bc:	b299      	uxth	r1, r3
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800d4be:	442b      	add	r3, r5
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d4c0:	d9f5      	bls.n	800d4ae <pattern_matching+0xe>
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800d4c2:	297f      	cmp	r1, #127	; 0x7f
 800d4c4:	bf88      	it	hi
 800d4c6:	f813 1c80 	ldrbhi.w	r1, [r3, #-128]
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 800d4ca:	2900      	cmp	r1, #0
 800d4cc:	d1ef      	bne.n	800d4ae <pattern_matching+0xe>
 800d4ce:	2000      	movs	r0, #0
		}
		get_achar(&nam);			/* nam++ */
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */

	return 0;
}
 800d4d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!*pat && inf) return 1;		/* (short circuit) */
 800d4d4:	f896 8000 	ldrb.w	r8, [r6]
 800d4d8:	f1b8 0f00 	cmp.w	r8, #0
 800d4dc:	d024      	beq.n	800d528 <pattern_matching+0x88>
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800d4de:	4d28      	ldr	r5, [pc, #160]	; (800d580 <pattern_matching+0xe0>)
		pp = pat; np = nam;			/* Top of pattern and name to match */
 800d4e0:	4631      	mov	r1, r6
	if (!*pat && inf) return 1;		/* (short circuit) */
 800d4e2:	4642      	mov	r2, r8
		pp = pat; np = nam;			/* Top of pattern and name to match */
 800d4e4:	46a1      	mov	r9, r4
 800d4e6:	e010      	b.n	800d50a <pattern_matching+0x6a>
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d4e8:	3b20      	subs	r3, #32
 800d4ea:	b29b      	uxth	r3, r3
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800d4ec:	f819 0b01 	ldrb.w	r0, [r9], #1
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d4f0:	f1a0 0c61 	sub.w	ip, r0, #97	; 0x61
 800d4f4:	f1bc 0f19 	cmp.w	ip, #25
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800d4f8:	b282      	uxth	r2, r0
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d4fa:	d81a      	bhi.n	800d532 <pattern_matching+0x92>
 800d4fc:	3a20      	subs	r2, #32
 800d4fe:	b292      	uxth	r2, r2
			if (pc != nc) break;	/* Branch mismatched? */
 800d500:	429a      	cmp	r2, r3
 800d502:	d11d      	bne.n	800d540 <pattern_matching+0xa0>
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 800d504:	b192      	cbz	r2, 800d52c <pattern_matching+0x8c>
 800d506:	f811 2f01 	ldrb.w	r2, [r1, #1]!
			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
 800d50a:	2a3f      	cmp	r2, #63	; 0x3f
 800d50c:	d01e      	beq.n	800d54c <pattern_matching+0xac>
 800d50e:	2a2a      	cmp	r2, #42	; 0x2a
 800d510:	d01c      	beq.n	800d54c <pattern_matching+0xac>
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d512:	f1a2 0061 	sub.w	r0, r2, #97	; 0x61
 800d516:	2819      	cmp	r0, #25
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800d518:	b293      	uxth	r3, r2
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800d51a:	d9e5      	bls.n	800d4e8 <pattern_matching+0x48>
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800d51c:	2b7f      	cmp	r3, #127	; 0x7f
 800d51e:	bf84      	itt	hi
 800d520:	1952      	addhi	r2, r2, r5
 800d522:	f812 3c80 	ldrbhi.w	r3, [r2, #-128]
 800d526:	e7e1      	b.n	800d4ec <pattern_matching+0x4c>
	if (!*pat && inf) return 1;		/* (short circuit) */
 800d528:	2f00      	cmp	r7, #0
 800d52a:	d0d8      	beq.n	800d4de <pattern_matching+0x3e>
 800d52c:	2001      	movs	r0, #1
}
 800d52e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 800d532:	2a7f      	cmp	r2, #127	; 0x7f
 800d534:	bf84      	itt	hi
 800d536:	1940      	addhi	r0, r0, r5
 800d538:	f810 2c80 	ldrbhi.w	r2, [r0, #-128]
			if (pc != nc) break;	/* Branch mismatched? */
 800d53c:	429a      	cmp	r2, r3
 800d53e:	d0e1      	beq.n	800d504 <pattern_matching+0x64>
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 800d540:	3401      	adds	r4, #1
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
 800d542:	2f00      	cmp	r7, #0
 800d544:	d0c3      	beq.n	800d4ce <pattern_matching+0x2e>
 800d546:	2a00      	cmp	r2, #0
 800d548:	d1ca      	bne.n	800d4e0 <pattern_matching+0x40>
 800d54a:	e7c0      	b.n	800d4ce <pattern_matching+0x2e>
		pp = pat; np = nam;			/* Top of pattern and name to match */
 800d54c:	2300      	movs	r3, #0
 800d54e:	f811 cb01 	ldrb.w	ip, [r1], #1
 800d552:	461a      	mov	r2, r3
					if (*pp++ == '?') nm++; else nx = 1;
 800d554:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
 800d558:	4608      	mov	r0, r1
				} while (*pp == '?' || *pp == '*');
 800d55a:	f811 cb01 	ldrb.w	ip, [r1], #1
					if (*pp++ == '?') nm++; else nx = 1;
 800d55e:	bf0c      	ite	eq
 800d560:	3201      	addeq	r2, #1
 800d562:	2301      	movne	r3, #1
				} while (*pp == '?' || *pp == '*');
 800d564:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
 800d568:	d0f4      	beq.n	800d554 <pattern_matching+0xb4>
 800d56a:	f1bc 0f2a 	cmp.w	ip, #42	; 0x2a
 800d56e:	d0f1      	beq.n	800d554 <pattern_matching+0xb4>
				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
 800d570:	4649      	mov	r1, r9
 800d572:	f7ff ff95 	bl	800d4a0 <pattern_matching>
 800d576:	2800      	cmp	r0, #0
 800d578:	d1d8      	bne.n	800d52c <pattern_matching+0x8c>
				nc = *np; break;	/* Branch mismatched */
 800d57a:	f899 2000 	ldrb.w	r2, [r9]
 800d57e:	e7df      	b.n	800d540 <pattern_matching+0xa0>
 800d580:	0801a1a0 	.word	0x0801a1a0

0800d584 <get_fileinfo>:
{
 800d584:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	fno->fname[0] = 0;		/* Invaidate file info */
 800d588:	2700      	movs	r7, #0
	FATFS *fs = dp->obj.fs;
 800d58a:	f8d0 8000 	ldr.w	r8, [r0]
	fno->fname[0] = 0;		/* Invaidate file info */
 800d58e:	758f      	strb	r7, [r1, #22]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 800d590:	69c3      	ldr	r3, [r0, #28]
 800d592:	2b00      	cmp	r3, #0
 800d594:	d065      	beq.n	800d662 <get_fileinfo+0xde>
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 800d596:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800d598:	3301      	adds	r3, #1
 800d59a:	4606      	mov	r6, r0
 800d59c:	460d      	mov	r5, r1
 800d59e:	d01d      	beq.n	800d5dc <get_fileinfo+0x58>
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 800d5a0:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800d5a4:	8818      	ldrh	r0, [r3, #0]
 800d5a6:	b1a0      	cbz	r0, 800d5d2 <get_fileinfo+0x4e>
 800d5a8:	f101 0715 	add.w	r7, r1, #21
 800d5ac:	2401      	movs	r4, #1
 800d5ae:	e00b      	b.n	800d5c8 <get_fileinfo+0x44>
				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
 800d5b0:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 800d5b4:	d00d      	beq.n	800d5d2 <get_fileinfo+0x4e>
				fno->fname[i++] = (TCHAR)w;
 800d5b6:	f807 0f01 	strb.w	r0, [r7, #1]!
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 800d5ba:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800d5be:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
 800d5c2:	1c63      	adds	r3, r4, #1
 800d5c4:	b130      	cbz	r0, 800d5d4 <get_fileinfo+0x50>
 800d5c6:	461c      	mov	r4, r3
				w = ff_convert(w, 0);		/* Unicode -> OEM */
 800d5c8:	2100      	movs	r1, #0
 800d5ca:	f003 fb8d 	bl	8010ce8 <ff_convert>
				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
 800d5ce:	2800      	cmp	r0, #0
 800d5d0:	d1ee      	bne.n	800d5b0 <get_fileinfo+0x2c>
			i = j = 0;
 800d5d2:	2400      	movs	r4, #0
			fno->fname[i] = 0;	/* Terminate the LFN */
 800d5d4:	442c      	add	r4, r5
 800d5d6:	2300      	movs	r3, #0
 800d5d8:	75a3      	strb	r3, [r4, #22]
 800d5da:	7daf      	ldrb	r7, [r5, #22]
		c = (TCHAR)dp->dir[i++];
 800d5dc:	6a36      	ldr	r6, [r6, #32]
	i = j = 0;
 800d5de:	2400      	movs	r4, #0
 800d5e0:	1e70      	subs	r0, r6, #1
 800d5e2:	f106 0c0a 	add.w	ip, r6, #10
			fno->altname[j++] = '.';
 800d5e6:	f04f 082e 	mov.w	r8, #46	; 0x2e
		c = (TCHAR)dp->dir[i++];
 800d5ea:	4602      	mov	r2, r0
 800d5ec:	f810 3f01 	ldrb.w	r3, [r0, #1]!
		if (c == ' ') continue;				/* Skip padding spaces */
 800d5f0:	2b20      	cmp	r3, #32
 800d5f2:	d01c      	beq.n	800d62e <get_fileinfo+0xaa>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800d5f4:	3202      	adds	r2, #2
 800d5f6:	2b05      	cmp	r3, #5
 800d5f8:	eba2 0206 	sub.w	r2, r2, r6
 800d5fc:	bf08      	it	eq
 800d5fe:	23e5      	moveq	r3, #229	; 0xe5
		if (i == 9) {						/* Insert a . if extension is exist */
 800d600:	2a09      	cmp	r2, #9
 800d602:	d030      	beq.n	800d666 <get_fileinfo+0xe2>
		fno->altname[j] = c;
 800d604:	1929      	adds	r1, r5, r4
 800d606:	724b      	strb	r3, [r1, #9]
		if (!lfv) {
 800d608:	b987      	cbnz	r7, 800d62c <get_fileinfo+0xa8>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 800d60a:	f1a3 0e41 	sub.w	lr, r3, #65	; 0x41
 800d60e:	f1be 0f19 	cmp.w	lr, #25
 800d612:	d80a      	bhi.n	800d62a <get_fileinfo+0xa6>
 800d614:	2a09      	cmp	r2, #9
 800d616:	f896 e00c 	ldrb.w	lr, [r6, #12]
 800d61a:	bf34      	ite	cc
 800d61c:	2208      	movcc	r2, #8
 800d61e:	2210      	movcs	r2, #16
 800d620:	ea1e 0f02 	tst.w	lr, r2
				c += 0x20;			/* To lower */
 800d624:	bf1c      	itt	ne
 800d626:	3320      	addne	r3, #32
 800d628:	b2db      	uxtbne	r3, r3
			fno->fname[j] = c;
 800d62a:	758b      	strb	r3, [r1, #22]
		j++;
 800d62c:	3401      	adds	r4, #1
	while (i < 11) {		/* Copy name body and extension */
 800d62e:	4584      	cmp	ip, r0
 800d630:	d1db      	bne.n	800d5ea <get_fileinfo+0x66>
		fno->fname[j] = 0;
 800d632:	1929      	adds	r1, r5, r4
	if (!lfv) {
 800d634:	b1ff      	cbz	r7, 800d676 <get_fileinfo+0xf2>
	fno->altname[j] = 0;	/* Terminate the SFN */
 800d636:	2300      	movs	r3, #0
 800d638:	724b      	strb	r3, [r1, #9]
	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 800d63a:	7af3      	ldrb	r3, [r6, #11]
 800d63c:	722b      	strb	r3, [r5, #8]
	rv = rv << 8 | ptr[2];
 800d63e:	8bf1      	ldrh	r1, [r6, #30]
	rv = rv << 8 | ptr[1];
 800d640:	7f72      	ldrb	r2, [r6, #29]
	rv = rv << 8 | ptr[0];
 800d642:	7f33      	ldrb	r3, [r6, #28]
	rv = rv << 8 | ptr[1];
 800d644:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800d648:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 800d64c:	602b      	str	r3, [r5, #0]
	rv = rv << 8 | ptr[2];
 800d64e:	8b31      	ldrh	r1, [r6, #24]
	rv = rv << 8 | ptr[1];
 800d650:	7df2      	ldrb	r2, [r6, #23]
	rv = rv << 8 | ptr[0];
 800d652:	7db3      	ldrb	r3, [r6, #22]
	rv = rv << 8 | ptr[1];
 800d654:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800d658:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 800d65c:	0c1a      	lsrs	r2, r3, #16
 800d65e:	80eb      	strh	r3, [r5, #6]
 800d660:	80aa      	strh	r2, [r5, #4]
}
 800d662:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (!lfv) fno->fname[j] = '.';
 800d666:	1929      	adds	r1, r5, r4
 800d668:	b90f      	cbnz	r7, 800d66e <get_fileinfo+0xea>
 800d66a:	f881 8016 	strb.w	r8, [r1, #22]
			fno->altname[j++] = '.';
 800d66e:	f881 8009 	strb.w	r8, [r1, #9]
 800d672:	3401      	adds	r4, #1
 800d674:	e7c6      	b.n	800d604 <get_fileinfo+0x80>
		fno->fname[j] = 0;
 800d676:	758f      	strb	r7, [r1, #22]
		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
 800d678:	7b33      	ldrb	r3, [r6, #12]
 800d67a:	2b00      	cmp	r3, #0
 800d67c:	bf08      	it	eq
 800d67e:	4629      	moveq	r1, r5
 800d680:	e7d9      	b.n	800d636 <get_fileinfo+0xb2>
 800d682:	bf00      	nop

0800d684 <move_window.part.0>:
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 800d684:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800d686:	78c3      	ldrb	r3, [r0, #3]
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
 800d688:	b083      	sub	sp, #12
 800d68a:	4604      	mov	r4, r0
 800d68c:	460d      	mov	r5, r1
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800d68e:	b973      	cbnz	r3, 800d6ae <move_window.part.0+0x2a>
 800d690:	f100 0134 	add.w	r1, r0, #52	; 0x34
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800d694:	462a      	mov	r2, r5
 800d696:	7860      	ldrb	r0, [r4, #1]
 800d698:	2301      	movs	r3, #1
 800d69a:	f7ff fed5 	bl	800d448 <disk_read>
				res = FR_DISK_ERR;
 800d69e:	2800      	cmp	r0, #0
 800d6a0:	bf1c      	itt	ne
 800d6a2:	2001      	movne	r0, #1
 800d6a4:	f04f 35ff 	movne.w	r5, #4294967295
			fs->winsect = sector;
 800d6a8:	6325      	str	r5, [r4, #48]	; 0x30
}
 800d6aa:	b003      	add	sp, #12
 800d6ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
 800d6ae:	6b06      	ldr	r6, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800d6b0:	7840      	ldrb	r0, [r0, #1]
 800d6b2:	f104 0134 	add.w	r1, r4, #52	; 0x34
 800d6b6:	4632      	mov	r2, r6
 800d6b8:	2301      	movs	r3, #1
 800d6ba:	9101      	str	r1, [sp, #4]
 800d6bc:	f7ff fed2 	bl	800d464 <disk_write>
 800d6c0:	b9b8      	cbnz	r0, 800d6f2 <move_window.part.0+0x6e>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800d6c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800d6c4:	69e3      	ldr	r3, [r4, #28]
 800d6c6:	9901      	ldr	r1, [sp, #4]
			fs->wflag = 0;
 800d6c8:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800d6ca:	1ab2      	subs	r2, r6, r2
 800d6cc:	429a      	cmp	r2, r3
 800d6ce:	d2e1      	bcs.n	800d694 <move_window.part.0+0x10>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800d6d0:	78a7      	ldrb	r7, [r4, #2]
 800d6d2:	2f01      	cmp	r7, #1
 800d6d4:	d801      	bhi.n	800d6da <move_window.part.0+0x56>
 800d6d6:	e7dd      	b.n	800d694 <move_window.part.0+0x10>
 800d6d8:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 800d6da:	7860      	ldrb	r0, [r4, #1]
 800d6dc:	9101      	str	r1, [sp, #4]
					wsect += fs->fsize;
 800d6de:	441e      	add	r6, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800d6e0:	3f01      	subs	r7, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 800d6e2:	4632      	mov	r2, r6
 800d6e4:	2301      	movs	r3, #1
 800d6e6:	f7ff febd 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800d6ea:	2f01      	cmp	r7, #1
 800d6ec:	9901      	ldr	r1, [sp, #4]
 800d6ee:	d1f3      	bne.n	800d6d8 <move_window.part.0+0x54>
 800d6f0:	e7d0      	b.n	800d694 <move_window.part.0+0x10>
			res = FR_DISK_ERR;
 800d6f2:	2001      	movs	r0, #1
}
 800d6f4:	b003      	add	sp, #12
 800d6f6:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800d6f8 <put_fat.part.0>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 800d6f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		switch (fs->fs_type) {
 800d6fc:	7803      	ldrb	r3, [r0, #0]
 800d6fe:	2b02      	cmp	r3, #2
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 800d700:	4604      	mov	r4, r0
 800d702:	460d      	mov	r5, r1
 800d704:	4616      	mov	r6, r2
		switch (fs->fs_type) {
 800d706:	d006      	beq.n	800d716 <put_fat.part.0+0x1e>
 800d708:	2b03      	cmp	r3, #3
 800d70a:	d052      	beq.n	800d7b2 <put_fat.part.0+0xba>
 800d70c:	2b01      	cmp	r3, #1
 800d70e:	d01b      	beq.n	800d748 <put_fat.part.0+0x50>
 800d710:	2002      	movs	r0, #2
}
 800d712:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800d716:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d718:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800d71a:	eb01 2115 	add.w	r1, r1, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d71e:	4299      	cmp	r1, r3
 800d720:	d003      	beq.n	800d72a <put_fat.part.0+0x32>
 800d722:	f7ff ffaf 	bl	800d684 <move_window.part.0>
			if (res != FR_OK) break;
 800d726:	2800      	cmp	r0, #0
 800d728:	d1f3      	bne.n	800d712 <put_fat.part.0+0x1a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 800d72a:	006d      	lsls	r5, r5, #1
 800d72c:	f104 0334 	add.w	r3, r4, #52	; 0x34
 800d730:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 800d734:	195a      	adds	r2, r3, r5
	*ptr++ = (BYTE)val; val >>= 8;
 800d736:	555e      	strb	r6, [r3, r5]
 800d738:	f3c6 2107 	ubfx	r1, r6, #8, #8
			fs->wflag = 1;
 800d73c:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 800d73e:	7051      	strb	r1, [r2, #1]
			fs->wflag = 1;
 800d740:	70e3      	strb	r3, [r4, #3]
			break;
 800d742:	2000      	movs	r0, #0
}
 800d744:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800d748:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d74a:	6b03      	ldr	r3, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 800d74c:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800d750:	eb01 2157 	add.w	r1, r1, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d754:	4299      	cmp	r1, r3
 800d756:	d003      	beq.n	800d760 <put_fat.part.0+0x68>
 800d758:	f7ff ff94 	bl	800d684 <move_window.part.0>
			if (res != FR_OK) break;
 800d75c:	2800      	cmp	r0, #0
 800d75e:	d1d8      	bne.n	800d712 <put_fat.part.0+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800d760:	07eb      	lsls	r3, r5, #31
			p = fs->win + bc++ % SS(fs);
 800d762:	f107 0801 	add.w	r8, r7, #1
 800d766:	f104 0934 	add.w	r9, r4, #52	; 0x34
 800d76a:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800d76e:	d543      	bpl.n	800d7f8 <put_fat.part.0+0x100>
 800d770:	f819 3007 	ldrb.w	r3, [r9, r7]
 800d774:	f003 030f 	and.w	r3, r3, #15
 800d778:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 800d77c:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800d780:	6a61      	ldr	r1, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d782:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800d784:	eb01 2158 	add.w	r1, r1, r8, lsr #9
			fs->wflag = 1;
 800d788:	2201      	movs	r2, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d78a:	4299      	cmp	r1, r3
			fs->wflag = 1;
 800d78c:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d78e:	d004      	beq.n	800d79a <put_fat.part.0+0xa2>
 800d790:	4620      	mov	r0, r4
 800d792:	f7ff ff77 	bl	800d684 <move_window.part.0>
			if (res != FR_OK) break;
 800d796:	2800      	cmp	r0, #0
 800d798:	d1bb      	bne.n	800d712 <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 800d79a:	f3c8 0808 	ubfx	r8, r8, #0, #9
 800d79e:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800d7a0:	f3c6 1207 	ubfx	r2, r6, #4, #8
			fs->wflag = 1;
 800d7a4:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800d7a6:	f888 2000 	strb.w	r2, [r8]
			fs->wflag = 1;
 800d7aa:	70e3      	strb	r3, [r4, #3]
			break;
 800d7ac:	2000      	movs	r0, #0
}
 800d7ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800d7b2:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d7b4:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800d7b6:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d7ba:	4299      	cmp	r1, r3
 800d7bc:	d003      	beq.n	800d7c6 <put_fat.part.0+0xce>
 800d7be:	f7ff ff61 	bl	800d684 <move_window.part.0>
			if (res != FR_OK) break;
 800d7c2:	2800      	cmp	r0, #0
 800d7c4:	d1a5      	bne.n	800d712 <put_fat.part.0+0x1a>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800d7c6:	00ad      	lsls	r5, r5, #2
 800d7c8:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 800d7cc:	f104 0134 	add.w	r1, r4, #52	; 0x34
 800d7d0:	1948      	adds	r0, r1, r5
 800d7d2:	f026 4270 	bic.w	r2, r6, #4026531840	; 0xf0000000
	rv = rv << 8 | ptr[2];
 800d7d6:	8843      	ldrh	r3, [r0, #2]
	rv = rv << 8 | ptr[0];
 800d7d8:	041b      	lsls	r3, r3, #16
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 800d7da:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800d7de:	4313      	orrs	r3, r2
	*ptr++ = (BYTE)val; val >>= 8;
 800d7e0:	554b      	strb	r3, [r1, r5]
 800d7e2:	0a1f      	lsrs	r7, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800d7e4:	0c1e      	lsrs	r6, r3, #16
			fs->wflag = 1;
 800d7e6:	2201      	movs	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 800d7e8:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val; val >>= 8;
 800d7ea:	7047      	strb	r7, [r0, #1]
	*ptr++ = (BYTE)val; val >>= 8;
 800d7ec:	7086      	strb	r6, [r0, #2]
	*ptr++ = (BYTE)val;
 800d7ee:	70c3      	strb	r3, [r0, #3]
			fs->wflag = 1;
 800d7f0:	70e2      	strb	r2, [r4, #3]
			break;
 800d7f2:	2000      	movs	r0, #0
}
 800d7f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800d7f8:	f809 6007 	strb.w	r6, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800d7fc:	6a61      	ldr	r1, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d7fe:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800d800:	eb01 2158 	add.w	r1, r1, r8, lsr #9
			fs->wflag = 1;
 800d804:	2201      	movs	r2, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d806:	4299      	cmp	r1, r3
			fs->wflag = 1;
 800d808:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d80a:	d005      	beq.n	800d818 <put_fat.part.0+0x120>
 800d80c:	4620      	mov	r0, r4
 800d80e:	f7ff ff39 	bl	800d684 <move_window.part.0>
			if (res != FR_OK) break;
 800d812:	2800      	cmp	r0, #0
 800d814:	f47f af7d 	bne.w	800d712 <put_fat.part.0+0x1a>
			p = fs->win + bc % SS(fs);
 800d818:	f3c8 0808 	ubfx	r8, r8, #0, #9
 800d81c:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800d81e:	f3c6 2203 	ubfx	r2, r6, #8, #4
 800d822:	f898 1000 	ldrb.w	r1, [r8]
 800d826:	f021 060f 	bic.w	r6, r1, #15
 800d82a:	4332      	orrs	r2, r6
 800d82c:	e7ba      	b.n	800d7a4 <put_fat.part.0+0xac>
 800d82e:	bf00      	nop

0800d830 <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800d830:	2901      	cmp	r1, #1
 800d832:	d90e      	bls.n	800d852 <get_fat.isra.0+0x22>
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 800d834:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800d836:	6983      	ldr	r3, [r0, #24]
 800d838:	4299      	cmp	r1, r3
 800d83a:	460c      	mov	r4, r1
 800d83c:	4605      	mov	r5, r0
 800d83e:	d206      	bcs.n	800d84e <get_fat.isra.0+0x1e>
		switch (fs->fs_type) {
 800d840:	7803      	ldrb	r3, [r0, #0]
 800d842:	2b02      	cmp	r3, #2
 800d844:	d046      	beq.n	800d8d4 <get_fat.isra.0+0xa4>
 800d846:	2b03      	cmp	r3, #3
 800d848:	d02c      	beq.n	800d8a4 <get_fat.isra.0+0x74>
 800d84a:	2b01      	cmp	r3, #1
 800d84c:	d003      	beq.n	800d856 <get_fat.isra.0+0x26>
 800d84e:	2001      	movs	r0, #1
}
 800d850:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 800d852:	2001      	movs	r0, #1
}
 800d854:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800d856:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d858:	6b02      	ldr	r2, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 800d85a:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800d85e:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d862:	4291      	cmp	r1, r2
 800d864:	d005      	beq.n	800d872 <get_fat.isra.0+0x42>
 800d866:	f7ff ff0d 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800d86a:	2800      	cmp	r0, #0
 800d86c:	d13b      	bne.n	800d8e6 <get_fat.isra.0+0xb6>
 800d86e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800d870:	6b2a      	ldr	r2, [r5, #48]	; 0x30
			wc = fs->win[bc++ % SS(fs)];
 800d872:	f3c7 0008 	ubfx	r0, r7, #0, #9
 800d876:	3701      	adds	r7, #1
 800d878:	4428      	add	r0, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800d87a:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d87e:	4291      	cmp	r1, r2
			wc = fs->win[bc++ % SS(fs)];
 800d880:	f890 6034 	ldrb.w	r6, [r0, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d884:	d003      	beq.n	800d88e <get_fat.isra.0+0x5e>
 800d886:	4628      	mov	r0, r5
 800d888:	f7ff fefc 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800d88c:	bb58      	cbnz	r0, 800d8e6 <get_fat.isra.0+0xb6>
			wc |= fs->win[bc % SS(fs)] << 8;
 800d88e:	f3c7 0708 	ubfx	r7, r7, #0, #9
 800d892:	443d      	add	r5, r7
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800d894:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800d896:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
 800d89a:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800d89e:	d52f      	bpl.n	800d900 <get_fat.isra.0+0xd0>
 800d8a0:	0900      	lsrs	r0, r0, #4
}
 800d8a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800d8a4:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d8a6:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800d8a8:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d8ac:	4299      	cmp	r1, r3
 800d8ae:	d002      	beq.n	800d8b6 <get_fat.isra.0+0x86>
 800d8b0:	f7ff fee8 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800d8b4:	b9b8      	cbnz	r0, 800d8e6 <get_fat.isra.0+0xb6>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800d8b6:	00a4      	lsls	r4, r4, #2
 800d8b8:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 800d8bc:	3534      	adds	r5, #52	; 0x34
 800d8be:	192a      	adds	r2, r5, r4
	rv = rv << 8 | ptr[0];
 800d8c0:	5d28      	ldrb	r0, [r5, r4]
	rv = rv << 8 | ptr[2];
 800d8c2:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 800d8c4:	7853      	ldrb	r3, [r2, #1]
 800d8c6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800d8ca:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800d8ce:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 800d8d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800d8d4:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d8d6:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800d8d8:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d8dc:	4299      	cmp	r1, r3
 800d8de:	d005      	beq.n	800d8ec <get_fat.isra.0+0xbc>
 800d8e0:	f7ff fed0 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800d8e4:	b110      	cbz	r0, 800d8ec <get_fat.isra.0+0xbc>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800d8e6:	f04f 30ff 	mov.w	r0, #4294967295
}
 800d8ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800d8ec:	0064      	lsls	r4, r4, #1
 800d8ee:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 800d8f2:	3534      	adds	r5, #52	; 0x34
 800d8f4:	192b      	adds	r3, r5, r4
	rv = rv << 8 | ptr[0];
 800d8f6:	5d28      	ldrb	r0, [r5, r4]
 800d8f8:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800d8fa:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
 800d8fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800d900:	f3c0 000b 	ubfx	r0, r0, #0, #12
}
 800d904:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d906:	bf00      	nop

0800d908 <dir_next.constprop.0>:
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800d908:	69c3      	ldr	r3, [r0, #28]
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
 800d90a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800d90e:	6945      	ldr	r5, [r0, #20]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800d910:	b37b      	cbz	r3, 800d972 <dir_next.constprop.0+0x6a>
 800d912:	3520      	adds	r5, #32
 800d914:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 800d918:	d22b      	bcs.n	800d972 <dir_next.constprop.0+0x6a>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800d91a:	f3c5 0708 	ubfx	r7, r5, #0, #9
	FATFS *fs = dp->obj.fs;
 800d91e:	6806      	ldr	r6, [r0, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800d920:	4604      	mov	r4, r0
 800d922:	b137      	cbz	r7, 800d932 <dir_next.constprop.0+0x2a>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800d924:	3634      	adds	r6, #52	; 0x34
 800d926:	443e      	add	r6, r7
 800d928:	6226      	str	r6, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 800d92a:	6165      	str	r5, [r4, #20]
	return FR_OK;
 800d92c:	2000      	movs	r0, #0
}
 800d92e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!dp->clust) {		/* Static table */
 800d932:	6981      	ldr	r1, [r0, #24]
		dp->sect++;				/* Next sector */
 800d934:	3301      	adds	r3, #1
 800d936:	61c3      	str	r3, [r0, #28]
		if (!dp->clust) {		/* Static table */
 800d938:	b1f1      	cbz	r1, 800d978 <dir_next.constprop.0+0x70>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800d93a:	8973      	ldrh	r3, [r6, #10]
 800d93c:	3b01      	subs	r3, #1
 800d93e:	ea13 2855 	ands.w	r8, r3, r5, lsr #9
 800d942:	d1ef      	bne.n	800d924 <dir_next.constprop.0+0x1c>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800d944:	4630      	mov	r0, r6
 800d946:	f7ff ff73 	bl	800d830 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800d94a:	2801      	cmp	r0, #1
 800d94c:	d91c      	bls.n	800d988 <dir_next.constprop.0+0x80>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800d94e:	1c43      	adds	r3, r0, #1
 800d950:	d01c      	beq.n	800d98c <dir_next.constprop.0+0x84>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800d952:	69b3      	ldr	r3, [r6, #24]
 800d954:	4298      	cmp	r0, r3
 800d956:	d213      	bcs.n	800d980 <dir_next.constprop.0+0x78>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800d958:	3b02      	subs	r3, #2
	clst -= 2;
 800d95a:	1e82      	subs	r2, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800d95c:	429a      	cmp	r2, r3
				dp->clust = clst;		/* Initialize data for new cluster */
 800d95e:	61a0      	str	r0, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800d960:	d204      	bcs.n	800d96c <dir_next.constprop.0+0x64>
	return clst * fs->csize + fs->database;
 800d962:	f8b6 800a 	ldrh.w	r8, [r6, #10]
 800d966:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800d968:	fb02 3808 	mla	r8, r2, r8, r3
				dp->sect = clust2sect(fs, clst);
 800d96c:	f8c4 801c 	str.w	r8, [r4, #28]
 800d970:	e7d8      	b.n	800d924 <dir_next.constprop.0+0x1c>
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800d972:	2004      	movs	r0, #4
}
 800d974:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800d978:	8933      	ldrh	r3, [r6, #8]
 800d97a:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 800d97e:	d8d1      	bhi.n	800d924 <dir_next.constprop.0+0x1c>
				dp->sect = 0; return FR_NO_FILE;
 800d980:	2300      	movs	r3, #0
 800d982:	61e3      	str	r3, [r4, #28]
 800d984:	2004      	movs	r0, #4
 800d986:	e7d2      	b.n	800d92e <dir_next.constprop.0+0x26>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800d988:	2002      	movs	r0, #2
 800d98a:	e7d0      	b.n	800d92e <dir_next.constprop.0+0x26>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800d98c:	2001      	movs	r0, #1
 800d98e:	e7ce      	b.n	800d92e <dir_next.constprop.0+0x26>

0800d990 <dir_read.constprop.0>:
FRESULT dir_read (
 800d990:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	while (dp->sect) {
 800d994:	69c6      	ldr	r6, [r0, #28]
	FATFS *fs = dp->obj.fs;
 800d996:	6807      	ldr	r7, [r0, #0]
FRESULT dir_read (
 800d998:	b083      	sub	sp, #12
 800d99a:	4604      	mov	r4, r0
	while (dp->sect) {
 800d99c:	2e00      	cmp	r6, #0
 800d99e:	d05c      	beq.n	800da5a <dir_read.constprop.0+0xca>
	BYTE ord = 0xFF, sum = 0xFF;
 800d9a0:	f04f 0aff 	mov.w	sl, #255	; 0xff
 800d9a4:	46d1      	mov	r9, sl
 800d9a6:	f107 0834 	add.w	r8, r7, #52	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 800d9aa:	6b3d      	ldr	r5, [r7, #48]	; 0x30
 800d9ac:	42b5      	cmp	r5, r6
 800d9ae:	d013      	beq.n	800d9d8 <dir_read.constprop.0+0x48>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800d9b0:	78fb      	ldrb	r3, [r7, #3]
 800d9b2:	2b00      	cmp	r3, #0
 800d9b4:	d158      	bne.n	800da68 <dir_read.constprop.0+0xd8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800d9b6:	7878      	ldrb	r0, [r7, #1]
 800d9b8:	2301      	movs	r3, #1
 800d9ba:	4632      	mov	r2, r6
 800d9bc:	4641      	mov	r1, r8
 800d9be:	f7ff fd43 	bl	800d448 <disk_read>
 800d9c2:	b140      	cbz	r0, 800d9d6 <dir_read.constprop.0+0x46>
			fs->winsect = sector;
 800d9c4:	f04f 33ff 	mov.w	r3, #4294967295
 800d9c8:	633b      	str	r3, [r7, #48]	; 0x30
				res = FR_DISK_ERR;
 800d9ca:	2001      	movs	r0, #1
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800d9cc:	2300      	movs	r3, #0
 800d9ce:	61e3      	str	r3, [r4, #28]
}
 800d9d0:	b003      	add	sp, #12
 800d9d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 800d9d6:	633e      	str	r6, [r7, #48]	; 0x30
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 800d9d8:	6a21      	ldr	r1, [r4, #32]
 800d9da:	780a      	ldrb	r2, [r1, #0]
		if (c == 0) {
 800d9dc:	2a00      	cmp	r2, #0
 800d9de:	d03c      	beq.n	800da5a <dir_read.constprop.0+0xca>
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800d9e0:	7acb      	ldrb	r3, [r1, #11]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800d9e2:	2ae5      	cmp	r2, #229	; 0xe5
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800d9e4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800d9e8:	71a3      	strb	r3, [r4, #6]
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800d9ea:	d005      	beq.n	800d9f8 <dir_read.constprop.0+0x68>
 800d9ec:	2a2e      	cmp	r2, #46	; 0x2e
 800d9ee:	d003      	beq.n	800d9f8 <dir_read.constprop.0+0x68>
 800d9f0:	f023 0020 	bic.w	r0, r3, #32
 800d9f4:	2808      	cmp	r0, #8
 800d9f6:	d159      	bne.n	800daac <dir_read.constprop.0+0x11c>
 800d9f8:	6965      	ldr	r5, [r4, #20]
				ord = 0xFF;
 800d9fa:	f04f 09ff 	mov.w	r9, #255	; 0xff
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800d9fe:	69e6      	ldr	r6, [r4, #28]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800da00:	3520      	adds	r5, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800da02:	b356      	cbz	r6, 800da5a <dir_read.constprop.0+0xca>
 800da04:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 800da08:	d227      	bcs.n	800da5a <dir_read.constprop.0+0xca>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800da0a:	f3c5 0208 	ubfx	r2, r5, #0, #9
	FATFS *fs = dp->obj.fs;
 800da0e:	6823      	ldr	r3, [r4, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800da10:	bb2a      	cbnz	r2, 800da5e <dir_read.constprop.0+0xce>
		if (!dp->clust) {		/* Static table */
 800da12:	69a1      	ldr	r1, [r4, #24]
		dp->sect++;				/* Next sector */
 800da14:	3601      	adds	r6, #1
 800da16:	61e6      	str	r6, [r4, #28]
		if (!dp->clust) {		/* Static table */
 800da18:	b961      	cbnz	r1, 800da34 <dir_read.constprop.0+0xa4>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800da1a:	891a      	ldrh	r2, [r3, #8]
 800da1c:	ebb2 1f55 	cmp.w	r2, r5, lsr #5
 800da20:	d91b      	bls.n	800da5a <dir_read.constprop.0+0xca>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800da22:	3334      	adds	r3, #52	; 0x34
 800da24:	6223      	str	r3, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 800da26:	6165      	str	r5, [r4, #20]
	while (dp->sect) {
 800da28:	2e00      	cmp	r6, #0
 800da2a:	d1be      	bne.n	800d9aa <dir_read.constprop.0+0x1a>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800da2c:	2000      	movs	r0, #0
}
 800da2e:	b003      	add	sp, #12
 800da30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800da34:	895a      	ldrh	r2, [r3, #10]
 800da36:	3a01      	subs	r2, #1
 800da38:	ea12 2b55 	ands.w	fp, r2, r5, lsr #9
 800da3c:	d1f1      	bne.n	800da22 <dir_read.constprop.0+0x92>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800da3e:	4618      	mov	r0, r3
 800da40:	9301      	str	r3, [sp, #4]
 800da42:	f7ff fef5 	bl	800d830 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800da46:	2801      	cmp	r0, #1
 800da48:	f240 80e9 	bls.w	800dc1e <dir_read.constprop.0+0x28e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800da4c:	1c43      	adds	r3, r0, #1
 800da4e:	d0bc      	beq.n	800d9ca <dir_read.constprop.0+0x3a>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800da50:	9b01      	ldr	r3, [sp, #4]
 800da52:	699a      	ldr	r2, [r3, #24]
 800da54:	4290      	cmp	r0, r2
 800da56:	f0c0 80d7 	bcc.w	800dc08 <dir_read.constprop.0+0x278>
	FRESULT res = FR_NO_FILE;
 800da5a:	2004      	movs	r0, #4
 800da5c:	e7b6      	b.n	800d9cc <dir_read.constprop.0+0x3c>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800da5e:	3334      	adds	r3, #52	; 0x34
 800da60:	441a      	add	r2, r3
 800da62:	6222      	str	r2, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 800da64:	6165      	str	r5, [r4, #20]
	while (dp->sect) {
 800da66:	e7a0      	b.n	800d9aa <dir_read.constprop.0+0x1a>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800da68:	7878      	ldrb	r0, [r7, #1]
 800da6a:	2301      	movs	r3, #1
 800da6c:	462a      	mov	r2, r5
 800da6e:	4641      	mov	r1, r8
 800da70:	f7ff fcf8 	bl	800d464 <disk_write>
 800da74:	2800      	cmp	r0, #0
 800da76:	d1a8      	bne.n	800d9ca <dir_read.constprop.0+0x3a>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800da78:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800da7a:	69fb      	ldr	r3, [r7, #28]
			fs->wflag = 0;
 800da7c:	70f8      	strb	r0, [r7, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800da7e:	1aaa      	subs	r2, r5, r2
 800da80:	429a      	cmp	r2, r3
 800da82:	d298      	bcs.n	800d9b6 <dir_read.constprop.0+0x26>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800da84:	f897 b002 	ldrb.w	fp, [r7, #2]
 800da88:	f1bb 0f01 	cmp.w	fp, #1
 800da8c:	d801      	bhi.n	800da92 <dir_read.constprop.0+0x102>
 800da8e:	e792      	b.n	800d9b6 <dir_read.constprop.0+0x26>
 800da90:	69fb      	ldr	r3, [r7, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 800da92:	7878      	ldrb	r0, [r7, #1]
					wsect += fs->fsize;
 800da94:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800da96:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 800da9a:	462a      	mov	r2, r5
 800da9c:	2301      	movs	r3, #1
 800da9e:	4641      	mov	r1, r8
 800daa0:	f7ff fce0 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800daa4:	f1bb 0f01 	cmp.w	fp, #1
 800daa8:	d1f2      	bne.n	800da90 <dir_read.constprop.0+0x100>
 800daaa:	e784      	b.n	800d9b6 <dir_read.constprop.0+0x26>
				if (a == AM_LFN) {			/* An LFN entry is found */
 800daac:	2b0f      	cmp	r3, #15
 800daae:	f040 8160 	bne.w	800dd72 <dir_read.constprop.0+0x3e2>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 800dab2:	0650      	lsls	r0, r2, #25
						dp->blk_ofs = dp->dptr;
 800dab4:	6965      	ldr	r5, [r4, #20]
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 800dab6:	f140 80a3 	bpl.w	800dc00 <dir_read.constprop.0+0x270>
						sum = dp->dir[LDIR_Chksum];
 800daba:	f891 a00d 	ldrb.w	sl, [r1, #13]
						dp->blk_ofs = dp->dptr;
 800dabe:	6325      	str	r5, [r4, #48]	; 0x30
						c &= (BYTE)~LLEF; ord = c;
 800dac0:	f002 09bf 	and.w	r9, r2, #191	; 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800dac4:	7b4b      	ldrb	r3, [r1, #13]
 800dac6:	4553      	cmp	r3, sl
 800dac8:	d197      	bne.n	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800daca:	7eca      	ldrb	r2, [r1, #27]
 800dacc:	7e8b      	ldrb	r3, [r1, #26]
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 800dace:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 800dad2:	d192      	bne.n	800d9fa <dir_read.constprop.0+0x6a>
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800dad4:	780b      	ldrb	r3, [r1, #0]
	rv = rv << 8 | ptr[0];
 800dad6:	788a      	ldrb	r2, [r1, #2]
 800dad8:	7848      	ldrb	r0, [r1, #1]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800dada:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800dade:	3b01      	subs	r3, #1
 800dae0:	eb03 0643 	add.w	r6, r3, r3, lsl #1
 800dae4:	eb03 0386 	add.w	r3, r3, r6, lsl #2
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dae8:	2bfe      	cmp	r3, #254	; 0xfe
	rv = rv << 8 | ptr[0];
 800daea:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800daee:	d884      	bhi.n	800d9fa <dir_read.constprop.0+0x6a>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800daf0:	f8d7 c00c 	ldr.w	ip, [r7, #12]
			lfnbuf[i++] = wc = uc;			/* Store it */
 800daf4:	f82c 0013 	strh.w	r0, [ip, r3, lsl #1]
	rv = rv << 8 | ptr[0];
 800daf8:	790a      	ldrb	r2, [r1, #4]
 800dafa:	78ce      	ldrb	r6, [r1, #3]
 800dafc:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800db00:	1c5a      	adds	r2, r3, #1
		if (wc) {
 800db02:	2800      	cmp	r0, #0
 800db04:	f040 8092 	bne.w	800dc2c <dir_read.constprop.0+0x29c>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db08:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db0c:	429e      	cmp	r6, r3
 800db0e:	f47f af74 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db12:	798b      	ldrb	r3, [r1, #6]
 800db14:	f891 e005 	ldrb.w	lr, [r1, #5]
 800db18:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db1c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db20:	459e      	cmp	lr, r3
 800db22:	f47f af6a 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db26:	7a0b      	ldrb	r3, [r1, #8]
 800db28:	79ce      	ldrb	r6, [r1, #7]
 800db2a:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db2e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db32:	429e      	cmp	r6, r3
 800db34:	f47f af61 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db38:	7a8b      	ldrb	r3, [r1, #10]
 800db3a:	f891 e009 	ldrb.w	lr, [r1, #9]
 800db3e:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db42:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db46:	459e      	cmp	lr, r3
 800db48:	f47f af57 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db4c:	7bcb      	ldrb	r3, [r1, #15]
 800db4e:	7b8e      	ldrb	r6, [r1, #14]
 800db50:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db54:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db58:	429e      	cmp	r6, r3
 800db5a:	f47f af4e 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db5e:	7c4b      	ldrb	r3, [r1, #17]
 800db60:	f891 e010 	ldrb.w	lr, [r1, #16]
 800db64:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db68:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db6c:	459e      	cmp	lr, r3
 800db6e:	f47f af44 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db72:	7ccb      	ldrb	r3, [r1, #19]
 800db74:	7c8e      	ldrb	r6, [r1, #18]
 800db76:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db7e:	429e      	cmp	r6, r3
 800db80:	f47f af3b 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db84:	7d4b      	ldrb	r3, [r1, #21]
 800db86:	f891 e014 	ldrb.w	lr, [r1, #20]
 800db8a:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800db8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db92:	459e      	cmp	lr, r3
 800db94:	f47f af31 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800db98:	7dcb      	ldrb	r3, [r1, #23]
 800db9a:	7d8e      	ldrb	r6, [r1, #22]
 800db9c:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800dba0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dba4:	429e      	cmp	r6, r3
 800dba6:	f47f af28 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800dbaa:	7e4b      	ldrb	r3, [r1, #25]
 800dbac:	f891 e018 	ldrb.w	lr, [r1, #24]
 800dbb0:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800dbb4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dbb8:	459e      	cmp	lr, r3
 800dbba:	f47f af1e 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800dbbe:	7f4b      	ldrb	r3, [r1, #29]
 800dbc0:	7f0e      	ldrb	r6, [r1, #28]
 800dbc2:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800dbc6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dbca:	429e      	cmp	r6, r3
 800dbcc:	f47f af15 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	rv = rv << 8 | ptr[0];
 800dbd0:	7fcb      	ldrb	r3, [r1, #31]
 800dbd2:	f891 e01e 	ldrb.w	lr, [r1, #30]
 800dbd6:	ea4e 2e03 	orr.w	lr, lr, r3, lsl #8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800dbda:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800dbde:	459e      	cmp	lr, r3
 800dbe0:	f47f af0b 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 800dbe4:	780b      	ldrb	r3, [r1, #0]
 800dbe6:	0659      	lsls	r1, r3, #25
 800dbe8:	d505      	bpl.n	800dbf6 <dir_read.constprop.0+0x266>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 800dbea:	2aff      	cmp	r2, #255	; 0xff
 800dbec:	f000 8111 	beq.w	800de12 <dir_read.constprop.0+0x482>
		lfnbuf[i] = 0;
 800dbf0:	2300      	movs	r3, #0
 800dbf2:	f82c 3012 	strh.w	r3, [ip, r2, lsl #1]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800dbf6:	f109 39ff 	add.w	r9, r9, #4294967295
 800dbfa:	fa5f f989 	uxtb.w	r9, r9
 800dbfe:	e6fe      	b.n	800d9fe <dir_read.constprop.0+0x6e>
 800dc00:	454a      	cmp	r2, r9
 800dc02:	f47f aefa 	bne.w	800d9fa <dir_read.constprop.0+0x6a>
 800dc06:	e75d      	b.n	800dac4 <dir_read.constprop.0+0x134>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800dc08:	3a02      	subs	r2, #2
	clst -= 2;
 800dc0a:	1e81      	subs	r1, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800dc0c:	4291      	cmp	r1, r2
				dp->clust = clst;		/* Initialize data for new cluster */
 800dc0e:	61a0      	str	r0, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800dc10:	d207      	bcs.n	800dc22 <dir_read.constprop.0+0x292>
	return clst * fs->csize + fs->database;
 800dc12:	895e      	ldrh	r6, [r3, #10]
 800dc14:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800dc16:	fb01 2606 	mla	r6, r1, r6, r2
				dp->sect = clust2sect(fs, clst);
 800dc1a:	61e6      	str	r6, [r4, #28]
 800dc1c:	e701      	b.n	800da22 <dir_read.constprop.0+0x92>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800dc1e:	2002      	movs	r0, #2
 800dc20:	e6d4      	b.n	800d9cc <dir_read.constprop.0+0x3c>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800dc22:	3334      	adds	r3, #52	; 0x34
				dp->sect = clust2sect(fs, clst);
 800dc24:	e9c4 b307 	strd	fp, r3, [r4, #28]
	dp->dptr = ofs;						/* Current entry */
 800dc28:	6165      	str	r5, [r4, #20]
	while (dp->sect) {
 800dc2a:	e6ff      	b.n	800da2c <dir_read.constprop.0+0x9c>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dc2c:	2aff      	cmp	r2, #255	; 0xff
 800dc2e:	f000 80f0 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc32:	f82c 6012 	strh.w	r6, [ip, r2, lsl #1]
	rv = rv << 8 | ptr[0];
 800dc36:	f891 b006 	ldrb.w	fp, [r1, #6]
 800dc3a:	f891 e005 	ldrb.w	lr, [r1, #5]
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc3e:	0050      	lsls	r0, r2, #1
	rv = rv << 8 | ptr[0];
 800dc40:	ea4e 2e0b 	orr.w	lr, lr, fp, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc44:	1c9a      	adds	r2, r3, #2
		if (wc) {
 800dc46:	2e00      	cmp	r6, #0
 800dc48:	f43f af68 	beq.w	800db1c <dir_read.constprop.0+0x18c>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dc4c:	2aff      	cmp	r2, #255	; 0xff
 800dc4e:	f000 80e0 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc52:	4460      	add	r0, ip
 800dc54:	1cda      	adds	r2, r3, #3
 800dc56:	f8a0 e002 	strh.w	lr, [r0, #2]
	rv = rv << 8 | ptr[0];
 800dc5a:	f891 b008 	ldrb.w	fp, [r1, #8]
 800dc5e:	79ce      	ldrb	r6, [r1, #7]
 800dc60:	ea46 260b 	orr.w	r6, r6, fp, lsl #8
		if (wc) {
 800dc64:	f1be 0f00 	cmp.w	lr, #0
 800dc68:	f43f af61 	beq.w	800db2e <dir_read.constprop.0+0x19e>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dc6c:	2aff      	cmp	r2, #255	; 0xff
 800dc6e:	f000 80d0 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc72:	8086      	strh	r6, [r0, #4]
	rv = rv << 8 | ptr[0];
 800dc74:	7a8a      	ldrb	r2, [r1, #10]
 800dc76:	f891 e009 	ldrb.w	lr, [r1, #9]
 800dc7a:	ea4e 2e02 	orr.w	lr, lr, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc7e:	1d1a      	adds	r2, r3, #4
		if (wc) {
 800dc80:	2e00      	cmp	r6, #0
 800dc82:	f43f af5e 	beq.w	800db42 <dir_read.constprop.0+0x1b2>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dc86:	2aff      	cmp	r2, #255	; 0xff
 800dc88:	f000 80c3 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc8c:	f8a0 e006 	strh.w	lr, [r0, #6]
	rv = rv << 8 | ptr[0];
 800dc90:	7bca      	ldrb	r2, [r1, #15]
 800dc92:	7b8e      	ldrb	r6, [r1, #14]
 800dc94:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dc98:	1d5a      	adds	r2, r3, #5
		if (wc) {
 800dc9a:	f1be 0f00 	cmp.w	lr, #0
 800dc9e:	f43f af59 	beq.w	800db54 <dir_read.constprop.0+0x1c4>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dca2:	2aff      	cmp	r2, #255	; 0xff
 800dca4:	f000 80b5 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dca8:	8106      	strh	r6, [r0, #8]
	rv = rv << 8 | ptr[0];
 800dcaa:	7c4a      	ldrb	r2, [r1, #17]
 800dcac:	f891 e010 	ldrb.w	lr, [r1, #16]
 800dcb0:	ea4e 2e02 	orr.w	lr, lr, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dcb4:	1d9a      	adds	r2, r3, #6
		if (wc) {
 800dcb6:	2e00      	cmp	r6, #0
 800dcb8:	f43f af56 	beq.w	800db68 <dir_read.constprop.0+0x1d8>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dcbc:	2aff      	cmp	r2, #255	; 0xff
 800dcbe:	f000 80a8 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dcc2:	f8a0 e00a 	strh.w	lr, [r0, #10]
	rv = rv << 8 | ptr[0];
 800dcc6:	7cca      	ldrb	r2, [r1, #19]
 800dcc8:	7c8e      	ldrb	r6, [r1, #18]
 800dcca:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dcce:	1dda      	adds	r2, r3, #7
		if (wc) {
 800dcd0:	f1be 0f00 	cmp.w	lr, #0
 800dcd4:	f43f af51 	beq.w	800db7a <dir_read.constprop.0+0x1ea>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dcd8:	2aff      	cmp	r2, #255	; 0xff
 800dcda:	f000 809a 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dcde:	8186      	strh	r6, [r0, #12]
	rv = rv << 8 | ptr[0];
 800dce0:	7d4a      	ldrb	r2, [r1, #21]
 800dce2:	f891 e014 	ldrb.w	lr, [r1, #20]
 800dce6:	ea4e 2e02 	orr.w	lr, lr, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dcea:	f103 0208 	add.w	r2, r3, #8
		if (wc) {
 800dcee:	2e00      	cmp	r6, #0
 800dcf0:	f43f af4d 	beq.w	800db8e <dir_read.constprop.0+0x1fe>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dcf4:	2aff      	cmp	r2, #255	; 0xff
 800dcf6:	f000 808c 	beq.w	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dcfa:	f8a0 e00e 	strh.w	lr, [r0, #14]
	rv = rv << 8 | ptr[0];
 800dcfe:	7dca      	ldrb	r2, [r1, #23]
 800dd00:	7d8e      	ldrb	r6, [r1, #22]
 800dd02:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd06:	f103 0209 	add.w	r2, r3, #9
		if (wc) {
 800dd0a:	f1be 0f00 	cmp.w	lr, #0
 800dd0e:	f43f af47 	beq.w	800dba0 <dir_read.constprop.0+0x210>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dd12:	2aff      	cmp	r2, #255	; 0xff
 800dd14:	f43f ae71 	beq.w	800d9fa <dir_read.constprop.0+0x6a>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd18:	8206      	strh	r6, [r0, #16]
	rv = rv << 8 | ptr[0];
 800dd1a:	7e4a      	ldrb	r2, [r1, #25]
 800dd1c:	f891 e018 	ldrb.w	lr, [r1, #24]
 800dd20:	ea4e 2e02 	orr.w	lr, lr, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd24:	f103 020a 	add.w	r2, r3, #10
		if (wc) {
 800dd28:	2e00      	cmp	r6, #0
 800dd2a:	f43f af43 	beq.w	800dbb4 <dir_read.constprop.0+0x224>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dd2e:	2aff      	cmp	r2, #255	; 0xff
 800dd30:	d06f      	beq.n	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd32:	f8a0 e012 	strh.w	lr, [r0, #18]
	rv = rv << 8 | ptr[0];
 800dd36:	7f4a      	ldrb	r2, [r1, #29]
 800dd38:	7f0e      	ldrb	r6, [r1, #28]
 800dd3a:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd3e:	f103 020b 	add.w	r2, r3, #11
		if (wc) {
 800dd42:	f1be 0f00 	cmp.w	lr, #0
 800dd46:	f43f af3e 	beq.w	800dbc6 <dir_read.constprop.0+0x236>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dd4a:	2aff      	cmp	r2, #255	; 0xff
 800dd4c:	d061      	beq.n	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd4e:	8286      	strh	r6, [r0, #20]
	rv = rv << 8 | ptr[0];
 800dd50:	7fca      	ldrb	r2, [r1, #31]
 800dd52:	f891 e01e 	ldrb.w	lr, [r1, #30]
 800dd56:	ea4e 2e02 	orr.w	lr, lr, r2, lsl #8
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd5a:	f103 020c 	add.w	r2, r3, #12
		if (wc) {
 800dd5e:	2e00      	cmp	r6, #0
 800dd60:	f43f af3b 	beq.w	800dbda <dir_read.constprop.0+0x24a>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 800dd64:	2aff      	cmp	r2, #255	; 0xff
 800dd66:	d054      	beq.n	800de12 <dir_read.constprop.0+0x482>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800dd68:	f103 020d 	add.w	r2, r3, #13
 800dd6c:	f8a0 e016 	strh.w	lr, [r0, #22]
 800dd70:	e738      	b.n	800dbe4 <dir_read.constprop.0+0x254>
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800dd72:	f1b9 0f00 	cmp.w	r9, #0
 800dd76:	d148      	bne.n	800de0a <dir_read.constprop.0+0x47a>
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800dd78:	780a      	ldrb	r2, [r1, #0]
 800dd7a:	7848      	ldrb	r0, [r1, #1]
 800dd7c:	01d3      	lsls	r3, r2, #7
 800dd7e:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 800dd82:	181a      	adds	r2, r3, r0
 800dd84:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800dd88:	7888      	ldrb	r0, [r1, #2]
 800dd8a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800dd8e:	fa50 f283 	uxtab	r2, r0, r3
 800dd92:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800dd96:	78c8      	ldrb	r0, [r1, #3]
 800dd98:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800dd9c:	fa50 f283 	uxtab	r2, r0, r3
 800dda0:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800dda4:	7908      	ldrb	r0, [r1, #4]
 800dda6:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800ddaa:	fa50 f283 	uxtab	r2, r0, r3
 800ddae:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800ddb2:	7948      	ldrb	r0, [r1, #5]
 800ddb4:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800ddb8:	fa50 f283 	uxtab	r2, r0, r3
 800ddbc:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800ddc0:	7988      	ldrb	r0, [r1, #6]
 800ddc2:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800ddc6:	fa50 f283 	uxtab	r2, r0, r3
 800ddca:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800ddce:	79c8      	ldrb	r0, [r1, #7]
 800ddd0:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800ddd4:	fa50 f283 	uxtab	r2, r0, r3
 800ddd8:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800dddc:	7a08      	ldrb	r0, [r1, #8]
 800ddde:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800dde2:	fa50 f283 	uxtab	r2, r0, r3
 800dde6:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800ddea:	7a48      	ldrb	r0, [r1, #9]
 800ddec:	7a89      	ldrb	r1, [r1, #10]
 800ddee:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800ddf2:	fa50 f283 	uxtab	r2, r0, r3
 800ddf6:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800ddfa:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800ddfe:	fa51 f383 	uxtab	r3, r1, r3
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 800de02:	b2db      	uxtb	r3, r3
 800de04:	4553      	cmp	r3, sl
 800de06:	f43f ae11 	beq.w	800da2c <dir_read.constprop.0+0x9c>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800de0a:	f04f 33ff 	mov.w	r3, #4294967295
 800de0e:	6323      	str	r3, [r4, #48]	; 0x30
 800de10:	e60c      	b.n	800da2c <dir_read.constprop.0+0x9c>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800de12:	4691      	mov	r9, r2
 800de14:	e5f3      	b.n	800d9fe <dir_read.constprop.0+0x6e>
 800de16:	bf00      	nop

0800de18 <sync_fs>:
{
 800de18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800de1a:	78c3      	ldrb	r3, [r0, #3]
{
 800de1c:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800de1e:	b95b      	cbnz	r3, 800de38 <sync_fs+0x20>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 800de20:	7823      	ldrb	r3, [r4, #0]
 800de22:	2b03      	cmp	r3, #3
 800de24:	d029      	beq.n	800de7a <sync_fs+0x62>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800de26:	2200      	movs	r2, #0
 800de28:	7860      	ldrb	r0, [r4, #1]
 800de2a:	4611      	mov	r1, r2
 800de2c:	f7ff fb28 	bl	800d480 <disk_ioctl>
			res = FR_DISK_ERR;
 800de30:	3800      	subs	r0, #0
 800de32:	bf18      	it	ne
 800de34:	2001      	movne	r0, #1
}
 800de36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
 800de38:	6b05      	ldr	r5, [r0, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800de3a:	7840      	ldrb	r0, [r0, #1]
 800de3c:	f104 0734 	add.w	r7, r4, #52	; 0x34
 800de40:	462a      	mov	r2, r5
 800de42:	4639      	mov	r1, r7
 800de44:	2301      	movs	r3, #1
 800de46:	f7ff fb0d 	bl	800d464 <disk_write>
 800de4a:	2800      	cmp	r0, #0
 800de4c:	d14f      	bne.n	800deee <sync_fs+0xd6>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800de4e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800de50:	69e3      	ldr	r3, [r4, #28]
			fs->wflag = 0;
 800de52:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800de54:	1aaa      	subs	r2, r5, r2
 800de56:	429a      	cmp	r2, r3
 800de58:	d2e2      	bcs.n	800de20 <sync_fs+0x8>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800de5a:	78a6      	ldrb	r6, [r4, #2]
 800de5c:	2e01      	cmp	r6, #1
 800de5e:	d801      	bhi.n	800de64 <sync_fs+0x4c>
 800de60:	e7de      	b.n	800de20 <sync_fs+0x8>
 800de62:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 800de64:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 800de66:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800de68:	3e01      	subs	r6, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 800de6a:	462a      	mov	r2, r5
 800de6c:	2301      	movs	r3, #1
 800de6e:	4639      	mov	r1, r7
 800de70:	f7ff faf8 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800de74:	2e01      	cmp	r6, #1
 800de76:	d1f4      	bne.n	800de62 <sync_fs+0x4a>
 800de78:	e7d2      	b.n	800de20 <sync_fs+0x8>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 800de7a:	7926      	ldrb	r6, [r4, #4]
 800de7c:	2e01      	cmp	r6, #1
 800de7e:	d1d2      	bne.n	800de26 <sync_fs+0xe>
			mem_set(fs->win, 0, SS(fs));
 800de80:	f104 0334 	add.w	r3, r4, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 800de84:	4618      	mov	r0, r3
 800de86:	f44f 7200 	mov.w	r2, #512	; 0x200
 800de8a:	2100      	movs	r1, #0
 800de8c:	f008 f880 	bl	8015f90 <memset>
 800de90:	4603      	mov	r3, r0
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 800de92:	e9d4 0504 	ldrd	r0, r5, [r4, #16]
			fs->winsect = fs->volbase + 1;
 800de96:	6a22      	ldr	r2, [r4, #32]
	*ptr++ = (BYTE)val; val >>= 8;
 800de98:	f884 521c 	strb.w	r5, [r4, #540]	; 0x21c
 800de9c:	0a2f      	lsrs	r7, r5, #8
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800de9e:	4619      	mov	r1, r3
 800dea0:	4633      	mov	r3, r6
	*ptr++ = (BYTE)val; val >>= 8;
 800dea2:	0c2e      	lsrs	r6, r5, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800dea4:	0e2d      	lsrs	r5, r5, #24
 800dea6:	f884 621e 	strb.w	r6, [r4, #542]	; 0x21e
	*ptr++ = (BYTE)val;
 800deaa:	f884 521f 	strb.w	r5, [r4, #543]	; 0x21f
	*ptr++ = (BYTE)val; val >>= 8;
 800deae:	0a06      	lsrs	r6, r0, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800deb0:	0c05      	lsrs	r5, r0, #16
	*ptr++ = (BYTE)val; val >>= 8;
 800deb2:	f884 0220 	strb.w	r0, [r4, #544]	; 0x220
	*ptr++ = (BYTE)val; val >>= 8;
 800deb6:	0e00      	lsrs	r0, r0, #24
			fs->winsect = fs->volbase + 1;
 800deb8:	3201      	adds	r2, #1
	*ptr++ = (BYTE)val; val >>= 8;
 800deba:	f884 721d 	strb.w	r7, [r4, #541]	; 0x21d
 800debe:	f884 6221 	strb.w	r6, [r4, #545]	; 0x221
	*ptr++ = (BYTE)val; val >>= 8;
 800dec2:	f884 5222 	strb.w	r5, [r4, #546]	; 0x222
	*ptr++ = (BYTE)val;
 800dec6:	f884 0223 	strb.w	r0, [r4, #547]	; 0x223
	*ptr++ = (BYTE)val; val >>= 8;
 800deca:	4d0a      	ldr	r5, [pc, #40]	; (800def4 <sync_fs+0xdc>)
 800decc:	480a      	ldr	r0, [pc, #40]	; (800def8 <sync_fs+0xe0>)
 800dece:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
 800ded2:	2755      	movs	r7, #85	; 0x55
	*ptr++ = (BYTE)val;
 800ded4:	26aa      	movs	r6, #170	; 0xaa
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800ded6:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
 800ded8:	6322      	str	r2, [r4, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 800deda:	f884 7232 	strb.w	r7, [r4, #562]	; 0x232
	*ptr++ = (BYTE)val;
 800dede:	f884 6233 	strb.w	r6, [r4, #563]	; 0x233
	*ptr++ = (BYTE)val; val >>= 8;
 800dee2:	6365      	str	r5, [r4, #52]	; 0x34
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800dee4:	f7ff fabe 	bl	800d464 <disk_write>
			fs->fsi_flag = 0;
 800dee8:	2300      	movs	r3, #0
 800deea:	7123      	strb	r3, [r4, #4]
 800deec:	e79b      	b.n	800de26 <sync_fs+0xe>
			res = FR_DISK_ERR;
 800deee:	2001      	movs	r0, #1
}
 800def0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800def2:	bf00      	nop
 800def4:	41615252 	.word	0x41615252
 800def8:	61417272 	.word	0x61417272

0800defc <create_chain>:
{
 800defc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FATFS *fs = obj->fs;
 800df00:	f8d0 8000 	ldr.w	r8, [r0]
{
 800df04:	4681      	mov	r9, r0
	if (clst == 0) {	/* Create a new chain */
 800df06:	460f      	mov	r7, r1
 800df08:	2900      	cmp	r1, #0
 800df0a:	f040 8098 	bne.w	800e03e <create_chain+0x142>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 800df0e:	f8d8 6010 	ldr.w	r6, [r8, #16]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800df12:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800df16:	b9c6      	cbnz	r6, 800df4a <create_chain+0x4e>
 800df18:	2601      	movs	r6, #1
		ncl = scl;	/* Start cluster */
 800df1a:	4634      	mov	r4, r6
			ncl++;							/* Next cluster */
 800df1c:	3401      	adds	r4, #1
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 800df1e:	429c      	cmp	r4, r3
 800df20:	d317      	bcc.n	800df52 <create_chain+0x56>
				if (ncl > scl) return 0;	/* No free cluster */
 800df22:	2e01      	cmp	r6, #1
 800df24:	f240 809b 	bls.w	800e05e <create_chain+0x162>
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 800df28:	f8d9 5000 	ldr.w	r5, [r9]
				ncl = 2;
 800df2c:	2402      	movs	r4, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800df2e:	69ab      	ldr	r3, [r5, #24]
 800df30:	42a3      	cmp	r3, r4
 800df32:	d906      	bls.n	800df42 <create_chain+0x46>
		switch (fs->fs_type) {
 800df34:	782b      	ldrb	r3, [r5, #0]
 800df36:	2b02      	cmp	r3, #2
 800df38:	d06c      	beq.n	800e014 <create_chain+0x118>
 800df3a:	2b03      	cmp	r3, #3
 800df3c:	d050      	beq.n	800dfe0 <create_chain+0xe4>
 800df3e:	2b01      	cmp	r3, #1
 800df40:	d00c      	beq.n	800df5c <create_chain+0x60>
 800df42:	2401      	movs	r4, #1
}
 800df44:	4620      	mov	r0, r4
 800df46:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800df4a:	42b3      	cmp	r3, r6
 800df4c:	bf98      	it	ls
 800df4e:	2601      	movls	r6, #1
 800df50:	e7e3      	b.n	800df1a <create_chain+0x1e>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800df52:	2c01      	cmp	r4, #1
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 800df54:	f8d9 5000 	ldr.w	r5, [r9]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800df58:	d9f3      	bls.n	800df42 <create_chain+0x46>
 800df5a:	e7e8      	b.n	800df2e <create_chain+0x32>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df5c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800df5e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 800df60:	eb04 0b54 	add.w	fp, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df64:	eb03 215b 	add.w	r1, r3, fp, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800df68:	4291      	cmp	r1, r2
 800df6a:	d005      	beq.n	800df78 <create_chain+0x7c>
 800df6c:	4628      	mov	r0, r5
 800df6e:	f7ff fb89 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df72:	bb80      	cbnz	r0, 800dfd6 <create_chain+0xda>
 800df74:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800df76:	6b2a      	ldr	r2, [r5, #48]	; 0x30
			wc = fs->win[bc++ % SS(fs)];
 800df78:	f3cb 0008 	ubfx	r0, fp, #0, #9
 800df7c:	f10b 0b01 	add.w	fp, fp, #1
 800df80:	4428      	add	r0, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df82:	eb03 215b 	add.w	r1, r3, fp, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800df86:	4291      	cmp	r1, r2
			wc = fs->win[bc++ % SS(fs)];
 800df88:	f890 a034 	ldrb.w	sl, [r0, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 800df8c:	d003      	beq.n	800df96 <create_chain+0x9a>
 800df8e:	4628      	mov	r0, r5
 800df90:	f7ff fb78 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800df94:	b9f8      	cbnz	r0, 800dfd6 <create_chain+0xda>
			wc |= fs->win[bc % SS(fs)] << 8;
 800df96:	f3cb 0b08 	ubfx	fp, fp, #0, #9
 800df9a:	445d      	add	r5, fp
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800df9c:	07e2      	lsls	r2, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800df9e:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
 800dfa2:	ea4a 2303 	orr.w	r3, sl, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800dfa6:	d55e      	bpl.n	800e066 <create_chain+0x16a>
 800dfa8:	091b      	lsrs	r3, r3, #4
			if (cs == 0) break;				/* Found a free cluster */
 800dfaa:	b133      	cbz	r3, 800dfba <create_chain+0xbe>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 800dfac:	2b01      	cmp	r3, #1
 800dfae:	d0c8      	beq.n	800df42 <create_chain+0x46>
			if (ncl == scl) return 0;		/* No free cluster */
 800dfb0:	42a6      	cmp	r6, r4
 800dfb2:	d054      	beq.n	800e05e <create_chain+0x162>
 800dfb4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800dfb8:	e7b0      	b.n	800df1c <create_chain+0x20>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800dfba:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800dfbe:	42a3      	cmp	r3, r4
 800dfc0:	d9bf      	bls.n	800df42 <create_chain+0x46>
 800dfc2:	f04f 32ff 	mov.w	r2, #4294967295
 800dfc6:	4621      	mov	r1, r4
 800dfc8:	4640      	mov	r0, r8
 800dfca:	f7ff fb95 	bl	800d6f8 <put_fat.part.0>
		if (res == FR_OK && clst != 0) {
 800dfce:	2800      	cmp	r0, #0
 800dfd0:	d04c      	beq.n	800e06c <create_chain+0x170>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 800dfd2:	2801      	cmp	r0, #1
 800dfd4:	d1b5      	bne.n	800df42 <create_chain+0x46>
 800dfd6:	f04f 34ff 	mov.w	r4, #4294967295
}
 800dfda:	4620      	mov	r0, r4
 800dfdc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800dfe0:	6a69      	ldr	r1, [r5, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800dfe2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800dfe4:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800dfe8:	4299      	cmp	r1, r3
 800dfea:	d004      	beq.n	800dff6 <create_chain+0xfa>
 800dfec:	4628      	mov	r0, r5
 800dfee:	f7ff fb49 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800dff2:	2800      	cmp	r0, #0
 800dff4:	d1ef      	bne.n	800dfd6 <create_chain+0xda>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800dff6:	00a3      	lsls	r3, r4, #2
 800dff8:	3534      	adds	r5, #52	; 0x34
 800dffa:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 800dffe:	18e9      	adds	r1, r5, r3
	rv = rv << 8 | ptr[0];
 800e000:	5ceb      	ldrb	r3, [r5, r3]
	rv = rv << 8 | ptr[2];
 800e002:	8848      	ldrh	r0, [r1, #2]
	rv = rv << 8 | ptr[1];
 800e004:	784a      	ldrb	r2, [r1, #1]
 800e006:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 800e00a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800e00e:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
			break;
 800e012:	e7ca      	b.n	800dfaa <create_chain+0xae>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e014:	6a69      	ldr	r1, [r5, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e016:	6b2b      	ldr	r3, [r5, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e018:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e01c:	4299      	cmp	r1, r3
 800e01e:	d004      	beq.n	800e02a <create_chain+0x12e>
 800e020:	4628      	mov	r0, r5
 800e022:	f7ff fb2f 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e026:	2800      	cmp	r0, #0
 800e028:	d1d5      	bne.n	800dfd6 <create_chain+0xda>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800e02a:	0063      	lsls	r3, r4, #1
 800e02c:	3534      	adds	r5, #52	; 0x34
 800e02e:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 800e032:	18ea      	adds	r2, r5, r3
	rv = rv << 8 | ptr[0];
 800e034:	5ceb      	ldrb	r3, [r5, r3]
 800e036:	7852      	ldrb	r2, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800e038:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			break;
 800e03c:	e7b5      	b.n	800dfaa <create_chain+0xae>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800e03e:	4640      	mov	r0, r8
 800e040:	f7ff fbf6 	bl	800d830 <get_fat.isra.0>
		if (cs < 2) return 1;				/* Invalid FAT value */
 800e044:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 800e046:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Invalid FAT value */
 800e048:	f67f af7b 	bls.w	800df42 <create_chain+0x46>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 800e04c:	1c41      	adds	r1, r0, #1
 800e04e:	d0c2      	beq.n	800dfd6 <create_chain+0xda>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800e050:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800e054:	4283      	cmp	r3, r0
 800e056:	f63f af75 	bhi.w	800df44 <create_chain+0x48>
 800e05a:	463e      	mov	r6, r7
 800e05c:	e75d      	b.n	800df1a <create_chain+0x1e>
				if (ncl > scl) return 0;	/* No free cluster */
 800e05e:	2400      	movs	r4, #0
}
 800e060:	4620      	mov	r0, r4
 800e062:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800e066:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800e06a:	e79e      	b.n	800dfaa <create_chain+0xae>
		if (res == FR_OK && clst != 0) {
 800e06c:	b177      	cbz	r7, 800e08c <create_chain+0x190>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800e06e:	2f01      	cmp	r7, #1
 800e070:	f67f af67 	bls.w	800df42 <create_chain+0x46>
 800e074:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800e078:	429f      	cmp	r7, r3
 800e07a:	f4bf af62 	bcs.w	800df42 <create_chain+0x46>
 800e07e:	4639      	mov	r1, r7
 800e080:	4622      	mov	r2, r4
 800e082:	4640      	mov	r0, r8
 800e084:	f7ff fb38 	bl	800d6f8 <put_fat.part.0>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 800e088:	2800      	cmp	r0, #0
 800e08a:	d1a2      	bne.n	800dfd2 <create_chain+0xd6>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800e08c:	e9d8 2305 	ldrd	r2, r3, [r8, #20]
 800e090:	3b02      	subs	r3, #2
 800e092:	429a      	cmp	r2, r3
		fs->last_clst = ncl;
 800e094:	f8c8 4010 	str.w	r4, [r8, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800e098:	d802      	bhi.n	800e0a0 <create_chain+0x1a4>
 800e09a:	3a01      	subs	r2, #1
 800e09c:	f8c8 2014 	str.w	r2, [r8, #20]
		fs->fsi_flag |= 1;
 800e0a0:	f898 3004 	ldrb.w	r3, [r8, #4]
 800e0a4:	f043 0301 	orr.w	r3, r3, #1
 800e0a8:	f888 3004 	strb.w	r3, [r8, #4]
 800e0ac:	e74a      	b.n	800df44 <create_chain+0x48>
 800e0ae:	bf00      	nop

0800e0b0 <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 800e0b0:	b570      	push	{r4, r5, r6, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800e0b2:	f04f 36ff 	mov.w	r6, #4294967295
 800e0b6:	2300      	movs	r3, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e0b8:	42b1      	cmp	r1, r6
{
 800e0ba:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800e0bc:	70c3      	strb	r3, [r0, #3]
 800e0be:	6306      	str	r6, [r0, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e0c0:	d00c      	beq.n	800e0dc <check_fs+0x2c>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800e0c2:	460d      	mov	r5, r1
 800e0c4:	460a      	mov	r2, r1
 800e0c6:	2301      	movs	r3, #1
 800e0c8:	f100 0134 	add.w	r1, r0, #52	; 0x34
 800e0cc:	7840      	ldrb	r0, [r0, #1]
 800e0ce:	f7ff f9bb 	bl	800d448 <disk_read>
 800e0d2:	b110      	cbz	r0, 800e0da <check_fs+0x2a>
			fs->winsect = sector;
 800e0d4:	6326      	str	r6, [r4, #48]	; 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 800e0d6:	2004      	movs	r0, #4
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
#endif
	return 2;
}
 800e0d8:	bd70      	pop	{r4, r5, r6, pc}
			fs->winsect = sector;
 800e0da:	6325      	str	r5, [r4, #48]	; 0x30
	rv = rv << 8 | ptr[0];
 800e0dc:	f894 1233 	ldrb.w	r1, [r4, #563]	; 0x233
 800e0e0:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800e0e4:	f64a 2255 	movw	r2, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 800e0e8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800e0ec:	4293      	cmp	r3, r2
 800e0ee:	d12a      	bne.n	800e146 <check_fs+0x96>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 800e0f0:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800e0f4:	2be9      	cmp	r3, #233	; 0xe9
 800e0f6:	d007      	beq.n	800e108 <check_fs+0x58>
 800e0f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800e0fa:	4a15      	ldr	r2, [pc, #84]	; (800e150 <check_fs+0xa0>)
 800e0fc:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 800e100:	4293      	cmp	r3, r2
 800e102:	d001      	beq.n	800e108 <check_fs+0x58>
	return 2;
 800e104:	2002      	movs	r0, #2
}
 800e106:	bd70      	pop	{r4, r5, r6, pc}
	rv = rv << 8 | ptr[2];
 800e108:	f8b4 006c 	ldrh.w	r0, [r4, #108]	; 0x6c
	rv = rv << 8 | ptr[1];
 800e10c:	f894 206b 	ldrb.w	r2, [r4, #107]	; 0x6b
	rv = rv << 8 | ptr[0];
 800e110:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 800e114:	490f      	ldr	r1, [pc, #60]	; (800e154 <check_fs+0xa4>)
	rv = rv << 8 | ptr[1];
 800e116:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 800e11a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 800e11e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800e122:	428b      	cmp	r3, r1
 800e124:	d011      	beq.n	800e14a <check_fs+0x9a>
	rv = rv << 8 | ptr[2];
 800e126:	f8b4 1088 	ldrh.w	r1, [r4, #136]	; 0x88
	rv = rv << 8 | ptr[1];
 800e12a:	f894 3087 	ldrb.w	r3, [r4, #135]	; 0x87
	rv = rv << 8 | ptr[0];
 800e12e:	f894 0086 	ldrb.w	r0, [r4, #134]	; 0x86
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800e132:	4a09      	ldr	r2, [pc, #36]	; (800e158 <check_fs+0xa8>)
	rv = rv << 8 | ptr[1];
 800e134:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800e138:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800e13c:	4290      	cmp	r0, r2
 800e13e:	bf14      	ite	ne
 800e140:	2002      	movne	r0, #2
 800e142:	2000      	moveq	r0, #0
}
 800e144:	bd70      	pop	{r4, r5, r6, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 800e146:	2003      	movs	r0, #3
}
 800e148:	bd70      	pop	{r4, r5, r6, pc}
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 800e14a:	2000      	movs	r0, #0
}
 800e14c:	bd70      	pop	{r4, r5, r6, pc}
 800e14e:	bf00      	nop
 800e150:	009000eb 	.word	0x009000eb
 800e154:	00544146 	.word	0x00544146
 800e158:	33544146 	.word	0x33544146

0800e15c <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
 800e15c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (*path) {	/* If the pointer is not a null */
 800e160:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 800e162:	2400      	movs	r4, #0
 800e164:	600c      	str	r4, [r1, #0]
	if (*path) {	/* If the pointer is not a null */
 800e166:	b173      	cbz	r3, 800e186 <find_volume+0x2a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800e168:	781e      	ldrb	r6, [r3, #0]
 800e16a:	2e1f      	cmp	r6, #31
 800e16c:	d913      	bls.n	800e196 <find_volume+0x3a>
 800e16e:	4634      	mov	r4, r6
 800e170:	461d      	mov	r5, r3
 800e172:	e003      	b.n	800e17c <find_volume+0x20>
 800e174:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800e178:	2c1f      	cmp	r4, #31
 800e17a:	d90c      	bls.n	800e196 <find_volume+0x3a>
 800e17c:	2c3a      	cmp	r4, #58	; 0x3a
 800e17e:	d1f9      	bne.n	800e174 <find_volume+0x18>
			i = *tp++ - '0';
 800e180:	3301      	adds	r3, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 800e182:	429d      	cmp	r5, r3
 800e184:	d003      	beq.n	800e18e <find_volume+0x32>
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 800e186:	250b      	movs	r5, #11
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
 800e188:	4628      	mov	r0, r5
 800e18a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800e18e:	2e30      	cmp	r6, #48	; 0x30
 800e190:	d1f9      	bne.n	800e186 <find_volume+0x2a>
					*path = ++tt;
 800e192:	3501      	adds	r5, #1
 800e194:	6005      	str	r5, [r0, #0]
	fs = FatFs[vol];					/* Get pointer to the file system object */
 800e196:	4ec0      	ldr	r6, [pc, #768]	; (800e498 <find_volume+0x33c>)
 800e198:	6834      	ldr	r4, [r6, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800e19a:	2c00      	cmp	r4, #0
 800e19c:	f000 8128 	beq.w	800e3f0 <find_volume+0x294>
	*rfs = fs;							/* Return pointer to the file system object */
 800e1a0:	600c      	str	r4, [r1, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 800e1a2:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800e1a4:	f002 05fe 	and.w	r5, r2, #254	; 0xfe
	if (fs->fs_type) {					/* If the volume has been mounted */
 800e1a8:	b17b      	cbz	r3, 800e1ca <find_volume+0x6e>
		stat = disk_status(fs->drv);
 800e1aa:	7860      	ldrb	r0, [r4, #1]
 800e1ac:	f7ff f932 	bl	800d414 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800e1b0:	07c1      	lsls	r1, r0, #31
 800e1b2:	d40a      	bmi.n	800e1ca <find_volume+0x6e>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 800e1b4:	2d00      	cmp	r5, #0
 800e1b6:	f000 810a 	beq.w	800e3ce <find_volume+0x272>
 800e1ba:	f010 0504 	ands.w	r5, r0, #4
 800e1be:	f000 8106 	beq.w	800e3ce <find_volume+0x272>
				return FR_WRITE_PROTECTED;
 800e1c2:	250a      	movs	r5, #10
}
 800e1c4:	4628      	mov	r0, r5
 800e1c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 800e1ca:	2000      	movs	r0, #0
 800e1cc:	8020      	strh	r0, [r4, #0]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 800e1ce:	f7ff f92b 	bl	800d428 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 800e1d2:	07c2      	lsls	r2, r0, #31
 800e1d4:	f100 80fe 	bmi.w	800e3d4 <find_volume+0x278>
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 800e1d8:	b10d      	cbz	r5, 800e1de <find_volume+0x82>
 800e1da:	0743      	lsls	r3, r0, #29
 800e1dc:	d4f1      	bmi.n	800e1c2 <find_volume+0x66>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 800e1de:	2100      	movs	r1, #0
 800e1e0:	4620      	mov	r0, r4
 800e1e2:	f7ff ff65 	bl	800e0b0 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 800e1e6:	2802      	cmp	r0, #2
 800e1e8:	f000 80ac 	beq.w	800e344 <find_volume+0x1e8>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800e1ec:	2804      	cmp	r0, #4
 800e1ee:	f000 80fd 	beq.w	800e3ec <find_volume+0x290>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800e1f2:	2801      	cmp	r0, #1
	bsect = 0;
 800e1f4:	bf98      	it	ls
 800e1f6:	2500      	movls	r5, #0
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800e1f8:	f200 80e8 	bhi.w	800e3cc <find_volume+0x270>
	rv = rv << 8 | ptr[0];
 800e1fc:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 800e200:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 800e204:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800e208:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800e20c:	f040 80de 	bne.w	800e3cc <find_volume+0x270>
	rv = rv << 8 | ptr[0];
 800e210:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
 800e214:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800e218:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 800e21c:	d109      	bne.n	800e232 <find_volume+0xd6>
	rv = rv << 8 | ptr[2];
 800e21e:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
	rv = rv << 8 | ptr[1];
 800e222:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
	rv = rv << 8 | ptr[0];
 800e226:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
	rv = rv << 8 | ptr[1];
 800e22a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800e22e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800e232:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
		fs->fsize = fasize;
 800e236:	61e3      	str	r3, [r4, #28]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800e238:	1e51      	subs	r1, r2, #1
 800e23a:	2901      	cmp	r1, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800e23c:	70a2      	strb	r2, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800e23e:	f200 80c5 	bhi.w	800e3cc <find_volume+0x270>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800e242:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
 800e246:	b2b9      	uxth	r1, r7
 800e248:	8161      	strh	r1, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800e24a:	2900      	cmp	r1, #0
 800e24c:	f000 80be 	beq.w	800e3cc <find_volume+0x270>
 800e250:	1e79      	subs	r1, r7, #1
 800e252:	4239      	tst	r1, r7
 800e254:	f040 80ba 	bne.w	800e3cc <find_volume+0x270>
	rv = rv << 8 | ptr[0];
 800e258:	f894 0046 	ldrb.w	r0, [r4, #70]	; 0x46
 800e25c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800e260:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 800e264:	468c      	mov	ip, r1
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800e266:	f01c 0f0f 	tst.w	ip, #15
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 800e26a:	8121      	strh	r1, [r4, #8]
	rv = rv << 8 | ptr[0];
 800e26c:	b209      	sxth	r1, r1
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 800e26e:	f040 80ad 	bne.w	800e3cc <find_volume+0x270>
	rv = rv << 8 | ptr[0];
 800e272:	f894 e048 	ldrb.w	lr, [r4, #72]	; 0x48
 800e276:	f894 0047 	ldrb.w	r0, [r4, #71]	; 0x47
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 800e27a:	ea50 200e 	orrs.w	r0, r0, lr, lsl #8
 800e27e:	d109      	bne.n	800e294 <find_volume+0x138>
	rv = rv << 8 | ptr[2];
 800e280:	f8b4 8056 	ldrh.w	r8, [r4, #86]	; 0x56
	rv = rv << 8 | ptr[1];
 800e284:	f894 0055 	ldrb.w	r0, [r4, #85]	; 0x55
	rv = rv << 8 | ptr[0];
 800e288:	f894 e054 	ldrb.w	lr, [r4, #84]	; 0x54
	rv = rv << 8 | ptr[1];
 800e28c:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
	rv = rv << 8 | ptr[0];
 800e290:	ea4e 2000 	orr.w	r0, lr, r0, lsl #8
	rv = rv << 8 | ptr[0];
 800e294:	f894 8043 	ldrb.w	r8, [r4, #67]	; 0x43
 800e298:	f894 e042 	ldrb.w	lr, [r4, #66]	; 0x42
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800e29c:	ea5e 2e08 	orrs.w	lr, lr, r8, lsl #8
 800e2a0:	f000 8094 	beq.w	800e3cc <find_volume+0x270>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800e2a4:	fb03 f202 	mul.w	r2, r3, r2
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800e2a8:	eb0e 181c 	add.w	r8, lr, ip, lsr #4
 800e2ac:	4490      	add	r8, r2
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 800e2ae:	4540      	cmp	r0, r8
 800e2b0:	f0c0 808c 	bcc.w	800e3cc <find_volume+0x270>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800e2b4:	eba0 0908 	sub.w	r9, r0, r8
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800e2b8:	45b9      	cmp	r9, r7
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800e2ba:	fbb9 f0f7 	udiv	r0, r9, r7
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800e2be:	f0c0 8085 	bcc.w	800e3cc <find_volume+0x270>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800e2c2:	f64f 77f5 	movw	r7, #65525	; 0xfff5
 800e2c6:	42b8      	cmp	r0, r7
 800e2c8:	f200 80a8 	bhi.w	800e41c <find_volume+0x2c0>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800e2cc:	f640 71f5 	movw	r1, #4085	; 0xff5
 800e2d0:	4288      	cmp	r0, r1
		fs->database = bsect + sysect;					/* Data start sector */
 800e2d2:	eb08 0705 	add.w	r7, r8, r5
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800e2d6:	f100 0002 	add.w	r0, r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800e2da:	eb0e 0105 	add.w	r1, lr, r5
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800e2de:	61a0      	str	r0, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800e2e0:	6261      	str	r1, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 800e2e2:	62e7      	str	r7, [r4, #44]	; 0x2c
		fs->volbase = bsect;							/* Volume start sector */
 800e2e4:	6225      	str	r5, [r4, #32]
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800e2e6:	f200 80cd 	bhi.w	800e484 <find_volume+0x328>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 800e2ea:	f1bc 0f00 	cmp.w	ip, #0
 800e2ee:	d06d      	beq.n	800e3cc <find_volume+0x270>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800e2f0:	440a      	add	r2, r1
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800e2f2:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 800e2f6:	f000 0001 	and.w	r0, r0, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800e2fa:	62a2      	str	r2, [r4, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800e2fc:	eb00 0251 	add.w	r2, r0, r1, lsr #1
 800e300:	2001      	movs	r0, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800e302:	f202 12ff 	addw	r2, r2, #511	; 0x1ff
 800e306:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
 800e30a:	d35f      	bcc.n	800e3cc <find_volume+0x270>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800e30c:	f04f 33ff 	mov.w	r3, #4294967295
 800e310:	e9c4 3304 	strd	r3, r3, [r4, #16]
		fs->fsi_flag = 0x80;
 800e314:	2280      	movs	r2, #128	; 0x80
 800e316:	7122      	strb	r2, [r4, #4]
	fs->id = ++Fsid;		/* File system mount ID */
 800e318:	88b3      	ldrh	r3, [r6, #4]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 800e31a:	4960      	ldr	r1, [pc, #384]	; (800e49c <find_volume+0x340>)
	fs->fs_type = fmt;		/* FAT sub-type */
 800e31c:	7020      	strb	r0, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 800e31e:	3301      	adds	r3, #1
 800e320:	b29b      	uxth	r3, r3
 800e322:	80b3      	strh	r3, [r6, #4]
 800e324:	80e3      	strh	r3, [r4, #6]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 800e326:	60e1      	str	r1, [r4, #12]
	for (i = 0; i < _FS_LOCK; i++) {
 800e328:	f501 7300 	add.w	r3, r1, #512	; 0x200
		if (Files[i].fs == fs) Files[i].fs = 0;
 800e32c:	2000      	movs	r0, #0
 800e32e:	f501 7150 	add.w	r1, r1, #832	; 0x340
 800e332:	681a      	ldr	r2, [r3, #0]
 800e334:	4294      	cmp	r4, r2
 800e336:	bf08      	it	eq
 800e338:	6018      	streq	r0, [r3, #0]
 800e33a:	3310      	adds	r3, #16
	for (i = 0; i < _FS_LOCK; i++) {
 800e33c:	4299      	cmp	r1, r3
 800e33e:	d1f8      	bne.n	800e332 <find_volume+0x1d6>
	return FR_OK;
 800e340:	2500      	movs	r5, #0
 800e342:	e044      	b.n	800e3ce <find_volume+0x272>
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800e344:	f894 11f6 	ldrb.w	r1, [r4, #502]	; 0x1f6
 800e348:	2900      	cmp	r1, #0
 800e34a:	d055      	beq.n	800e3f8 <find_volume+0x29c>
	rv = rv << 8 | ptr[2];
 800e34c:	f8b4 31fc 	ldrh.w	r3, [r4, #508]	; 0x1fc
	rv = rv << 8 | ptr[1];
 800e350:	f894 11fb 	ldrb.w	r1, [r4, #507]	; 0x1fb
	rv = rv << 8 | ptr[0];
 800e354:	f894 91fa 	ldrb.w	r9, [r4, #506]	; 0x1fa
	rv = rv << 8 | ptr[1];
 800e358:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
	rv = rv << 8 | ptr[0];
 800e35c:	ea49 2901 	orr.w	r9, r9, r1, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800e360:	f894 5206 	ldrb.w	r5, [r4, #518]	; 0x206
 800e364:	b14d      	cbz	r5, 800e37a <find_volume+0x21e>
	rv = rv << 8 | ptr[2];
 800e366:	f8b4 220c 	ldrh.w	r2, [r4, #524]	; 0x20c
	rv = rv << 8 | ptr[1];
 800e36a:	f894 320b 	ldrb.w	r3, [r4, #523]	; 0x20b
	rv = rv << 8 | ptr[0];
 800e36e:	f894 520a 	ldrb.w	r5, [r4, #522]	; 0x20a
	rv = rv << 8 | ptr[1];
 800e372:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
 800e376:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800e37a:	f894 3216 	ldrb.w	r3, [r4, #534]	; 0x216
 800e37e:	b3cb      	cbz	r3, 800e3f4 <find_volume+0x298>
	rv = rv << 8 | ptr[2];
 800e380:	f8b4 221c 	ldrh.w	r2, [r4, #540]	; 0x21c
	rv = rv << 8 | ptr[1];
 800e384:	f894 321b 	ldrb.w	r3, [r4, #539]	; 0x21b
	rv = rv << 8 | ptr[0];
 800e388:	f894 821a 	ldrb.w	r8, [r4, #538]	; 0x21a
	rv = rv << 8 | ptr[1];
 800e38c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
 800e390:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800e394:	f894 7226 	ldrb.w	r7, [r4, #550]	; 0x226
 800e398:	b14f      	cbz	r7, 800e3ae <find_volume+0x252>
	rv = rv << 8 | ptr[2];
 800e39a:	f8b4 222c 	ldrh.w	r2, [r4, #556]	; 0x22c
	rv = rv << 8 | ptr[1];
 800e39e:	f894 322b 	ldrb.w	r3, [r4, #555]	; 0x22b
	rv = rv << 8 | ptr[0];
 800e3a2:	f894 722a 	ldrb.w	r7, [r4, #554]	; 0x22a
	rv = rv << 8 | ptr[1];
 800e3a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
 800e3aa:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800e3ae:	f1b9 0f00 	cmp.w	r9, #0
 800e3b2:	d123      	bne.n	800e3fc <find_volume+0x2a0>
 800e3b4:	b135      	cbz	r5, 800e3c4 <find_volume+0x268>
 800e3b6:	4629      	mov	r1, r5
 800e3b8:	4620      	mov	r0, r4
 800e3ba:	f7ff fe79 	bl	800e0b0 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800e3be:	2801      	cmp	r0, #1
 800e3c0:	f67f af1c 	bls.w	800e1fc <find_volume+0xa0>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800e3c4:	f1b8 0f00 	cmp.w	r8, #0
 800e3c8:	d120      	bne.n	800e40c <find_volume+0x2b0>
 800e3ca:	b93f      	cbnz	r7, 800e3dc <find_volume+0x280>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800e3cc:	250d      	movs	r5, #13
}
 800e3ce:	4628      	mov	r0, r5
 800e3d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800e3d4:	2503      	movs	r5, #3
}
 800e3d6:	4628      	mov	r0, r5
 800e3d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800e3dc:	4639      	mov	r1, r7
 800e3de:	4620      	mov	r0, r4
 800e3e0:	f7ff fe66 	bl	800e0b0 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800e3e4:	2801      	cmp	r0, #1
 800e3e6:	d955      	bls.n	800e494 <find_volume+0x338>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800e3e8:	2804      	cmp	r0, #4
 800e3ea:	d1ef      	bne.n	800e3cc <find_volume+0x270>
 800e3ec:	2501      	movs	r5, #1
 800e3ee:	e7ee      	b.n	800e3ce <find_volume+0x272>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800e3f0:	250c      	movs	r5, #12
 800e3f2:	e7ec      	b.n	800e3ce <find_volume+0x272>
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800e3f4:	4698      	mov	r8, r3
 800e3f6:	e7cd      	b.n	800e394 <find_volume+0x238>
 800e3f8:	4689      	mov	r9, r1
 800e3fa:	e7b1      	b.n	800e360 <find_volume+0x204>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800e3fc:	4649      	mov	r1, r9
 800e3fe:	4620      	mov	r0, r4
 800e400:	f7ff fe56 	bl	800e0b0 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800e404:	2801      	cmp	r0, #1
 800e406:	d8d5      	bhi.n	800e3b4 <find_volume+0x258>
 800e408:	464d      	mov	r5, r9
 800e40a:	e6f7      	b.n	800e1fc <find_volume+0xa0>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 800e40c:	4641      	mov	r1, r8
 800e40e:	4620      	mov	r0, r4
 800e410:	f7ff fe4e 	bl	800e0b0 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 800e414:	2801      	cmp	r0, #1
 800e416:	d8d8      	bhi.n	800e3ca <find_volume+0x26e>
 800e418:	4645      	mov	r5, r8
 800e41a:	e6ef      	b.n	800e1fc <find_volume+0xa0>
	rv = rv << 8 | ptr[0];
 800e41c:	f894 705f 	ldrb.w	r7, [r4, #95]	; 0x5f
 800e420:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
		fs->volbase = bsect;							/* Volume start sector */
 800e424:	6225      	str	r5, [r4, #32]
	rv = rv << 8 | ptr[0];
 800e426:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800e42a:	4311      	orrs	r1, r2
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800e42c:	3002      	adds	r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800e42e:	eb0e 0205 	add.w	r2, lr, r5
		fs->database = bsect + sysect;					/* Data start sector */
 800e432:	eb08 0705 	add.w	r7, r8, r5
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800e436:	b209      	sxth	r1, r1
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800e438:	61a0      	str	r0, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800e43a:	6262      	str	r2, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 800e43c:	62e7      	str	r7, [r4, #44]	; 0x2c
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 800e43e:	2900      	cmp	r1, #0
 800e440:	d1c4      	bne.n	800e3cc <find_volume+0x270>
	rv = rv << 8 | ptr[2];
 800e442:	f8b4 2062 	ldrh.w	r2, [r4, #98]	; 0x62
	rv = rv << 8 | ptr[1];
 800e446:	f894 7061 	ldrb.w	r7, [r4, #97]	; 0x61
	rv = rv << 8 | ptr[0];
 800e44a:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800e44e:	0080      	lsls	r0, r0, #2
	rv = rv << 8 | ptr[1];
 800e450:	ea47 2702 	orr.w	r7, r7, r2, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800e454:	f200 12ff 	addw	r2, r0, #511	; 0x1ff
	rv = rv << 8 | ptr[0];
 800e458:	ea41 2107 	orr.w	r1, r1, r7, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800e45c:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800e460:	62a1      	str	r1, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800e462:	d3b3      	bcc.n	800e3cc <find_volume+0x270>
	rv = rv << 8 | ptr[0];
 800e464:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 800e468:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 800e46c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		fs->fsi_flag = 0x80;
 800e470:	2180      	movs	r1, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800e472:	f04f 32ff 	mov.w	r2, #4294967295
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800e476:	2b01      	cmp	r3, #1
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800e478:	e9c4 2204 	strd	r2, r2, [r4, #16]
		fs->fsi_flag = 0x80;
 800e47c:	7121      	strb	r1, [r4, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800e47e:	d00f      	beq.n	800e4a0 <find_volume+0x344>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800e480:	2003      	movs	r0, #3
 800e482:	e749      	b.n	800e318 <find_volume+0x1bc>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 800e484:	f1bc 0f00 	cmp.w	ip, #0
 800e488:	d0a0      	beq.n	800e3cc <find_volume+0x270>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800e48a:	440a      	add	r2, r1
 800e48c:	62a2      	str	r2, [r4, #40]	; 0x28
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800e48e:	0042      	lsls	r2, r0, #1
 800e490:	2002      	movs	r0, #2
 800e492:	e736      	b.n	800e302 <find_volume+0x1a6>
 800e494:	463d      	mov	r5, r7
 800e496:	e6b1      	b.n	800e1fc <find_volume+0xa0>
 800e498:	200018c0 	.word	0x200018c0
 800e49c:	200018c8 	.word	0x200018c8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e4a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
			&& move_window(fs, bsect + 1) == FR_OK)
 800e4a2:	1c69      	adds	r1, r5, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e4a4:	4299      	cmp	r1, r3
 800e4a6:	d004      	beq.n	800e4b2 <find_volume+0x356>
 800e4a8:	4620      	mov	r0, r4
 800e4aa:	f7ff f8eb 	bl	800d684 <move_window.part.0>
			&& move_window(fs, bsect + 1) == FR_OK)
 800e4ae:	2800      	cmp	r0, #0
 800e4b0:	d1e6      	bne.n	800e480 <find_volume+0x324>
	rv = rv << 8 | ptr[0];
 800e4b2:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
 800e4b6:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
 800e4ba:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800e4be:	f64a 2255 	movw	r2, #43605	; 0xaa55
			fs->fsi_flag = 0;
 800e4c2:	2100      	movs	r1, #0
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800e4c4:	4293      	cmp	r3, r2
			fs->fsi_flag = 0;
 800e4c6:	7121      	strb	r1, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800e4c8:	d1da      	bne.n	800e480 <find_volume+0x324>
	rv = rv << 8 | ptr[2];
 800e4ca:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
	rv = rv << 8 | ptr[1];
 800e4cc:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
	rv = rv << 8 | ptr[0];
 800e4d0:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800e4d4:	4917      	ldr	r1, [pc, #92]	; (800e534 <find_volume+0x3d8>)
	rv = rv << 8 | ptr[1];
 800e4d6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 800e4da:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800e4de:	428b      	cmp	r3, r1
 800e4e0:	d1ce      	bne.n	800e480 <find_volume+0x324>
	rv = rv << 8 | ptr[2];
 800e4e2:	f8b4 021a 	ldrh.w	r0, [r4, #538]	; 0x21a
	rv = rv << 8 | ptr[1];
 800e4e6:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
	rv = rv << 8 | ptr[0];
 800e4ea:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 800e4ee:	f101 51ff 	add.w	r1, r1, #534773760	; 0x1fe00000
 800e4f2:	f501 5100 	add.w	r1, r1, #8192	; 0x2000
	rv = rv << 8 | ptr[1];
 800e4f6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 800e4fa:	3120      	adds	r1, #32
	rv = rv << 8 | ptr[0];
 800e4fc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 800e500:	428b      	cmp	r3, r1
 800e502:	d1bd      	bne.n	800e480 <find_volume+0x324>
	rv = rv << 8 | ptr[1];
 800e504:	f894 3221 	ldrb.w	r3, [r4, #545]	; 0x221
	rv = rv << 8 | ptr[2];
 800e508:	f8b4 1222 	ldrh.w	r1, [r4, #546]	; 0x222
 800e50c:	f8b4 521e 	ldrh.w	r5, [r4, #542]	; 0x21e
	rv = rv << 8 | ptr[1];
 800e510:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
	rv = rv << 8 | ptr[0];
 800e514:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
	rv = rv << 8 | ptr[1];
 800e518:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800e51c:	f894 3220 	ldrb.w	r3, [r4, #544]	; 0x220
	rv = rv << 8 | ptr[1];
 800e520:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
	rv = rv << 8 | ptr[0];
 800e524:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 800e528:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800e52c:	e9c4 3204 	strd	r3, r2, [r4, #16]
 800e530:	e7a6      	b.n	800e480 <find_volume+0x324>
 800e532:	bf00      	nop
 800e534:	41615252 	.word	0x41615252

0800e538 <dir_sdi>:
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800e538:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800e53c:	d274      	bcs.n	800e628 <dir_sdi+0xf0>
 800e53e:	06ca      	lsls	r2, r1, #27
{
 800e540:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e544:	460c      	mov	r4, r1
	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800e546:	d151      	bne.n	800e5ec <dir_sdi+0xb4>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800e548:	6885      	ldr	r5, [r0, #8]
	FATFS *fs = dp->obj.fs;
 800e54a:	f8d0 8000 	ldr.w	r8, [r0]
	dp->dptr = ofs;				/* Set current offset */
 800e54e:	6141      	str	r1, [r0, #20]
 800e550:	4607      	mov	r7, r0
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800e552:	2d00      	cmp	r5, #0
 800e554:	d04d      	beq.n	800e5f2 <dir_sdi+0xba>
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800e556:	f8b8 300a 	ldrh.w	r3, [r8, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 800e55a:	ebb4 2f43 	cmp.w	r4, r3, lsl #9
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800e55e:	ea4f 2943 	mov.w	r9, r3, lsl #9
		while (ofs >= csz) {				/* Follow cluster chain */
 800e562:	f0c0 8099 	bcc.w	800e698 <dir_sdi+0x160>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800e566:	2d01      	cmp	r5, #1
 800e568:	d940      	bls.n	800e5ec <dir_sdi+0xb4>
 800e56a:	4646      	mov	r6, r8
 800e56c:	e03b      	b.n	800e5e6 <dir_sdi+0xae>
		switch (fs->fs_type) {
 800e56e:	7833      	ldrb	r3, [r6, #0]
 800e570:	2b02      	cmp	r3, #2
 800e572:	d07a      	beq.n	800e66a <dir_sdi+0x132>
 800e574:	2b03      	cmp	r3, #3
 800e576:	d05f      	beq.n	800e638 <dir_sdi+0x100>
 800e578:	2b01      	cmp	r3, #1
 800e57a:	d137      	bne.n	800e5ec <dir_sdi+0xb4>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e57c:	6a73      	ldr	r3, [r6, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e57e:	6b32      	ldr	r2, [r6, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 800e580:	eb05 0a55 	add.w	sl, r5, r5, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e584:	eb03 215a 	add.w	r1, r3, sl, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e588:	4291      	cmp	r1, r2
 800e58a:	d006      	beq.n	800e59a <dir_sdi+0x62>
 800e58c:	4630      	mov	r0, r6
 800e58e:	f7ff f879 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e592:	2800      	cmp	r0, #0
 800e594:	d17d      	bne.n	800e692 <dir_sdi+0x15a>
 800e596:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800e598:	6b32      	ldr	r2, [r6, #48]	; 0x30
			wc = fs->win[bc++ % SS(fs)];
 800e59a:	f3ca 0008 	ubfx	r0, sl, #0, #9
 800e59e:	f10a 0a01 	add.w	sl, sl, #1
 800e5a2:	4430      	add	r0, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e5a4:	eb03 215a 	add.w	r1, r3, sl, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e5a8:	4291      	cmp	r1, r2
			wc = fs->win[bc++ % SS(fs)];
 800e5aa:	f890 b034 	ldrb.w	fp, [r0, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e5ae:	d004      	beq.n	800e5ba <dir_sdi+0x82>
 800e5b0:	4630      	mov	r0, r6
 800e5b2:	f7ff f867 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800e5b6:	2800      	cmp	r0, #0
 800e5b8:	d16b      	bne.n	800e692 <dir_sdi+0x15a>
			wc |= fs->win[bc % SS(fs)] << 8;
 800e5ba:	f3ca 0a08 	ubfx	sl, sl, #0, #9
 800e5be:	4456      	add	r6, sl
 800e5c0:	f896 3034 	ldrb.w	r3, [r6, #52]	; 0x34
 800e5c4:	ea4b 2b03 	orr.w	fp, fp, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800e5c8:	07eb      	lsls	r3, r5, #31
 800e5ca:	d573      	bpl.n	800e6b4 <dir_sdi+0x17c>
 800e5cc:	ea4f 151b 	mov.w	r5, fp, lsr #4
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800e5d0:	2d01      	cmp	r5, #1
 800e5d2:	d90b      	bls.n	800e5ec <dir_sdi+0xb4>
 800e5d4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800e5d8:	42ab      	cmp	r3, r5
 800e5da:	d907      	bls.n	800e5ec <dir_sdi+0xb4>
			ofs -= csz;
 800e5dc:	eba4 0409 	sub.w	r4, r4, r9
		while (ofs >= csz) {				/* Follow cluster chain */
 800e5e0:	45a1      	cmp	r9, r4
 800e5e2:	d85b      	bhi.n	800e69c <dir_sdi+0x164>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800e5e4:	683e      	ldr	r6, [r7, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800e5e6:	69b3      	ldr	r3, [r6, #24]
 800e5e8:	42ab      	cmp	r3, r5
 800e5ea:	d8c0      	bhi.n	800e56e <dir_sdi+0x36>
		switch (fs->fs_type) {
 800e5ec:	2002      	movs	r0, #2
}
 800e5ee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800e5f2:	f898 3000 	ldrb.w	r3, [r8]
 800e5f6:	2b02      	cmp	r3, #2
 800e5f8:	d818      	bhi.n	800e62c <dir_sdi+0xf4>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 800e5fa:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 800e5fe:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
 800e602:	d9f3      	bls.n	800e5ec <dir_sdi+0xb4>
		dp->sect = fs->dirbase;
 800e604:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
 800e608:	61f9      	str	r1, [r7, #28]
	dp->clust = clst;					/* Current cluster# */
 800e60a:	61bd      	str	r5, [r7, #24]
	if (!dp->sect) return FR_INT_ERR;
 800e60c:	2900      	cmp	r1, #0
 800e60e:	d0ed      	beq.n	800e5ec <dir_sdi+0xb4>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800e610:	f108 0834 	add.w	r8, r8, #52	; 0x34
 800e614:	f3c4 0308 	ubfx	r3, r4, #0, #9
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800e618:	eb01 2154 	add.w	r1, r1, r4, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800e61c:	4443      	add	r3, r8
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800e61e:	e9c7 1307 	strd	r1, r3, [r7, #28]
	return FR_OK;
 800e622:	2000      	movs	r0, #0
}
 800e624:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_INT_ERR;
 800e628:	2002      	movs	r0, #2
}
 800e62a:	4770      	bx	lr
		clst = fs->dirbase;
 800e62c:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 800e630:	2b00      	cmp	r3, #0
 800e632:	d0e2      	beq.n	800e5fa <dir_sdi+0xc2>
 800e634:	461d      	mov	r5, r3
 800e636:	e78e      	b.n	800e556 <dir_sdi+0x1e>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e638:	6a71      	ldr	r1, [r6, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e63a:	6b33      	ldr	r3, [r6, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e63c:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e640:	4299      	cmp	r1, r3
 800e642:	d003      	beq.n	800e64c <dir_sdi+0x114>
 800e644:	4630      	mov	r0, r6
 800e646:	f7ff f81d 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800e64a:	bb10      	cbnz	r0, 800e692 <dir_sdi+0x15a>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800e64c:	00ad      	lsls	r5, r5, #2
 800e64e:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 800e652:	3634      	adds	r6, #52	; 0x34
 800e654:	1972      	adds	r2, r6, r5
	rv = rv << 8 | ptr[0];
 800e656:	5d75      	ldrb	r5, [r6, r5]
	rv = rv << 8 | ptr[2];
 800e658:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 800e65a:	7853      	ldrb	r3, [r2, #1]
 800e65c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800e660:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800e664:	f025 4570 	bic.w	r5, r5, #4026531840	; 0xf0000000
			break;
 800e668:	e7b2      	b.n	800e5d0 <dir_sdi+0x98>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e66a:	6a71      	ldr	r1, [r6, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e66c:	6b33      	ldr	r3, [r6, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e66e:	eb01 2115 	add.w	r1, r1, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e672:	4299      	cmp	r1, r3
 800e674:	d003      	beq.n	800e67e <dir_sdi+0x146>
 800e676:	4630      	mov	r0, r6
 800e678:	f7ff f804 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800e67c:	b948      	cbnz	r0, 800e692 <dir_sdi+0x15a>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800e67e:	006d      	lsls	r5, r5, #1
 800e680:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 800e684:	3634      	adds	r6, #52	; 0x34
 800e686:	1973      	adds	r3, r6, r5
	rv = rv << 8 | ptr[0];
 800e688:	5d75      	ldrb	r5, [r6, r5]
 800e68a:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800e68c:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
			break;
 800e690:	e79e      	b.n	800e5d0 <dir_sdi+0x98>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800e692:	2001      	movs	r0, #1
}
 800e694:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e698:	f8d8 3018 	ldr.w	r3, [r8, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e69c:	3b02      	subs	r3, #2
	clst -= 2;
 800e69e:	1eaa      	subs	r2, r5, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e6a0:	429a      	cmp	r2, r3
 800e6a2:	d20a      	bcs.n	800e6ba <dir_sdi+0x182>
	return clst * fs->csize + fs->database;
 800e6a4:	f8b8 100a 	ldrh.w	r1, [r8, #10]
 800e6a8:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 800e6ac:	fb02 3101 	mla	r1, r2, r1, r3
		dp->sect = clust2sect(fs, clst);
 800e6b0:	61f9      	str	r1, [r7, #28]
 800e6b2:	e7aa      	b.n	800e60a <dir_sdi+0xd2>
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800e6b4:	f3cb 050b 	ubfx	r5, fp, #0, #12
 800e6b8:	e78a      	b.n	800e5d0 <dir_sdi+0x98>
		dp->sect = clust2sect(fs, clst);
 800e6ba:	2300      	movs	r3, #0
 800e6bc:	e9c7 5306 	strd	r5, r3, [r7, #24]
	if (!dp->sect) return FR_INT_ERR;
 800e6c0:	e794      	b.n	800e5ec <dir_sdi+0xb4>
 800e6c2:	bf00      	nop

0800e6c4 <dir_find>:
{
 800e6c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800e6c8:	2100      	movs	r1, #0
{
 800e6ca:	b085      	sub	sp, #20
	FATFS *fs = dp->obj.fs;
 800e6cc:	6806      	ldr	r6, [r0, #0]
{
 800e6ce:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800e6d0:	f7ff ff32 	bl	800e538 <dir_sdi>
	if (res != FR_OK) return res;
 800e6d4:	4681      	mov	r9, r0
 800e6d6:	b9e0      	cbnz	r0, 800e712 <dir_find+0x4e>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800e6d8:	f04f 33ff 	mov.w	r3, #4294967295
 800e6dc:	f04f 08ff 	mov.w	r8, #255	; 0xff
 800e6e0:	69e7      	ldr	r7, [r4, #28]
 800e6e2:	6323      	str	r3, [r4, #48]	; 0x30
 800e6e4:	46c1      	mov	r9, r8
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800e6e6:	f64f 7bff 	movw	fp, #65535	; 0xffff
	if (sector != fs->winsect) {	/* Window offset changed? */
 800e6ea:	6b35      	ldr	r5, [r6, #48]	; 0x30
 800e6ec:	42bd      	cmp	r5, r7
 800e6ee:	d015      	beq.n	800e71c <dir_find+0x58>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800e6f0:	78f3      	ldrb	r3, [r6, #3]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800e6f2:	f106 0134 	add.w	r1, r6, #52	; 0x34
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800e6f6:	2b00      	cmp	r3, #0
 800e6f8:	f040 809b 	bne.w	800e832 <dir_find+0x16e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800e6fc:	7870      	ldrb	r0, [r6, #1]
 800e6fe:	2301      	movs	r3, #1
 800e700:	463a      	mov	r2, r7
 800e702:	f7fe fea1 	bl	800d448 <disk_read>
 800e706:	b140      	cbz	r0, 800e71a <dir_find+0x56>
			fs->winsect = sector;
 800e708:	f04f 33ff 	mov.w	r3, #4294967295
 800e70c:	6333      	str	r3, [r6, #48]	; 0x30
				res = FR_DISK_ERR;
 800e70e:	f04f 0901 	mov.w	r9, #1
}
 800e712:	4648      	mov	r0, r9
 800e714:	b005      	add	sp, #20
 800e716:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fs->winsect = sector;
 800e71a:	6337      	str	r7, [r6, #48]	; 0x30
		c = dp->dir[DIR_Name];
 800e71c:	6a25      	ldr	r5, [r4, #32]
 800e71e:	782f      	ldrb	r7, [r5, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800e720:	2f00      	cmp	r7, #0
 800e722:	d03d      	beq.n	800e7a0 <dir_find+0xdc>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800e724:	7aea      	ldrb	r2, [r5, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800e726:	2fe5      	cmp	r7, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800e728:	f002 033f 	and.w	r3, r2, #63	; 0x3f
 800e72c:	71a3      	strb	r3, [r4, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800e72e:	d004      	beq.n	800e73a <dir_find+0x76>
 800e730:	0712      	lsls	r2, r2, #28
 800e732:	d53b      	bpl.n	800e7ac <dir_find+0xe8>
 800e734:	2b0f      	cmp	r3, #15
 800e736:	f000 80a6 	beq.w	800e886 <dir_find+0x1c2>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800e73a:	f04f 33ff 	mov.w	r3, #4294967295
 800e73e:	6323      	str	r3, [r4, #48]	; 0x30
 800e740:	f04f 09ff 	mov.w	r9, #255	; 0xff
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800e744:	6965      	ldr	r5, [r4, #20]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e746:	69e7      	ldr	r7, [r4, #28]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800e748:	3520      	adds	r5, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800e74a:	b34f      	cbz	r7, 800e7a0 <dir_find+0xdc>
 800e74c:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 800e750:	d226      	bcs.n	800e7a0 <dir_find+0xdc>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800e752:	f3c5 0208 	ubfx	r2, r5, #0, #9
	FATFS *fs = dp->obj.fs;
 800e756:	6823      	ldr	r3, [r4, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800e758:	b93a      	cbnz	r2, 800e76a <dir_find+0xa6>
		if (!dp->clust) {		/* Static table */
 800e75a:	69a1      	ldr	r1, [r4, #24]
		dp->sect++;				/* Next sector */
 800e75c:	3701      	adds	r7, #1
 800e75e:	61e7      	str	r7, [r4, #28]
		if (!dp->clust) {		/* Static table */
 800e760:	b941      	cbnz	r1, 800e774 <dir_find+0xb0>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800e762:	8919      	ldrh	r1, [r3, #8]
 800e764:	ebb1 1f55 	cmp.w	r1, r5, lsr #5
 800e768:	d918      	bls.n	800e79c <dir_find+0xd8>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800e76a:	3334      	adds	r3, #52	; 0x34
 800e76c:	4413      	add	r3, r2
 800e76e:	6223      	str	r3, [r4, #32]
	dp->dptr = ofs;						/* Current entry */
 800e770:	6165      	str	r5, [r4, #20]
	} while (res == FR_OK);
 800e772:	e7ba      	b.n	800e6ea <dir_find+0x26>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800e774:	8958      	ldrh	r0, [r3, #10]
 800e776:	3801      	subs	r0, #1
 800e778:	ea10 2055 	ands.w	r0, r0, r5, lsr #9
 800e77c:	d1f5      	bne.n	800e76a <dir_find+0xa6>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800e77e:	4618      	mov	r0, r3
 800e780:	9201      	str	r2, [sp, #4]
 800e782:	9300      	str	r3, [sp, #0]
 800e784:	f7ff f854 	bl	800d830 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800e788:	2801      	cmp	r0, #1
 800e78a:	f240 8129 	bls.w	800e9e0 <dir_find+0x31c>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800e78e:	1c43      	adds	r3, r0, #1
 800e790:	d0bd      	beq.n	800e70e <dir_find+0x4a>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800e792:	9b00      	ldr	r3, [sp, #0]
 800e794:	6999      	ldr	r1, [r3, #24]
 800e796:	4288      	cmp	r0, r1
 800e798:	f0c0 8114 	bcc.w	800e9c4 <dir_find+0x300>
				dp->sect = 0; return FR_NO_FILE;
 800e79c:	2300      	movs	r3, #0
 800e79e:	61e3      	str	r3, [r4, #28]
 800e7a0:	f04f 0904 	mov.w	r9, #4
}
 800e7a4:	4648      	mov	r0, r9
 800e7a6:	b005      	add	sp, #20
 800e7a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (a == AM_LFN) {			/* An LFN entry is found */
 800e7ac:	2b0f      	cmp	r3, #15
 800e7ae:	d06a      	beq.n	800e886 <dir_find+0x1c2>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800e7b0:	f1b9 0f00 	cmp.w	r9, #0
 800e7b4:	f000 80bc 	beq.w	800e930 <dir_find+0x26c>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800e7b8:	f894 902f 	ldrb.w	r9, [r4, #47]	; 0x2f
 800e7bc:	f019 0901 	ands.w	r9, r9, #1
 800e7c0:	d1bb      	bne.n	800e73a <dir_find+0x76>
	} while (--cnt && r == 0);
 800e7c2:	782a      	ldrb	r2, [r5, #0]
 800e7c4:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 800e7c8:	429a      	cmp	r2, r3
 800e7ca:	d1b6      	bne.n	800e73a <dir_find+0x76>
 800e7cc:	f894 2025 	ldrb.w	r2, [r4, #37]	; 0x25
 800e7d0:	786b      	ldrb	r3, [r5, #1]
 800e7d2:	429a      	cmp	r2, r3
 800e7d4:	d1b1      	bne.n	800e73a <dir_find+0x76>
 800e7d6:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
 800e7da:	78ab      	ldrb	r3, [r5, #2]
 800e7dc:	429a      	cmp	r2, r3
 800e7de:	d1ac      	bne.n	800e73a <dir_find+0x76>
 800e7e0:	78ea      	ldrb	r2, [r5, #3]
 800e7e2:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
 800e7e6:	429a      	cmp	r2, r3
 800e7e8:	d1a7      	bne.n	800e73a <dir_find+0x76>
 800e7ea:	792a      	ldrb	r2, [r5, #4]
 800e7ec:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800e7f0:	429a      	cmp	r2, r3
 800e7f2:	d1a2      	bne.n	800e73a <dir_find+0x76>
 800e7f4:	796a      	ldrb	r2, [r5, #5]
 800e7f6:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 800e7fa:	429a      	cmp	r2, r3
 800e7fc:	d19d      	bne.n	800e73a <dir_find+0x76>
 800e7fe:	79aa      	ldrb	r2, [r5, #6]
 800e800:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 800e804:	429a      	cmp	r2, r3
 800e806:	d198      	bne.n	800e73a <dir_find+0x76>
 800e808:	79ea      	ldrb	r2, [r5, #7]
 800e80a:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 800e80e:	429a      	cmp	r2, r3
 800e810:	d193      	bne.n	800e73a <dir_find+0x76>
 800e812:	7a2a      	ldrb	r2, [r5, #8]
 800e814:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 800e818:	429a      	cmp	r2, r3
 800e81a:	d18e      	bne.n	800e73a <dir_find+0x76>
 800e81c:	7a6a      	ldrb	r2, [r5, #9]
 800e81e:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800e822:	429a      	cmp	r2, r3
 800e824:	d189      	bne.n	800e73a <dir_find+0x76>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800e826:	7aaa      	ldrb	r2, [r5, #10]
 800e828:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 800e82c:	429a      	cmp	r2, r3
 800e82e:	d184      	bne.n	800e73a <dir_find+0x76>
 800e830:	e76f      	b.n	800e712 <dir_find+0x4e>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800e832:	7870      	ldrb	r0, [r6, #1]
 800e834:	9100      	str	r1, [sp, #0]
 800e836:	2301      	movs	r3, #1
 800e838:	462a      	mov	r2, r5
 800e83a:	f7fe fe13 	bl	800d464 <disk_write>
 800e83e:	9900      	ldr	r1, [sp, #0]
 800e840:	2800      	cmp	r0, #0
 800e842:	f47f af64 	bne.w	800e70e <dir_find+0x4a>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800e846:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800e848:	69f3      	ldr	r3, [r6, #28]
			fs->wflag = 0;
 800e84a:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800e84c:	1aaa      	subs	r2, r5, r2
 800e84e:	429a      	cmp	r2, r3
 800e850:	f4bf af54 	bcs.w	800e6fc <dir_find+0x38>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e854:	f896 a002 	ldrb.w	sl, [r6, #2]
 800e858:	f1ba 0f01 	cmp.w	sl, #1
 800e85c:	f67f af4e 	bls.w	800e6fc <dir_find+0x38>
 800e860:	9400      	str	r4, [sp, #0]
 800e862:	460c      	mov	r4, r1
 800e864:	e000      	b.n	800e868 <dir_find+0x1a4>
 800e866:	69f3      	ldr	r3, [r6, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 800e868:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 800e86a:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e86c:	f10a 3aff 	add.w	sl, sl, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 800e870:	462a      	mov	r2, r5
 800e872:	2301      	movs	r3, #1
 800e874:	4621      	mov	r1, r4
 800e876:	f7fe fdf5 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800e87a:	f1ba 0f01 	cmp.w	sl, #1
 800e87e:	d1f2      	bne.n	800e866 <dir_find+0x1a2>
 800e880:	4621      	mov	r1, r4
 800e882:	9c00      	ldr	r4, [sp, #0]
 800e884:	e73a      	b.n	800e6fc <dir_find+0x38>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800e886:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 800e88a:	0658      	lsls	r0, r3, #25
 800e88c:	f53f af5a 	bmi.w	800e744 <dir_find+0x80>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 800e890:	0679      	lsls	r1, r7, #25
 800e892:	d548      	bpl.n	800e926 <dir_find+0x262>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800e894:	6963      	ldr	r3, [r4, #20]
						sum = dp->dir[LDIR_Chksum];
 800e896:	f895 800d 	ldrb.w	r8, [r5, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800e89a:	6323      	str	r3, [r4, #48]	; 0x30
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800e89c:	f007 07bf 	and.w	r7, r7, #191	; 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e8a0:	7b6b      	ldrb	r3, [r5, #13]
 800e8a2:	4543      	cmp	r3, r8
 800e8a4:	d141      	bne.n	800e92a <dir_find+0x266>
	rv = rv << 8 | ptr[0];
 800e8a6:	7eea      	ldrb	r2, [r5, #27]
 800e8a8:	7eab      	ldrb	r3, [r5, #26]
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 800e8aa:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 800e8ae:	d13c      	bne.n	800e92a <dir_find+0x266>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800e8b0:	f895 a000 	ldrb.w	sl, [r5]
 800e8b4:	4b55      	ldr	r3, [pc, #340]	; (800ea0c <dir_find+0x348>)
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e8b6:	68f0      	ldr	r0, [r6, #12]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e8b8:	9702      	str	r7, [sp, #8]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800e8ba:	f00a 0a3f 	and.w	sl, sl, #63	; 0x3f
 800e8be:	f10a 3aff 	add.w	sl, sl, #4294967295
 800e8c2:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
 800e8c6:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e8ca:	2101      	movs	r1, #1
 800e8cc:	462f      	mov	r7, r5
 800e8ce:	9401      	str	r4, [sp, #4]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e8d0:	9003      	str	r0, [sp, #12]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e8d2:	4654      	mov	r4, sl
 800e8d4:	9600      	str	r6, [sp, #0]
 800e8d6:	469a      	mov	sl, r3
 800e8d8:	4605      	mov	r5, r0
 800e8da:	460b      	mov	r3, r1
 800e8dc:	e010      	b.n	800e900 <dir_find+0x23c>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800e8de:	2cfe      	cmp	r4, #254	; 0xfe
 800e8e0:	d81c      	bhi.n	800e91c <dir_find+0x258>
 800e8e2:	f002 fa25 	bl	8010d30 <ff_wtoupper>
 800e8e6:	4684      	mov	ip, r0
 800e8e8:	f835 0014 	ldrh.w	r0, [r5, r4, lsl #1]
 800e8ec:	4664      	mov	r4, ip
 800e8ee:	f002 fa1f 	bl	8010d30 <ff_wtoupper>
 800e8f2:	4284      	cmp	r4, r0
 800e8f4:	d112      	bne.n	800e91c <dir_find+0x258>
	rv = rv << 8 | ptr[0];
 800e8f6:	464b      	mov	r3, r9
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800e8f8:	4634      	mov	r4, r6
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800e8fa:	4a45      	ldr	r2, [pc, #276]	; (800ea10 <dir_find+0x34c>)
 800e8fc:	4552      	cmp	r2, sl
 800e8fe:	d072      	beq.n	800e9e6 <dir_find+0x322>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800e900:	f81a 2b01 	ldrb.w	r2, [sl], #1
 800e904:	18b8      	adds	r0, r7, r2
	rv = rv << 8 | ptr[0];
 800e906:	f817 9002 	ldrb.w	r9, [r7, r2]
 800e90a:	7840      	ldrb	r0, [r0, #1]
 800e90c:	ea49 2900 	orr.w	r9, r9, r0, lsl #8
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800e910:	1c66      	adds	r6, r4, #1
 800e912:	4648      	mov	r0, r9
		if (wc) {
 800e914:	2b00      	cmp	r3, #0
 800e916:	d1e2      	bne.n	800e8de <dir_find+0x21a>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800e918:	45d9      	cmp	r9, fp
 800e91a:	d0ee      	beq.n	800e8fa <dir_find+0x236>
 800e91c:	e9dd 6400 	ldrd	r6, r4, [sp]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800e920:	f04f 09ff 	mov.w	r9, #255	; 0xff
 800e924:	e70e      	b.n	800e744 <dir_find+0x80>
 800e926:	45b9      	cmp	r9, r7
 800e928:	d0ba      	beq.n	800e8a0 <dir_find+0x1dc>
 800e92a:	f04f 09ff 	mov.w	r9, #255	; 0xff
 800e92e:	e709      	b.n	800e744 <dir_find+0x80>
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800e930:	782a      	ldrb	r2, [r5, #0]
 800e932:	7869      	ldrb	r1, [r5, #1]
 800e934:	01d3      	lsls	r3, r2, #7
 800e936:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 800e93a:	185a      	adds	r2, r3, r1
 800e93c:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800e940:	78a9      	ldrb	r1, [r5, #2]
 800e942:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800e946:	fa51 f383 	uxtab	r3, r1, r3
 800e94a:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800e94e:	78e9      	ldrb	r1, [r5, #3]
 800e950:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800e954:	fa51 f382 	uxtab	r3, r1, r2
 800e958:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800e95c:	7929      	ldrb	r1, [r5, #4]
 800e95e:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800e962:	fa51 f282 	uxtab	r2, r1, r2
 800e966:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800e96a:	7969      	ldrb	r1, [r5, #5]
 800e96c:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800e970:	fa51 f283 	uxtab	r2, r1, r3
 800e974:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800e978:	79a9      	ldrb	r1, [r5, #6]
 800e97a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800e97e:	fa51 f383 	uxtab	r3, r1, r3
 800e982:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800e986:	79e9      	ldrb	r1, [r5, #7]
 800e988:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800e98c:	fa51 f382 	uxtab	r3, r1, r2
 800e990:	f3c3 0246 	ubfx	r2, r3, #1, #7
 800e994:	7a29      	ldrb	r1, [r5, #8]
 800e996:	ea42 12c3 	orr.w	r2, r2, r3, lsl #7
 800e99a:	fa51 f282 	uxtab	r2, r1, r2
 800e99e:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800e9a2:	7a69      	ldrb	r1, [r5, #9]
 800e9a4:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800e9a8:	fa51 f283 	uxtab	r2, r1, r3
 800e9ac:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800e9b0:	7aa9      	ldrb	r1, [r5, #10]
 800e9b2:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800e9b6:	fa51 f383 	uxtab	r3, r1, r3
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800e9ba:	b2db      	uxtb	r3, r3
 800e9bc:	4598      	cmp	r8, r3
 800e9be:	f47f aefb 	bne.w	800e7b8 <dir_find+0xf4>
 800e9c2:	e6a6      	b.n	800e712 <dir_find+0x4e>
	clst -= 2;
 800e9c4:	1e87      	subs	r7, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e9c6:	3902      	subs	r1, #2
 800e9c8:	428f      	cmp	r7, r1
	return clst * fs->csize + fs->database;
 800e9ca:	bf38      	it	cc
 800e9cc:	6ad9      	ldrcc	r1, [r3, #44]	; 0x2c
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e9ce:	9a01      	ldr	r2, [sp, #4]
				dp->clust = clst;		/* Initialize data for new cluster */
 800e9d0:	61a0      	str	r0, [r4, #24]
	return clst * fs->csize + fs->database;
 800e9d2:	bf36      	itet	cc
 800e9d4:	8958      	ldrhcc	r0, [r3, #10]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800e9d6:	4617      	movcs	r7, r2
	return clst * fs->csize + fs->database;
 800e9d8:	fb07 1700 	mlacc	r7, r7, r0, r1
				dp->sect = clust2sect(fs, clst);
 800e9dc:	61e7      	str	r7, [r4, #28]
 800e9de:	e6c4      	b.n	800e76a <dir_find+0xa6>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800e9e0:	f04f 0902 	mov.w	r9, #2
 800e9e4:	e695      	b.n	800e712 <dir_find+0x4e>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800e9e6:	463d      	mov	r5, r7
 800e9e8:	4619      	mov	r1, r3
 800e9ea:	782b      	ldrb	r3, [r5, #0]
 800e9ec:	9e00      	ldr	r6, [sp, #0]
 800e9ee:	9f02      	ldr	r7, [sp, #8]
 800e9f0:	065a      	lsls	r2, r3, #25
 800e9f2:	46a2      	mov	sl, r4
 800e9f4:	9c01      	ldr	r4, [sp, #4]
 800e9f6:	d505      	bpl.n	800ea04 <dir_find+0x340>
 800e9f8:	b121      	cbz	r1, 800ea04 <dir_find+0x340>
 800e9fa:	9b03      	ldr	r3, [sp, #12]
 800e9fc:	f833 301a 	ldrh.w	r3, [r3, sl, lsl #1]
 800ea00:	2b00      	cmp	r3, #0
 800ea02:	d192      	bne.n	800e92a <dir_find+0x266>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800ea04:	3f01      	subs	r7, #1
 800ea06:	fa5f f987 	uxtb.w	r9, r7
 800ea0a:	e69b      	b.n	800e744 <dir_find+0x80>
 800ea0c:	0801a220 	.word	0x0801a220
 800ea10:	0801a22d 	.word	0x0801a22d

0800ea14 <follow_path>:
{
 800ea14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ea18:	b083      	sub	sp, #12
	FATFS *fs = obj->fs;
 800ea1a:	6803      	ldr	r3, [r0, #0]
 800ea1c:	9300      	str	r3, [sp, #0]
{
 800ea1e:	4606      	mov	r6, r0
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 800ea20:	460f      	mov	r7, r1
 800ea22:	f811 3b01 	ldrb.w	r3, [r1], #1
 800ea26:	2b2f      	cmp	r3, #47	; 0x2f
 800ea28:	d0fa      	beq.n	800ea20 <follow_path+0xc>
 800ea2a:	2b5c      	cmp	r3, #92	; 0x5c
 800ea2c:	d0f8      	beq.n	800ea20 <follow_path+0xc>
		obj->sclust = 0;					/* Start from root directory */
 800ea2e:	2100      	movs	r1, #0
 800ea30:	60b1      	str	r1, [r6, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 800ea32:	783b      	ldrb	r3, [r7, #0]
 800ea34:	2b1f      	cmp	r3, #31
 800ea36:	f240 8140 	bls.w	800ecba <follow_path+0x2a6>
 800ea3a:	9a00      	ldr	r2, [sp, #0]
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 800ea3c:	f8d2 b00c 	ldr.w	fp, [r2, #12]
		if (w < ' ') break;				/* Break if end of the path name */
 800ea40:	2b1f      	cmp	r3, #31
		w = p[si++];					/* Get a character */
 800ea42:	b298      	uxth	r0, r3
		if (w < ' ') break;				/* Break if end of the path name */
 800ea44:	d941      	bls.n	800eaca <follow_path+0xb6>
 800ea46:	f1ab 0802 	sub.w	r8, fp, #2
 800ea4a:	46c1      	mov	r9, r8
 800ea4c:	46ba      	mov	sl, r7
		w = p[si++];					/* Get a character */
 800ea4e:	2501      	movs	r5, #1
 800ea50:	e009      	b.n	800ea66 <follow_path+0x52>
		lfn[di++] = w;					/* Store the Unicode character */
 800ea52:	f829 0f02 	strh.w	r0, [r9, #2]!
		w = p[si++];					/* Get a character */
 800ea56:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ') break;				/* Break if end of the path name */
 800ea5a:	281f      	cmp	r0, #31
		w = p[si++];					/* Get a character */
 800ea5c:	f105 0301 	add.w	r3, r5, #1
		if (w < ' ') break;				/* Break if end of the path name */
 800ea60:	f240 80fc 	bls.w	800ec5c <follow_path+0x248>
		w = p[si++];					/* Get a character */
 800ea64:	461d      	mov	r5, r3
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 800ea66:	282f      	cmp	r0, #47	; 0x2f
 800ea68:	f105 34ff 	add.w	r4, r5, #4294967295
 800ea6c:	d017      	beq.n	800ea9e <follow_path+0x8a>
 800ea6e:	285c      	cmp	r0, #92	; 0x5c
 800ea70:	d015      	beq.n	800ea9e <follow_path+0x8a>
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 800ea72:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800ea76:	d00e      	beq.n	800ea96 <follow_path+0x82>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 800ea78:	2101      	movs	r1, #1
 800ea7a:	f002 f935 	bl	8010ce8 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 800ea7e:	b150      	cbz	r0, 800ea96 <follow_path+0x82>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 800ea80:	287f      	cmp	r0, #127	; 0x7f
 800ea82:	d8e6      	bhi.n	800ea52 <follow_path+0x3e>
 800ea84:	4a9c      	ldr	r2, [pc, #624]	; (800ecf8 <follow_path+0x2e4>)
	while (*str && *str != chr) str++;
 800ea86:	2322      	movs	r3, #34	; 0x22
 800ea88:	e003      	b.n	800ea92 <follow_path+0x7e>
 800ea8a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800ea8e:	2b00      	cmp	r3, #0
 800ea90:	d0df      	beq.n	800ea52 <follow_path+0x3e>
 800ea92:	4298      	cmp	r0, r3
 800ea94:	d1f9      	bne.n	800ea8a <follow_path+0x76>
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 800ea96:	2006      	movs	r0, #6
}
 800ea98:	b003      	add	sp, #12
 800ea9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ea9e:	443d      	add	r5, r7
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800eaa0:	782b      	ldrb	r3, [r5, #0]
 800eaa2:	2b2f      	cmp	r3, #47	; 0x2f
 800eaa4:	462f      	mov	r7, r5
 800eaa6:	f105 0501 	add.w	r5, r5, #1
 800eaaa:	d0f9      	beq.n	800eaa0 <follow_path+0x8c>
 800eaac:	2b5c      	cmp	r3, #92	; 0x5c
 800eaae:	d0f7      	beq.n	800eaa0 <follow_path+0x8c>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800eab0:	b15c      	cbz	r4, 800eaca <follow_path+0xb6>
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800eab2:	f04f 0900 	mov.w	r9, #0
 800eab6:	eb0b 0144 	add.w	r1, fp, r4, lsl #1
		w = lfn[di - 1];
 800eaba:	f831 3d02 	ldrh.w	r3, [r1, #-2]!
		if (w != ' ' && w != '.') break;
 800eabe:	2b20      	cmp	r3, #32
 800eac0:	d001      	beq.n	800eac6 <follow_path+0xb2>
 800eac2:	2b2e      	cmp	r3, #46	; 0x2e
 800eac4:	d105      	bne.n	800ead2 <follow_path+0xbe>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800eac6:	3c01      	subs	r4, #1
 800eac8:	d1f7      	bne.n	800eaba <follow_path+0xa6>
	lfn[di] = 0;						/* LFN is created */
 800eaca:	2300      	movs	r3, #0
 800eacc:	f8ab 3000 	strh.w	r3, [fp]
 800ead0:	e7e1      	b.n	800ea96 <follow_path+0x82>
		*d++ = (BYTE)val;
 800ead2:	2320      	movs	r3, #32
 800ead4:	f04f 3120 	mov.w	r1, #538976288	; 0x20202020
	lfn[di] = 0;						/* LFN is created */
 800ead8:	2500      	movs	r5, #0
 800eada:	f82b 5014 	strh.w	r5, [fp, r4, lsl #1]
		*d++ = (BYTE)val;
 800eade:	6271      	str	r1, [r6, #36]	; 0x24
 800eae0:	62b1      	str	r1, [r6, #40]	; 0x28
 800eae2:	f886 302c 	strb.w	r3, [r6, #44]	; 0x2c
 800eae6:	f886 302d 	strb.w	r3, [r6, #45]	; 0x2d
 800eaea:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
	} while (--cnt);
 800eaee:	e000      	b.n	800eaf2 <follow_path+0xde>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 800eaf0:	3501      	adds	r5, #1
 800eaf2:	f838 0f02 	ldrh.w	r0, [r8, #2]!
 800eaf6:	2820      	cmp	r0, #32
 800eaf8:	d0fa      	beq.n	800eaf0 <follow_path+0xdc>
 800eafa:	282e      	cmp	r0, #46	; 0x2e
 800eafc:	d0f8      	beq.n	800eaf0 <follow_path+0xdc>
	if (si) cf |= NS_LOSS | NS_LFN;
 800eafe:	b10d      	cbz	r5, 800eb04 <follow_path+0xf0>
 800eb00:	f049 0903 	orr.w	r9, r9, #3
 800eb04:	eb0b 0344 	add.w	r3, fp, r4, lsl #1
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 800eb08:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 800eb0c:	2a2e      	cmp	r2, #46	; 0x2e
 800eb0e:	d001      	beq.n	800eb14 <follow_path+0x100>
 800eb10:	3c01      	subs	r4, #1
 800eb12:	d1f9      	bne.n	800eb08 <follow_path+0xf4>
		w = lfn[si++];					/* Get an LFN character */
 800eb14:	3501      	adds	r5, #1
		if (!w) break;					/* Break on end of the LFN */
 800eb16:	2800      	cmp	r0, #0
 800eb18:	d04b      	beq.n	800ebb2 <follow_path+0x19e>
 800eb1a:	4632      	mov	r2, r6
 800eb1c:	f04f 0800 	mov.w	r8, #0
 800eb20:	465e      	mov	r6, fp
 800eb22:	463b      	mov	r3, r7
 800eb24:	46a3      	mov	fp, r4
 800eb26:	f04f 0a08 	mov.w	sl, #8
 800eb2a:	4644      	mov	r4, r8
 800eb2c:	4617      	mov	r7, r2
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 800eb2e:	2820      	cmp	r0, #32
 800eb30:	d067      	beq.n	800ec02 <follow_path+0x1ee>
 800eb32:	282e      	cmp	r0, #46	; 0x2e
 800eb34:	d068      	beq.n	800ec08 <follow_path+0x1f4>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
 800eb36:	45a2      	cmp	sl, r4
 800eb38:	d974      	bls.n	800ec24 <follow_path+0x210>
 800eb3a:	455d      	cmp	r5, fp
 800eb3c:	d066      	beq.n	800ec0c <follow_path+0x1f8>
		if (w >= 0x80) {				/* Non ASCII character */
 800eb3e:	287f      	cmp	r0, #127	; 0x7f
 800eb40:	f200 809b 	bhi.w	800ec7a <follow_path+0x266>
	while (*str && *str != chr) str++;
 800eb44:	496d      	ldr	r1, [pc, #436]	; (800ecfc <follow_path+0x2e8>)
 800eb46:	222b      	movs	r2, #43	; 0x2b
 800eb48:	e004      	b.n	800eb54 <follow_path+0x140>
 800eb4a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800eb4e:	2a00      	cmp	r2, #0
 800eb50:	f000 80bc 	beq.w	800eccc <follow_path+0x2b8>
 800eb54:	4282      	cmp	r2, r0
 800eb56:	d1f8      	bne.n	800eb4a <follow_path+0x136>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800eb58:	f049 0903 	orr.w	r9, r9, #3
 800eb5c:	205f      	movs	r0, #95	; 0x5f
		dp->fn[i++] = (BYTE)w;
 800eb5e:	193a      	adds	r2, r7, r4
 800eb60:	3401      	adds	r4, #1
 800eb62:	f882 0024 	strb.w	r0, [r2, #36]	; 0x24
		w = lfn[si++];					/* Get an LFN character */
 800eb66:	f836 0015 	ldrh.w	r0, [r6, r5, lsl #1]
 800eb6a:	3501      	adds	r5, #1
		if (!w) break;					/* Break on end of the LFN */
 800eb6c:	2800      	cmp	r0, #0
 800eb6e:	d1de      	bne.n	800eb2e <follow_path+0x11a>
 800eb70:	463e      	mov	r6, r7
 800eb72:	461f      	mov	r7, r3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800eb74:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 800eb78:	2be5      	cmp	r3, #229	; 0xe5
 800eb7a:	bf04      	itt	eq
 800eb7c:	2305      	moveq	r3, #5
 800eb7e:	f886 3024 	strbeq.w	r3, [r6, #36]	; 0x24
	if (ni == 8) b <<= 2;
 800eb82:	f1ba 0f08 	cmp.w	sl, #8
 800eb86:	d06e      	beq.n	800ec66 <follow_path+0x252>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800eb88:	f008 030c 	and.w	r3, r8, #12
 800eb8c:	2b0c      	cmp	r3, #12
 800eb8e:	d052      	beq.n	800ec36 <follow_path+0x222>
 800eb90:	f008 0803 	and.w	r8, r8, #3
 800eb94:	f1b8 0f03 	cmp.w	r8, #3
 800eb98:	d04d      	beq.n	800ec36 <follow_path+0x222>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800eb9a:	f019 0f02 	tst.w	r9, #2
 800eb9e:	d108      	bne.n	800ebb2 <follow_path+0x19e>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 800eba0:	f1b8 0f01 	cmp.w	r8, #1
 800eba4:	bf08      	it	eq
 800eba6:	f049 0910 	orreq.w	r9, r9, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 800ebaa:	2b04      	cmp	r3, #4
 800ebac:	bf08      	it	eq
 800ebae:	f049 0908 	orreq.w	r9, r9, #8
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800ebb2:	f886 902f 	strb.w	r9, [r6, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
 800ebb6:	4630      	mov	r0, r6
 800ebb8:	f7ff fd84 	bl	800e6c4 <dir_find>
			ns = dp->fn[NSFLAG];
 800ebbc:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 800ebc0:	2800      	cmp	r0, #0
 800ebc2:	d143      	bne.n	800ec4c <follow_path+0x238>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800ebc4:	075a      	lsls	r2, r3, #29
 800ebc6:	f53f af67 	bmi.w	800ea98 <follow_path+0x84>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 800ebca:	79b3      	ldrb	r3, [r6, #6]
 800ebcc:	06db      	lsls	r3, r3, #27
 800ebce:	f140 808f 	bpl.w	800ecf0 <follow_path+0x2dc>
	if (fs->fs_type == FS_FAT32) {
 800ebd2:	9800      	ldr	r0, [sp, #0]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800ebd4:	6973      	ldr	r3, [r6, #20]
	if (fs->fs_type == FS_FAT32) {
 800ebd6:	7801      	ldrb	r1, [r0, #0]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800ebd8:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800ebdc:	f100 0334 	add.w	r3, r0, #52	; 0x34
 800ebe0:	4413      	add	r3, r2
	if (fs->fs_type == FS_FAT32) {
 800ebe2:	2903      	cmp	r1, #3
	rv = rv << 8 | ptr[0];
 800ebe4:	7ed8      	ldrb	r0, [r3, #27]
 800ebe6:	7e9a      	ldrb	r2, [r3, #26]
	cl = ld_word(dir + DIR_FstClusLO);
 800ebe8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 800ebec:	d105      	bne.n	800ebfa <follow_path+0x1e6>
	rv = rv << 8 | ptr[0];
 800ebee:	7d59      	ldrb	r1, [r3, #21]
 800ebf0:	7d1b      	ldrb	r3, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800ebf2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800ebf6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 800ebfa:	60b2      	str	r2, [r6, #8]
		for (;;) {
 800ebfc:	783b      	ldrb	r3, [r7, #0]
 800ebfe:	6832      	ldr	r2, [r6, #0]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800ec00:	e71c      	b.n	800ea3c <follow_path+0x28>
			cf |= NS_LOSS | NS_LFN; continue;
 800ec02:	f049 0903 	orr.w	r9, r9, #3
 800ec06:	e7ae      	b.n	800eb66 <follow_path+0x152>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 800ec08:	455d      	cmp	r5, fp
 800ec0a:	d1fa      	bne.n	800ec02 <follow_path+0x1ee>
			if (ni == 11) {				/* Long extension */
 800ec0c:	f1ba 0f0b 	cmp.w	sl, #11
 800ec10:	d046      	beq.n	800eca0 <follow_path+0x28c>
			b <<= 2; continue;
 800ec12:	ea4f 0888 	mov.w	r8, r8, lsl #2
 800ec16:	fa5f f888 	uxtb.w	r8, r8
 800ec1a:	465d      	mov	r5, fp
			si = di; i = 8; ni = 11;	/* Enter extension section */
 800ec1c:	f04f 0a0b 	mov.w	sl, #11
 800ec20:	2408      	movs	r4, #8
			b <<= 2; continue;
 800ec22:	e7a0      	b.n	800eb66 <follow_path+0x152>
			if (ni == 11) {				/* Long extension */
 800ec24:	f1ba 0f0b 	cmp.w	sl, #11
 800ec28:	d03a      	beq.n	800eca0 <follow_path+0x28c>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800ec2a:	455d      	cmp	r5, fp
 800ec2c:	d0f1      	beq.n	800ec12 <follow_path+0x1fe>
 800ec2e:	f049 0903 	orr.w	r9, r9, #3
			if (si > di) break;			/* No extension */
 800ec32:	d89d      	bhi.n	800eb70 <follow_path+0x15c>
 800ec34:	e7ed      	b.n	800ec12 <follow_path+0x1fe>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800ec36:	f049 0902 	orr.w	r9, r9, #2
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800ec3a:	f886 902f 	strb.w	r9, [r6, #47]	; 0x2f
			res = dir_find(dp);				/* Find an object with the segment name */
 800ec3e:	4630      	mov	r0, r6
 800ec40:	f7ff fd40 	bl	800e6c4 <dir_find>
			ns = dp->fn[NSFLAG];
 800ec44:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 800ec48:	2800      	cmp	r0, #0
 800ec4a:	d0bb      	beq.n	800ebc4 <follow_path+0x1b0>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800ec4c:	2804      	cmp	r0, #4
 800ec4e:	f47f af23 	bne.w	800ea98 <follow_path+0x84>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800ec52:	f013 0f04 	tst.w	r3, #4
 800ec56:	bf08      	it	eq
 800ec58:	2005      	moveq	r0, #5
 800ec5a:	e71d      	b.n	800ea98 <follow_path+0x84>
	*path = &p[si];						/* Return pointer to the next segment */
 800ec5c:	441f      	add	r7, r3
 800ec5e:	462c      	mov	r4, r5
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800ec60:	f04f 0904 	mov.w	r9, #4
 800ec64:	e727      	b.n	800eab6 <follow_path+0xa2>
	if (ni == 8) b <<= 2;
 800ec66:	ea4f 0888 	mov.w	r8, r8, lsl #2
 800ec6a:	f008 030c 	and.w	r3, r8, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800ec6e:	2b0c      	cmp	r3, #12
 800ec70:	d0e1      	beq.n	800ec36 <follow_path+0x222>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800ec72:	f019 0f02 	tst.w	r9, #2
 800ec76:	d098      	beq.n	800ebaa <follow_path+0x196>
 800ec78:	e79b      	b.n	800ebb2 <follow_path+0x19e>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 800ec7a:	2100      	movs	r1, #0
 800ec7c:	9301      	str	r3, [sp, #4]
 800ec7e:	f002 f833 	bl	8010ce8 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800ec82:	9b01      	ldr	r3, [sp, #4]
 800ec84:	b148      	cbz	r0, 800ec9a <follow_path+0x286>
 800ec86:	4a1e      	ldr	r2, [pc, #120]	; (800ed00 <follow_path+0x2ec>)
 800ec88:	4410      	add	r0, r2
			cf |= NS_LFN;				/* Force create LFN entry */
 800ec8a:	f049 0902 	orr.w	r9, r9, #2
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800ec8e:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 800ec92:	2800      	cmp	r0, #0
 800ec94:	f43f af60 	beq.w	800eb58 <follow_path+0x144>
 800ec98:	e754      	b.n	800eb44 <follow_path+0x130>
			cf |= NS_LFN;				/* Force create LFN entry */
 800ec9a:	f049 0902 	orr.w	r9, r9, #2
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 800ec9e:	e75b      	b.n	800eb58 <follow_path+0x144>
				cf |= NS_LOSS | NS_LFN; break;
 800eca0:	463e      	mov	r6, r7
 800eca2:	461f      	mov	r7, r3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800eca4:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 800eca8:	2be5      	cmp	r3, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN; break;
 800ecaa:	f049 0903 	orr.w	r9, r9, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800ecae:	f47f af6b 	bne.w	800eb88 <follow_path+0x174>
 800ecb2:	2305      	movs	r3, #5
 800ecb4:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
	if (ni == 8) b <<= 2;
 800ecb8:	e766      	b.n	800eb88 <follow_path+0x174>
		dp->fn[NSFLAG] = NS_NONAME;
 800ecba:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 800ecbc:	4630      	mov	r0, r6
		dp->fn[NSFLAG] = NS_NONAME;
 800ecbe:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
}
 800ecc2:	b003      	add	sp, #12
 800ecc4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 800ecc8:	f7ff bc36 	b.w	800e538 <dir_sdi>
				if (IsUpper(w)) {		/* ASCII large capital */
 800eccc:	f1a0 0241 	sub.w	r2, r0, #65	; 0x41
 800ecd0:	2a19      	cmp	r2, #25
 800ecd2:	d803      	bhi.n	800ecdc <follow_path+0x2c8>
					b |= 2;
 800ecd4:	f048 0802 	orr.w	r8, r8, #2
 800ecd8:	b2c0      	uxtb	r0, r0
 800ecda:	e740      	b.n	800eb5e <follow_path+0x14a>
					if (IsLower(w)) {	/* ASCII small capital */
 800ecdc:	f1a0 0261 	sub.w	r2, r0, #97	; 0x61
 800ece0:	2a19      	cmp	r2, #25
						b |= 1; w -= 0x20;
 800ece2:	bf97      	itett	ls
 800ece4:	3820      	subls	r0, #32
 800ece6:	b2c0      	uxtbhi	r0, r0
 800ece8:	b2c0      	uxtbls	r0, r0
 800ecea:	f048 0801 	orrls.w	r8, r8, #1
 800ecee:	e736      	b.n	800eb5e <follow_path+0x14a>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800ecf0:	2005      	movs	r0, #5
}
 800ecf2:	b003      	add	sp, #12
 800ecf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ecf8:	0801aab0 	.word	0x0801aab0
 800ecfc:	0801aabc 	.word	0x0801aabc
 800ed00:	0801a1a0 	.word	0x0801a1a0

0800ed04 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800ed04:	2901      	cmp	r1, #1
{
 800ed06:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs = obj->fs;
 800ed0a:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800ed0c:	d90f      	bls.n	800ed2e <remove_chain+0x2a>
 800ed0e:	69ab      	ldr	r3, [r5, #24]
 800ed10:	428b      	cmp	r3, r1
 800ed12:	460c      	mov	r4, r1
 800ed14:	d90b      	bls.n	800ed2e <remove_chain+0x2a>
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800ed16:	4606      	mov	r6, r0
 800ed18:	b962      	cbnz	r2, 800ed34 <remove_chain+0x30>
 800ed1a:	462f      	mov	r7, r5
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800ed1c:	42a3      	cmp	r3, r4
 800ed1e:	d906      	bls.n	800ed2e <remove_chain+0x2a>
		switch (fs->fs_type) {
 800ed20:	783b      	ldrb	r3, [r7, #0]
 800ed22:	2b02      	cmp	r3, #2
 800ed24:	d07a      	beq.n	800ee1c <remove_chain+0x118>
 800ed26:	2b03      	cmp	r3, #3
 800ed28:	d05e      	beq.n	800ede8 <remove_chain+0xe4>
 800ed2a:	2b01      	cmp	r3, #1
 800ed2c:	d011      	beq.n	800ed52 <remove_chain+0x4e>
 800ed2e:	2002      	movs	r0, #2
}
 800ed30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800ed34:	2a01      	cmp	r2, #1
 800ed36:	d9fa      	bls.n	800ed2e <remove_chain+0x2a>
 800ed38:	4293      	cmp	r3, r2
 800ed3a:	d9f8      	bls.n	800ed2e <remove_chain+0x2a>
 800ed3c:	4611      	mov	r1, r2
 800ed3e:	4628      	mov	r0, r5
 800ed40:	f04f 32ff 	mov.w	r2, #4294967295
 800ed44:	f7fe fcd8 	bl	800d6f8 <put_fat.part.0>
		if (res != FR_OK) return res;
 800ed48:	2800      	cmp	r0, #0
 800ed4a:	d1f1      	bne.n	800ed30 <remove_chain+0x2c>
 800ed4c:	6837      	ldr	r7, [r6, #0]
 800ed4e:	69bb      	ldr	r3, [r7, #24]
 800ed50:	e7e4      	b.n	800ed1c <remove_chain+0x18>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800ed52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ed54:	6b3a      	ldr	r2, [r7, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 800ed56:	eb04 0854 	add.w	r8, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800ed5a:	eb03 2158 	add.w	r1, r3, r8, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ed5e:	4291      	cmp	r1, r2
 800ed60:	d006      	beq.n	800ed70 <remove_chain+0x6c>
 800ed62:	4638      	mov	r0, r7
 800ed64:	f7fe fc8e 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800ed68:	2800      	cmp	r0, #0
 800ed6a:	d16c      	bne.n	800ee46 <remove_chain+0x142>
 800ed6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ed6e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
			wc = fs->win[bc++ % SS(fs)];
 800ed70:	f3c8 0008 	ubfx	r0, r8, #0, #9
 800ed74:	f108 0801 	add.w	r8, r8, #1
 800ed78:	4438      	add	r0, r7
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800ed7a:	eb03 2158 	add.w	r1, r3, r8, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ed7e:	4291      	cmp	r1, r2
			wc = fs->win[bc++ % SS(fs)];
 800ed80:	f890 9034 	ldrb.w	r9, [r0, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ed84:	d004      	beq.n	800ed90 <remove_chain+0x8c>
 800ed86:	4638      	mov	r0, r7
 800ed88:	f7fe fc7c 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800ed8c:	2800      	cmp	r0, #0
 800ed8e:	d15a      	bne.n	800ee46 <remove_chain+0x142>
			wc |= fs->win[bc % SS(fs)] << 8;
 800ed90:	f3c8 0808 	ubfx	r8, r8, #0, #9
 800ed94:	4447      	add	r7, r8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800ed96:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 800ed98:	f897 8034 	ldrb.w	r8, [r7, #52]	; 0x34
 800ed9c:	ea49 2808 	orr.w	r8, r9, r8, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800eda0:	d553      	bpl.n	800ee4a <remove_chain+0x146>
 800eda2:	ea4f 1818 	mov.w	r8, r8, lsr #4
		if (nxt == 0) break;				/* Empty cluster? */
 800eda6:	f1b8 0f00 	cmp.w	r8, #0
 800edaa:	d051      	beq.n	800ee50 <remove_chain+0x14c>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800edac:	f1b8 0f01 	cmp.w	r8, #1
 800edb0:	d0bd      	beq.n	800ed2e <remove_chain+0x2a>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800edb2:	69ab      	ldr	r3, [r5, #24]
 800edb4:	42a3      	cmp	r3, r4
 800edb6:	d9ba      	bls.n	800ed2e <remove_chain+0x2a>
 800edb8:	4621      	mov	r1, r4
 800edba:	2200      	movs	r2, #0
 800edbc:	4628      	mov	r0, r5
 800edbe:	f7fe fc9b 	bl	800d6f8 <put_fat.part.0>
			if (res != FR_OK) return res;
 800edc2:	2800      	cmp	r0, #0
 800edc4:	d1b4      	bne.n	800ed30 <remove_chain+0x2c>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 800edc6:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
 800edca:	1e91      	subs	r1, r2, #2
 800edcc:	428b      	cmp	r3, r1
 800edce:	d205      	bcs.n	800eddc <remove_chain+0xd8>
			fs->fsi_flag |= 1;
 800edd0:	7929      	ldrb	r1, [r5, #4]
			fs->free_clst++;
 800edd2:	3301      	adds	r3, #1
			fs->fsi_flag |= 1;
 800edd4:	f041 0101 	orr.w	r1, r1, #1
			fs->free_clst++;
 800edd8:	616b      	str	r3, [r5, #20]
			fs->fsi_flag |= 1;
 800edda:	7129      	strb	r1, [r5, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 800eddc:	4542      	cmp	r2, r8
 800edde:	d937      	bls.n	800ee50 <remove_chain+0x14c>
		nxt = get_fat(obj, clst);			/* Get cluster status */
 800ede0:	6837      	ldr	r7, [r6, #0]
 800ede2:	4644      	mov	r4, r8
 800ede4:	69bb      	ldr	r3, [r7, #24]
 800ede6:	e799      	b.n	800ed1c <remove_chain+0x18>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800ede8:	6a79      	ldr	r1, [r7, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800edea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800edec:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800edf0:	4299      	cmp	r1, r3
 800edf2:	d003      	beq.n	800edfc <remove_chain+0xf8>
 800edf4:	4638      	mov	r0, r7
 800edf6:	f7fe fc45 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800edfa:	bb20      	cbnz	r0, 800ee46 <remove_chain+0x142>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800edfc:	00a3      	lsls	r3, r4, #2
 800edfe:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 800ee02:	3734      	adds	r7, #52	; 0x34
 800ee04:	18fa      	adds	r2, r7, r3
	rv = rv << 8 | ptr[0];
 800ee06:	f817 8003 	ldrb.w	r8, [r7, r3]
	rv = rv << 8 | ptr[2];
 800ee0a:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 800ee0c:	7853      	ldrb	r3, [r2, #1]
 800ee0e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800ee12:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800ee16:	f028 4870 	bic.w	r8, r8, #4026531840	; 0xf0000000
			break;
 800ee1a:	e7c4      	b.n	800eda6 <remove_chain+0xa2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800ee1c:	6a79      	ldr	r1, [r7, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ee1e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800ee20:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ee24:	4299      	cmp	r1, r3
 800ee26:	d003      	beq.n	800ee30 <remove_chain+0x12c>
 800ee28:	4638      	mov	r0, r7
 800ee2a:	f7fe fc2b 	bl	800d684 <move_window.part.0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800ee2e:	b950      	cbnz	r0, 800ee46 <remove_chain+0x142>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800ee30:	0063      	lsls	r3, r4, #1
 800ee32:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 800ee36:	3734      	adds	r7, #52	; 0x34
 800ee38:	18fa      	adds	r2, r7, r3
	rv = rv << 8 | ptr[0];
 800ee3a:	f817 8003 	ldrb.w	r8, [r7, r3]
 800ee3e:	7853      	ldrb	r3, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 800ee40:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
			break;
 800ee44:	e7af      	b.n	800eda6 <remove_chain+0xa2>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800ee46:	2001      	movs	r0, #1
 800ee48:	e772      	b.n	800ed30 <remove_chain+0x2c>
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800ee4a:	f3c8 080b 	ubfx	r8, r8, #0, #12
 800ee4e:	e7aa      	b.n	800eda6 <remove_chain+0xa2>
	return FR_OK;
 800ee50:	2000      	movs	r0, #0
 800ee52:	e76d      	b.n	800ed30 <remove_chain+0x2c>

0800ee54 <dir_register>:
{
 800ee54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800ee58:	f890 402f 	ldrb.w	r4, [r0, #47]	; 0x2f
 800ee5c:	f014 04a0 	ands.w	r4, r4, #160	; 0xa0
{
 800ee60:	b091      	sub	sp, #68	; 0x44
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800ee62:	f040 830a 	bne.w	800f47a <dir_register+0x626>
	FATFS *fs = dp->obj.fs;
 800ee66:	6803      	ldr	r3, [r0, #0]
 800ee68:	9300      	str	r3, [sp, #0]
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 800ee6a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 800ee6e:	f8bc 3000 	ldrh.w	r3, [ip]
 800ee72:	4682      	mov	sl, r0
 800ee74:	2b00      	cmp	r3, #0
 800ee76:	f000 84b0 	beq.w	800f7da <dir_register+0x986>
 800ee7a:	4663      	mov	r3, ip
 800ee7c:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 800ee80:	3401      	adds	r4, #1
 800ee82:	2a00      	cmp	r2, #0
 800ee84:	d1fa      	bne.n	800ee7c <dir_register+0x28>
	mem_cpy(sn, dp->fn, 12);
 800ee86:	f10a 0b24 	add.w	fp, sl, #36	; 0x24
	if (cnt) {
 800ee8a:	e89b 0007 	ldmia.w	fp, {r0, r1, r2}
 800ee8e:	ab10      	add	r3, sp, #64	; 0x40
 800ee90:	e903 0007 	stmdb	r3, {r0, r1, r2}
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 800ee94:	f89d 303f 	ldrb.w	r3, [sp, #63]	; 0x3f
 800ee98:	9308      	str	r3, [sp, #32]
 800ee9a:	07d9      	lsls	r1, r3, #31
 800ee9c:	d46e      	bmi.n	800ef7c <dir_register+0x128>
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800ee9e:	f013 0302 	ands.w	r3, r3, #2
 800eea2:	f8dd 9000 	ldr.w	r9, [sp]
 800eea6:	f000 828d 	beq.w	800f3c4 <dir_register+0x570>
 800eeaa:	4b5f      	ldr	r3, [pc, #380]	; (800f028 <dir_register+0x1d4>)
 800eeac:	340c      	adds	r4, #12
 800eeae:	fba3 3404 	umull	r3, r4, r3, r4
 800eeb2:	08a3      	lsrs	r3, r4, #2
 800eeb4:	9302      	str	r3, [sp, #8]
	res = dir_sdi(dp, 0);
 800eeb6:	2100      	movs	r1, #0
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800eeb8:	3301      	adds	r3, #1
	res = dir_sdi(dp, 0);
 800eeba:	4650      	mov	r0, sl
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800eebc:	461c      	mov	r4, r3
	res = dir_sdi(dp, 0);
 800eebe:	f7ff fb3b 	bl	800e538 <dir_sdi>
	if (res == FR_OK) {
 800eec2:	9001      	str	r0, [sp, #4]
 800eec4:	2800      	cmp	r0, #0
 800eec6:	f040 8288 	bne.w	800f3da <dir_register+0x586>
						fs->wflag = 1;
 800eeca:	f8cd b00c 	str.w	fp, [sp, #12]
 800eece:	f8da 101c 	ldr.w	r1, [sl, #28]
		n = 0;
 800eed2:	4680      	mov	r8, r0
						fs->wflag = 1;
 800eed4:	46a3      	mov	fp, r4
 800eed6:	e027      	b.n	800ef28 <dir_register+0xd4>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 800eed8:	b3ab      	cbz	r3, 800ef46 <dir_register+0xf2>
				n = 0;					/* Not a blank entry. Restart to search */
 800eeda:	f04f 0800 	mov.w	r8, #0
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800eede:	f8da 4014 	ldr.w	r4, [sl, #20]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800eee2:	f8da 101c 	ldr.w	r1, [sl, #28]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 800eee6:	3420      	adds	r4, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800eee8:	2900      	cmp	r1, #0
 800eeea:	f000 8279 	beq.w	800f3e0 <dir_register+0x58c>
 800eeee:	f5b4 1f00 	cmp.w	r4, #2097152	; 0x200000
 800eef2:	f080 8275 	bcs.w	800f3e0 <dir_register+0x58c>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800eef6:	f3c4 0708 	ubfx	r7, r4, #0, #9
	FATFS *fs = dp->obj.fs;
 800eefa:	f8da 6000 	ldr.w	r6, [sl]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 800eefe:	b967      	cbnz	r7, 800ef1a <dir_register+0xc6>
		if (!dp->clust) {		/* Static table */
 800ef00:	f8da 3018 	ldr.w	r3, [sl, #24]
		dp->sect++;				/* Next sector */
 800ef04:	3101      	adds	r1, #1
 800ef06:	f8ca 101c 	str.w	r1, [sl, #28]
		if (!dp->clust) {		/* Static table */
 800ef0a:	2b00      	cmp	r3, #0
 800ef0c:	f040 8282 	bne.w	800f414 <dir_register+0x5c0>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 800ef10:	8932      	ldrh	r2, [r6, #8]
 800ef12:	ebb2 1f54 	cmp.w	r2, r4, lsr #5
 800ef16:	f240 845d 	bls.w	800f7d4 <dir_register+0x980>
 800ef1a:	f106 0534 	add.w	r5, r6, #52	; 0x34
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 800ef1e:	443d      	add	r5, r7
 800ef20:	f8ca 5020 	str.w	r5, [sl, #32]
	dp->dptr = ofs;						/* Current entry */
 800ef24:	f8ca 4014 	str.w	r4, [sl, #20]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ef28:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
 800ef2c:	428b      	cmp	r3, r1
 800ef2e:	d005      	beq.n	800ef3c <dir_register+0xe8>
 800ef30:	4648      	mov	r0, r9
 800ef32:	f7fe fba7 	bl	800d684 <move_window.part.0>
			if (res != FR_OK) break;
 800ef36:	2800      	cmp	r0, #0
 800ef38:	f040 8452 	bne.w	800f7e0 <dir_register+0x98c>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 800ef3c:	f8da 3020 	ldr.w	r3, [sl, #32]
 800ef40:	781b      	ldrb	r3, [r3, #0]
 800ef42:	2be5      	cmp	r3, #229	; 0xe5
 800ef44:	d1c8      	bne.n	800eed8 <dir_register+0x84>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 800ef46:	f108 0801 	add.w	r8, r8, #1
 800ef4a:	45c3      	cmp	fp, r8
 800ef4c:	d1c7      	bne.n	800eede <dir_register+0x8a>
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 800ef4e:	e9dd 3b02 	ldrd	r3, fp, [sp, #8]
 800ef52:	2b00      	cmp	r3, #0
 800ef54:	f040 82c4 	bne.w	800f4e0 <dir_register+0x68c>
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ef58:	9b00      	ldr	r3, [sp, #0]
		res = move_window(fs, dp->sect);
 800ef5a:	f8da 101c 	ldr.w	r1, [sl, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800ef5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ef60:	4299      	cmp	r1, r3
 800ef62:	f000 8290 	beq.w	800f486 <dir_register+0x632>
 800ef66:	9800      	ldr	r0, [sp, #0]
 800ef68:	f7fe fb8c 	bl	800d684 <move_window.part.0>
		if (res == FR_OK) {
 800ef6c:	2800      	cmp	r0, #0
 800ef6e:	f000 828a 	beq.w	800f486 <dir_register+0x632>
 800ef72:	9001      	str	r0, [sp, #4]
}
 800ef74:	9801      	ldr	r0, [sp, #4]
 800ef76:	b011      	add	sp, #68	; 0x44
 800ef78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800ef7c:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
 800ef80:	9201      	str	r2, [sp, #4]
 800ef82:	f89d 2035 	ldrb.w	r2, [sp, #53]	; 0x35
 800ef86:	9204      	str	r2, [sp, #16]
 800ef88:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 800ef8c:	9203      	str	r2, [sp, #12]
 800ef8e:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 800ef92:	9202      	str	r2, [sp, #8]
 800ef94:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
 800ef98:	f89d 103b 	ldrb.w	r1, [sp, #59]	; 0x3b
 800ef9c:	9207      	str	r2, [sp, #28]
 800ef9e:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
 800efa2:	9206      	str	r2, [sp, #24]
		for (n = 1; n < 100; n++) {
 800efa4:	f04f 0801 	mov.w	r8, #1
 800efa8:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
 800efac:	f89d 603e 	ldrb.w	r6, [sp, #62]	; 0x3e
 800efb0:	f8bd 503c 	ldrh.w	r5, [sp, #60]	; 0x3c
				if (sr & 0x10000) sr ^= 0x11021;
 800efb4:	4f1d      	ldr	r7, [pc, #116]	; (800f02c <dir_register+0x1d8>)
 800efb6:	9205      	str	r2, [sp, #20]
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800efb8:	2340      	movs	r3, #64	; 0x40
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800efba:	9409      	str	r4, [sp, #36]	; 0x24
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800efbc:	f88a 302f 	strb.w	r3, [sl, #47]	; 0x2f
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800efc0:	4644      	mov	r4, r8
 800efc2:	f04f 0920 	mov.w	r9, #32
 800efc6:	4662      	mov	r2, ip
 800efc8:	4688      	mov	r8, r1
			*d++ = *s++;
 800efca:	9901      	ldr	r1, [sp, #4]
 800efcc:	f8aa 502c 	strh.w	r5, [sl, #44]	; 0x2c
 800efd0:	2000      	movs	r0, #0
 800efd2:	4603      	mov	r3, r0
 800efd4:	f361 0007 	bfi	r0, r1, #0, #8
 800efd8:	9907      	ldr	r1, [sp, #28]
 800efda:	f88a 602e 	strb.w	r6, [sl, #46]	; 0x2e
 800efde:	f361 0307 	bfi	r3, r1, #0, #8
 800efe2:	9904      	ldr	r1, [sp, #16]
 800efe4:	f361 200f 	bfi	r0, r1, #8, #8
 800efe8:	9906      	ldr	r1, [sp, #24]
 800efea:	f361 230f 	bfi	r3, r1, #8, #8
 800efee:	9903      	ldr	r1, [sp, #12]
 800eff0:	f361 4017 	bfi	r0, r1, #16, #8
 800eff4:	9905      	ldr	r1, [sp, #20]
 800eff6:	f361 4317 	bfi	r3, r1, #16, #8
 800effa:	9902      	ldr	r1, [sp, #8]
 800effc:	f368 631f 	bfi	r3, r8, #24, #8
 800f000:	f361 601f 	bfi	r0, r1, #24, #8
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 800f004:	2c05      	cmp	r4, #5
			*d++ = *s++;
 800f006:	e9ca 0309 	strd	r0, r3, [sl, #36]	; 0x24
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 800f00a:	f240 8158 	bls.w	800f2be <dir_register+0x46a>
		while (*lfn) {	/* Create a CRC */
 800f00e:	8813      	ldrh	r3, [r2, #0]
 800f010:	2b00      	cmp	r3, #0
 800f012:	f000 8154 	beq.w	800f2be <dir_register+0x46a>
				sr = (sr << 1) + (wc & 1);
 800f016:	f003 0001 	and.w	r0, r3, #1
 800f01a:	4694      	mov	ip, r2
 800f01c:	eb00 0044 	add.w	r0, r0, r4, lsl #1
				wc >>= 1;
 800f020:	ea4f 0e53 	mov.w	lr, r3, lsr #1
				if (sr & 0x10000) sr ^= 0x11021;
 800f024:	e00d      	b.n	800f042 <dir_register+0x1ee>
 800f026:	bf00      	nop
 800f028:	4ec4ec4f 	.word	0x4ec4ec4f
 800f02c:	00011021 	.word	0x00011021
				sr = (sr << 1) + (wc & 1);
 800f030:	f003 0001 	and.w	r0, r3, #1
 800f034:	eb00 0042 	add.w	r0, r0, r2, lsl #1
				if (sr & 0x10000) sr ^= 0x11021;
 800f038:	0412      	lsls	r2, r2, #16
				wc >>= 1;
 800f03a:	ea4f 0e53 	mov.w	lr, r3, lsr #1
				if (sr & 0x10000) sr ^= 0x11021;
 800f03e:	bf48      	it	mi
 800f040:	4078      	eormi	r0, r7
				sr = (sr << 1) + (wc & 1);
 800f042:	f00e 0e01 	and.w	lr, lr, #1
 800f046:	eb0e 0e40 	add.w	lr, lr, r0, lsl #1
				wc >>= 1;
 800f04a:	0899      	lsrs	r1, r3, #2
				if (sr & 0x10000) sr ^= 0x11021;
 800f04c:	0400      	lsls	r0, r0, #16
 800f04e:	bf48      	it	mi
 800f050:	ea8e 0e07 	eormi.w	lr, lr, r7
				sr = (sr << 1) + (wc & 1);
 800f054:	f001 0101 	and.w	r1, r1, #1
 800f058:	eb01 014e 	add.w	r1, r1, lr, lsl #1
				wc >>= 1;
 800f05c:	08da      	lsrs	r2, r3, #3
				if (sr & 0x10000) sr ^= 0x11021;
 800f05e:	f41e 4f00 	tst.w	lr, #32768	; 0x8000
 800f062:	bf18      	it	ne
 800f064:	4079      	eorne	r1, r7
				sr = (sr << 1) + (wc & 1);
 800f066:	f002 0201 	and.w	r2, r2, #1
 800f06a:	eb02 0241 	add.w	r2, r2, r1, lsl #1
				wc >>= 1;
 800f06e:	0918      	lsrs	r0, r3, #4
				if (sr & 0x10000) sr ^= 0x11021;
 800f070:	0409      	lsls	r1, r1, #16
 800f072:	bf48      	it	mi
 800f074:	407a      	eormi	r2, r7
				sr = (sr << 1) + (wc & 1);
 800f076:	f000 0001 	and.w	r0, r0, #1
 800f07a:	eb00 0042 	add.w	r0, r0, r2, lsl #1
				wc >>= 1;
 800f07e:	0959      	lsrs	r1, r3, #5
				if (sr & 0x10000) sr ^= 0x11021;
 800f080:	0412      	lsls	r2, r2, #16
 800f082:	bf48      	it	mi
 800f084:	4078      	eormi	r0, r7
				sr = (sr << 1) + (wc & 1);
 800f086:	f001 0101 	and.w	r1, r1, #1
 800f08a:	eb01 0140 	add.w	r1, r1, r0, lsl #1
				wc >>= 1;
 800f08e:	099a      	lsrs	r2, r3, #6
				if (sr & 0x10000) sr ^= 0x11021;
 800f090:	0400      	lsls	r0, r0, #16
 800f092:	bf48      	it	mi
 800f094:	4079      	eormi	r1, r7
				sr = (sr << 1) + (wc & 1);
 800f096:	f002 0201 	and.w	r2, r2, #1
 800f09a:	eb02 0241 	add.w	r2, r2, r1, lsl #1
				wc >>= 1;
 800f09e:	09d8      	lsrs	r0, r3, #7
				if (sr & 0x10000) sr ^= 0x11021;
 800f0a0:	0409      	lsls	r1, r1, #16
 800f0a2:	bf48      	it	mi
 800f0a4:	407a      	eormi	r2, r7
				sr = (sr << 1) + (wc & 1);
 800f0a6:	f000 0001 	and.w	r0, r0, #1
 800f0aa:	eb00 0042 	add.w	r0, r0, r2, lsl #1
				wc >>= 1;
 800f0ae:	0a19      	lsrs	r1, r3, #8
				if (sr & 0x10000) sr ^= 0x11021;
 800f0b0:	0412      	lsls	r2, r2, #16
 800f0b2:	bf48      	it	mi
 800f0b4:	4078      	eormi	r0, r7
				sr = (sr << 1) + (wc & 1);
 800f0b6:	f001 0101 	and.w	r1, r1, #1
 800f0ba:	eb01 0140 	add.w	r1, r1, r0, lsl #1
				wc >>= 1;
 800f0be:	0a5a      	lsrs	r2, r3, #9
				if (sr & 0x10000) sr ^= 0x11021;
 800f0c0:	0400      	lsls	r0, r0, #16
 800f0c2:	bf48      	it	mi
 800f0c4:	4079      	eormi	r1, r7
				sr = (sr << 1) + (wc & 1);
 800f0c6:	f002 0201 	and.w	r2, r2, #1
 800f0ca:	eb02 0241 	add.w	r2, r2, r1, lsl #1
				wc >>= 1;
 800f0ce:	0a98      	lsrs	r0, r3, #10
				if (sr & 0x10000) sr ^= 0x11021;
 800f0d0:	0409      	lsls	r1, r1, #16
 800f0d2:	bf48      	it	mi
 800f0d4:	407a      	eormi	r2, r7
				sr = (sr << 1) + (wc & 1);
 800f0d6:	f000 0001 	and.w	r0, r0, #1
 800f0da:	eb00 0042 	add.w	r0, r0, r2, lsl #1
				wc >>= 1;
 800f0de:	0ad9      	lsrs	r1, r3, #11
				if (sr & 0x10000) sr ^= 0x11021;
 800f0e0:	0412      	lsls	r2, r2, #16
 800f0e2:	bf48      	it	mi
 800f0e4:	4078      	eormi	r0, r7
				sr = (sr << 1) + (wc & 1);
 800f0e6:	f001 0101 	and.w	r1, r1, #1
 800f0ea:	eb01 0140 	add.w	r1, r1, r0, lsl #1
				wc >>= 1;
 800f0ee:	0b1a      	lsrs	r2, r3, #12
				if (sr & 0x10000) sr ^= 0x11021;
 800f0f0:	0400      	lsls	r0, r0, #16
 800f0f2:	bf48      	it	mi
 800f0f4:	4079      	eormi	r1, r7
				sr = (sr << 1) + (wc & 1);
 800f0f6:	f002 0201 	and.w	r2, r2, #1
 800f0fa:	eb02 0241 	add.w	r2, r2, r1, lsl #1
				wc >>= 1;
 800f0fe:	0b58      	lsrs	r0, r3, #13
				if (sr & 0x10000) sr ^= 0x11021;
 800f100:	0409      	lsls	r1, r1, #16
 800f102:	bf48      	it	mi
 800f104:	407a      	eormi	r2, r7
				sr = (sr << 1) + (wc & 1);
 800f106:	f000 0001 	and.w	r0, r0, #1
 800f10a:	eb00 0042 	add.w	r0, r0, r2, lsl #1
				wc >>= 1;
 800f10e:	0b99      	lsrs	r1, r3, #14
				if (sr & 0x10000) sr ^= 0x11021;
 800f110:	0412      	lsls	r2, r2, #16
 800f112:	bf48      	it	mi
 800f114:	4078      	eormi	r0, r7
				sr = (sr << 1) + (wc & 1);
 800f116:	f001 0101 	and.w	r1, r1, #1
 800f11a:	eb01 0140 	add.w	r1, r1, r0, lsl #1
				if (sr & 0x10000) sr ^= 0x11021;
 800f11e:	0400      	lsls	r0, r0, #16
				wc >>= 1;
 800f120:	ea4f 33d3 	mov.w	r3, r3, lsr #15
				if (sr & 0x10000) sr ^= 0x11021;
 800f124:	bf48      	it	mi
 800f126:	4079      	eormi	r1, r7
				sr = (sr << 1) + (wc & 1);
 800f128:	eb03 0241 	add.w	r2, r3, r1, lsl #1
		while (*lfn) {	/* Create a CRC */
 800f12c:	f83c 3f02 	ldrh.w	r3, [ip, #2]!
				if (sr & 0x10000) sr ^= 0x11021;
 800f130:	0409      	lsls	r1, r1, #16
 800f132:	bf48      	it	mi
 800f134:	407a      	eormi	r2, r7
		while (*lfn) {	/* Create a CRC */
 800f136:	2b00      	cmp	r3, #0
 800f138:	f47f af7a 	bne.w	800f030 <dir_register+0x1dc>
		c = (BYTE)((seq % 16) + '0');
 800f13c:	f002 000f 	and.w	r0, r2, #15
 800f140:	f100 0330 	add.w	r3, r0, #48	; 0x30
		if (c > '9') c += 7;
 800f144:	2b39      	cmp	r3, #57	; 0x39
 800f146:	bf88      	it	hi
 800f148:	f100 0337 	addhi.w	r3, r0, #55	; 0x37
	} while (seq);
 800f14c:	2a0f      	cmp	r2, #15
		ns[i--] = c;
 800f14e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		seq /= 16;
 800f152:	ea4f 1012 	mov.w	r0, r2, lsr #4
	} while (seq);
 800f156:	f240 8149 	bls.w	800f3ec <dir_register+0x598>
		c = (BYTE)((seq % 16) + '0');
 800f15a:	f000 0c0f 	and.w	ip, r0, #15
 800f15e:	f10c 0330 	add.w	r3, ip, #48	; 0x30
		if (c > '9') c += 7;
 800f162:	2b39      	cmp	r3, #57	; 0x39
 800f164:	bf88      	it	hi
 800f166:	f10c 0337 	addhi.w	r3, ip, #55	; 0x37
	} while (seq);
 800f16a:	280f      	cmp	r0, #15
		ns[i--] = c;
 800f16c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
		seq /= 16;
 800f170:	ea4f 2c12 	mov.w	ip, r2, lsr #8
	} while (seq);
 800f174:	f240 813f 	bls.w	800f3f6 <dir_register+0x5a2>
		c = (BYTE)((seq % 16) + '0');
 800f178:	f00c 000f 	and.w	r0, ip, #15
 800f17c:	f100 0330 	add.w	r3, r0, #48	; 0x30
		if (c > '9') c += 7;
 800f180:	2b39      	cmp	r3, #57	; 0x39
 800f182:	bf88      	it	hi
 800f184:	f100 0337 	addhi.w	r3, r0, #55	; 0x37
	} while (seq);
 800f188:	f1bc 0f0f 	cmp.w	ip, #15
		ns[i--] = c;
 800f18c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		seq /= 16;
 800f190:	ea4f 3012 	mov.w	r0, r2, lsr #12
	} while (seq);
 800f194:	f240 8134 	bls.w	800f400 <dir_register+0x5ac>
		c = (BYTE)((seq % 16) + '0');
 800f198:	f000 0c0f 	and.w	ip, r0, #15
 800f19c:	f10c 0330 	add.w	r3, ip, #48	; 0x30
		if (c > '9') c += 7;
 800f1a0:	2b39      	cmp	r3, #57	; 0x39
 800f1a2:	bf88      	it	hi
 800f1a4:	f10c 0337 	addhi.w	r3, ip, #55	; 0x37
	} while (seq);
 800f1a8:	280f      	cmp	r0, #15
		ns[i--] = c;
 800f1aa:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		seq /= 16;
 800f1ae:	ea4f 4c12 	mov.w	ip, r2, lsr #16
	} while (seq);
 800f1b2:	f240 812a 	bls.w	800f40a <dir_register+0x5b6>
		c = (BYTE)((seq % 16) + '0');
 800f1b6:	f00c 000f 	and.w	r0, ip, #15
 800f1ba:	f100 0330 	add.w	r3, r0, #48	; 0x30
		if (c > '9') c += 7;
 800f1be:	2b39      	cmp	r3, #57	; 0x39
 800f1c0:	bf88      	it	hi
 800f1c2:	f100 0337 	addhi.w	r3, r0, #55	; 0x37
	} while (seq);
 800f1c6:	f1bc 0f0f 	cmp.w	ip, #15
		ns[i--] = c;
 800f1ca:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
		seq /= 16;
 800f1ce:	ea4f 5012 	mov.w	r0, r2, lsr #20
	} while (seq);
 800f1d2:	f240 8148 	bls.w	800f466 <dir_register+0x612>
		c = (BYTE)((seq % 16) + '0');
 800f1d6:	f000 0c0f 	and.w	ip, r0, #15
 800f1da:	f10c 0330 	add.w	r3, ip, #48	; 0x30
		if (c > '9') c += 7;
 800f1de:	2b39      	cmp	r3, #57	; 0x39
 800f1e0:	bf88      	it	hi
 800f1e2:	f10c 0337 	addhi.w	r3, ip, #55	; 0x37
	} while (seq);
 800f1e6:	280f      	cmp	r0, #15
		ns[i--] = c;
 800f1e8:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
		seq /= 16;
 800f1ec:	ea4f 6c12 	mov.w	ip, r2, lsr #24
	} while (seq);
 800f1f0:	f240 813e 	bls.w	800f470 <dir_register+0x61c>
		c = (BYTE)((seq % 16) + '0');
 800f1f4:	f00c 000f 	and.w	r0, ip, #15
 800f1f8:	f100 0330 	add.w	r3, r0, #48	; 0x30
		if (c > '9') c += 7;
 800f1fc:	2b39      	cmp	r3, #57	; 0x39
 800f1fe:	bf88      	it	hi
 800f200:	f100 0337 	addhi.w	r3, r0, #55	; 0x37
	} while (seq);
 800f204:	f1bc 0f0f 	cmp.w	ip, #15
		ns[i--] = c;
 800f208:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
		seq /= 16;
 800f20c:	ea4f 7212 	mov.w	r2, r2, lsr #28
	} while (seq);
 800f210:	d957      	bls.n	800f2c2 <dir_register+0x46e>
		c = (BYTE)((seq % 16) + '0');
 800f212:	f102 0330 	add.w	r3, r2, #48	; 0x30
		if (c > '9') c += 7;
 800f216:	2b39      	cmp	r3, #57	; 0x39
		c = (BYTE)((seq % 16) + '0');
 800f218:	b2d2      	uxtb	r2, r2
		if (c > '9') c += 7;
 800f21a:	bf88      	it	hi
 800f21c:	f102 0337 	addhi.w	r3, r2, #55	; 0x37
		ns[i--] = c;
 800f220:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
 800f224:	f04f 32ff 	mov.w	r2, #4294967295
 800f228:	f10a 0023 	add.w	r0, sl, #35	; 0x23
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800f22c:	2300      	movs	r3, #0
 800f22e:	e002      	b.n	800f236 <dir_register+0x3e2>
 800f230:	3301      	adds	r3, #1
 800f232:	4293      	cmp	r3, r2
 800f234:	d003      	beq.n	800f23e <dir_register+0x3ea>
 800f236:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 800f23a:	2920      	cmp	r1, #32
 800f23c:	d1f8      	bne.n	800f230 <dir_register+0x3dc>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f23e:	2a07      	cmp	r2, #7
 800f240:	d944      	bls.n	800f2cc <dir_register+0x478>
 800f242:	1c58      	adds	r0, r3, #1
	} while (j < 8);
 800f244:	2807      	cmp	r0, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f246:	f80b 9003 	strb.w	r9, [fp, r3]
	} while (j < 8);
 800f24a:	d82c      	bhi.n	800f2a6 <dir_register+0x452>
 800f24c:	2807      	cmp	r0, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f24e:	f80b 9000 	strb.w	r9, [fp, r0]
 800f252:	f100 0c01 	add.w	ip, r0, #1
	} while (j < 8);
 800f256:	d026      	beq.n	800f2a6 <dir_register+0x452>
 800f258:	f1bc 0f07 	cmp.w	ip, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f25c:	f80b 900c 	strb.w	r9, [fp, ip]
 800f260:	f10c 0001 	add.w	r0, ip, #1
	} while (j < 8);
 800f264:	d01f      	beq.n	800f2a6 <dir_register+0x452>
 800f266:	2807      	cmp	r0, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f268:	f80b 9000 	strb.w	r9, [fp, r0]
 800f26c:	f100 0c01 	add.w	ip, r0, #1
	} while (j < 8);
 800f270:	d019      	beq.n	800f2a6 <dir_register+0x452>
 800f272:	f1bc 0f07 	cmp.w	ip, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f276:	f80b 900c 	strb.w	r9, [fp, ip]
 800f27a:	f10c 0001 	add.w	r0, ip, #1
	} while (j < 8);
 800f27e:	d012      	beq.n	800f2a6 <dir_register+0x452>
 800f280:	2807      	cmp	r0, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f282:	f80b 9000 	strb.w	r9, [fp, r0]
 800f286:	f100 0c01 	add.w	ip, r0, #1
	} while (j < 8);
 800f28a:	d00c      	beq.n	800f2a6 <dir_register+0x452>
 800f28c:	f1bc 0f07 	cmp.w	ip, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f290:	f80b 900c 	strb.w	r9, [fp, ip]
 800f294:	f10c 0001 	add.w	r0, ip, #1
	} while (j < 8);
 800f298:	d005      	beq.n	800f2a6 <dir_register+0x452>
 800f29a:	2806      	cmp	r0, #6
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f29c:	f80b 9000 	strb.w	r9, [fp, r0]
	} while (j < 8);
 800f2a0:	d101      	bne.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f2a2:	f88a 902b 	strb.w	r9, [sl, #43]	; 0x2b
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 800f2a6:	4650      	mov	r0, sl
 800f2a8:	f7ff fa0c 	bl	800e6c4 <dir_find>
			if (res != FR_OK) break;
 800f2ac:	2800      	cmp	r0, #0
 800f2ae:	d17c      	bne.n	800f3aa <dir_register+0x556>
		for (n = 1; n < 100; n++) {
 800f2b0:	3401      	adds	r4, #1
 800f2b2:	2c64      	cmp	r4, #100	; 0x64
 800f2b4:	f000 8094 	beq.w	800f3e0 <dir_register+0x58c>
 800f2b8:	9b00      	ldr	r3, [sp, #0]
 800f2ba:	68da      	ldr	r2, [r3, #12]
 800f2bc:	e685      	b.n	800efca <dir_register+0x176>
 800f2be:	4622      	mov	r2, r4
 800f2c0:	e73c      	b.n	800f13c <dir_register+0x2e8>
	ns[i] = '~';
 800f2c2:	237e      	movs	r3, #126	; 0x7e
 800f2c4:	2200      	movs	r2, #0
 800f2c6:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800f2ca:	4613      	mov	r3, r2
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f2cc:	a910      	add	r1, sp, #64	; 0x40
 800f2ce:	eb01 0c02 	add.w	ip, r1, r2
 800f2d2:	1c58      	adds	r0, r3, #1
 800f2d4:	f81c cc14 	ldrb.w	ip, [ip, #-20]
 800f2d8:	f80b c003 	strb.w	ip, [fp, r3]
	} while (j < 8);
 800f2dc:	2807      	cmp	r0, #7
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f2de:	f102 0c01 	add.w	ip, r2, #1
	} while (j < 8);
 800f2e2:	d8e0      	bhi.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f2e4:	f1bc 0f07 	cmp.w	ip, #7
 800f2e8:	d8b0      	bhi.n	800f24c <dir_register+0x3f8>
 800f2ea:	448c      	add	ip, r1
	} while (j < 8);
 800f2ec:	2b06      	cmp	r3, #6
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f2ee:	f81c cc14 	ldrb.w	ip, [ip, #-20]
 800f2f2:	f80b c000 	strb.w	ip, [fp, r0]
 800f2f6:	f102 0e02 	add.w	lr, r2, #2
 800f2fa:	f103 0c02 	add.w	ip, r3, #2
	} while (j < 8);
 800f2fe:	d0d2      	beq.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f300:	f1be 0f08 	cmp.w	lr, #8
 800f304:	d0a8      	beq.n	800f258 <dir_register+0x404>
 800f306:	eb01 000e 	add.w	r0, r1, lr
	} while (j < 8);
 800f30a:	2b05      	cmp	r3, #5
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f30c:	f810 0c14 	ldrb.w	r0, [r0, #-20]
 800f310:	f80b 000c 	strb.w	r0, [fp, ip]
 800f314:	f102 0e03 	add.w	lr, r2, #3
 800f318:	f103 0003 	add.w	r0, r3, #3
	} while (j < 8);
 800f31c:	d0c3      	beq.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f31e:	f1be 0f07 	cmp.w	lr, #7
 800f322:	d8a0      	bhi.n	800f266 <dir_register+0x412>
 800f324:	eb01 0c0e 	add.w	ip, r1, lr
	} while (j < 8);
 800f328:	2b04      	cmp	r3, #4
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f32a:	f81c cc14 	ldrb.w	ip, [ip, #-20]
 800f32e:	f80b c000 	strb.w	ip, [fp, r0]
 800f332:	f102 0e04 	add.w	lr, r2, #4
 800f336:	f103 0c04 	add.w	ip, r3, #4
	} while (j < 8);
 800f33a:	d0b4      	beq.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f33c:	f1be 0f08 	cmp.w	lr, #8
 800f340:	d097      	beq.n	800f272 <dir_register+0x41e>
 800f342:	eb01 000e 	add.w	r0, r1, lr
	} while (j < 8);
 800f346:	2b03      	cmp	r3, #3
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f348:	f810 0c14 	ldrb.w	r0, [r0, #-20]
 800f34c:	f80b 000c 	strb.w	r0, [fp, ip]
 800f350:	f102 0e05 	add.w	lr, r2, #5
 800f354:	f103 0005 	add.w	r0, r3, #5
	} while (j < 8);
 800f358:	d0a5      	beq.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f35a:	f1be 0f07 	cmp.w	lr, #7
 800f35e:	d88f      	bhi.n	800f280 <dir_register+0x42c>
 800f360:	eb01 0c0e 	add.w	ip, r1, lr
	} while (j < 8);
 800f364:	2b02      	cmp	r3, #2
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f366:	f81c cc14 	ldrb.w	ip, [ip, #-20]
 800f36a:	f80b c000 	strb.w	ip, [fp, r0]
 800f36e:	f102 0e06 	add.w	lr, r2, #6
 800f372:	f103 0c06 	add.w	ip, r3, #6
	} while (j < 8);
 800f376:	d096      	beq.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f378:	f1be 0f08 	cmp.w	lr, #8
 800f37c:	d086      	beq.n	800f28c <dir_register+0x438>
 800f37e:	448e      	add	lr, r1
	} while (j < 8);
 800f380:	2b01      	cmp	r3, #1
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f382:	f81e ec14 	ldrb.w	lr, [lr, #-20]
 800f386:	f80b e00c 	strb.w	lr, [fp, ip]
 800f38a:	f103 0007 	add.w	r0, r3, #7
	} while (j < 8);
 800f38e:	d08a      	beq.n	800f2a6 <dir_register+0x452>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800f390:	2a00      	cmp	r2, #0
 800f392:	d182      	bne.n	800f29a <dir_register+0x446>
 800f394:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 800f398:	f80b 3000 	strb.w	r3, [fp, r0]
	} while (j < 8);
 800f39c:	2806      	cmp	r0, #6
 800f39e:	d080      	beq.n	800f2a2 <dir_register+0x44e>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 800f3a0:	4650      	mov	r0, sl
 800f3a2:	f7ff f98f 	bl	800e6c4 <dir_find>
			if (res != FR_OK) break;
 800f3a6:	2800      	cmp	r0, #0
 800f3a8:	d082      	beq.n	800f2b0 <dir_register+0x45c>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 800f3aa:	2804      	cmp	r0, #4
 800f3ac:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800f3ae:	9001      	str	r0, [sp, #4]
 800f3b0:	d118      	bne.n	800f3e4 <dir_register+0x590>
		dp->fn[NSFLAG] = sn[NSFLAG];
 800f3b2:	9b08      	ldr	r3, [sp, #32]
 800f3b4:	f88a 302f 	strb.w	r3, [sl, #47]	; 0x2f
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800f3b8:	f013 0302 	ands.w	r3, r3, #2
 800f3bc:	f8da 9000 	ldr.w	r9, [sl]
 800f3c0:	f47f ad73 	bne.w	800eeaa <dir_register+0x56>
 800f3c4:	9302      	str	r3, [sp, #8]
	res = dir_sdi(dp, 0);
 800f3c6:	2100      	movs	r1, #0
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800f3c8:	2301      	movs	r3, #1
	res = dir_sdi(dp, 0);
 800f3ca:	4650      	mov	r0, sl
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 800f3cc:	461c      	mov	r4, r3
	res = dir_sdi(dp, 0);
 800f3ce:	f7ff f8b3 	bl	800e538 <dir_sdi>
	if (res == FR_OK) {
 800f3d2:	9001      	str	r0, [sp, #4]
 800f3d4:	2800      	cmp	r0, #0
 800f3d6:	f43f ad78 	beq.w	800eeca <dir_register+0x76>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 800f3da:	9b01      	ldr	r3, [sp, #4]
 800f3dc:	2b04      	cmp	r3, #4
 800f3de:	d101      	bne.n	800f3e4 <dir_register+0x590>
 800f3e0:	2307      	movs	r3, #7
 800f3e2:	9301      	str	r3, [sp, #4]
}
 800f3e4:	9801      	ldr	r0, [sp, #4]
 800f3e6:	b011      	add	sp, #68	; 0x44
 800f3e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ns[i] = '~';
 800f3ec:	237e      	movs	r3, #126	; 0x7e
 800f3ee:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
		ns[i--] = c;
 800f3f2:	2206      	movs	r2, #6
 800f3f4:	e718      	b.n	800f228 <dir_register+0x3d4>
	ns[i] = '~';
 800f3f6:	237e      	movs	r3, #126	; 0x7e
 800f3f8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		ns[i--] = c;
 800f3fc:	2205      	movs	r2, #5
 800f3fe:	e713      	b.n	800f228 <dir_register+0x3d4>
	ns[i] = '~';
 800f400:	237e      	movs	r3, #126	; 0x7e
 800f402:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		ns[i--] = c;
 800f406:	2204      	movs	r2, #4
 800f408:	e70e      	b.n	800f228 <dir_register+0x3d4>
	ns[i] = '~';
 800f40a:	237e      	movs	r3, #126	; 0x7e
 800f40c:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
		ns[i--] = c;
 800f410:	2203      	movs	r2, #3
 800f412:	e709      	b.n	800f228 <dir_register+0x3d4>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 800f414:	8972      	ldrh	r2, [r6, #10]
 800f416:	3a01      	subs	r2, #1
 800f418:	ea12 2254 	ands.w	r2, r2, r4, lsr #9
 800f41c:	f47f ad7d 	bne.w	800ef1a <dir_register+0xc6>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800f420:	4619      	mov	r1, r3
 800f422:	4630      	mov	r0, r6
 800f424:	f7fe fa04 	bl	800d830 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800f428:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800f42a:	9004      	str	r0, [sp, #16]
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800f42c:	f240 8251 	bls.w	800f8d2 <dir_register+0xa7e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800f430:	1c42      	adds	r2, r0, #1
 800f432:	f000 81c9 	beq.w	800f7c8 <dir_register+0x974>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800f436:	69b3      	ldr	r3, [r6, #24]
 800f438:	4298      	cmp	r0, r3
 800f43a:	f080 81d3 	bcs.w	800f7e4 <dir_register+0x990>
 800f43e:	1e82      	subs	r2, r0, #2
 800f440:	3b02      	subs	r3, #2
 800f442:	9205      	str	r2, [sp, #20]
 800f444:	f106 0534 	add.w	r5, r6, #52	; 0x34
				dp->clust = clst;		/* Initialize data for new cluster */
 800f448:	9a04      	ldr	r2, [sp, #16]
 800f44a:	f8ca 2018 	str.w	r2, [sl, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f44e:	9a05      	ldr	r2, [sp, #20]
 800f450:	4293      	cmp	r3, r2
 800f452:	4611      	mov	r1, r2
	return clst * fs->csize + fs->database;
 800f454:	bf85      	ittet	hi
 800f456:	6af3      	ldrhi	r3, [r6, #44]	; 0x2c
 800f458:	8971      	ldrhhi	r1, [r6, #10]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f45a:	2100      	movls	r1, #0
	return clst * fs->csize + fs->database;
 800f45c:	fb02 3101 	mlahi	r1, r2, r1, r3
				dp->sect = clust2sect(fs, clst);
 800f460:	f8ca 101c 	str.w	r1, [sl, #28]
 800f464:	e55b      	b.n	800ef1e <dir_register+0xca>
	ns[i] = '~';
 800f466:	237e      	movs	r3, #126	; 0x7e
 800f468:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
		ns[i--] = c;
 800f46c:	2202      	movs	r2, #2
 800f46e:	e6db      	b.n	800f228 <dir_register+0x3d4>
	ns[i] = '~';
 800f470:	237e      	movs	r3, #126	; 0x7e
 800f472:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
		ns[i--] = c;
 800f476:	2201      	movs	r2, #1
 800f478:	e6d6      	b.n	800f228 <dir_register+0x3d4>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 800f47a:	2306      	movs	r3, #6
 800f47c:	9301      	str	r3, [sp, #4]
}
 800f47e:	9801      	ldr	r0, [sp, #4]
 800f480:	b011      	add	sp, #68	; 0x44
 800f482:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	BYTE *d = (BYTE*)dst;
 800f486:	2220      	movs	r2, #32
 800f488:	f8da 0020 	ldr.w	r0, [sl, #32]
 800f48c:	2100      	movs	r1, #0
 800f48e:	f006 fd7f 	bl	8015f90 <memset>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800f492:	f8da 3020 	ldr.w	r3, [sl, #32]
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800f496:	1d1a      	adds	r2, r3, #4
 800f498:	4593      	cmp	fp, r2
 800f49a:	d204      	bcs.n	800f4a6 <dir_register+0x652>
 800f49c:	f10a 0228 	add.w	r2, sl, #40	; 0x28
 800f4a0:	4293      	cmp	r3, r2
 800f4a2:	f0c0 81fd 	bcc.w	800f8a0 <dir_register+0xa4c>
			*d++ = *s++;
 800f4a6:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 800f4aa:	601a      	str	r2, [r3, #0]
 800f4ac:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
 800f4b0:	605a      	str	r2, [r3, #4]
 800f4b2:	f89a 202c 	ldrb.w	r2, [sl, #44]	; 0x2c
 800f4b6:	721a      	strb	r2, [r3, #8]
 800f4b8:	f89a 202d 	ldrb.w	r2, [sl, #45]	; 0x2d
 800f4bc:	725a      	strb	r2, [r3, #9]
 800f4be:	f89a 202e 	ldrb.w	r2, [sl, #46]	; 0x2e
 800f4c2:	729a      	strb	r2, [r3, #10]
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 800f4c4:	f89a 302f 	ldrb.w	r3, [sl, #47]	; 0x2f
 800f4c8:	f8da 1020 	ldr.w	r1, [sl, #32]
}
 800f4cc:	9801      	ldr	r0, [sp, #4]
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 800f4ce:	f003 0318 	and.w	r3, r3, #24
 800f4d2:	730b      	strb	r3, [r1, #12]
			fs->wflag = 1;
 800f4d4:	9b00      	ldr	r3, [sp, #0]
 800f4d6:	2201      	movs	r2, #1
 800f4d8:	70da      	strb	r2, [r3, #3]
}
 800f4da:	b011      	add	sp, #68	; 0x44
 800f4dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 800f4e0:	f8da 1014 	ldr.w	r1, [sl, #20]
 800f4e4:	4650      	mov	r0, sl
 800f4e6:	eba1 1143 	sub.w	r1, r1, r3, lsl #5
 800f4ea:	461e      	mov	r6, r3
 800f4ec:	f7ff f824 	bl	800e538 <dir_sdi>
		if (res == FR_OK) {
 800f4f0:	2800      	cmp	r0, #0
 800f4f2:	f47f ad3e 	bne.w	800ef72 <dir_register+0x11e>
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800f4f6:	f89a 2024 	ldrb.w	r2, [sl, #36]	; 0x24
 800f4fa:	f89a 4025 	ldrb.w	r4, [sl, #37]	; 0x25
 800f4fe:	f89a 1026 	ldrb.w	r1, [sl, #38]	; 0x26
	*ptr++ = (BYTE)val; val >>= 8;
 800f502:	9602      	str	r6, [sp, #8]
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800f504:	01d3      	lsls	r3, r2, #7
 800f506:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 800f50a:	191a      	adds	r2, r3, r4
 800f50c:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f510:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f514:	fa51 f283 	uxtab	r2, r1, r3
 800f518:	f89a 4027 	ldrb.w	r4, [sl, #39]	; 0x27
 800f51c:	f89a 1028 	ldrb.w	r1, [sl, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
 800f520:	9f00      	ldr	r7, [sp, #0]
 800f522:	f8cd b00c 	str.w	fp, [sp, #12]
		sum = (sum >> 1) + (sum << 7) + *dir++;
 800f526:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f52a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f52e:	fa54 f283 	uxtab	r2, r4, r3
 800f532:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f536:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f53a:	fa51 f283 	uxtab	r2, r1, r3
 800f53e:	f89a 4029 	ldrb.w	r4, [sl, #41]	; 0x29
 800f542:	f89a 102a 	ldrb.w	r1, [sl, #42]	; 0x2a
 800f546:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f54a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f54e:	fa54 f283 	uxtab	r2, r4, r3
 800f552:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f556:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f55a:	fa51 f283 	uxtab	r2, r1, r3
 800f55e:	f89a 402b 	ldrb.w	r4, [sl, #43]	; 0x2b
 800f562:	f89a 102c 	ldrb.w	r1, [sl, #44]	; 0x2c
 800f566:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f56a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f56e:	fa54 f283 	uxtab	r2, r4, r3
 800f572:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f576:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f57a:	fa51 f283 	uxtab	r2, r1, r3
 800f57e:	f89a 402d 	ldrb.w	r4, [sl, #45]	; 0x2d
 800f582:	f89a 102e 	ldrb.w	r1, [sl, #46]	; 0x2e
 800f586:	f3c2 0346 	ubfx	r3, r2, #1, #7
 800f58a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 800f58e:	fa54 f383 	uxtab	r3, r4, r3
 800f592:	f3c3 0846 	ubfx	r8, r3, #1, #7
 800f596:	ea48 18c3 	orr.w	r8, r8, r3, lsl #7
 800f59a:	fa51 f888 	uxtab	r8, r1, r8
 800f59e:	fa5f f888 	uxtb.w	r8, r8
	dir[LDIR_Type] = 0;
 800f5a2:	4605      	mov	r5, r0
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 800f5a4:	f04f 090f 	mov.w	r9, #15
	*ptr++ = (BYTE)val; val >>= 8;
 800f5a8:	24ff      	movs	r4, #255	; 0xff
 800f5aa:	4646      	mov	r6, r8
 800f5ac:	e027      	b.n	800f5fe <dir_register+0x7aa>
 800f5ae:	70dc      	strb	r4, [r3, #3]
	*ptr++ = (BYTE)val;
 800f5b0:	711c      	strb	r4, [r3, #4]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5b2:	715c      	strb	r4, [r3, #5]
	*ptr++ = (BYTE)val;
 800f5b4:	719c      	strb	r4, [r3, #6]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5b6:	71dc      	strb	r4, [r3, #7]
	*ptr++ = (BYTE)val;
 800f5b8:	721c      	strb	r4, [r3, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5ba:	725c      	strb	r4, [r3, #9]
	*ptr++ = (BYTE)val;
 800f5bc:	729c      	strb	r4, [r3, #10]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5be:	739c      	strb	r4, [r3, #14]
	*ptr++ = (BYTE)val;
 800f5c0:	73dc      	strb	r4, [r3, #15]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5c2:	741c      	strb	r4, [r3, #16]
	*ptr++ = (BYTE)val;
 800f5c4:	745c      	strb	r4, [r3, #17]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5c6:	749c      	strb	r4, [r3, #18]
	*ptr++ = (BYTE)val;
 800f5c8:	74dc      	strb	r4, [r3, #19]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5ca:	751c      	strb	r4, [r3, #20]
	*ptr++ = (BYTE)val;
 800f5cc:	755c      	strb	r4, [r3, #21]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5ce:	759c      	strb	r4, [r3, #22]
	*ptr++ = (BYTE)val;
 800f5d0:	75dc      	strb	r4, [r3, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5d2:	761c      	strb	r4, [r3, #24]
	*ptr++ = (BYTE)val;
 800f5d4:	765c      	strb	r4, [r3, #25]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5d6:	771c      	strb	r4, [r3, #28]
	*ptr++ = (BYTE)val;
 800f5d8:	775c      	strb	r4, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 800f5da:	779c      	strb	r4, [r3, #30]
	*ptr++ = (BYTE)val;
 800f5dc:	77dc      	strb	r4, [r3, #31]
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 800f5de:	f040 0040 	orr.w	r0, r0, #64	; 0x40
				fs->wflag = 1;
 800f5e2:	2201      	movs	r2, #1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 800f5e4:	7018      	strb	r0, [r3, #0]
				res = dir_next(dp, 0);	/* Next entry */
 800f5e6:	4650      	mov	r0, sl
				fs->wflag = 1;
 800f5e8:	70fa      	strb	r2, [r7, #3]
				res = dir_next(dp, 0);	/* Next entry */
 800f5ea:	f7fe f98d 	bl	800d908 <dir_next.constprop.0>
			} while (res == FR_OK && --nent);
 800f5ee:	2800      	cmp	r0, #0
 800f5f0:	f47f acbf 	bne.w	800ef72 <dir_register+0x11e>
 800f5f4:	9b02      	ldr	r3, [sp, #8]
 800f5f6:	3b01      	subs	r3, #1
 800f5f8:	9302      	str	r3, [sp, #8]
 800f5fa:	f000 816d 	beq.w	800f8d8 <dir_register+0xa84>
				res = move_window(fs, dp->sect);
 800f5fe:	f8da 101c 	ldr.w	r1, [sl, #28]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800f602:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f604:	4299      	cmp	r1, r3
 800f606:	d005      	beq.n	800f614 <dir_register+0x7c0>
 800f608:	4638      	mov	r0, r7
 800f60a:	f7fe f83b 	bl	800d684 <move_window.part.0>
				if (res != FR_OK) break;
 800f60e:	2800      	cmp	r0, #0
 800f610:	f47f acaf 	bne.w	800ef72 <dir_register+0x11e>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 800f614:	f89d 0008 	ldrb.w	r0, [sp, #8]
 800f618:	f8da 3020 	ldr.w	r3, [sl, #32]
 800f61c:	68f9      	ldr	r1, [r7, #12]
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 800f61e:	735e      	strb	r6, [r3, #13]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 800f620:	1e42      	subs	r2, r0, #1
 800f622:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800f626:	eb02 028c 	add.w	r2, r2, ip, lsl #2
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 800f62a:	f883 900b 	strb.w	r9, [r3, #11]
	dir[LDIR_Type] = 0;
 800f62e:	731d      	strb	r5, [r3, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800f630:	769d      	strb	r5, [r3, #26]
	*ptr++ = (BYTE)val;
 800f632:	76dd      	strb	r5, [r3, #27]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f634:	f831 c012 	ldrh.w	ip, [r1, r2, lsl #1]
	*ptr++ = (BYTE)val; val >>= 8;
 800f638:	f883 c001 	strb.w	ip, [r3, #1]
 800f63c:	ea4f 2e1c 	mov.w	lr, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f640:	f883 e002 	strb.w	lr, [r3, #2]
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f644:	ea4f 0e42 	mov.w	lr, r2, lsl #1
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f648:	f1bc 0f00 	cmp.w	ip, #0
 800f64c:	d0af      	beq.n	800f5ae <dir_register+0x75a>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f64e:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800f652:	45c4      	cmp	ip, r8
 800f654:	d0ab      	beq.n	800f5ae <dir_register+0x75a>
 800f656:	3201      	adds	r2, #1
 800f658:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 800f65c:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
	*ptr++ = (BYTE)val; val >>= 8;
 800f660:	70da      	strb	r2, [r3, #3]
 800f662:	ea4f 2b12 	mov.w	fp, r2, lsr #8
	*ptr++ = (BYTE)val;
 800f666:	f883 b004 	strb.w	fp, [r3, #4]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f66a:	2a00      	cmp	r2, #0
 800f66c:	d0a1      	beq.n	800f5b2 <dir_register+0x75e>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f66e:	4542      	cmp	r2, r8
 800f670:	d09f      	beq.n	800f5b2 <dir_register+0x75e>
 800f672:	eb01 020c 	add.w	r2, r1, ip
 800f676:	f8b2 c002 	ldrh.w	ip, [r2, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 800f67a:	f883 c005 	strb.w	ip, [r3, #5]
 800f67e:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f682:	f883 b006 	strb.w	fp, [r3, #6]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f686:	f1bc 0f00 	cmp.w	ip, #0
 800f68a:	d094      	beq.n	800f5b6 <dir_register+0x762>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f68c:	45c4      	cmp	ip, r8
 800f68e:	d092      	beq.n	800f5b6 <dir_register+0x762>
 800f690:	f8b2 c004 	ldrh.w	ip, [r2, #4]
	*ptr++ = (BYTE)val; val >>= 8;
 800f694:	f883 c007 	strb.w	ip, [r3, #7]
 800f698:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f69c:	f883 b008 	strb.w	fp, [r3, #8]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f6a0:	f1bc 0f00 	cmp.w	ip, #0
 800f6a4:	d089      	beq.n	800f5ba <dir_register+0x766>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f6a6:	45c4      	cmp	ip, r8
 800f6a8:	d087      	beq.n	800f5ba <dir_register+0x766>
 800f6aa:	f8b2 c006 	ldrh.w	ip, [r2, #6]
	*ptr++ = (BYTE)val; val >>= 8;
 800f6ae:	f883 c009 	strb.w	ip, [r3, #9]
 800f6b2:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f6b6:	f883 b00a 	strb.w	fp, [r3, #10]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f6ba:	f1bc 0f00 	cmp.w	ip, #0
 800f6be:	f43f af7e 	beq.w	800f5be <dir_register+0x76a>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f6c2:	45c4      	cmp	ip, r8
 800f6c4:	f43f af7b 	beq.w	800f5be <dir_register+0x76a>
 800f6c8:	f8b2 c008 	ldrh.w	ip, [r2, #8]
	*ptr++ = (BYTE)val; val >>= 8;
 800f6cc:	f883 c00e 	strb.w	ip, [r3, #14]
 800f6d0:	ea4f 281c 	mov.w	r8, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f6d4:	f883 800f 	strb.w	r8, [r3, #15]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f6d8:	f1bc 0f00 	cmp.w	ip, #0
 800f6dc:	f43f af71 	beq.w	800f5c2 <dir_register+0x76e>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f6e0:	f64f 78ff 	movw	r8, #65535	; 0xffff
 800f6e4:	45c4      	cmp	ip, r8
 800f6e6:	f43f af6c 	beq.w	800f5c2 <dir_register+0x76e>
 800f6ea:	f8b2 c00a 	ldrh.w	ip, [r2, #10]
	*ptr++ = (BYTE)val; val >>= 8;
 800f6ee:	f883 c010 	strb.w	ip, [r3, #16]
 800f6f2:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f6f6:	f883 b011 	strb.w	fp, [r3, #17]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f6fa:	f1bc 0f00 	cmp.w	ip, #0
 800f6fe:	f43f af62 	beq.w	800f5c6 <dir_register+0x772>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f702:	45c4      	cmp	ip, r8
 800f704:	f43f af5f 	beq.w	800f5c6 <dir_register+0x772>
 800f708:	f8b2 c00c 	ldrh.w	ip, [r2, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800f70c:	f883 c012 	strb.w	ip, [r3, #18]
 800f710:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f714:	f883 b013 	strb.w	fp, [r3, #19]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f718:	f1bc 0f00 	cmp.w	ip, #0
 800f71c:	f43f af55 	beq.w	800f5ca <dir_register+0x776>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f720:	45c4      	cmp	ip, r8
 800f722:	f43f af52 	beq.w	800f5ca <dir_register+0x776>
 800f726:	f8b2 c00e 	ldrh.w	ip, [r2, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 800f72a:	f883 c014 	strb.w	ip, [r3, #20]
 800f72e:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f732:	f883 b015 	strb.w	fp, [r3, #21]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f736:	f1bc 0f00 	cmp.w	ip, #0
 800f73a:	f43f af48 	beq.w	800f5ce <dir_register+0x77a>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f73e:	45c4      	cmp	ip, r8
 800f740:	f43f af45 	beq.w	800f5ce <dir_register+0x77a>
 800f744:	f8b2 c010 	ldrh.w	ip, [r2, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 800f748:	f883 c016 	strb.w	ip, [r3, #22]
 800f74c:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f750:	f883 b017 	strb.w	fp, [r3, #23]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f754:	f1bc 0f00 	cmp.w	ip, #0
 800f758:	f43f af3b 	beq.w	800f5d2 <dir_register+0x77e>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f75c:	45c4      	cmp	ip, r8
 800f75e:	f43f af38 	beq.w	800f5d2 <dir_register+0x77e>
 800f762:	f8b2 c012 	ldrh.w	ip, [r2, #18]
	*ptr++ = (BYTE)val; val >>= 8;
 800f766:	f883 c018 	strb.w	ip, [r3, #24]
 800f76a:	ea4f 281c 	mov.w	r8, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f76e:	f883 8019 	strb.w	r8, [r3, #25]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f772:	f1bc 0f00 	cmp.w	ip, #0
 800f776:	f43f af2e 	beq.w	800f5d6 <dir_register+0x782>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f77a:	f64f 7bff 	movw	fp, #65535	; 0xffff
 800f77e:	45dc      	cmp	ip, fp
 800f780:	f43f af29 	beq.w	800f5d6 <dir_register+0x782>
 800f784:	f8b2 c014 	ldrh.w	ip, [r2, #20]
	*ptr++ = (BYTE)val; val >>= 8;
 800f788:	f883 c01c 	strb.w	ip, [r3, #28]
 800f78c:	ea4f 281c 	mov.w	r8, ip, lsr #8
	*ptr++ = (BYTE)val;
 800f790:	f883 801d 	strb.w	r8, [r3, #29]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f794:	f1bc 0f00 	cmp.w	ip, #0
 800f798:	f43f af1f 	beq.w	800f5da <dir_register+0x786>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800f79c:	45dc      	cmp	ip, fp
 800f79e:	f43f af1c 	beq.w	800f5da <dir_register+0x786>
 800f7a2:	8ad2      	ldrh	r2, [r2, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 800f7a4:	779a      	strb	r2, [r3, #30]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f7a6:	f102 3cff 	add.w	ip, r2, #4294967295
 800f7aa:	fa1f fc8c 	uxth.w	ip, ip
 800f7ae:	f64f 78fd 	movw	r8, #65533	; 0xfffd
	*ptr++ = (BYTE)val; val >>= 8;
 800f7b2:	0a12      	lsrs	r2, r2, #8
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f7b4:	45c4      	cmp	ip, r8
	*ptr++ = (BYTE)val;
 800f7b6:	77da      	strb	r2, [r3, #31]
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 800f7b8:	f63f af11 	bhi.w	800f5de <dir_register+0x78a>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 800f7bc:	4471      	add	r1, lr
 800f7be:	8b4a      	ldrh	r2, [r1, #26]
 800f7c0:	2a00      	cmp	r2, #0
 800f7c2:	f47f af0e 	bne.w	800f5e2 <dir_register+0x78e>
 800f7c6:	e70a      	b.n	800f5de <dir_register+0x78a>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800f7c8:	2301      	movs	r3, #1
 800f7ca:	9301      	str	r3, [sp, #4]
}
 800f7cc:	9801      	ldr	r0, [sp, #4]
 800f7ce:	b011      	add	sp, #68	; 0x44
 800f7d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				dp->sect = 0; return FR_NO_FILE;
 800f7d4:	f8ca 301c 	str.w	r3, [sl, #28]
 800f7d8:	e602      	b.n	800f3e0 <dir_register+0x58c>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 800f7da:	461c      	mov	r4, r3
 800f7dc:	f7ff bb53 	b.w	800ee86 <dir_register+0x32>
 800f7e0:	9001      	str	r0, [sp, #4]
 800f7e2:	e5fa      	b.n	800f3da <dir_register+0x586>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800f7e4:	f8da 1018 	ldr.w	r1, [sl, #24]
 800f7e8:	4650      	mov	r0, sl
 800f7ea:	f7fe fb87 	bl	800defc <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800f7ee:	4603      	mov	r3, r0
 800f7f0:	9004      	str	r0, [sp, #16]
 800f7f2:	2800      	cmp	r0, #0
 800f7f4:	f43f adf4 	beq.w	800f3e0 <dir_register+0x58c>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 800f7f8:	2801      	cmp	r0, #1
 800f7fa:	d06a      	beq.n	800f8d2 <dir_register+0xa7e>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800f7fc:	3301      	adds	r3, #1
 800f7fe:	d0e3      	beq.n	800f7c8 <dir_register+0x974>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 800f800:	78f3      	ldrb	r3, [r6, #3]
 800f802:	2b00      	cmp	r3, #0
 800f804:	d177      	bne.n	800f8f6 <dir_register+0xaa2>
 800f806:	f106 0534 	add.w	r5, r6, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 800f80a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f80e:	2100      	movs	r1, #0
 800f810:	4628      	mov	r0, r5
 800f812:	f006 fbbd 	bl	8015f90 <memset>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f816:	69b3      	ldr	r3, [r6, #24]
	clst -= 2;
 800f818:	9a04      	ldr	r2, [sp, #16]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f81a:	3b02      	subs	r3, #2
	clst -= 2;
 800f81c:	3a02      	subs	r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f81e:	429a      	cmp	r2, r3
	clst -= 2;
 800f820:	9205      	str	r2, [sp, #20]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f822:	f080 8095 	bcs.w	800f950 <dir_register+0xafc>
	return clst * fs->csize + fs->database;
 800f826:	4610      	mov	r0, r2
 800f828:	8971      	ldrh	r1, [r6, #10]
 800f82a:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800f82c:	fb00 2201 	mla	r2, r0, r1, r2
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 800f830:	6332      	str	r2, [r6, #48]	; 0x30
 800f832:	2900      	cmp	r1, #0
 800f834:	d05d      	beq.n	800f8f2 <dir_register+0xa9e>
 800f836:	2300      	movs	r3, #0
 800f838:	e9cd b406 	strd	fp, r4, [sp, #24]
 800f83c:	9708      	str	r7, [sp, #32]
 800f83e:	461c      	mov	r4, r3
 800f840:	462f      	mov	r7, r5
 800f842:	4615      	mov	r5, r2
						fs->wflag = 1;
 800f844:	f04f 0301 	mov.w	r3, #1
 800f848:	70f3      	strb	r3, [r6, #3]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800f84a:	7870      	ldrb	r0, [r6, #1]
 800f84c:	2301      	movs	r3, #1
 800f84e:	462a      	mov	r2, r5
 800f850:	4639      	mov	r1, r7
 800f852:	f7fd fe07 	bl	800d464 <disk_write>
 800f856:	2800      	cmp	r0, #0
 800f858:	d1b6      	bne.n	800f7c8 <dir_register+0x974>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800f85a:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800f85c:	69f3      	ldr	r3, [r6, #28]
			fs->wflag = 0;
 800f85e:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800f860:	1aa8      	subs	r0, r5, r2
 800f862:	4298      	cmp	r0, r3
 800f864:	d212      	bcs.n	800f88c <dir_register+0xa38>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800f866:	f896 b002 	ldrb.w	fp, [r6, #2]
 800f86a:	f1bb 0f01 	cmp.w	fp, #1
 800f86e:	d801      	bhi.n	800f874 <dir_register+0xa20>
 800f870:	e00c      	b.n	800f88c <dir_register+0xa38>
 800f872:	69f3      	ldr	r3, [r6, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 800f874:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 800f876:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800f878:	f10b 3bff 	add.w	fp, fp, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 800f87c:	462a      	mov	r2, r5
 800f87e:	2301      	movs	r3, #1
 800f880:	4639      	mov	r1, r7
 800f882:	f7fd fdef 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800f886:	f1bb 0f01 	cmp.w	fp, #1
 800f88a:	d1f2      	bne.n	800f872 <dir_register+0xa1e>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 800f88c:	6b30      	ldr	r0, [r6, #48]	; 0x30
 800f88e:	f8b6 c00a 	ldrh.w	ip, [r6, #10]
 800f892:	1c63      	adds	r3, r4, #1
 800f894:	1c45      	adds	r5, r0, #1
 800f896:	4563      	cmp	r3, ip
 800f898:	6335      	str	r5, [r6, #48]	; 0x30
 800f89a:	d221      	bcs.n	800f8e0 <dir_register+0xa8c>
 800f89c:	461c      	mov	r4, r3
 800f89e:	e7d1      	b.n	800f844 <dir_register+0x9f0>
			*d++ = *s++;
 800f8a0:	f89a 2024 	ldrb.w	r2, [sl, #36]	; 0x24
 800f8a4:	701a      	strb	r2, [r3, #0]
 800f8a6:	f89a 2025 	ldrb.w	r2, [sl, #37]	; 0x25
 800f8aa:	705a      	strb	r2, [r3, #1]
 800f8ac:	f89a 2026 	ldrb.w	r2, [sl, #38]	; 0x26
 800f8b0:	709a      	strb	r2, [r3, #2]
 800f8b2:	f89a 2027 	ldrb.w	r2, [sl, #39]	; 0x27
 800f8b6:	70da      	strb	r2, [r3, #3]
 800f8b8:	f89a 2028 	ldrb.w	r2, [sl, #40]	; 0x28
 800f8bc:	711a      	strb	r2, [r3, #4]
 800f8be:	f89a 2029 	ldrb.w	r2, [sl, #41]	; 0x29
 800f8c2:	715a      	strb	r2, [r3, #5]
 800f8c4:	f89a 202a 	ldrb.w	r2, [sl, #42]	; 0x2a
 800f8c8:	719a      	strb	r2, [r3, #6]
 800f8ca:	f89a 202b 	ldrb.w	r2, [sl, #43]	; 0x2b
 800f8ce:	71da      	strb	r2, [r3, #7]
 800f8d0:	e5ef      	b.n	800f4b2 <dir_register+0x65e>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800f8d2:	2302      	movs	r3, #2
 800f8d4:	9301      	str	r3, [sp, #4]
 800f8d6:	e585      	b.n	800f3e4 <dir_register+0x590>
 800f8d8:	f8dd b00c 	ldr.w	fp, [sp, #12]
 800f8dc:	f7ff bb3c 	b.w	800ef58 <dir_register+0x104>
 800f8e0:	69b3      	ldr	r3, [r6, #24]
 800f8e2:	f8dd b018 	ldr.w	fp, [sp, #24]
 800f8e6:	4622      	mov	r2, r4
 800f8e8:	463d      	mov	r5, r7
 800f8ea:	9c07      	ldr	r4, [sp, #28]
 800f8ec:	9f08      	ldr	r7, [sp, #32]
 800f8ee:	1a82      	subs	r2, r0, r2
 800f8f0:	3b02      	subs	r3, #2
					fs->winsect -= n;							/* Restore window offset */
 800f8f2:	6332      	str	r2, [r6, #48]	; 0x30
 800f8f4:	e5a8      	b.n	800f448 <dir_register+0x5f4>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800f8f6:	f106 0534 	add.w	r5, r6, #52	; 0x34
		wsect = fs->winsect;	/* Current sector number */
 800f8fa:	6b32      	ldr	r2, [r6, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 800f8fc:	7870      	ldrb	r0, [r6, #1]
 800f8fe:	9205      	str	r2, [sp, #20]
 800f900:	4629      	mov	r1, r5
 800f902:	2301      	movs	r3, #1
 800f904:	f7fd fdae 	bl	800d464 <disk_write>
 800f908:	2800      	cmp	r0, #0
 800f90a:	f47f af5d 	bne.w	800f7c8 <dir_register+0x974>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800f90e:	6a71      	ldr	r1, [r6, #36]	; 0x24
 800f910:	9a05      	ldr	r2, [sp, #20]
 800f912:	69f3      	ldr	r3, [r6, #28]
			fs->wflag = 0;
 800f914:	70f0      	strb	r0, [r6, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800f916:	1a51      	subs	r1, r2, r1
 800f918:	4299      	cmp	r1, r3
 800f91a:	f4bf af76 	bcs.w	800f80a <dir_register+0x9b6>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800f91e:	78b1      	ldrb	r1, [r6, #2]
 800f920:	2901      	cmp	r1, #1
 800f922:	f67f af72 	bls.w	800f80a <dir_register+0x9b6>
 800f926:	e9cd 4705 	strd	r4, r7, [sp, #20]
 800f92a:	462f      	mov	r7, r5
 800f92c:	460c      	mov	r4, r1
 800f92e:	4615      	mov	r5, r2
 800f930:	e000      	b.n	800f934 <dir_register+0xae0>
 800f932:	69f3      	ldr	r3, [r6, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 800f934:	7870      	ldrb	r0, [r6, #1]
					wsect += fs->fsize;
 800f936:	441d      	add	r5, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800f938:	3c01      	subs	r4, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 800f93a:	462a      	mov	r2, r5
 800f93c:	2301      	movs	r3, #1
 800f93e:	4639      	mov	r1, r7
 800f940:	f7fd fd90 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800f944:	2c01      	cmp	r4, #1
 800f946:	d1f4      	bne.n	800f932 <dir_register+0xade>
 800f948:	463d      	mov	r5, r7
 800f94a:	9c05      	ldr	r4, [sp, #20]
 800f94c:	9f06      	ldr	r7, [sp, #24]
 800f94e:	e75c      	b.n	800f80a <dir_register+0x9b6>
 800f950:	8971      	ldrh	r1, [r6, #10]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800f952:	2200      	movs	r2, #0
 800f954:	e76c      	b.n	800f830 <dir_register+0x9dc>
 800f956:	bf00      	nop

0800f958 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 800f958:	b570      	push	{r4, r5, r6, lr}
 800f95a:	b082      	sub	sp, #8
 800f95c:	e9cd 1000 	strd	r1, r0, [sp]
	if (*path) {	/* If the pointer is not a null */
 800f960:	b171      	cbz	r1, 800f980 <f_mount+0x28>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 800f962:	780c      	ldrb	r4, [r1, #0]
 800f964:	2c1f      	cmp	r4, #31
 800f966:	d910      	bls.n	800f98a <f_mount+0x32>
 800f968:	4623      	mov	r3, r4
 800f96a:	4608      	mov	r0, r1
 800f96c:	e003      	b.n	800f976 <f_mount+0x1e>
 800f96e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800f972:	2b1f      	cmp	r3, #31
 800f974:	d909      	bls.n	800f98a <f_mount+0x32>
 800f976:	2b3a      	cmp	r3, #58	; 0x3a
 800f978:	d1f9      	bne.n	800f96e <f_mount+0x16>
			i = *tp++ - '0';
 800f97a:	3101      	adds	r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 800f97c:	4288      	cmp	r0, r1
 800f97e:	d002      	beq.n	800f986 <f_mount+0x2e>
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 800f980:	200b      	movs	r0, #11

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 800f982:	b002      	add	sp, #8
 800f984:	bd70      	pop	{r4, r5, r6, pc}
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800f986:	2c30      	cmp	r4, #48	; 0x30
 800f988:	d1fa      	bne.n	800f980 <f_mount+0x28>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800f98a:	4e11      	ldr	r6, [pc, #68]	; (800f9d0 <f_mount+0x78>)
 800f98c:	6830      	ldr	r0, [r6, #0]
	if (cfs) {
 800f98e:	b168      	cbz	r0, 800f9ac <f_mount+0x54>
 800f990:	f506 7302 	add.w	r3, r6, #520	; 0x208
 800f994:	f506 7452 	add.w	r4, r6, #840	; 0x348
		if (Files[i].fs == fs) Files[i].fs = 0;
 800f998:	2500      	movs	r5, #0
 800f99a:	6819      	ldr	r1, [r3, #0]
 800f99c:	4288      	cmp	r0, r1
 800f99e:	bf08      	it	eq
 800f9a0:	601d      	streq	r5, [r3, #0]
 800f9a2:	3310      	adds	r3, #16
	for (i = 0; i < _FS_LOCK; i++) {
 800f9a4:	42a3      	cmp	r3, r4
 800f9a6:	d1f8      	bne.n	800f99a <f_mount+0x42>
		cfs->fs_type = 0;				/* Clear old fs object */
 800f9a8:	2300      	movs	r3, #0
 800f9aa:	7003      	strb	r3, [r0, #0]
	if (fs) {
 800f9ac:	9b01      	ldr	r3, [sp, #4]
 800f9ae:	b15b      	cbz	r3, 800f9c8 <f_mount+0x70>
		fs->fs_type = 0;				/* Clear new fs object */
 800f9b0:	2000      	movs	r0, #0
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800f9b2:	2a01      	cmp	r2, #1
	FatFs[vol] = fs;					/* Register new fs object */
 800f9b4:	6033      	str	r3, [r6, #0]
		fs->fs_type = 0;				/* Clear new fs object */
 800f9b6:	7018      	strb	r0, [r3, #0]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800f9b8:	d1e3      	bne.n	800f982 <f_mount+0x2a>
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800f9ba:	4602      	mov	r2, r0
 800f9bc:	a901      	add	r1, sp, #4
 800f9be:	4668      	mov	r0, sp
 800f9c0:	f7fe fbcc 	bl	800e15c <find_volume>
}
 800f9c4:	b002      	add	sp, #8
 800f9c6:	bd70      	pop	{r4, r5, r6, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800f9c8:	4618      	mov	r0, r3
	FatFs[vol] = fs;					/* Register new fs object */
 800f9ca:	6033      	str	r3, [r6, #0]
}
 800f9cc:	b002      	add	sp, #8
 800f9ce:	bd70      	pop	{r4, r5, r6, pc}
 800f9d0:	200018c0 	.word	0x200018c0

0800f9d4 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800f9d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f9d8:	b093      	sub	sp, #76	; 0x4c
 800f9da:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800f9dc:	2800      	cmp	r0, #0
 800f9de:	f000 8156 	beq.w	800fc8e <f_open+0x2ba>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800f9e2:	f002 073f 	and.w	r7, r2, #63	; 0x3f
	res = find_volume(&path, &fs, mode);
 800f9e6:	4616      	mov	r6, r2
 800f9e8:	4604      	mov	r4, r0
 800f9ea:	463a      	mov	r2, r7
 800f9ec:	a903      	add	r1, sp, #12
 800f9ee:	a801      	add	r0, sp, #4
 800f9f0:	f7fe fbb4 	bl	800e15c <find_volume>
	if (res == FR_OK) {
 800f9f4:	4605      	mov	r5, r0
 800f9f6:	b128      	cbz	r0, 800fa04 <f_open+0x30>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800f9f8:	2300      	movs	r3, #0
 800f9fa:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 800f9fc:	4628      	mov	r0, r5
 800f9fe:	b013      	add	sp, #76	; 0x4c
 800fa00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dj.obj.fs = fs;
 800fa04:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 800fa06:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 800fa08:	9304      	str	r3, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the file path */
 800fa0a:	a804      	add	r0, sp, #16
 800fa0c:	f7ff f802 	bl	800ea14 <follow_path>
		if (res == FR_OK) {
 800fa10:	bb10      	cbnz	r0, 800fa58 <f_open+0x84>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 800fa12:	f99d 303f 	ldrsb.w	r3, [sp, #63]	; 0x3f
 800fa16:	2b00      	cmp	r3, #0
 800fa18:	f2c0 8140 	blt.w	800fc9c <f_open+0x2c8>
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800fa1c:	f8df 8378 	ldr.w	r8, [pc, #888]	; 800fd98 <f_open+0x3c4>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800fa20:	9b04      	ldr	r3, [sp, #16]
				Files[i].clu == dp->obj.sclust &&
 800fa22:	9906      	ldr	r1, [sp, #24]
				Files[i].ofs == dp->dptr) break;
 800fa24:	9809      	ldr	r0, [sp, #36]	; 0x24
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800fa26:	f027 0b01 	bic.w	fp, r7, #1
 800fa2a:	46c4      	mov	ip, r8
 800fa2c:	46da      	mov	sl, fp
	for (i = be = 0; i < _FS_LOCK; i++) {
 800fa2e:	46a9      	mov	r9, r5
 800fa30:	46ae      	mov	lr, r5
 800fa32:	e00a      	b.n	800fa4a <f_open+0x76>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800fa34:	429a      	cmp	r2, r3
 800fa36:	f000 8109 	beq.w	800fc4c <f_open+0x278>
	for (i = be = 0; i < _FS_LOCK; i++) {
 800fa3a:	f10e 0e01 	add.w	lr, lr, #1
 800fa3e:	f1be 0f14 	cmp.w	lr, #20
 800fa42:	f10c 0c10 	add.w	ip, ip, #16
 800fa46:	f000 8170 	beq.w	800fd2a <f_open+0x356>
		if (Files[i].fs) {	/* Existing entry */
 800fa4a:	f8dc 2000 	ldr.w	r2, [ip]
 800fa4e:	2a00      	cmp	r2, #0
 800fa50:	d1f0      	bne.n	800fa34 <f_open+0x60>
			be = 1;
 800fa52:	f04f 0901 	mov.w	r9, #1
 800fa56:	e7f0      	b.n	800fa3a <f_open+0x66>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800fa58:	f016 0f1c 	tst.w	r6, #28
 800fa5c:	f000 811c 	beq.w	800fc98 <f_open+0x2c4>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 800fa60:	2804      	cmp	r0, #4
 800fa62:	f040 8119 	bne.w	800fc98 <f_open+0x2c4>
 800fa66:	f8df 8330 	ldr.w	r8, [pc, #816]	; 800fd98 <f_open+0x3c4>
 800fa6a:	4643      	mov	r3, r8
 800fa6c:	f508 71a0 	add.w	r1, r8, #320	; 0x140
 800fa70:	e002      	b.n	800fa78 <f_open+0xa4>
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 800fa72:	428b      	cmp	r3, r1
 800fa74:	f000 815c 	beq.w	800fd30 <f_open+0x35c>
 800fa78:	681a      	ldr	r2, [r3, #0]
 800fa7a:	3310      	adds	r3, #16
 800fa7c:	2a00      	cmp	r2, #0
 800fa7e:	d1f8      	bne.n	800fa72 <f_open+0x9e>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 800fa80:	a804      	add	r0, sp, #16
 800fa82:	f7ff f9e7 	bl	800ee54 <dir_register>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 800fa86:	f047 0708 	orr.w	r7, r7, #8
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800fa8a:	2800      	cmp	r0, #0
 800fa8c:	f040 8104 	bne.w	800fc98 <f_open+0x2c4>
				dw = GET_FATTIME();
 800fa90:	f7fd fd04 	bl	800d49c <get_fattime>
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 800fa94:	9b0c      	ldr	r3, [sp, #48]	; 0x30
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 800fa96:	f8dd 900c 	ldr.w	r9, [sp, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 800fa9a:	b2c6      	uxtb	r6, r0
	*ptr++ = (BYTE)val; val >>= 8;
 800fa9c:	f3c0 2107 	ubfx	r1, r0, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800faa0:	f3c0 4207 	ubfx	r2, r0, #16, #8
	*ptr++ = (BYTE)val;
 800faa4:	0e00      	lsrs	r0, r0, #24
	*ptr++ = (BYTE)val; val >>= 8;
 800faa6:	741a      	strb	r2, [r3, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 800faa8:	739e      	strb	r6, [r3, #14]
	*ptr++ = (BYTE)val; val >>= 8;
 800faaa:	73d9      	strb	r1, [r3, #15]
	*ptr++ = (BYTE)val;
 800faac:	7458      	strb	r0, [r3, #17]
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 800faae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 800fab0:	761a      	strb	r2, [r3, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 800fab2:	759e      	strb	r6, [r3, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 800fab4:	75d9      	strb	r1, [r3, #23]
	*ptr++ = (BYTE)val;
 800fab6:	7658      	strb	r0, [r3, #25]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 800fab8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800faba:	2220      	movs	r2, #32
 800fabc:	72da      	strb	r2, [r3, #11]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 800fabe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	if (fs->fs_type == FS_FAT32) {
 800fac0:	f899 1000 	ldrb.w	r1, [r9]
	rv = rv << 8 | ptr[0];
 800fac4:	7ed6      	ldrb	r6, [r2, #27]
 800fac6:	7e93      	ldrb	r3, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 800fac8:	2903      	cmp	r1, #3
	cl = ld_word(dir + DIR_FstClusLO);
 800faca:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
	if (fs->fs_type == FS_FAT32) {
 800face:	d105      	bne.n	800fadc <f_open+0x108>
	rv = rv << 8 | ptr[0];
 800fad0:	7d51      	ldrb	r1, [r2, #21]
 800fad2:	7d13      	ldrb	r3, [r2, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800fad4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800fad8:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
	*ptr++ = (BYTE)val; val >>= 8;
 800fadc:	2300      	movs	r3, #0
 800fade:	7693      	strb	r3, [r2, #26]
	*ptr++ = (BYTE)val;
 800fae0:	76d3      	strb	r3, [r2, #27]
	if (fs->fs_type == FS_FAT32) {
 800fae2:	f899 1000 	ldrb.w	r1, [r9]
 800fae6:	2903      	cmp	r1, #3
 800fae8:	d101      	bne.n	800faee <f_open+0x11a>
	*ptr++ = (BYTE)val; val >>= 8;
 800faea:	7513      	strb	r3, [r2, #20]
	*ptr++ = (BYTE)val;
 800faec:	7553      	strb	r3, [r2, #21]
					st_dword(dj.dir + DIR_FileSize, 0);
 800faee:	990c      	ldr	r1, [sp, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 800faf0:	2200      	movs	r2, #0
					fs->wflag = 1;
 800faf2:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val; val >>= 8;
 800faf4:	61ca      	str	r2, [r1, #28]
					fs->wflag = 1;
 800faf6:	f889 3003 	strb.w	r3, [r9, #3]
					if (cl) {							/* Remove the cluster chain if exist */
 800fafa:	b1ee      	cbz	r6, 800fb38 <f_open+0x164>
						dw = fs->winsect;
 800fafc:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
 800fb00:	9300      	str	r3, [sp, #0]
						res = remove_chain(&dj.obj, cl, 0);
 800fb02:	a804      	add	r0, sp, #16
 800fb04:	4631      	mov	r1, r6
 800fb06:	f7ff f8fd 	bl	800ed04 <remove_chain>
						if (res == FR_OK) {
 800fb0a:	2800      	cmp	r0, #0
 800fb0c:	f040 80c4 	bne.w	800fc98 <f_open+0x2c4>
							res = move_window(fs, dw);
 800fb10:	f8dd 900c 	ldr.w	r9, [sp, #12]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800fb14:	9b00      	ldr	r3, [sp, #0]
 800fb16:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
 800fb1a:	4293      	cmp	r3, r2
 800fb1c:	f000 8133 	beq.w	800fd86 <f_open+0x3b2>
 800fb20:	4648      	mov	r0, r9
 800fb22:	4619      	mov	r1, r3
 800fb24:	f7fd fdae 	bl	800d684 <move_window.part.0>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800fb28:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800fb2c:	3e01      	subs	r6, #1
 800fb2e:	f8c9 6010 	str.w	r6, [r9, #16]
		if (res == FR_OK) {
 800fb32:	2800      	cmp	r0, #0
 800fb34:	f040 80b0 	bne.w	800fc98 <f_open+0x2c4>
 800fb38:	9b04      	ldr	r3, [sp, #16]
 800fb3a:	9906      	ldr	r1, [sp, #24]
 800fb3c:	9809      	ldr	r0, [sp, #36]	; 0x24
				mode |= FA_MODIFIED;
 800fb3e:	f047 0740 	orr.w	r7, r7, #64	; 0x40
 800fb42:	f027 0a01 	bic.w	sl, r7, #1
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 800fb46:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
			fp->dir_ptr = dj.dir;
 800fb4a:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
 800fb4e:	46c4      	mov	ip, r8
 800fb50:	e9c4 2e09 	strd	r2, lr, [r4, #36]	; 0x24
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 800fb54:	2600      	movs	r6, #0
 800fb56:	e005      	b.n	800fb64 <f_open+0x190>
 800fb58:	3601      	adds	r6, #1
 800fb5a:	2e14      	cmp	r6, #20
 800fb5c:	f10c 0c10 	add.w	ip, ip, #16
 800fb60:	f000 80a0 	beq.w	800fca4 <f_open+0x2d0>
		if (Files[i].fs == dp->obj.fs &&
 800fb64:	f8dc 2000 	ldr.w	r2, [ip]
 800fb68:	429a      	cmp	r2, r3
 800fb6a:	d1f5      	bne.n	800fb58 <f_open+0x184>
 800fb6c:	f8dc 2004 	ldr.w	r2, [ip, #4]
 800fb70:	428a      	cmp	r2, r1
 800fb72:	d1f1      	bne.n	800fb58 <f_open+0x184>
			Files[i].clu == dp->obj.sclust &&
 800fb74:	f8dc 2008 	ldr.w	r2, [ip, #8]
 800fb78:	4282      	cmp	r2, r0
 800fb7a:	d1ed      	bne.n	800fb58 <f_open+0x184>
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800fb7c:	4a85      	ldr	r2, [pc, #532]	; (800fd94 <f_open+0x3c0>)
 800fb7e:	ea4f 1c06 	mov.w	ip, r6, lsl #4
 800fb82:	eb02 1306 	add.w	r3, r2, r6, lsl #4
 800fb86:	f1ba 0f00 	cmp.w	sl, #0
 800fb8a:	f000 80bb 	beq.w	800fd04 <f_open+0x330>
 800fb8e:	f8b3 3214 	ldrh.w	r3, [r3, #532]	; 0x214
 800fb92:	2b00      	cmp	r3, #0
 800fb94:	f040 80c3 	bne.w	800fd1e <f_open+0x34a>
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800fb98:	f44f 7a80 	mov.w	sl, #256	; 0x100
 800fb9c:	4462      	add	r2, ip
	return i + 1;
 800fb9e:	3601      	adds	r6, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800fba0:	f8a2 a214 	strh.w	sl, [r2, #532]	; 0x214
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800fba4:	6126      	str	r6, [r4, #16]
	if (fs->fs_type == FS_FAT32) {
 800fba6:	f899 3000 	ldrb.w	r3, [r9]
	rv = rv << 8 | ptr[0];
 800fbaa:	f89e 001b 	ldrb.w	r0, [lr, #27]
 800fbae:	f89e 601a 	ldrb.w	r6, [lr, #26]
	if (fs->fs_type == FS_FAT32) {
 800fbb2:	2b03      	cmp	r3, #3
	cl = ld_word(dir + DIR_FstClusLO);
 800fbb4:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 800fbb8:	d107      	bne.n	800fbca <f_open+0x1f6>
	rv = rv << 8 | ptr[0];
 800fbba:	f89e 2015 	ldrb.w	r2, [lr, #21]
 800fbbe:	f89e 3014 	ldrb.w	r3, [lr, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800fbc2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800fbc6:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 800fbca:	60a6      	str	r6, [r4, #8]
	rv = rv << 8 | ptr[2];
 800fbcc:	f8be 101e 	ldrh.w	r1, [lr, #30]
	rv = rv << 8 | ptr[1];
 800fbd0:	f89e 301d 	ldrb.w	r3, [lr, #29]
	rv = rv << 8 | ptr[0];
 800fbd4:	f89e 801c 	ldrb.w	r8, [lr, #28]
			fp->obj.id = fs->id;
 800fbd8:	f8b9 2006 	ldrh.w	r2, [r9, #6]
 800fbdc:	80a2      	strh	r2, [r4, #4]
	rv = rv << 8 | ptr[1];
 800fbde:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800fbe2:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
			fp->cltbl = 0;			/* Disable fast seek mode */
 800fbe6:	2100      	movs	r1, #0
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 800fbe8:	f104 0a30 	add.w	sl, r4, #48	; 0x30
 800fbec:	f44f 7200 	mov.w	r2, #512	; 0x200
			fp->obj.fs = fs;	 	/* Validate the file object */
 800fbf0:	f8c4 9000 	str.w	r9, [r4]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 800fbf4:	f8c4 800c 	str.w	r8, [r4, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
 800fbf8:	62e1      	str	r1, [r4, #44]	; 0x2c
			fp->err = 0;			/* Clear error flag */
 800fbfa:	7561      	strb	r1, [r4, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 800fbfc:	6221      	str	r1, [r4, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 800fbfe:	61a1      	str	r1, [r4, #24]
			fp->flag = mode;		/* Set file access mode */
 800fc00:	7527      	strb	r7, [r4, #20]
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 800fc02:	4650      	mov	r0, sl
 800fc04:	f006 f9c4 	bl	8015f90 <memset>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800fc08:	06ba      	lsls	r2, r7, #26
 800fc0a:	f57f aef7 	bpl.w	800f9fc <f_open+0x28>
 800fc0e:	f1b8 0f00 	cmp.w	r8, #0
 800fc12:	f43f aef3 	beq.w	800f9fc <f_open+0x28>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800fc16:	f8b9 300a 	ldrh.w	r3, [r9, #10]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 800fc1a:	f8c4 8018 	str.w	r8, [r4, #24]
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800fc1e:	ebb8 2f43 	cmp.w	r8, r3, lsl #9
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800fc22:	ea4f 2743 	mov.w	r7, r3, lsl #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800fc26:	d807      	bhi.n	800fc38 <f_open+0x264>
 800fc28:	e08d      	b.n	800fd46 <f_open+0x372>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800fc2a:	1c43      	adds	r3, r0, #1
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800fc2c:	eba8 0807 	sub.w	r8, r8, r7
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800fc30:	d066      	beq.n	800fd00 <f_open+0x32c>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 800fc32:	4547      	cmp	r7, r8
 800fc34:	f080 8087 	bcs.w	800fd46 <f_open+0x372>
					clst = get_fat(&fp->obj, clst);
 800fc38:	4631      	mov	r1, r6
 800fc3a:	6820      	ldr	r0, [r4, #0]
 800fc3c:	f7fd fdf8 	bl	800d830 <get_fat.isra.0>
					if (clst <= 1) res = FR_INT_ERR;
 800fc40:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 800fc42:	4606      	mov	r6, r0
					if (clst <= 1) res = FR_INT_ERR;
 800fc44:	d8f1      	bhi.n	800fc2a <f_open+0x256>
 800fc46:	2502      	movs	r5, #2
				fp->clust = clst;
 800fc48:	61e6      	str	r6, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800fc4a:	e6d5      	b.n	800f9f8 <f_open+0x24>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 800fc4c:	f8dc 2004 	ldr.w	r2, [ip, #4]
 800fc50:	428a      	cmp	r2, r1
 800fc52:	f47f aef2 	bne.w	800fa3a <f_open+0x66>
				Files[i].clu == dp->obj.sclust &&
 800fc56:	f8dc 2008 	ldr.w	r2, [ip, #8]
 800fc5a:	4282      	cmp	r2, r0
 800fc5c:	f47f aeed 	bne.w	800fa3a <f_open+0x66>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800fc60:	f1bb 0f00 	cmp.w	fp, #0
 800fc64:	d11c      	bne.n	800fca0 <f_open+0x2cc>
 800fc66:	4a4b      	ldr	r2, [pc, #300]	; (800fd94 <f_open+0x3c0>)
 800fc68:	eb02 1e0e 	add.w	lr, r2, lr, lsl #4
 800fc6c:	f8be 2214 	ldrh.w	r2, [lr, #532]	; 0x214
 800fc70:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800fc74:	d014      	beq.n	800fca0 <f_open+0x2cc>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800fc76:	f016 0f1c 	tst.w	r6, #28
 800fc7a:	d030      	beq.n	800fcde <f_open+0x30a>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 800fc7c:	f89d 2016 	ldrb.w	r2, [sp, #22]
 800fc80:	f012 0f11 	tst.w	r2, #17
 800fc84:	d14f      	bne.n	800fd26 <f_open+0x352>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800fc86:	0772      	lsls	r2, r6, #29
 800fc88:	d543      	bpl.n	800fd12 <f_open+0x33e>
 800fc8a:	2508      	movs	r5, #8
 800fc8c:	e6b4      	b.n	800f9f8 <f_open+0x24>
	if (!fp) return FR_INVALID_OBJECT;
 800fc8e:	2509      	movs	r5, #9
}
 800fc90:	4628      	mov	r0, r5
 800fc92:	b013      	add	sp, #76	; 0x4c
 800fc94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fc98:	4605      	mov	r5, r0
 800fc9a:	e6ad      	b.n	800f9f8 <f_open+0x24>
				res = FR_INVALID_NAME;
 800fc9c:	2506      	movs	r5, #6
 800fc9e:	e6ab      	b.n	800f9f8 <f_open+0x24>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800fca0:	2510      	movs	r5, #16
 800fca2:	e6a9      	b.n	800f9f8 <f_open+0x24>
 800fca4:	4a3b      	ldr	r2, [pc, #236]	; (800fd94 <f_open+0x3c0>)
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 800fca6:	2600      	movs	r6, #0
 800fca8:	e002      	b.n	800fcb0 <f_open+0x2dc>
 800fcaa:	3601      	adds	r6, #1
 800fcac:	2e14      	cmp	r6, #20
 800fcae:	d036      	beq.n	800fd1e <f_open+0x34a>
 800fcb0:	ea4f 1c06 	mov.w	ip, r6, lsl #4
 800fcb4:	f858 b00c 	ldr.w	fp, [r8, ip]
 800fcb8:	f1bb 0f00 	cmp.w	fp, #0
 800fcbc:	d1f5      	bne.n	800fcaa <f_open+0x2d6>
		Files[i].fs = dp->obj.fs;
 800fcbe:	eb02 080c 	add.w	r8, r2, ip
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800fcc2:	f1ba 0f00 	cmp.w	sl, #0
		Files[i].clu = dp->obj.sclust;
 800fcc6:	e9c8 3182 	strd	r3, r1, [r8, #520]	; 0x208
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800fcca:	bf14      	ite	ne
 800fccc:	f44f 7a80 	movne.w	sl, #256	; 0x100
 800fcd0:	f04f 0a01 	moveq.w	sl, #1
		Files[i].ofs = dp->dptr;
 800fcd4:	f8c8 0210 	str.w	r0, [r8, #528]	; 0x210
		Files[i].ctr = 0;
 800fcd8:	f8a8 b214 	strh.w	fp, [r8, #532]	; 0x214
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 800fcdc:	e75e      	b.n	800fb9c <f_open+0x1c8>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 800fcde:	f89d 2016 	ldrb.w	r2, [sp, #22]
 800fce2:	f012 0f10 	tst.w	r2, #16
 800fce6:	d12c      	bne.n	800fd42 <f_open+0x36e>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 800fce8:	f016 0f02 	tst.w	r6, #2
 800fcec:	d122      	bne.n	800fd34 <f_open+0x360>
 800fcee:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800fcf2:	f006 0608 	and.w	r6, r6, #8
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 800fcf6:	2e00      	cmp	r6, #0
 800fcf8:	f47f af21 	bne.w	800fb3e <f_open+0x16a>
 800fcfc:	46da      	mov	sl, fp
 800fcfe:	e722      	b.n	800fb46 <f_open+0x172>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 800fd00:	2501      	movs	r5, #1
 800fd02:	e7a1      	b.n	800fc48 <f_open+0x274>
 800fd04:	f8b3 a214 	ldrh.w	sl, [r3, #532]	; 0x214
 800fd08:	f10a 0a01 	add.w	sl, sl, #1
 800fd0c:	fa1f fa8a 	uxth.w	sl, sl
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800fd10:	e744      	b.n	800fb9c <f_open+0x1c8>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800fd12:	0732      	lsls	r2, r6, #28
 800fd14:	f53f aebc 	bmi.w	800fa90 <f_open+0xbc>
 800fd18:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800fd1c:	e713      	b.n	800fb46 <f_open+0x172>
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800fd1e:	2300      	movs	r3, #0
 800fd20:	6123      	str	r3, [r4, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 800fd22:	2502      	movs	r5, #2
 800fd24:	e668      	b.n	800f9f8 <f_open+0x24>
						res = FR_DENIED;
 800fd26:	2507      	movs	r5, #7
 800fd28:	e666      	b.n	800f9f8 <f_open+0x24>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 800fd2a:	f1b9 0f00 	cmp.w	r9, #0
 800fd2e:	d1a2      	bne.n	800fc76 <f_open+0x2a2>
 800fd30:	2512      	movs	r5, #18
 800fd32:	e661      	b.n	800f9f8 <f_open+0x24>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 800fd34:	07d2      	lsls	r2, r2, #31
 800fd36:	d4f6      	bmi.n	800fd26 <f_open+0x352>
 800fd38:	f8dd 900c 	ldr.w	r9, [sp, #12]
 800fd3c:	f006 0608 	and.w	r6, r6, #8
 800fd40:	e7d9      	b.n	800fcf6 <f_open+0x322>
					res = FR_NO_FILE;
 800fd42:	2504      	movs	r5, #4
 800fd44:	e658      	b.n	800f9f8 <f_open+0x24>
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800fd46:	f3c8 0308 	ubfx	r3, r8, #0, #9
				fp->clust = clst;
 800fd4a:	61e6      	str	r6, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 800fd4c:	2b00      	cmp	r3, #0
 800fd4e:	f43f ae55 	beq.w	800f9fc <f_open+0x28>
					if ((sc = clust2sect(fs, clst)) == 0) {
 800fd52:	9903      	ldr	r1, [sp, #12]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800fd54:	698b      	ldr	r3, [r1, #24]
	clst -= 2;
 800fd56:	3e02      	subs	r6, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800fd58:	3b02      	subs	r3, #2
 800fd5a:	429e      	cmp	r6, r3
 800fd5c:	d204      	bcs.n	800fd68 <f_open+0x394>
	return clst * fs->csize + fs->database;
 800fd5e:	894b      	ldrh	r3, [r1, #10]
 800fd60:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800fd62:	fb06 2203 	mla	r2, r6, r3, r2
					if ((sc = clust2sect(fs, clst)) == 0) {
 800fd66:	b90a      	cbnz	r2, 800fd6c <f_open+0x398>
 800fd68:	2502      	movs	r5, #2
 800fd6a:	e645      	b.n	800f9f8 <f_open+0x24>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 800fd6c:	eb02 2258 	add.w	r2, r2, r8, lsr #9
 800fd70:	6222      	str	r2, [r4, #32]
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 800fd72:	7848      	ldrb	r0, [r1, #1]
 800fd74:	2301      	movs	r3, #1
 800fd76:	4651      	mov	r1, sl
 800fd78:	f7fd fb66 	bl	800d448 <disk_read>
 800fd7c:	2800      	cmp	r0, #0
 800fd7e:	f43f ae3d 	beq.w	800f9fc <f_open+0x28>
 800fd82:	2501      	movs	r5, #1
 800fd84:	e638      	b.n	800f9f8 <f_open+0x24>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 800fd86:	3e01      	subs	r6, #1
 800fd88:	9b04      	ldr	r3, [sp, #16]
 800fd8a:	9906      	ldr	r1, [sp, #24]
 800fd8c:	9809      	ldr	r0, [sp, #36]	; 0x24
 800fd8e:	f8c9 6010 	str.w	r6, [r9, #16]
		if (res == FR_OK) {
 800fd92:	e6d4      	b.n	800fb3e <f_open+0x16a>
 800fd94:	200018c0 	.word	0x200018c0
 800fd98:	20001ac8 	.word	0x20001ac8

0800fd9c <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 800fd9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fda0:	461f      	mov	r7, r3
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 800fda2:	2300      	movs	r3, #0
{
 800fda4:	b085      	sub	sp, #20
	*br = 0;	/* Clear read byte counter */
 800fda6:	603b      	str	r3, [r7, #0]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800fda8:	b150      	cbz	r0, 800fdc0 <f_read+0x24>
 800fdaa:	6803      	ldr	r3, [r0, #0]
 800fdac:	4604      	mov	r4, r0
 800fdae:	b13b      	cbz	r3, 800fdc0 <f_read+0x24>
 800fdb0:	4690      	mov	r8, r2
 800fdb2:	781a      	ldrb	r2, [r3, #0]
 800fdb4:	b122      	cbz	r2, 800fdc0 <f_read+0x24>
 800fdb6:	88da      	ldrh	r2, [r3, #6]
 800fdb8:	460e      	mov	r6, r1
 800fdba:	8881      	ldrh	r1, [r0, #4]
 800fdbc:	4291      	cmp	r1, r2
 800fdbe:	d005      	beq.n	800fdcc <f_read+0x30>
	FRESULT res = FR_INVALID_OBJECT;
 800fdc0:	f04f 0909 	mov.w	r9, #9
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 800fdc4:	4648      	mov	r0, r9
 800fdc6:	b005      	add	sp, #20
 800fdc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 800fdcc:	7858      	ldrb	r0, [r3, #1]
 800fdce:	f7fd fb21 	bl	800d414 <disk_status>
 800fdd2:	07c2      	lsls	r2, r0, #31
 800fdd4:	d4f4      	bmi.n	800fdc0 <f_read+0x24>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 800fdd6:	f894 9015 	ldrb.w	r9, [r4, #21]
 800fdda:	f1b9 0f00 	cmp.w	r9, #0
 800fdde:	d1f1      	bne.n	800fdc4 <f_read+0x28>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800fde0:	7d23      	ldrb	r3, [r4, #20]
 800fde2:	f013 0301 	ands.w	r3, r3, #1
 800fde6:	9301      	str	r3, [sp, #4]
 800fde8:	f000 80d4 	beq.w	800ff94 <f_read+0x1f8>
	remain = fp->obj.objsize - fp->fptr;
 800fdec:	69a1      	ldr	r1, [r4, #24]
 800fdee:	68e2      	ldr	r2, [r4, #12]
 800fdf0:	1a52      	subs	r2, r2, r1
 800fdf2:	4590      	cmp	r8, r2
 800fdf4:	bf28      	it	cs
 800fdf6:	4690      	movcs	r8, r2
	for ( ;  btr;								/* Repeat until all data read */
 800fdf8:	f1b8 0f00 	cmp.w	r8, #0
 800fdfc:	d0e2      	beq.n	800fdc4 <f_read+0x28>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800fdfe:	46a3      	mov	fp, r4
 800fe00:	f104 0334 	add.w	r3, r4, #52	; 0x34
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800fe04:	f3c1 0208 	ubfx	r2, r1, #0, #9
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 800fe08:	f85b ab30 	ldr.w	sl, [fp], #48
 800fe0c:	9302      	str	r3, [sp, #8]
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800fe0e:	2a00      	cmp	r2, #0
 800fe10:	d140      	bne.n	800fe94 <f_read+0xf8>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800fe12:	f8ba 200a 	ldrh.w	r2, [sl, #10]
 800fe16:	3a01      	subs	r2, #1
			if (csect == 0) {					/* On the cluster boundary? */
 800fe18:	ea12 2251 	ands.w	r2, r2, r1, lsr #9
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800fe1c:	ea4f 2351 	mov.w	r3, r1, lsr #9
			if (csect == 0) {					/* On the cluster boundary? */
 800fe20:	d06a      	beq.n	800fef8 <f_read+0x15c>
 800fe22:	69e0      	ldr	r0, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800fe24:	f8da 3018 	ldr.w	r3, [sl, #24]
	clst -= 2;
 800fe28:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800fe2a:	3b02      	subs	r3, #2
 800fe2c:	4298      	cmp	r0, r3
 800fe2e:	d270      	bcs.n	800ff12 <f_read+0x176>
	return clst * fs->csize + fs->database;
 800fe30:	f8ba 100a 	ldrh.w	r1, [sl, #10]
 800fe34:	f8da 502c 	ldr.w	r5, [sl, #44]	; 0x2c
 800fe38:	fb01 5500 	mla	r5, r1, r0, r5
			if (!sect) ABORT(fs, FR_INT_ERR);
 800fe3c:	2d00      	cmp	r5, #0
 800fe3e:	d068      	beq.n	800ff12 <f_read+0x176>
			if (cc) {							/* Read maximum contiguous sectors directly */
 800fe40:	f5b8 7f00 	cmp.w	r8, #512	; 0x200
			sect += csect;
 800fe44:	4415      	add	r5, r2
			if (cc) {							/* Read maximum contiguous sectors directly */
 800fe46:	d36c      	bcc.n	800ff22 <f_read+0x186>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800fe48:	eb02 2058 	add.w	r0, r2, r8, lsr #9
 800fe4c:	4288      	cmp	r0, r1
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 800fe4e:	ea4f 2358 	mov.w	r3, r8, lsr #9
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800fe52:	f89a 0001 	ldrb.w	r0, [sl, #1]
					cc = fs->csize - csect;
 800fe56:	bf88      	it	hi
 800fe58:	1a8b      	subhi	r3, r1, r2
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800fe5a:	462a      	mov	r2, r5
 800fe5c:	4631      	mov	r1, r6
 800fe5e:	9303      	str	r3, [sp, #12]
 800fe60:	f7fd faf2 	bl	800d448 <disk_read>
 800fe64:	2800      	cmp	r0, #0
 800fe66:	f040 8084 	bne.w	800ff72 <f_read+0x1d6>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800fe6a:	f994 2014 	ldrsb.w	r2, [r4, #20]
 800fe6e:	9b03      	ldr	r3, [sp, #12]
 800fe70:	2a00      	cmp	r2, #0
 800fe72:	f2c0 80a6 	blt.w	800ffc2 <f_read+0x226>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800fe76:	025b      	lsls	r3, r3, #9
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800fe78:	69a1      	ldr	r1, [r4, #24]
 800fe7a:	683a      	ldr	r2, [r7, #0]
 800fe7c:	4419      	add	r1, r3
 800fe7e:	441a      	add	r2, r3
	for ( ;  btr;								/* Repeat until all data read */
 800fe80:	ebb8 0803 	subs.w	r8, r8, r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800fe84:	61a1      	str	r1, [r4, #24]
 800fe86:	441e      	add	r6, r3
 800fe88:	603a      	str	r2, [r7, #0]
	for ( ;  btr;								/* Repeat until all data read */
 800fe8a:	d09b      	beq.n	800fdc4 <f_read+0x28>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 800fe8c:	f3c1 0208 	ubfx	r2, r1, #0, #9
 800fe90:	2a00      	cmp	r2, #0
 800fe92:	d0be      	beq.n	800fe12 <f_read+0x76>
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 800fe94:	f5c2 7300 	rsb	r3, r2, #512	; 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 800fe98:	1d10      	adds	r0, r2, #4
 800fe9a:	4543      	cmp	r3, r8
 800fe9c:	4458      	add	r0, fp
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 800fe9e:	445a      	add	r2, fp
 800fea0:	f106 0104 	add.w	r1, r6, #4
 800fea4:	bf28      	it	cs
 800fea6:	4643      	movcs	r3, r8
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800fea8:	428a      	cmp	r2, r1
 800feaa:	bf38      	it	cc
 800feac:	4286      	cmpcc	r6, r0
 800feae:	f103 3cff 	add.w	ip, r3, #4294967295
 800feb2:	d366      	bcc.n	800ff82 <f_read+0x1e6>
 800feb4:	f1bc 0f07 	cmp.w	ip, #7
 800feb8:	d963      	bls.n	800ff82 <f_read+0x1e6>
 800feba:	f023 0503 	bic.w	r5, r3, #3
 800febe:	4435      	add	r5, r6
 800fec0:	4631      	mov	r1, r6
 800fec2:	4610      	mov	r0, r2
			*d++ = *s++;
 800fec4:	f850 eb04 	ldr.w	lr, [r0], #4
 800fec8:	f841 eb04 	str.w	lr, [r1], #4
		} while (--cnt);
 800fecc:	428d      	cmp	r5, r1
 800fece:	d1f9      	bne.n	800fec4 <f_read+0x128>
 800fed0:	f023 0103 	bic.w	r1, r3, #3
 800fed4:	428b      	cmp	r3, r1
 800fed6:	eb06 0001 	add.w	r0, r6, r1
 800feda:	eb02 0501 	add.w	r5, r2, r1
 800fede:	d0cb      	beq.n	800fe78 <f_read+0xdc>
			*d++ = *s++;
 800fee0:	5c52      	ldrb	r2, [r2, r1]
 800fee2:	5472      	strb	r2, [r6, r1]
		} while (--cnt);
 800fee4:	ebbc 0101 	subs.w	r1, ip, r1
 800fee8:	d0c6      	beq.n	800fe78 <f_read+0xdc>
			*d++ = *s++;
 800feea:	786a      	ldrb	r2, [r5, #1]
 800feec:	7042      	strb	r2, [r0, #1]
		} while (--cnt);
 800feee:	2901      	cmp	r1, #1
 800fef0:	d0c2      	beq.n	800fe78 <f_read+0xdc>
			*d++ = *s++;
 800fef2:	78aa      	ldrb	r2, [r5, #2]
 800fef4:	7082      	strb	r2, [r0, #2]
		} while (--cnt);
 800fef6:	e7bf      	b.n	800fe78 <f_read+0xdc>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800fef8:	bb39      	cbnz	r1, 800ff4a <f_read+0x1ae>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 800fefa:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800fefc:	2801      	cmp	r0, #1
 800fefe:	d908      	bls.n	800ff12 <f_read+0x176>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800ff00:	1c43      	adds	r3, r0, #1
 800ff02:	d036      	beq.n	800ff72 <f_read+0x1d6>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800ff04:	f8da 3018 	ldr.w	r3, [sl, #24]
				fp->clust = clst;				/* Update current cluster */
 800ff08:	61e0      	str	r0, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800ff0a:	3b02      	subs	r3, #2
	clst -= 2;
 800ff0c:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800ff0e:	4298      	cmp	r0, r3
 800ff10:	d38e      	bcc.n	800fe30 <f_read+0x94>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800ff12:	f04f 0902 	mov.w	r9, #2
}
 800ff16:	4648      	mov	r0, r9
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 800ff18:	f884 9015 	strb.w	r9, [r4, #21]
}
 800ff1c:	b005      	add	sp, #20
 800ff1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 800ff22:	6a22      	ldr	r2, [r4, #32]
 800ff24:	42aa      	cmp	r2, r5
 800ff26:	d00b      	beq.n	800ff40 <f_read+0x1a4>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 800ff28:	f994 3014 	ldrsb.w	r3, [r4, #20]
 800ff2c:	2b00      	cmp	r3, #0
 800ff2e:	db3b      	blt.n	800ffa8 <f_read+0x20c>
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 800ff30:	f89a 0001 	ldrb.w	r0, [sl, #1]
 800ff34:	2301      	movs	r3, #1
 800ff36:	462a      	mov	r2, r5
 800ff38:	4659      	mov	r1, fp
 800ff3a:	f7fd fa85 	bl	800d448 <disk_read>
 800ff3e:	b9c0      	cbnz	r0, 800ff72 <f_read+0x1d6>
			fp->sect = sect;
 800ff40:	69a2      	ldr	r2, [r4, #24]
 800ff42:	6225      	str	r5, [r4, #32]
 800ff44:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800ff48:	e7a4      	b.n	800fe94 <f_read+0xf8>
					if (fp->cltbl) {
 800ff4a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800ff4c:	b328      	cbz	r0, 800ff9a <f_read+0x1fe>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800ff4e:	6825      	ldr	r5, [r4, #0]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800ff50:	6841      	ldr	r1, [r0, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 800ff52:	896d      	ldrh	r5, [r5, #10]
 800ff54:	fbb3 f3f5 	udiv	r3, r3, r5
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 800ff58:	3004      	adds	r0, #4
		if (ncl == 0) return 0;	/* End of table? (error) */
 800ff5a:	b929      	cbnz	r1, 800ff68 <f_read+0x1cc>
 800ff5c:	e7d9      	b.n	800ff12 <f_read+0x176>
		cl -= ncl; tbl++;		/* Next fragment */
 800ff5e:	1a5b      	subs	r3, r3, r1
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800ff60:	f850 1f08 	ldr.w	r1, [r0, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 800ff64:	2900      	cmp	r1, #0
 800ff66:	d0d4      	beq.n	800ff12 <f_read+0x176>
		if (cl < ncl) break;	/* In this fragment? */
 800ff68:	4299      	cmp	r1, r3
 800ff6a:	d9f8      	bls.n	800ff5e <f_read+0x1c2>
	return cl + *tbl;	/* Return the cluster number */
 800ff6c:	6840      	ldr	r0, [r0, #4]
 800ff6e:	4418      	add	r0, r3
 800ff70:	e7c4      	b.n	800fefc <f_read+0x160>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800ff72:	f8dd 9004 	ldr.w	r9, [sp, #4]
 800ff76:	2301      	movs	r3, #1
}
 800ff78:	4648      	mov	r0, r9
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800ff7a:	7563      	strb	r3, [r4, #21]
}
 800ff7c:	b005      	add	sp, #20
 800ff7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ff82:	1e71      	subs	r1, r6, #1
 800ff84:	18d5      	adds	r5, r2, r3
			*d++ = *s++;
 800ff86:	f812 0b01 	ldrb.w	r0, [r2], #1
 800ff8a:	f801 0f01 	strb.w	r0, [r1, #1]!
		} while (--cnt);
 800ff8e:	42aa      	cmp	r2, r5
 800ff90:	d1f9      	bne.n	800ff86 <f_read+0x1ea>
 800ff92:	e771      	b.n	800fe78 <f_read+0xdc>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800ff94:	f04f 0907 	mov.w	r9, #7
 800ff98:	e714      	b.n	800fdc4 <f_read+0x28>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 800ff9a:	69e1      	ldr	r1, [r4, #28]
 800ff9c:	6820      	ldr	r0, [r4, #0]
 800ff9e:	9203      	str	r2, [sp, #12]
 800ffa0:	f7fd fc46 	bl	800d830 <get_fat.isra.0>
 800ffa4:	9a03      	ldr	r2, [sp, #12]
 800ffa6:	e7a9      	b.n	800fefc <f_read+0x160>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800ffa8:	f89a 0001 	ldrb.w	r0, [sl, #1]
 800ffac:	2301      	movs	r3, #1
 800ffae:	4659      	mov	r1, fp
 800ffb0:	f7fd fa58 	bl	800d464 <disk_write>
 800ffb4:	2800      	cmp	r0, #0
 800ffb6:	d1dc      	bne.n	800ff72 <f_read+0x1d6>
					fp->flag &= (BYTE)~FA_DIRTY;
 800ffb8:	7d23      	ldrb	r3, [r4, #20]
 800ffba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ffbe:	7523      	strb	r3, [r4, #20]
 800ffc0:	e7b6      	b.n	800ff30 <f_read+0x194>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800ffc2:	6a22      	ldr	r2, [r4, #32]
 800ffc4:	1b55      	subs	r5, r2, r5
 800ffc6:	429d      	cmp	r5, r3
 800ffc8:	f4bf af55 	bcs.w	800fe76 <f_read+0xda>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 800ffcc:	eb06 2045 	add.w	r0, r6, r5, lsl #9
 800ffd0:	3004      	adds	r0, #4
 800ffd2:	4583      	cmp	fp, r0
 800ffd4:	eb06 2245 	add.w	r2, r6, r5, lsl #9
 800ffd8:	4659      	mov	r1, fp
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800ffda:	d202      	bcs.n	800ffe2 <f_read+0x246>
 800ffdc:	9802      	ldr	r0, [sp, #8]
 800ffde:	4282      	cmp	r2, r0
 800ffe0:	d309      	bcc.n	800fff6 <f_read+0x25a>
 800ffe2:	f502 7500 	add.w	r5, r2, #512	; 0x200
 800ffe6:	4659      	mov	r1, fp
			*d++ = *s++;
 800ffe8:	f851 0b04 	ldr.w	r0, [r1], #4
 800ffec:	f842 0b04 	str.w	r0, [r2], #4
		} while (--cnt);
 800fff0:	42aa      	cmp	r2, r5
 800fff2:	d1f9      	bne.n	800ffe8 <f_read+0x24c>
 800fff4:	e73f      	b.n	800fe76 <f_read+0xda>
 800fff6:	3a01      	subs	r2, #1
 800fff8:	f504 750c 	add.w	r5, r4, #560	; 0x230
			*d++ = *s++;
 800fffc:	f811 0b01 	ldrb.w	r0, [r1], #1
 8010000:	f802 0f01 	strb.w	r0, [r2, #1]!
		} while (--cnt);
 8010004:	428d      	cmp	r5, r1
 8010006:	d1f9      	bne.n	800fffc <f_read+0x260>
 8010008:	e735      	b.n	800fe76 <f_read+0xda>
 801000a:	bf00      	nop

0801000c <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 801000c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010010:	461f      	mov	r7, r3
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 8010012:	2300      	movs	r3, #0
{
 8010014:	b085      	sub	sp, #20
	*bw = 0;	/* Clear write byte counter */
 8010016:	603b      	str	r3, [r7, #0]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8010018:	b150      	cbz	r0, 8010030 <f_write+0x24>
 801001a:	6803      	ldr	r3, [r0, #0]
 801001c:	4604      	mov	r4, r0
 801001e:	b13b      	cbz	r3, 8010030 <f_write+0x24>
 8010020:	4616      	mov	r6, r2
 8010022:	781a      	ldrb	r2, [r3, #0]
 8010024:	b122      	cbz	r2, 8010030 <f_write+0x24>
 8010026:	88da      	ldrh	r2, [r3, #6]
 8010028:	460d      	mov	r5, r1
 801002a:	8881      	ldrh	r1, [r0, #4]
 801002c:	4291      	cmp	r1, r2
 801002e:	d005      	beq.n	801003c <f_write+0x30>
	FRESULT res = FR_INVALID_OBJECT;
 8010030:	f04f 0809 	mov.w	r8, #9
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */

	LEAVE_FF(fs, FR_OK);
}
 8010034:	4640      	mov	r0, r8
 8010036:	b005      	add	sp, #20
 8010038:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 801003c:	7858      	ldrb	r0, [r3, #1]
 801003e:	f7fd f9e9 	bl	800d414 <disk_status>
 8010042:	07c1      	lsls	r1, r0, #31
 8010044:	d4f4      	bmi.n	8010030 <f_write+0x24>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8010046:	f894 8015 	ldrb.w	r8, [r4, #21]
 801004a:	f1b8 0f00 	cmp.w	r8, #0
 801004e:	d1f1      	bne.n	8010034 <f_write+0x28>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8010050:	7d23      	ldrb	r3, [r4, #20]
 8010052:	079a      	lsls	r2, r3, #30
 8010054:	f140 80f8 	bpl.w	8010248 <f_write+0x23c>
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8010058:	69a1      	ldr	r1, [r4, #24]
 801005a:	42f1      	cmn	r1, r6
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 801005c:	bf28      	it	cs
 801005e:	43ce      	mvncs	r6, r1
	for ( ;  btw;							/* Repeat until all data written */
 8010060:	2e00      	cmp	r6, #0
 8010062:	d067      	beq.n	8010134 <f_write+0x128>
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8010064:	46a2      	mov	sl, r4
 8010066:	f504 730c 	add.w	r3, r4, #560	; 0x230
 801006a:	f85a 9b30 	ldr.w	r9, [sl], #48
 801006e:	9301      	str	r3, [sp, #4]
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8010070:	f3c1 0208 	ubfx	r2, r1, #0, #9
 8010074:	2a00      	cmp	r2, #0
 8010076:	d16c      	bne.n	8010152 <f_write+0x146>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8010078:	f8b9 b00a 	ldrh.w	fp, [r9, #10]
 801007c:	f10b 3bff 	add.w	fp, fp, #4294967295
			if (csect == 0) {				/* On the cluster boundary? */
 8010080:	ea1b 2b51 	ands.w	fp, fp, r1, lsr #9
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8010084:	ea4f 2351 	mov.w	r3, r1, lsr #9
			if (csect == 0) {				/* On the cluster boundary? */
 8010088:	d110      	bne.n	80100ac <f_write+0xa0>
				if (fp->fptr == 0) {		/* On the top of the file? */
 801008a:	2900      	cmp	r1, #0
 801008c:	f040 80a5 	bne.w	80101da <f_write+0x1ce>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8010090:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 8010092:	2800      	cmp	r0, #0
 8010094:	f000 80e3 	beq.w	801025e <f_write+0x252>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8010098:	2801      	cmp	r0, #1
 801009a:	f000 8096 	beq.w	80101ca <f_write+0x1be>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 801009e:	1c43      	adds	r3, r0, #1
 80100a0:	f000 80c0 	beq.w	8010224 <f_write+0x218>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 80100a4:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 80100a6:	61e0      	str	r0, [r4, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 80100a8:	b903      	cbnz	r3, 80100ac <f_write+0xa0>
 80100aa:	60a0      	str	r0, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 80100ac:	f994 3014 	ldrsb.w	r3, [r4, #20]
 80100b0:	2b00      	cmp	r3, #0
 80100b2:	f2c0 80aa 	blt.w	801020a <f_write+0x1fe>
	clst -= 2;
 80100b6:	69e2      	ldr	r2, [r4, #28]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80100b8:	f8d9 3018 	ldr.w	r3, [r9, #24]
	clst -= 2;
 80100bc:	3a02      	subs	r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80100be:	3b02      	subs	r3, #2
 80100c0:	429a      	cmp	r2, r3
 80100c2:	f080 8082 	bcs.w	80101ca <f_write+0x1be>
	return clst * fs->csize + fs->database;
 80100c6:	f8b9 100a 	ldrh.w	r1, [r9, #10]
 80100ca:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
 80100ce:	fb01 3202 	mla	r2, r1, r2, r3
			if (!sect) ABORT(fs, FR_INT_ERR);
 80100d2:	2a00      	cmp	r2, #0
 80100d4:	d079      	beq.n	80101ca <f_write+0x1be>
			if (cc) {						/* Write maximum contiguous sectors directly */
 80100d6:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
			sect += csect;
 80100da:	445a      	add	r2, fp
			if (cc) {						/* Write maximum contiguous sectors directly */
 80100dc:	d32e      	bcc.n	801013c <f_write+0x130>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 80100de:	eb0b 2056 	add.w	r0, fp, r6, lsr #9
 80100e2:	4288      	cmp	r0, r1
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 80100e4:	ea4f 2356 	mov.w	r3, r6, lsr #9
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80100e8:	f899 0001 	ldrb.w	r0, [r9, #1]
					cc = fs->csize - csect;
 80100ec:	bf88      	it	hi
 80100ee:	eba1 030b 	subhi.w	r3, r1, fp
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80100f2:	4629      	mov	r1, r5
 80100f4:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80100f8:	f7fd f9b4 	bl	800d464 <disk_write>
 80100fc:	2800      	cmp	r0, #0
 80100fe:	f040 8091 	bne.w	8010224 <f_write+0x218>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8010102:	6a21      	ldr	r1, [r4, #32]
 8010104:	9a02      	ldr	r2, [sp, #8]
 8010106:	9b03      	ldr	r3, [sp, #12]
 8010108:	1a8a      	subs	r2, r1, r2
 801010a:	429a      	cmp	r2, r3
 801010c:	f0c0 80bb 	bcc.w	8010286 <f_write+0x27a>
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 8010110:	eb05 2c43 	add.w	ip, r5, r3, lsl #9
 8010114:	025b      	lsls	r3, r3, #9
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 8010116:	69a1      	ldr	r1, [r4, #24]
 8010118:	68e0      	ldr	r0, [r4, #12]
 801011a:	683a      	ldr	r2, [r7, #0]
 801011c:	4419      	add	r1, r3
 801011e:	4288      	cmp	r0, r1
 8010120:	bf38      	it	cc
 8010122:	4608      	movcc	r0, r1
 8010124:	441a      	add	r2, r3
	for ( ;  btw;							/* Repeat until all data written */
 8010126:	1af6      	subs	r6, r6, r3
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 8010128:	61a1      	str	r1, [r4, #24]
 801012a:	60e0      	str	r0, [r4, #12]
 801012c:	4665      	mov	r5, ip
 801012e:	603a      	str	r2, [r7, #0]
	for ( ;  btw;							/* Repeat until all data written */
 8010130:	d19e      	bne.n	8010070 <f_write+0x64>
 8010132:	7d23      	ldrb	r3, [r4, #20]
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8010134:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010138:	7523      	strb	r3, [r4, #20]
	LEAVE_FF(fs, FR_OK);
 801013a:	e77b      	b.n	8010034 <f_write+0x28>
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 801013c:	6a23      	ldr	r3, [r4, #32]
 801013e:	4293      	cmp	r3, r2
				fp->fptr < fp->obj.objsize &&
 8010140:	69a3      	ldr	r3, [r4, #24]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8010142:	d003      	beq.n	801014c <f_write+0x140>
 8010144:	68e1      	ldr	r1, [r4, #12]
 8010146:	428b      	cmp	r3, r1
 8010148:	f0c0 8091 	bcc.w	801026e <f_write+0x262>
			fp->sect = sect;
 801014c:	6222      	str	r2, [r4, #32]
 801014e:	f3c3 0208 	ubfx	r2, r3, #0, #9
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8010152:	f5c2 7300 	rsb	r3, r2, #512	; 0x200
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 8010156:	1d10      	adds	r0, r2, #4
 8010158:	42b3      	cmp	r3, r6
 801015a:	4450      	add	r0, sl
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 801015c:	4452      	add	r2, sl
 801015e:	f105 0104 	add.w	r1, r5, #4
 8010162:	bf28      	it	cs
 8010164:	4633      	movcs	r3, r6
void mem_cpy (void* dst, const void* src, UINT cnt) {
 8010166:	428a      	cmp	r2, r1
 8010168:	bf38      	it	cc
 801016a:	4285      	cmpcc	r5, r0
 801016c:	f103 3eff 	add.w	lr, r3, #4294967295
 8010170:	d360      	bcc.n	8010234 <f_write+0x228>
 8010172:	f1be 0f07 	cmp.w	lr, #7
 8010176:	d95d      	bls.n	8010234 <f_write+0x228>
 8010178:	f023 0c03 	bic.w	ip, r3, #3
 801017c:	44ac      	add	ip, r5
 801017e:	4629      	mov	r1, r5
 8010180:	4610      	mov	r0, r2
			*d++ = *s++;
 8010182:	f851 bb04 	ldr.w	fp, [r1], #4
 8010186:	f840 bb04 	str.w	fp, [r0], #4
		} while (--cnt);
 801018a:	458c      	cmp	ip, r1
 801018c:	d1f9      	bne.n	8010182 <f_write+0x176>
 801018e:	f023 0103 	bic.w	r1, r3, #3
 8010192:	428b      	cmp	r3, r1
 8010194:	eb02 0001 	add.w	r0, r2, r1
 8010198:	eb05 0c01 	add.w	ip, r5, r1
 801019c:	d010      	beq.n	80101c0 <f_write+0x1b4>
			*d++ = *s++;
 801019e:	f815 b001 	ldrb.w	fp, [r5, r1]
 80101a2:	f802 b001 	strb.w	fp, [r2, r1]
		} while (--cnt);
 80101a6:	ebbe 0101 	subs.w	r1, lr, r1
 80101aa:	d007      	beq.n	80101bc <f_write+0x1b0>
			*d++ = *s++;
 80101ac:	f89c 2001 	ldrb.w	r2, [ip, #1]
 80101b0:	7042      	strb	r2, [r0, #1]
		} while (--cnt);
 80101b2:	2901      	cmp	r1, #1
			*d++ = *s++;
 80101b4:	bf1c      	itt	ne
 80101b6:	f89c 2002 	ldrbne.w	r2, [ip, #2]
 80101ba:	7082      	strbne	r2, [r0, #2]
		} while (--cnt);
 80101bc:	eb05 0c03 	add.w	ip, r5, r3
		fp->flag |= FA_DIRTY;
 80101c0:	7d22      	ldrb	r2, [r4, #20]
 80101c2:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80101c6:	7522      	strb	r2, [r4, #20]
 80101c8:	e7a5      	b.n	8010116 <f_write+0x10a>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 80101ca:	f04f 0802 	mov.w	r8, #2
}
 80101ce:	4640      	mov	r0, r8
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 80101d0:	f884 8015 	strb.w	r8, [r4, #21]
}
 80101d4:	b005      	add	sp, #20
 80101d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (fp->cltbl) {
 80101da:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80101dc:	2900      	cmp	r1, #0
 80101de:	d036      	beq.n	801024e <f_write+0x242>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 80101e0:	6820      	ldr	r0, [r4, #0]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 80101e2:	684a      	ldr	r2, [r1, #4]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 80101e4:	8940      	ldrh	r0, [r0, #10]
 80101e6:	fbb3 f3f0 	udiv	r3, r3, r0
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 80101ea:	3104      	adds	r1, #4
		if (ncl == 0) return 0;	/* End of table? (error) */
 80101ec:	b92a      	cbnz	r2, 80101fa <f_write+0x1ee>
 80101ee:	e7a0      	b.n	8010132 <f_write+0x126>
		cl -= ncl; tbl++;		/* Next fragment */
 80101f0:	1a9b      	subs	r3, r3, r2
		ncl = *tbl++;			/* Number of cluters in the fragment */
 80101f2:	f851 2f08 	ldr.w	r2, [r1, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 80101f6:	2a00      	cmp	r2, #0
 80101f8:	d09b      	beq.n	8010132 <f_write+0x126>
		if (cl < ncl) break;	/* In this fragment? */
 80101fa:	4293      	cmp	r3, r2
 80101fc:	d2f8      	bcs.n	80101f0 <f_write+0x1e4>
	return cl + *tbl;	/* Return the cluster number */
 80101fe:	6848      	ldr	r0, [r1, #4]
 8010200:	4418      	add	r0, r3
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8010202:	2800      	cmp	r0, #0
 8010204:	f47f af48 	bne.w	8010098 <f_write+0x8c>
 8010208:	e793      	b.n	8010132 <f_write+0x126>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 801020a:	6a22      	ldr	r2, [r4, #32]
 801020c:	f899 0001 	ldrb.w	r0, [r9, #1]
 8010210:	2301      	movs	r3, #1
 8010212:	4651      	mov	r1, sl
 8010214:	f7fd f926 	bl	800d464 <disk_write>
 8010218:	b920      	cbnz	r0, 8010224 <f_write+0x218>
				fp->flag &= (BYTE)~FA_DIRTY;
 801021a:	7d23      	ldrb	r3, [r4, #20]
 801021c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010220:	7523      	strb	r3, [r4, #20]
 8010222:	e748      	b.n	80100b6 <f_write+0xaa>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8010224:	f04f 0801 	mov.w	r8, #1
}
 8010228:	4640      	mov	r0, r8
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 801022a:	f884 8015 	strb.w	r8, [r4, #21]
}
 801022e:	b005      	add	sp, #20
 8010230:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010234:	3a01      	subs	r2, #1
 8010236:	eb05 0c03 	add.w	ip, r5, r3
			*d++ = *s++;
 801023a:	f815 1b01 	ldrb.w	r1, [r5], #1
 801023e:	f802 1f01 	strb.w	r1, [r2, #1]!
		} while (--cnt);
 8010242:	4565      	cmp	r5, ip
 8010244:	d1f9      	bne.n	801023a <f_write+0x22e>
 8010246:	e7bb      	b.n	80101c0 <f_write+0x1b4>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8010248:	f04f 0807 	mov.w	r8, #7
 801024c:	e6f2      	b.n	8010034 <f_write+0x28>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 801024e:	69e1      	ldr	r1, [r4, #28]
 8010250:	4620      	mov	r0, r4
 8010252:	f7fd fe53 	bl	800defc <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8010256:	2800      	cmp	r0, #0
 8010258:	f47f af1e 	bne.w	8010098 <f_write+0x8c>
 801025c:	e769      	b.n	8010132 <f_write+0x126>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 801025e:	4659      	mov	r1, fp
 8010260:	4620      	mov	r0, r4
 8010262:	f7fd fe4b 	bl	800defc <create_chain>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8010266:	2800      	cmp	r0, #0
 8010268:	f47f af16 	bne.w	8010098 <f_write+0x8c>
 801026c:	e761      	b.n	8010132 <f_write+0x126>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 801026e:	f899 0001 	ldrb.w	r0, [r9, #1]
 8010272:	9202      	str	r2, [sp, #8]
 8010274:	2301      	movs	r3, #1
 8010276:	4651      	mov	r1, sl
 8010278:	f7fd f8e6 	bl	800d448 <disk_read>
				fp->fptr < fp->obj.objsize &&
 801027c:	2800      	cmp	r0, #0
 801027e:	d1d1      	bne.n	8010224 <f_write+0x218>
 8010280:	69a3      	ldr	r3, [r4, #24]
 8010282:	9a02      	ldr	r2, [sp, #8]
 8010284:	e762      	b.n	801014c <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 8010286:	eb05 2142 	add.w	r1, r5, r2, lsl #9
 801028a:	3104      	adds	r1, #4
 801028c:	458a      	cmp	sl, r1
 801028e:	eb05 2242 	add.w	r2, r5, r2, lsl #9
void mem_cpy (void* dst, const void* src, UINT cnt) {
 8010292:	d203      	bcs.n	801029c <f_write+0x290>
 8010294:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8010298:	428a      	cmp	r2, r1
 801029a:	d30d      	bcc.n	80102b8 <f_write+0x2ac>
 801029c:	f8dd c004 	ldr.w	ip, [sp, #4]
 80102a0:	4651      	mov	r1, sl
			*d++ = *s++;
 80102a2:	f852 0b04 	ldr.w	r0, [r2], #4
 80102a6:	f841 0b04 	str.w	r0, [r1], #4
		} while (--cnt);
 80102aa:	4561      	cmp	r1, ip
 80102ac:	d1f9      	bne.n	80102a2 <f_write+0x296>
					fp->flag &= (BYTE)~FA_DIRTY;
 80102ae:	7d22      	ldrb	r2, [r4, #20]
 80102b0:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80102b4:	7522      	strb	r2, [r4, #20]
 80102b6:	e72b      	b.n	8010110 <f_write+0x104>
 80102b8:	f104 012f 	add.w	r1, r4, #47	; 0x2f
 80102bc:	f502 7c00 	add.w	ip, r2, #512	; 0x200
			*d++ = *s++;
 80102c0:	f812 0b01 	ldrb.w	r0, [r2], #1
 80102c4:	f801 0f01 	strb.w	r0, [r1, #1]!
		} while (--cnt);
 80102c8:	4594      	cmp	ip, r2
 80102ca:	d1f9      	bne.n	80102c0 <f_write+0x2b4>
 80102cc:	e7ef      	b.n	80102ae <f_write+0x2a2>
 80102ce:	bf00      	nop

080102d0 <f_close>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80102d0:	b158      	cbz	r0, 80102ea <f_close+0x1a>
 80102d2:	6803      	ldr	r3, [r0, #0]
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 80102d4:	b570      	push	{r4, r5, r6, lr}
 80102d6:	4604      	mov	r4, r0
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80102d8:	b12b      	cbz	r3, 80102e6 <f_close+0x16>
 80102da:	781a      	ldrb	r2, [r3, #0]
 80102dc:	b11a      	cbz	r2, 80102e6 <f_close+0x16>
 80102de:	8881      	ldrh	r1, [r0, #4]
 80102e0:	88da      	ldrh	r2, [r3, #6]
 80102e2:	4291      	cmp	r1, r2
 80102e4:	d003      	beq.n	80102ee <f_close+0x1e>
	FRESULT res = FR_INVALID_OBJECT;
 80102e6:	2009      	movs	r0, #9
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 80102e8:	bd70      	pop	{r4, r5, r6, pc}
	FRESULT res = FR_INVALID_OBJECT;
 80102ea:	2009      	movs	r0, #9
}
 80102ec:	4770      	bx	lr
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 80102ee:	7858      	ldrb	r0, [r3, #1]
 80102f0:	f7fd f890 	bl	800d414 <disk_status>
 80102f4:	07c1      	lsls	r1, r0, #31
 80102f6:	d4f6      	bmi.n	80102e6 <f_close+0x16>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 80102f8:	7d23      	ldrb	r3, [r4, #20]
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 80102fa:	6825      	ldr	r5, [r4, #0]
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 80102fc:	065a      	lsls	r2, r3, #25
 80102fe:	d53d      	bpl.n	801037c <f_close+0xac>
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8010300:	061b      	lsls	r3, r3, #24
 8010302:	d460      	bmi.n	80103c6 <f_close+0xf6>
			tm = GET_FATTIME();				/* Modified time */
 8010304:	f7fd f8ca 	bl	800d49c <get_fattime>
				res = move_window(fs, fp->dir_sect);
 8010308:	6a61      	ldr	r1, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 801030a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 801030c:	4299      	cmp	r1, r3
			tm = GET_FATTIME();				/* Modified time */
 801030e:	4606      	mov	r6, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8010310:	d004      	beq.n	801031c <f_close+0x4c>
 8010312:	4628      	mov	r0, r5
 8010314:	f7fd f9b6 	bl	800d684 <move_window.part.0>
				if (res == FR_OK) {
 8010318:	2800      	cmp	r0, #0
 801031a:	d1e5      	bne.n	80102e8 <f_close+0x18>
					dir = fp->dir_ptr;
 801031c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 801031e:	7ad3      	ldrb	r3, [r2, #11]
 8010320:	f043 0320 	orr.w	r3, r3, #32
 8010324:	72d3      	strb	r3, [r2, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 8010326:	68a3      	ldr	r3, [r4, #8]
 8010328:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 801032a:	7693      	strb	r3, [r2, #26]
 801032c:	f3c3 2007 	ubfx	r0, r3, #8, #8
	*ptr++ = (BYTE)val;
 8010330:	76d0      	strb	r0, [r2, #27]
	if (fs->fs_type == FS_FAT32) {
 8010332:	7809      	ldrb	r1, [r1, #0]
 8010334:	2903      	cmp	r1, #3
 8010336:	d103      	bne.n	8010340 <f_close+0x70>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8010338:	0c1b      	lsrs	r3, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 801033a:	0a19      	lsrs	r1, r3, #8
 801033c:	7513      	strb	r3, [r2, #20]
	*ptr++ = (BYTE)val;
 801033e:	7551      	strb	r1, [r2, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8010340:	68e3      	ldr	r3, [r4, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 8010342:	7713      	strb	r3, [r2, #28]
 8010344:	0a19      	lsrs	r1, r3, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8010346:	0c18      	lsrs	r0, r3, #16
 8010348:	7751      	strb	r1, [r2, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 801034a:	0e1b      	lsrs	r3, r3, #24
	*ptr++ = (BYTE)val; val >>= 8;
 801034c:	0a31      	lsrs	r1, r6, #8
 801034e:	7596      	strb	r6, [r2, #22]
	*ptr++ = (BYTE)val; val >>= 8;
 8010350:	7790      	strb	r0, [r2, #30]
	*ptr++ = (BYTE)val;
 8010352:	77d3      	strb	r3, [r2, #31]
	*ptr++ = (BYTE)val; val >>= 8;
 8010354:	0c30      	lsrs	r0, r6, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8010356:	2300      	movs	r3, #0
	*ptr++ = (BYTE)val; val >>= 8;
 8010358:	75d1      	strb	r1, [r2, #23]
	*ptr++ = (BYTE)val; val >>= 8;
 801035a:	0e36      	lsrs	r6, r6, #24
					fs->wflag = 1;
 801035c:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 801035e:	7610      	strb	r0, [r2, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 8010360:	7493      	strb	r3, [r2, #18]
	*ptr++ = (BYTE)val;
 8010362:	74d3      	strb	r3, [r2, #19]
	*ptr++ = (BYTE)val;
 8010364:	7656      	strb	r6, [r2, #25]
					res = sync_fs(fs);					/* Restore it to the directory */
 8010366:	4628      	mov	r0, r5
					fs->wflag = 1;
 8010368:	70e9      	strb	r1, [r5, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 801036a:	f7fd fd55 	bl	800de18 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 801036e:	7d23      	ldrb	r3, [r4, #20]
 8010370:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8010374:	7523      	strb	r3, [r4, #20]
	if (res == FR_OK)
 8010376:	2800      	cmp	r0, #0
 8010378:	d1b6      	bne.n	80102e8 <f_close+0x18>
 801037a:	6825      	ldr	r5, [r4, #0]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 801037c:	2d00      	cmp	r5, #0
 801037e:	d0b2      	beq.n	80102e6 <f_close+0x16>
 8010380:	782b      	ldrb	r3, [r5, #0]
 8010382:	2b00      	cmp	r3, #0
 8010384:	d0af      	beq.n	80102e6 <f_close+0x16>
 8010386:	88a2      	ldrh	r2, [r4, #4]
 8010388:	88eb      	ldrh	r3, [r5, #6]
 801038a:	429a      	cmp	r2, r3
 801038c:	d1ab      	bne.n	80102e6 <f_close+0x16>
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 801038e:	7868      	ldrb	r0, [r5, #1]
 8010390:	f7fd f840 	bl	800d414 <disk_status>
 8010394:	f010 0001 	ands.w	r0, r0, #1
 8010398:	d1a5      	bne.n	80102e6 <f_close+0x16>
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 801039a:	6923      	ldr	r3, [r4, #16]
 801039c:	3b01      	subs	r3, #1
 801039e:	2b13      	cmp	r3, #19
 80103a0:	d825      	bhi.n	80103ee <f_close+0x11e>
		n = Files[i].ctr;
 80103a2:	4915      	ldr	r1, [pc, #84]	; (80103f8 <f_close+0x128>)
 80103a4:	eb01 1503 	add.w	r5, r1, r3, lsl #4
 80103a8:	011b      	lsls	r3, r3, #4
 80103aa:	f8b5 2214 	ldrh.w	r2, [r5, #532]	; 0x214
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 80103ae:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80103b2:	d015      	beq.n	80103e0 <f_close+0x110>
		if (n > 0) n--;				/* Decrement read mode open count */
 80103b4:	b1b2      	cbz	r2, 80103e4 <f_close+0x114>
 80103b6:	3a01      	subs	r2, #1
 80103b8:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 80103ba:	f8a5 2214 	strh.w	r2, [r5, #532]	; 0x214
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 80103be:	b18a      	cbz	r2, 80103e4 <f_close+0x114>
				fp->obj.fs = 0;			/* Invalidate file object */
 80103c0:	2300      	movs	r3, #0
 80103c2:	6023      	str	r3, [r4, #0]
}
 80103c4:	bd70      	pop	{r4, r5, r6, pc}
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 80103c6:	6a22      	ldr	r2, [r4, #32]
 80103c8:	7868      	ldrb	r0, [r5, #1]
 80103ca:	2301      	movs	r3, #1
 80103cc:	f104 0130 	add.w	r1, r4, #48	; 0x30
 80103d0:	f7fd f848 	bl	800d464 <disk_write>
 80103d4:	b968      	cbnz	r0, 80103f2 <f_close+0x122>
				fp->flag &= (BYTE)~FA_DIRTY;
 80103d6:	7d23      	ldrb	r3, [r4, #20]
 80103d8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80103dc:	7523      	strb	r3, [r4, #20]
 80103de:	e791      	b.n	8010304 <f_close+0x34>
		Files[i].ctr = n;
 80103e0:	f8a5 0214 	strh.w	r0, [r5, #532]	; 0x214
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 80103e4:	440b      	add	r3, r1
 80103e6:	2200      	movs	r2, #0
 80103e8:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
			if (res == FR_OK)
 80103ec:	e7e8      	b.n	80103c0 <f_close+0xf0>
		res = FR_INT_ERR;			/* Invalid index nunber */
 80103ee:	2002      	movs	r0, #2
}
 80103f0:	bd70      	pop	{r4, r5, r6, pc}
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 80103f2:	2001      	movs	r0, #1
}
 80103f4:	bd70      	pop	{r4, r5, r6, pc}
 80103f6:	bf00      	nop
 80103f8:	200018c0 	.word	0x200018c0

080103fc <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80103fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80103fe:	b085      	sub	sp, #20
 8010400:	9101      	str	r1, [sp, #4]
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 8010402:	2800      	cmp	r0, #0
 8010404:	d037      	beq.n	8010476 <f_opendir+0x7a>

	/* Get logical drive */
	obj = &dp->obj;
 8010406:	4604      	mov	r4, r0
	res = find_volume(&path, &fs, 0);
 8010408:	2200      	movs	r2, #0
 801040a:	a903      	add	r1, sp, #12
 801040c:	a801      	add	r0, sp, #4
 801040e:	f7fd fea5 	bl	800e15c <find_volume>
	if (res == FR_OK) {
 8010412:	b118      	cbz	r0, 801041c <f_opendir+0x20>
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8010414:	2300      	movs	r3, #0
 8010416:	6023      	str	r3, [r4, #0]

	LEAVE_FF(fs, res);
}
 8010418:	b005      	add	sp, #20
 801041a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		obj->fs = fs;
 801041c:	9b03      	ldr	r3, [sp, #12]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 801041e:	9901      	ldr	r1, [sp, #4]
		obj->fs = fs;
 8010420:	6023      	str	r3, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8010422:	4620      	mov	r0, r4
 8010424:	f7fe faf6 	bl	800ea14 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8010428:	bb08      	cbnz	r0, 801046e <f_opendir+0x72>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 801042a:	f994 302f 	ldrsb.w	r3, [r4, #47]	; 0x2f
 801042e:	2b00      	cmp	r3, #0
 8010430:	db24      	blt.n	801047c <f_opendir+0x80>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 8010432:	79a3      	ldrb	r3, [r4, #6]
 8010434:	06db      	lsls	r3, r3, #27
 8010436:	d51c      	bpl.n	8010472 <f_opendir+0x76>
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8010438:	9a03      	ldr	r2, [sp, #12]
 801043a:	6a21      	ldr	r1, [r4, #32]
	if (fs->fs_type == FS_FAT32) {
 801043c:	7810      	ldrb	r0, [r2, #0]
	rv = rv << 8 | ptr[0];
 801043e:	7ecd      	ldrb	r5, [r1, #27]
 8010440:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 8010442:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8010444:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8010448:	d105      	bne.n	8010456 <f_opendir+0x5a>
	rv = rv << 8 | ptr[0];
 801044a:	7d48      	ldrb	r0, [r1, #21]
 801044c:	7d09      	ldrb	r1, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 801044e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8010452:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8010456:	60a3      	str	r3, [r4, #8]
				obj->id = fs->id;
 8010458:	88d3      	ldrh	r3, [r2, #6]
 801045a:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 801045c:	2100      	movs	r1, #0
 801045e:	4620      	mov	r0, r4
 8010460:	f7fe f86a 	bl	800e538 <dir_sdi>
				if (res == FR_OK) {
 8010464:	b918      	cbnz	r0, 801046e <f_opendir+0x72>
					if (obj->sclust) {
 8010466:	68a6      	ldr	r6, [r4, #8]
 8010468:	b956      	cbnz	r6, 8010480 <f_opendir+0x84>
						obj->lockid = 0;	/* Root directory need not to be locked */
 801046a:	6120      	str	r0, [r4, #16]
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 801046c:	e7d4      	b.n	8010418 <f_opendir+0x1c>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 801046e:	2804      	cmp	r0, #4
 8010470:	d1d0      	bne.n	8010414 <f_opendir+0x18>
 8010472:	2005      	movs	r0, #5
 8010474:	e7ce      	b.n	8010414 <f_opendir+0x18>
	if (!dp) return FR_INVALID_OBJECT;
 8010476:	2009      	movs	r0, #9
}
 8010478:	b005      	add	sp, #20
 801047a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801047c:	9a03      	ldr	r2, [sp, #12]
 801047e:	e7eb      	b.n	8010458 <f_opendir+0x5c>
 8010480:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8010500 <f_opendir+0x104>
		if (Files[i].fs == dp->obj.fs &&
 8010484:	6825      	ldr	r5, [r4, #0]
 8010486:	4662      	mov	r2, ip
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8010488:	4603      	mov	r3, r0
 801048a:	e004      	b.n	8010496 <f_opendir+0x9a>
 801048c:	3301      	adds	r3, #1
 801048e:	2b14      	cmp	r3, #20
 8010490:	f102 0210 	add.w	r2, r2, #16
 8010494:	d018      	beq.n	80104c8 <f_opendir+0xcc>
		if (Files[i].fs == dp->obj.fs &&
 8010496:	6811      	ldr	r1, [r2, #0]
 8010498:	42a9      	cmp	r1, r5
 801049a:	d1f7      	bne.n	801048c <f_opendir+0x90>
 801049c:	6851      	ldr	r1, [r2, #4]
 801049e:	428e      	cmp	r6, r1
 80104a0:	d1f4      	bne.n	801048c <f_opendir+0x90>
			Files[i].clu == dp->obj.sclust &&
 80104a2:	6897      	ldr	r7, [r2, #8]
 80104a4:	6961      	ldr	r1, [r4, #20]
 80104a6:	428f      	cmp	r7, r1
 80104a8:	d1f0      	bne.n	801048c <f_opendir+0x90>
 80104aa:	f8df e058 	ldr.w	lr, [pc, #88]	; 8010504 <f_opendir+0x108>
 80104ae:	eb0e 1103 	add.w	r1, lr, r3, lsl #4
 80104b2:	011a      	lsls	r2, r3, #4
 80104b4:	f8b1 1214 	ldrh.w	r1, [r1, #532]	; 0x214
 80104b8:	3101      	adds	r1, #1
 80104ba:	b289      	uxth	r1, r1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80104bc:	4472      	add	r2, lr
	return i + 1;
 80104be:	3301      	adds	r3, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80104c0:	f8a2 1214 	strh.w	r1, [r2, #532]	; 0x214
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 80104c4:	6123      	str	r3, [r4, #16]
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 80104c6:	e7a7      	b.n	8010418 <f_opendir+0x1c>
 80104c8:	f8df e038 	ldr.w	lr, [pc, #56]	; 8010504 <f_opendir+0x108>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80104cc:	2300      	movs	r3, #0
 80104ce:	e002      	b.n	80104d6 <f_opendir+0xda>
 80104d0:	3301      	adds	r3, #1
 80104d2:	2b14      	cmp	r3, #20
 80104d4:	d00f      	beq.n	80104f6 <f_opendir+0xfa>
 80104d6:	011a      	lsls	r2, r3, #4
 80104d8:	f85c 1002 	ldr.w	r1, [ip, r2]
 80104dc:	2900      	cmp	r1, #0
 80104de:	d1f7      	bne.n	80104d0 <f_opendir+0xd4>
		Files[i].fs = dp->obj.fs;
 80104e0:	eb0e 0c02 	add.w	ip, lr, r2
		Files[i].ofs = dp->dptr;
 80104e4:	6967      	ldr	r7, [r4, #20]
 80104e6:	f8cc 7210 	str.w	r7, [ip, #528]	; 0x210
		Files[i].ctr = 0;
 80104ea:	f8ac 1214 	strh.w	r1, [ip, #532]	; 0x214
		Files[i].clu = dp->obj.sclust;
 80104ee:	e9cc 5682 	strd	r5, r6, [ip, #520]	; 0x208
		Files[i].ctr = 0;
 80104f2:	2101      	movs	r1, #1
 80104f4:	e7e2      	b.n	80104bc <f_opendir+0xc0>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 80104f6:	2300      	movs	r3, #0
 80104f8:	6123      	str	r3, [r4, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 80104fa:	2012      	movs	r0, #18
 80104fc:	e78a      	b.n	8010414 <f_opendir+0x18>
 80104fe:	bf00      	nop
 8010500:	20001ac8 	.word	0x20001ac8
 8010504:	200018c0 	.word	0x200018c0

08010508 <f_closedir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8010508:	b340      	cbz	r0, 801055c <f_closedir+0x54>
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 801050a:	b538      	push	{r3, r4, r5, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 801050c:	6803      	ldr	r3, [r0, #0]
 801050e:	4604      	mov	r4, r0
 8010510:	b12b      	cbz	r3, 801051e <f_closedir+0x16>
 8010512:	781a      	ldrb	r2, [r3, #0]
 8010514:	b11a      	cbz	r2, 801051e <f_closedir+0x16>
 8010516:	8881      	ldrh	r1, [r0, #4]
 8010518:	88da      	ldrh	r2, [r3, #6]
 801051a:	4291      	cmp	r1, r2
 801051c:	d001      	beq.n	8010522 <f_closedir+0x1a>
	FRESULT res = FR_INVALID_OBJECT;
 801051e:	2009      	movs	r0, #9
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 8010520:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8010522:	7858      	ldrb	r0, [r3, #1]
 8010524:	f7fc ff76 	bl	800d414 <disk_status>
 8010528:	f010 0001 	ands.w	r0, r0, #1
 801052c:	d1f7      	bne.n	801051e <f_closedir+0x16>
		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
 801052e:	6923      	ldr	r3, [r4, #16]
 8010530:	b18b      	cbz	r3, 8010556 <f_closedir+0x4e>
	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8010532:	3b01      	subs	r3, #1
 8010534:	2b13      	cmp	r3, #19
 8010536:	d81a      	bhi.n	801056e <f_closedir+0x66>
		n = Files[i].ctr;
 8010538:	490e      	ldr	r1, [pc, #56]	; (8010574 <f_closedir+0x6c>)
 801053a:	eb01 1503 	add.w	r5, r1, r3, lsl #4
 801053e:	011b      	lsls	r3, r3, #4
 8010540:	f8b5 2214 	ldrh.w	r2, [r5, #532]	; 0x214
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8010544:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8010548:	d00a      	beq.n	8010560 <f_closedir+0x58>
		if (n > 0) n--;				/* Decrement read mode open count */
 801054a:	b15a      	cbz	r2, 8010564 <f_closedir+0x5c>
 801054c:	3a01      	subs	r2, #1
 801054e:	b292      	uxth	r2, r2
		Files[i].ctr = n;
 8010550:	f8a5 2214 	strh.w	r2, [r5, #532]	; 0x214
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8010554:	b132      	cbz	r2, 8010564 <f_closedir+0x5c>
			dp->obj.fs = 0;			/* Invalidate directory object */
 8010556:	2300      	movs	r3, #0
 8010558:	6023      	str	r3, [r4, #0]
}
 801055a:	bd38      	pop	{r3, r4, r5, pc}
	FRESULT res = FR_INVALID_OBJECT;
 801055c:	2009      	movs	r0, #9
}
 801055e:	4770      	bx	lr
		Files[i].ctr = n;
 8010560:	f8a5 0214 	strh.w	r0, [r5, #532]	; 0x214
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8010564:	440b      	add	r3, r1
 8010566:	2200      	movs	r2, #0
 8010568:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
		if (res == FR_OK)
 801056c:	e7f3      	b.n	8010556 <f_closedir+0x4e>
		res = FR_INT_ERR;			/* Invalid index nunber */
 801056e:	2002      	movs	r0, #2
}
 8010570:	bd38      	pop	{r3, r4, r5, pc}
 8010572:	bf00      	nop
 8010574:	200018c0 	.word	0x200018c0

08010578 <f_readdir>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8010578:	b318      	cbz	r0, 80105c2 <f_readdir+0x4a>

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 801057a:	b538      	push	{r3, r4, r5, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 801057c:	6803      	ldr	r3, [r0, #0]
 801057e:	4604      	mov	r4, r0
 8010580:	b133      	cbz	r3, 8010590 <f_readdir+0x18>
 8010582:	781a      	ldrb	r2, [r3, #0]
 8010584:	b122      	cbz	r2, 8010590 <f_readdir+0x18>
 8010586:	88da      	ldrh	r2, [r3, #6]
 8010588:	460d      	mov	r5, r1
 801058a:	8881      	ldrh	r1, [r0, #4]
 801058c:	4291      	cmp	r1, r2
 801058e:	d001      	beq.n	8010594 <f_readdir+0x1c>
	FRESULT res = FR_INVALID_OBJECT;
 8010590:	2009      	movs	r0, #9
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 8010592:	bd38      	pop	{r3, r4, r5, pc}
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8010594:	7858      	ldrb	r0, [r3, #1]
 8010596:	f7fc ff3d 	bl	800d414 <disk_status>
 801059a:	07c3      	lsls	r3, r0, #31
 801059c:	d4f8      	bmi.n	8010590 <f_readdir+0x18>
		if (!fno) {
 801059e:	b195      	cbz	r5, 80105c6 <f_readdir+0x4e>
			res = dir_read(dp, 0);			/* Read an item */
 80105a0:	4620      	mov	r0, r4
 80105a2:	f7fd f9f5 	bl	800d990 <dir_read.constprop.0>
			if (res == FR_OK) {				/* A valid entry is found */
 80105a6:	f010 0ffb 	tst.w	r0, #251	; 0xfb
 80105aa:	d1f2      	bne.n	8010592 <f_readdir+0x1a>
				get_fileinfo(dp, fno);		/* Get the object information */
 80105ac:	4629      	mov	r1, r5
 80105ae:	4620      	mov	r0, r4
 80105b0:	f7fc ffe8 	bl	800d584 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 80105b4:	4620      	mov	r0, r4
 80105b6:	f7fd f9a7 	bl	800d908 <dir_next.constprop.0>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 80105ba:	2804      	cmp	r0, #4
 80105bc:	bf08      	it	eq
 80105be:	2000      	moveq	r0, #0
}
 80105c0:	bd38      	pop	{r3, r4, r5, pc}
	FRESULT res = FR_INVALID_OBJECT;
 80105c2:	2009      	movs	r0, #9
}
 80105c4:	4770      	bx	lr
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80105c6:	4629      	mov	r1, r5
 80105c8:	4620      	mov	r0, r4
}
 80105ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80105ce:	f7fd bfb3 	b.w	800e538 <dir_sdi>
 80105d2:	bf00      	nop

080105d4 <f_findnext>:
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80105d4:	b168      	cbz	r0, 80105f2 <f_findnext+0x1e>

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
 80105d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 80105d8:	4e3c      	ldr	r6, [pc, #240]	; (80106cc <f_findnext+0xf8>)
 80105da:	460d      	mov	r5, r1
 80105dc:	4604      	mov	r4, r0
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 80105de:	6823      	ldr	r3, [r4, #0]
 80105e0:	b12b      	cbz	r3, 80105ee <f_findnext+0x1a>
 80105e2:	781a      	ldrb	r2, [r3, #0]
 80105e4:	b11a      	cbz	r2, 80105ee <f_findnext+0x1a>
 80105e6:	88a1      	ldrh	r1, [r4, #4]
 80105e8:	88da      	ldrh	r2, [r3, #6]
 80105ea:	4291      	cmp	r1, r2
 80105ec:	d003      	beq.n	80105f6 <f_findnext+0x22>
					if (*pp++ == '?') nm++; else nx = 1;
 80105ee:	2009      	movs	r0, #9
#if _USE_LFN != 0 && _USE_FIND == 2
		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
}
 80105f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if (*pp++ == '?') nm++; else nx = 1;
 80105f2:	2009      	movs	r0, #9
}
 80105f4:	4770      	bx	lr
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 80105f6:	7858      	ldrb	r0, [r3, #1]
 80105f8:	f7fc ff0c 	bl	800d414 <disk_status>
 80105fc:	07c3      	lsls	r3, r0, #31
 80105fe:	d4f6      	bmi.n	80105ee <f_findnext+0x1a>
		if (!fno) {
 8010600:	2d00      	cmp	r5, #0
 8010602:	d043      	beq.n	801068c <f_findnext+0xb8>
			res = dir_read(dp, 0);			/* Read an item */
 8010604:	4620      	mov	r0, r4
 8010606:	f7fd f9c3 	bl	800d990 <dir_read.constprop.0>
			if (res == FR_OK) {				/* A valid entry is found */
 801060a:	f010 0ffb 	tst.w	r0, #251	; 0xfb
 801060e:	d1ef      	bne.n	80105f0 <f_findnext+0x1c>
				get_fileinfo(dp, fno);		/* Get the object information */
 8010610:	4629      	mov	r1, r5
 8010612:	4620      	mov	r0, r4
 8010614:	f7fc ffb6 	bl	800d584 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 8010618:	4620      	mov	r0, r4
 801061a:	f7fd f975 	bl	800d908 <dir_next.constprop.0>
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 801061e:	f010 0ffb 	tst.w	r0, #251	; 0xfb
 8010622:	d1e5      	bne.n	80105f0 <f_findnext+0x1c>
 8010624:	7dab      	ldrb	r3, [r5, #22]
 8010626:	b3bb      	cbz	r3, 8010698 <f_findnext+0xc4>
		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
 8010628:	f8d4 c034 	ldr.w	ip, [r4, #52]	; 0x34
 801062c:	f105 0116 	add.w	r1, r5, #22
		pp = pat; np = nam;			/* Top of pattern and name to match */
 8010630:	e00d      	b.n	801064e <f_findnext+0x7a>
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 8010632:	f811 0b01 	ldrb.w	r0, [r1], #1
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 8010636:	f1a0 0761 	sub.w	r7, r0, #97	; 0x61
 801063a:	3a20      	subs	r2, #32
 801063c:	2f19      	cmp	r7, #25
 801063e:	b292      	uxth	r2, r2
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 8010640:	b283      	uxth	r3, r0
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 8010642:	d81d      	bhi.n	8010680 <f_findnext+0xac>
 8010644:	3b20      	subs	r3, #32
 8010646:	b29b      	uxth	r3, r3
			if (pc != nc) break;	/* Branch mismatched? */
 8010648:	4293      	cmp	r3, r2
 801064a:	d1c8      	bne.n	80105de <f_findnext+0xa>
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 801064c:	b323      	cbz	r3, 8010698 <f_findnext+0xc4>
 801064e:	4667      	mov	r7, ip
			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
 8010650:	f81c 3b01 	ldrb.w	r3, [ip], #1
 8010654:	2b3f      	cmp	r3, #63	; 0x3f
 8010656:	d021      	beq.n	801069c <f_findnext+0xc8>
 8010658:	2b2a      	cmp	r3, #42	; 0x2a
 801065a:	d01f      	beq.n	801069c <f_findnext+0xc8>
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 801065c:	f1a3 0061 	sub.w	r0, r3, #97	; 0x61
 8010660:	2819      	cmp	r0, #25
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 8010662:	b29a      	uxth	r2, r3
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 8010664:	d9e5      	bls.n	8010632 <f_findnext+0x5e>
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 8010666:	2a7f      	cmp	r2, #127	; 0x7f
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 8010668:	f811 0b01 	ldrb.w	r0, [r1], #1
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 801066c:	bf88      	it	hi
 801066e:	199b      	addhi	r3, r3, r6
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 8010670:	f1a0 0761 	sub.w	r7, r0, #97	; 0x61
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 8010674:	bf88      	it	hi
 8010676:	f813 2c80 	ldrbhi.w	r2, [r3, #-128]
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 801067a:	2f19      	cmp	r7, #25
	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 801067c:	b283      	uxth	r3, r0
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 801067e:	d9e1      	bls.n	8010644 <f_findnext+0x70>
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 8010680:	2b7f      	cmp	r3, #127	; 0x7f
 8010682:	bf84      	itt	hi
 8010684:	1980      	addhi	r0, r0, r6
 8010686:	f810 3c80 	ldrbhi.w	r3, [r0, #-128]
 801068a:	e7dd      	b.n	8010648 <f_findnext+0x74>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 801068c:	4629      	mov	r1, r5
 801068e:	4620      	mov	r0, r4
 8010690:	f7fd ff52 	bl	800e538 <dir_sdi>
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 8010694:	2800      	cmp	r0, #0
 8010696:	d1ab      	bne.n	80105f0 <f_findnext+0x1c>
		res = f_readdir(dp, fno);		/* Get a directory item */
 8010698:	2000      	movs	r0, #0
}
 801069a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
 801069c:	2300      	movs	r3, #0
 801069e:	f817 cb01 	ldrb.w	ip, [r7], #1
 80106a2:	461a      	mov	r2, r3
					if (*pp++ == '?') nm++; else nx = 1;
 80106a4:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
 80106a8:	4638      	mov	r0, r7
				} while (*pp == '?' || *pp == '*');
 80106aa:	f817 cb01 	ldrb.w	ip, [r7], #1
					if (*pp++ == '?') nm++; else nx = 1;
 80106ae:	bf0c      	ite	eq
 80106b0:	3201      	addeq	r2, #1
 80106b2:	2301      	movne	r3, #1
				} while (*pp == '?' || *pp == '*');
 80106b4:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
 80106b8:	d0f4      	beq.n	80106a4 <f_findnext+0xd0>
 80106ba:	f1bc 0f2a 	cmp.w	ip, #42	; 0x2a
 80106be:	d0f1      	beq.n	80106a4 <f_findnext+0xd0>
				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
 80106c0:	f7fc feee 	bl	800d4a0 <pattern_matching>
 80106c4:	2800      	cmp	r0, #0
 80106c6:	d08a      	beq.n	80105de <f_findnext+0xa>
 80106c8:	e7e6      	b.n	8010698 <f_findnext+0xc4>
 80106ca:	bf00      	nop
 80106cc:	0801a1a0 	.word	0x0801a1a0

080106d0 <f_findfirst>:
	DIR* dp,				/* Pointer to the blank directory object */
	FILINFO* fno,			/* Pointer to the file information structure */
	const TCHAR* path,		/* Pointer to the directory to open */
	const TCHAR* pattern	/* Pointer to the matching pattern */
)
{
 80106d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80106d2:	b083      	sub	sp, #12
	FRESULT res;


	dp->pat = pattern;		/* Save pointer to pattern string */
 80106d4:	6343      	str	r3, [r0, #52]	; 0x34
{
 80106d6:	4604      	mov	r4, r0
 80106d8:	4613      	mov	r3, r2
 80106da:	460d      	mov	r5, r1
	res = find_volume(&path, &fs, 0);
 80106dc:	2200      	movs	r2, #0
 80106de:	a901      	add	r1, sp, #4
 80106e0:	4668      	mov	r0, sp
 80106e2:	9300      	str	r3, [sp, #0]
 80106e4:	f7fd fd3a 	bl	800e15c <find_volume>
	if (res == FR_OK) {
 80106e8:	b118      	cbz	r0, 80106f2 <f_findfirst+0x22>
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 80106ea:	2300      	movs	r3, #0
 80106ec:	6023      	str	r3, [r4, #0]
	res = f_opendir(dp, path);		/* Open the target directory */
	if (res == FR_OK) {
		res = f_findnext(dp, fno);	/* Find the first item */
	}
	return res;
}
 80106ee:	b003      	add	sp, #12
 80106f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		obj->fs = fs;
 80106f2:	9b01      	ldr	r3, [sp, #4]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 80106f4:	9900      	ldr	r1, [sp, #0]
		obj->fs = fs;
 80106f6:	6023      	str	r3, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 80106f8:	4620      	mov	r0, r4
 80106fa:	f7fe f98b 	bl	800ea14 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 80106fe:	bb30      	cbnz	r0, 801074e <f_findfirst+0x7e>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 8010700:	f994 302f 	ldrsb.w	r3, [r4, #47]	; 0x2f
 8010704:	2b00      	cmp	r3, #0
 8010706:	db2a      	blt.n	801075e <f_findfirst+0x8e>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 8010708:	79a3      	ldrb	r3, [r4, #6]
 801070a:	06db      	lsls	r3, r3, #27
 801070c:	d525      	bpl.n	801075a <f_findfirst+0x8a>
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 801070e:	9a01      	ldr	r2, [sp, #4]
 8010710:	6a21      	ldr	r1, [r4, #32]
	if (fs->fs_type == FS_FAT32) {
 8010712:	7810      	ldrb	r0, [r2, #0]
	rv = rv << 8 | ptr[0];
 8010714:	7ece      	ldrb	r6, [r1, #27]
 8010716:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 8010718:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 801071a:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
	if (fs->fs_type == FS_FAT32) {
 801071e:	d105      	bne.n	801072c <f_findfirst+0x5c>
	rv = rv << 8 | ptr[0];
 8010720:	7d48      	ldrb	r0, [r1, #21]
 8010722:	7d09      	ldrb	r1, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8010724:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8010728:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 801072c:	60a3      	str	r3, [r4, #8]
				obj->id = fs->id;
 801072e:	88d3      	ldrh	r3, [r2, #6]
 8010730:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8010732:	2100      	movs	r1, #0
 8010734:	4620      	mov	r0, r4
 8010736:	f7fd feff 	bl	800e538 <dir_sdi>
				if (res == FR_OK) {
 801073a:	b940      	cbnz	r0, 801074e <f_findfirst+0x7e>
					if (obj->sclust) {
 801073c:	68a7      	ldr	r7, [r4, #8]
 801073e:	b987      	cbnz	r7, 8010762 <f_findfirst+0x92>
						obj->lockid = 0;	/* Root directory need not to be locked */
 8010740:	6127      	str	r7, [r4, #16]
		res = f_findnext(dp, fno);	/* Find the first item */
 8010742:	4629      	mov	r1, r5
 8010744:	4620      	mov	r0, r4
 8010746:	f7ff ff45 	bl	80105d4 <f_findnext>
}
 801074a:	b003      	add	sp, #12
 801074c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 801074e:	2804      	cmp	r0, #4
 8010750:	d1cb      	bne.n	80106ea <f_findfirst+0x1a>
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8010752:	2300      	movs	r3, #0
 8010754:	6023      	str	r3, [r4, #0]
	res = f_opendir(dp, path);		/* Open the target directory */
 8010756:	2005      	movs	r0, #5
 8010758:	e7c9      	b.n	80106ee <f_findfirst+0x1e>
 801075a:	2005      	movs	r0, #5
 801075c:	e7c5      	b.n	80106ea <f_findfirst+0x1a>
 801075e:	9a01      	ldr	r2, [sp, #4]
 8010760:	e7e5      	b.n	801072e <f_findfirst+0x5e>
 8010762:	f8df c080 	ldr.w	ip, [pc, #128]	; 80107e4 <f_findfirst+0x114>
		if (Files[i].fs == dp->obj.fs &&
 8010766:	6826      	ldr	r6, [r4, #0]
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 8010768:	4603      	mov	r3, r0
 801076a:	4662      	mov	r2, ip
 801076c:	e004      	b.n	8010778 <f_findfirst+0xa8>
 801076e:	3301      	adds	r3, #1
 8010770:	2b14      	cmp	r3, #20
 8010772:	f102 0210 	add.w	r2, r2, #16
 8010776:	d017      	beq.n	80107a8 <f_findfirst+0xd8>
		if (Files[i].fs == dp->obj.fs &&
 8010778:	6811      	ldr	r1, [r2, #0]
 801077a:	42b1      	cmp	r1, r6
 801077c:	d1f7      	bne.n	801076e <f_findfirst+0x9e>
 801077e:	6851      	ldr	r1, [r2, #4]
 8010780:	428f      	cmp	r7, r1
 8010782:	d1f4      	bne.n	801076e <f_findfirst+0x9e>
			Files[i].clu == dp->obj.sclust &&
 8010784:	6890      	ldr	r0, [r2, #8]
 8010786:	6961      	ldr	r1, [r4, #20]
 8010788:	4288      	cmp	r0, r1
 801078a:	d1f0      	bne.n	801076e <f_findfirst+0x9e>
 801078c:	4914      	ldr	r1, [pc, #80]	; (80107e0 <f_findfirst+0x110>)
 801078e:	eb01 1003 	add.w	r0, r1, r3, lsl #4
 8010792:	011a      	lsls	r2, r3, #4
 8010794:	f8b0 6214 	ldrh.w	r6, [r0, #532]	; 0x214
 8010798:	3601      	adds	r6, #1
 801079a:	b2b6      	uxth	r6, r6
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 801079c:	440a      	add	r2, r1
	return i + 1;
 801079e:	3301      	adds	r3, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80107a0:	f8a2 6214 	strh.w	r6, [r2, #532]	; 0x214
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 80107a4:	6123      	str	r3, [r4, #16]
	if (res == FR_OK) {
 80107a6:	e7cc      	b.n	8010742 <f_findfirst+0x72>
 80107a8:	490d      	ldr	r1, [pc, #52]	; (80107e0 <f_findfirst+0x110>)
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80107aa:	2300      	movs	r3, #0
 80107ac:	e002      	b.n	80107b4 <f_findfirst+0xe4>
 80107ae:	3301      	adds	r3, #1
 80107b0:	2b14      	cmp	r3, #20
 80107b2:	d010      	beq.n	80107d6 <f_findfirst+0x106>
 80107b4:	011a      	lsls	r2, r3, #4
 80107b6:	f85c e002 	ldr.w	lr, [ip, r2]
 80107ba:	f1be 0f00 	cmp.w	lr, #0
 80107be:	d1f6      	bne.n	80107ae <f_findfirst+0xde>
		Files[i].fs = dp->obj.fs;
 80107c0:	eb01 0c02 	add.w	ip, r1, r2
		Files[i].ofs = dp->dptr;
 80107c4:	6960      	ldr	r0, [r4, #20]
 80107c6:	f8cc 0210 	str.w	r0, [ip, #528]	; 0x210
		Files[i].clu = dp->obj.sclust;
 80107ca:	e9cc 6782 	strd	r6, r7, [ip, #520]	; 0x208
		Files[i].ctr = 0;
 80107ce:	f8ac e214 	strh.w	lr, [ip, #532]	; 0x214
 80107d2:	2601      	movs	r6, #1
 80107d4:	e7e2      	b.n	801079c <f_findfirst+0xcc>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 80107d6:	2300      	movs	r3, #0
 80107d8:	6123      	str	r3, [r4, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 80107da:	2012      	movs	r0, #18
 80107dc:	e785      	b.n	80106ea <f_findfirst+0x1a>
 80107de:	bf00      	nop
 80107e0:	200018c0 	.word	0x200018c0
 80107e4:	20001ac8 	.word	0x20001ac8

080107e8 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 80107e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80107ec:	b099      	sub	sp, #100	; 0x64
	DWORD dsc, dcl, pcl, tm;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 80107ee:	2202      	movs	r2, #2
{
 80107f0:	9007      	str	r0, [sp, #28]
	res = find_volume(&path, &fs, FA_WRITE);
 80107f2:	a909      	add	r1, sp, #36	; 0x24
 80107f4:	a807      	add	r0, sp, #28
 80107f6:	f7fd fcb1 	bl	800e15c <find_volume>
	dj.obj.fs = fs;
 80107fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80107fc:	930a      	str	r3, [sp, #40]	; 0x28
	if (res == FR_OK) {
 80107fe:	4605      	mov	r5, r0
 8010800:	b118      	cbz	r0, 801080a <f_mkdir+0x22>
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 8010802:	4628      	mov	r0, r5
 8010804:	b019      	add	sp, #100	; 0x64
 8010806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = follow_path(&dj, path);			/* Follow the file path */
 801080a:	9907      	ldr	r1, [sp, #28]
 801080c:	a80a      	add	r0, sp, #40	; 0x28
 801080e:	f7fe f901 	bl	800ea14 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8010812:	b130      	cbz	r0, 8010822 <f_mkdir+0x3a>
		if (res == FR_NO_FILE) {				/* Can create a new directory */
 8010814:	2804      	cmp	r0, #4
 8010816:	d009      	beq.n	801082c <f_mkdir+0x44>
 8010818:	4605      	mov	r5, r0
}
 801081a:	4628      	mov	r0, r5
 801081c:	b019      	add	sp, #100	; 0x64
 801081e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8010822:	2508      	movs	r5, #8
}
 8010824:	4628      	mov	r0, r5
 8010826:	b019      	add	sp, #100	; 0x64
 8010828:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
 801082c:	4629      	mov	r1, r5
 801082e:	a80a      	add	r0, sp, #40	; 0x28
 8010830:	f7fd fb64 	bl	800defc <create_chain>
			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
 8010834:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8010836:	8963      	ldrh	r3, [r4, #10]
 8010838:	025b      	lsls	r3, r3, #9
 801083a:	930d      	str	r3, [sp, #52]	; 0x34
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 801083c:	4607      	mov	r7, r0
 801083e:	2800      	cmp	r0, #0
 8010840:	f000 810e 	beq.w	8010a60 <f_mkdir+0x278>
			if (dcl == 1) res = FR_INT_ERR;
 8010844:	2801      	cmp	r0, #1
 8010846:	f000 810f 	beq.w	8010a68 <f_mkdir+0x280>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 801084a:	1c43      	adds	r3, r0, #1
 801084c:	f000 8115 	beq.w	8010a7a <f_mkdir+0x292>
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8010850:	78e3      	ldrb	r3, [r4, #3]
 8010852:	2b00      	cmp	r3, #0
 8010854:	f040 8113 	bne.w	8010a7e <f_mkdir+0x296>
			tm = GET_FATTIME();
 8010858:	f7fc fe20 	bl	800d49c <get_fattime>
				dsc = clust2sect(fs, dcl);
 801085c:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8010860:	f8d8 3018 	ldr.w	r3, [r8, #24]
	clst -= 2;
 8010864:	1eba      	subs	r2, r7, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8010866:	3b02      	subs	r3, #2
 8010868:	429a      	cmp	r2, r3
	return clst * fs->csize + fs->database;
 801086a:	bf3c      	itt	cc
 801086c:	f8d8 302c 	ldrcc.w	r3, [r8, #44]	; 0x2c
 8010870:	f8b8 600a 	ldrhcc.w	r6, [r8, #10]
				dir = fs->win;
 8010874:	f108 0934 	add.w	r9, r8, #52	; 0x34
			tm = GET_FATTIME();
 8010878:	4683      	mov	fp, r0
	return clst * fs->csize + fs->database;
 801087a:	bf38      	it	cc
 801087c:	fb02 3606 	mlacc	r6, r2, r6, r3
 8010880:	f04f 0100 	mov.w	r1, #0
 8010884:	f44f 7200 	mov.w	r2, #512	; 0x200
 8010888:	4648      	mov	r0, r9
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 801088a:	bf28      	it	cs
 801088c:	2600      	movcs	r6, #0
				mem_set(dir, 0, SS(fs));
 801088e:	f005 fb7f 	bl	8015f90 <memset>
 8010892:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
 8010896:	f8c8 3034 	str.w	r3, [r8, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 801089a:	f3cb 4207 	ubfx	r2, fp, #16, #8
 801089e:	f8c9 3004 	str.w	r3, [r9, #4]
 80108a2:	f8c9 3007 	str.w	r3, [r9, #7]
	*ptr++ = (BYTE)val;
 80108a6:	ea4f 6c1b 	mov.w	ip, fp, lsr #24
	if (fs->fs_type == FS_FAT32) {
 80108aa:	f898 3000 	ldrb.w	r3, [r8]
	*ptr++ = (BYTE)val; val >>= 8;
 80108ae:	9202      	str	r2, [sp, #8]
 80108b0:	9a02      	ldr	r2, [sp, #8]
	*ptr++ = (BYTE)val;
 80108b2:	f8cd c00c 	str.w	ip, [sp, #12]
					dir[DIR_Name] = '.';
 80108b6:	212e      	movs	r1, #46	; 0x2e
	*ptr++ = (BYTE)val; val >>= 8;
 80108b8:	fa5f f08b 	uxtb.w	r0, fp
	*ptr++ = (BYTE)val; val >>= 8;
 80108bc:	f3cb 2407 	ubfx	r4, fp, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 80108c0:	fa5f fc87 	uxtb.w	ip, r7
					dir[DIR_Attr] = AM_DIR;
 80108c4:	f04f 0e10 	mov.w	lr, #16
					dir[DIR_Name] = '.';
 80108c8:	f888 1034 	strb.w	r1, [r8, #52]	; 0x34
	*ptr++ = (BYTE)val; val >>= 8;
 80108cc:	f888 204c 	strb.w	r2, [r8, #76]	; 0x4c
	*ptr++ = (BYTE)val;
 80108d0:	f3c7 2107 	ubfx	r1, r7, #8, #8
	*ptr++ = (BYTE)val;
 80108d4:	9a03      	ldr	r2, [sp, #12]
	*ptr++ = (BYTE)val; val >>= 8;
 80108d6:	9005      	str	r0, [sp, #20]
	if (fs->fs_type == FS_FAT32) {
 80108d8:	2b03      	cmp	r3, #3
	*ptr++ = (BYTE)val; val >>= 8;
 80108da:	9406      	str	r4, [sp, #24]
	*ptr++ = (BYTE)val; val >>= 8;
 80108dc:	f8cd c004 	str.w	ip, [sp, #4]
	*ptr++ = (BYTE)val;
 80108e0:	9104      	str	r1, [sp, #16]
					dir[DIR_Attr] = AM_DIR;
 80108e2:	f888 e03f 	strb.w	lr, [r8, #63]	; 0x3f
	*ptr++ = (BYTE)val; val >>= 8;
 80108e6:	f888 004a 	strb.w	r0, [r8, #74]	; 0x4a
	*ptr++ = (BYTE)val; val >>= 8;
 80108ea:	f888 404b 	strb.w	r4, [r8, #75]	; 0x4b
	*ptr++ = (BYTE)val;
 80108ee:	f888 204d 	strb.w	r2, [r8, #77]	; 0x4d
	*ptr++ = (BYTE)val; val >>= 8;
 80108f2:	f888 c04e 	strb.w	ip, [r8, #78]	; 0x4e
	*ptr++ = (BYTE)val;
 80108f6:	f888 104f 	strb.w	r1, [r8, #79]	; 0x4f
	if (fs->fs_type == FS_FAT32) {
 80108fa:	d106      	bne.n	801090a <f_mkdir+0x122>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 80108fc:	fa27 f30e 	lsr.w	r3, r7, lr
	*ptr++ = (BYTE)val; val >>= 8;
 8010900:	0a1a      	lsrs	r2, r3, #8
 8010902:	f888 3048 	strb.w	r3, [r8, #72]	; 0x48
	*ptr++ = (BYTE)val;
 8010906:	f888 2049 	strb.w	r2, [r8, #73]	; 0x49
void mem_cpy (void* dst, const void* src, UINT cnt) {
 801090a:	f108 0358 	add.w	r3, r8, #88	; 0x58
 801090e:	4599      	cmp	r9, r3
 8010910:	d206      	bcs.n	8010920 <f_mkdir+0x138>
					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
 8010912:	f108 0154 	add.w	r1, r8, #84	; 0x54
 8010916:	f108 0338 	add.w	r3, r8, #56	; 0x38
 801091a:	4299      	cmp	r1, r3
 801091c:	f0c0 80bd 	bcc.w	8010a9a <f_mkdir+0x2b2>
			*d++ = *s++;
 8010920:	f8d8 2034 	ldr.w	r2, [r8, #52]	; 0x34
 8010924:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8010928:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 801092c:	f8c8 3058 	str.w	r3, [r8, #88]	; 0x58
 8010930:	f8d8 203c 	ldr.w	r2, [r8, #60]	; 0x3c
 8010934:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
 8010938:	f8c8 205c 	str.w	r2, [r8, #92]	; 0x5c
 801093c:	f8c8 3060 	str.w	r3, [r8, #96]	; 0x60
 8010940:	f8d8 2044 	ldr.w	r2, [r8, #68]	; 0x44
 8010944:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
 8010948:	f8c8 2064 	str.w	r2, [r8, #100]	; 0x64
 801094c:	f8c8 3068 	str.w	r3, [r8, #104]	; 0x68
 8010950:	f8d8 204c 	ldr.w	r2, [r8, #76]	; 0x4c
 8010954:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 8010958:	f8c8 206c 	str.w	r2, [r8, #108]	; 0x6c
 801095c:	f8c8 3070 	str.w	r3, [r8, #112]	; 0x70
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8010960:	232e      	movs	r3, #46	; 0x2e
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8010962:	9c09      	ldr	r4, [sp, #36]	; 0x24
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8010964:	f888 3055 	strb.w	r3, [r8, #85]	; 0x55
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8010968:	7822      	ldrb	r2, [r4, #0]
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 801096a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 801096c:	2a03      	cmp	r2, #3
 801096e:	d07d      	beq.n	8010a6c <f_mkdir+0x284>
 8010970:	b2dd      	uxtb	r5, r3
 8010972:	f3c3 2207 	ubfx	r2, r3, #8, #8
	*ptr++ = (BYTE)val; val >>= 8;
 8010976:	f888 506e 	strb.w	r5, [r8, #110]	; 0x6e
	*ptr++ = (BYTE)val;
 801097a:	f888 206f 	strb.w	r2, [r8, #111]	; 0x6f
	if (fs->fs_type == FS_FAT32) {
 801097e:	7822      	ldrb	r2, [r4, #0]
 8010980:	2a03      	cmp	r2, #3
 8010982:	d105      	bne.n	8010990 <f_mkdir+0x1a8>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8010984:	0c1b      	lsrs	r3, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8010986:	0a1a      	lsrs	r2, r3, #8
 8010988:	f888 3068 	strb.w	r3, [r8, #104]	; 0x68
	*ptr++ = (BYTE)val;
 801098c:	f888 2069 	strb.w	r2, [r8, #105]	; 0x69
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8010990:	8963      	ldrh	r3, [r4, #10]
 8010992:	2b00      	cmp	r3, #0
 8010994:	d03b      	beq.n	8010a0e <f_mkdir+0x226>
 8010996:	3b01      	subs	r3, #1
 8010998:	4433      	add	r3, r6
					fs->wflag = 1;
 801099a:	f04f 0a01 	mov.w	sl, #1
 801099e:	9700      	str	r7, [sp, #0]
 80109a0:	469b      	mov	fp, r3
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80109a2:	f104 0734 	add.w	r7, r4, #52	; 0x34
 80109a6:	7860      	ldrb	r0, [r4, #1]
					fs->winsect = dsc++;
 80109a8:	6326      	str	r6, [r4, #48]	; 0x30
					fs->wflag = 1;
 80109aa:	f884 a003 	strb.w	sl, [r4, #3]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80109ae:	4639      	mov	r1, r7
 80109b0:	2301      	movs	r3, #1
 80109b2:	4632      	mov	r2, r6
 80109b4:	f7fc fd56 	bl	800d464 <disk_write>
 80109b8:	bb00      	cbnz	r0, 80109fc <f_mkdir+0x214>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80109ba:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80109bc:	69e3      	ldr	r3, [r4, #28]
			fs->wflag = 0;
 80109be:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 80109c0:	1ab2      	subs	r2, r6, r2
 80109c2:	429a      	cmp	r2, r3
 80109c4:	d20f      	bcs.n	80109e6 <f_mkdir+0x1fe>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80109c6:	78a5      	ldrb	r5, [r4, #2]
 80109c8:	2d01      	cmp	r5, #1
 80109ca:	d90c      	bls.n	80109e6 <f_mkdir+0x1fe>
 80109cc:	46b0      	mov	r8, r6
 80109ce:	e000      	b.n	80109d2 <f_mkdir+0x1ea>
 80109d0:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 80109d2:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 80109d4:	4498      	add	r8, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80109d6:	3d01      	subs	r5, #1
					disk_write(fs->drv, fs->win, wsect, 1);
 80109d8:	4642      	mov	r2, r8
 80109da:	2301      	movs	r3, #1
 80109dc:	4639      	mov	r1, r7
 80109de:	f7fc fd41 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80109e2:	2d01      	cmp	r5, #1
 80109e4:	d1f4      	bne.n	80109d0 <f_mkdir+0x1e8>
 80109e6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80109ea:	2100      	movs	r1, #0
 80109ec:	4648      	mov	r0, r9
 80109ee:	f005 facf 	bl	8015f90 <memset>
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 80109f2:	45b3      	cmp	fp, r6
 80109f4:	d00a      	beq.n	8010a0c <f_mkdir+0x224>
 80109f6:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80109f8:	3601      	adds	r6, #1
 80109fa:	e7d2      	b.n	80109a2 <f_mkdir+0x1ba>
 80109fc:	9f00      	ldr	r7, [sp, #0]
			res = FR_DISK_ERR;
 80109fe:	2501      	movs	r5, #1
				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
 8010a00:	4639      	mov	r1, r7
 8010a02:	a80a      	add	r0, sp, #40	; 0x28
 8010a04:	2200      	movs	r2, #0
 8010a06:	f7fe f97d 	bl	800ed04 <remove_chain>
 8010a0a:	e6fa      	b.n	8010802 <f_mkdir+0x1a>
 8010a0c:	9f00      	ldr	r7, [sp, #0]
				res = dir_register(&dj);	/* Register the object to the directoy */
 8010a0e:	a80a      	add	r0, sp, #40	; 0x28
 8010a10:	f7fe fa20 	bl	800ee54 <dir_register>
			if (res == FR_OK) {
 8010a14:	4605      	mov	r5, r0
 8010a16:	2800      	cmp	r0, #0
 8010a18:	d1f2      	bne.n	8010a00 <f_mkdir+0x218>
	*ptr++ = (BYTE)val; val >>= 8;
 8010a1a:	9b05      	ldr	r3, [sp, #20]
	*ptr++ = (BYTE)val; val >>= 8;
 8010a1c:	9a01      	ldr	r2, [sp, #4]
					st_clust(fs, dir, dcl);				/* Table start cluster */
 8010a1e:	9809      	ldr	r0, [sp, #36]	; 0x24
	*ptr++ = (BYTE)val; val >>= 8;
 8010a20:	f363 0507 	bfi	r5, r3, #0, #8
 8010a24:	9b06      	ldr	r3, [sp, #24]
 8010a26:	f363 250f 	bfi	r5, r3, #8, #8
 8010a2a:	9b02      	ldr	r3, [sp, #8]
 8010a2c:	f363 4517 	bfi	r5, r3, #16, #8
					dir = dj.dir;
 8010a30:	9b12      	ldr	r3, [sp, #72]	; 0x48
	*ptr++ = (BYTE)val; val >>= 8;
 8010a32:	769a      	strb	r2, [r3, #26]
	*ptr++ = (BYTE)val; val >>= 8;
 8010a34:	9a03      	ldr	r2, [sp, #12]
 8010a36:	f362 651f 	bfi	r5, r2, #24, #8
	*ptr++ = (BYTE)val;
 8010a3a:	9a04      	ldr	r2, [sp, #16]
	*ptr++ = (BYTE)val; val >>= 8;
 8010a3c:	f8c3 5016 	str.w	r5, [r3, #22]
	*ptr++ = (BYTE)val;
 8010a40:	76da      	strb	r2, [r3, #27]
	if (fs->fs_type == FS_FAT32) {
 8010a42:	7802      	ldrb	r2, [r0, #0]
 8010a44:	2a03      	cmp	r2, #3
 8010a46:	d103      	bne.n	8010a50 <f_mkdir+0x268>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8010a48:	0c3f      	lsrs	r7, r7, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8010a4a:	0a3a      	lsrs	r2, r7, #8
 8010a4c:	751f      	strb	r7, [r3, #20]
	*ptr++ = (BYTE)val;
 8010a4e:	755a      	strb	r2, [r3, #21]
					dir[DIR_Attr] = AM_DIR;				/* Attribute */
 8010a50:	2110      	movs	r1, #16
					fs->wflag = 1;
 8010a52:	2201      	movs	r2, #1
					dir[DIR_Attr] = AM_DIR;				/* Attribute */
 8010a54:	72d9      	strb	r1, [r3, #11]
					fs->wflag = 1;
 8010a56:	70c2      	strb	r2, [r0, #3]
					res = sync_fs(fs);
 8010a58:	f7fd f9de 	bl	800de18 <sync_fs>
 8010a5c:	4605      	mov	r5, r0
 8010a5e:	e6d0      	b.n	8010802 <f_mkdir+0x1a>
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8010a60:	2507      	movs	r5, #7
			tm = GET_FATTIME();
 8010a62:	f7fc fd1b 	bl	800d49c <get_fattime>
			if (res == FR_OK) {					/* Initialize the new directory table */
 8010a66:	e7cb      	b.n	8010a00 <f_mkdir+0x218>
			if (dcl == 1) res = FR_INT_ERR;
 8010a68:	2502      	movs	r5, #2
 8010a6a:	e7fa      	b.n	8010a62 <f_mkdir+0x27a>
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8010a6c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8010a6e:	429a      	cmp	r2, r3
 8010a70:	f47f af7e 	bne.w	8010970 <f_mkdir+0x188>
 8010a74:	2200      	movs	r2, #0
 8010a76:	4613      	mov	r3, r2
 8010a78:	e77d      	b.n	8010976 <f_mkdir+0x18e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8010a7a:	2501      	movs	r5, #1
 8010a7c:	e7f1      	b.n	8010a62 <f_mkdir+0x27a>
		wsect = fs->winsect;	/* Current sector number */
 8010a7e:	6b26      	ldr	r6, [r4, #48]	; 0x30
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8010a80:	7860      	ldrb	r0, [r4, #1]
 8010a82:	f104 0934 	add.w	r9, r4, #52	; 0x34
 8010a86:	4632      	mov	r2, r6
 8010a88:	4649      	mov	r1, r9
 8010a8a:	2301      	movs	r3, #1
 8010a8c:	f7fc fcea 	bl	800d464 <disk_write>
 8010a90:	b150      	cbz	r0, 8010aa8 <f_mkdir+0x2c0>
			tm = GET_FATTIME();
 8010a92:	f7fc fd03 	bl	800d49c <get_fattime>
			res = FR_DISK_ERR;
 8010a96:	2501      	movs	r5, #1
 8010a98:	e7b2      	b.n	8010a00 <f_mkdir+0x218>
					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
 8010a9a:	464b      	mov	r3, r9
			*d++ = *s++;
 8010a9c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8010aa0:	77da      	strb	r2, [r3, #31]
		} while (--cnt);
 8010aa2:	4299      	cmp	r1, r3
 8010aa4:	d1fa      	bne.n	8010a9c <f_mkdir+0x2b4>
 8010aa6:	e75b      	b.n	8010960 <f_mkdir+0x178>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8010aa8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8010aaa:	69e3      	ldr	r3, [r4, #28]
			fs->wflag = 0;
 8010aac:	70e5      	strb	r5, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8010aae:	1ab2      	subs	r2, r6, r2
 8010ab0:	429a      	cmp	r2, r3
 8010ab2:	f4bf aed1 	bcs.w	8010858 <f_mkdir+0x70>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8010ab6:	f894 8002 	ldrb.w	r8, [r4, #2]
 8010aba:	f1b8 0f01 	cmp.w	r8, #1
 8010abe:	d801      	bhi.n	8010ac4 <f_mkdir+0x2dc>
 8010ac0:	e6ca      	b.n	8010858 <f_mkdir+0x70>
 8010ac2:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
 8010ac4:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 8010ac6:	441e      	add	r6, r3
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8010ac8:	f108 38ff 	add.w	r8, r8, #4294967295
					disk_write(fs->drv, fs->win, wsect, 1);
 8010acc:	4632      	mov	r2, r6
 8010ace:	2301      	movs	r3, #1
 8010ad0:	4649      	mov	r1, r9
 8010ad2:	f7fc fcc7 	bl	800d464 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8010ad6:	f1b8 0f01 	cmp.w	r8, #1
 8010ada:	d1f2      	bne.n	8010ac2 <f_mkdir+0x2da>
 8010adc:	e6bc      	b.n	8010858 <f_mkdir+0x70>
 8010ade:	bf00      	nop

08010ae0 <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 8010ae0:	b4f0      	push	{r4, r5, r6, r7}
  if(disk.nbr < _VOLUMES)
 8010ae2:	4b0f      	ldr	r3, [pc, #60]	; (8010b20 <FATFS_LinkDriver+0x40>)
 8010ae4:	7a5c      	ldrb	r4, [r3, #9]
 8010ae6:	b9c4      	cbnz	r4, 8010b1a <FATFS_LinkDriver+0x3a>
    disk.is_initialized[disk.nbr] = 0;
 8010ae8:	7a5f      	ldrb	r7, [r3, #9]
    disk.drv[disk.nbr] = drv;
 8010aea:	7a5e      	ldrb	r6, [r3, #9]
    disk.lun[disk.nbr] = lun;
 8010aec:	7a5d      	ldrb	r5, [r3, #9]
 8010aee:	4602      	mov	r2, r0
    disk.drv[disk.nbr] = drv;
 8010af0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8010af4:	f004 00ff 	and.w	r0, r4, #255	; 0xff
    DiskNum = disk.nbr++;
 8010af8:	7a5c      	ldrb	r4, [r3, #9]
    disk.drv[disk.nbr] = drv;
 8010afa:	6072      	str	r2, [r6, #4]
    disk.lun[disk.nbr] = lun;
 8010afc:	441d      	add	r5, r3
    DiskNum = disk.nbr++;
 8010afe:	1c62      	adds	r2, r4, #1
    disk.is_initialized[disk.nbr] = 0;
 8010b00:	55d8      	strb	r0, [r3, r7]
    DiskNum = disk.nbr++;
 8010b02:	b2d2      	uxtb	r2, r2
    disk.lun[disk.nbr] = lun;
 8010b04:	7228      	strb	r0, [r5, #8]
    DiskNum = disk.nbr++;
 8010b06:	725a      	strb	r2, [r3, #9]
    path[0] = DiskNum + '0';
 8010b08:	3430      	adds	r4, #48	; 0x30
    path[1] = ':';
 8010b0a:	253a      	movs	r5, #58	; 0x3a
    path[2] = '/';
 8010b0c:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 8010b0e:	700c      	strb	r4, [r1, #0]
    path[1] = ':';
 8010b10:	704d      	strb	r5, [r1, #1]
    path[3] = 0;
 8010b12:	70c8      	strb	r0, [r1, #3]
  return FATFS_LinkDriverEx(drv, path, 0);
}
 8010b14:	bcf0      	pop	{r4, r5, r6, r7}
    path[2] = '/';
 8010b16:	708b      	strb	r3, [r1, #2]
}
 8010b18:	4770      	bx	lr
  uint8_t ret = 1;
 8010b1a:	2001      	movs	r0, #1
}
 8010b1c:	bcf0      	pop	{r4, r5, r6, r7}
 8010b1e:	4770      	bx	lr
 8010b20:	20001c08 	.word	0x20001c08

08010b24 <FATFS_UnLinkDriver>:
uint8_t FATFS_UnLinkDriverEx(char *path, uint8_t lun)
{
  uint8_t DiskNum = 0;
  uint8_t ret = 1;

  if(disk.nbr >= 1)
 8010b24:	4a0d      	ldr	r2, [pc, #52]	; (8010b5c <FATFS_UnLinkDriver+0x38>)
 8010b26:	7a53      	ldrb	r3, [r2, #9]
 8010b28:	b193      	cbz	r3, 8010b50 <FATFS_UnLinkDriver+0x2c>
  *         drivers.
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriver(char *path)
{
 8010b2a:	b410      	push	{r4}
    DiskNum = path[0] - '0';
 8010b2c:	7803      	ldrb	r3, [r0, #0]
 8010b2e:	3b30      	subs	r3, #48	; 0x30
    if(disk.drv[DiskNum] != 0)
 8010b30:	b2db      	uxtb	r3, r3
 8010b32:	eb02 0483 	add.w	r4, r2, r3, lsl #2
 8010b36:	6861      	ldr	r1, [r4, #4]
 8010b38:	b161      	cbz	r1, 8010b54 <FATFS_UnLinkDriver+0x30>
      disk.nbr--;
 8010b3a:	7a51      	ldrb	r1, [r2, #9]
      disk.lun[DiskNum] = 0;
 8010b3c:	4413      	add	r3, r2
      disk.nbr--;
 8010b3e:	3901      	subs	r1, #1
      disk.drv[DiskNum] = 0;
 8010b40:	2000      	movs	r0, #0
      disk.nbr--;
 8010b42:	b2c9      	uxtb	r1, r1
      disk.lun[DiskNum] = 0;
 8010b44:	7218      	strb	r0, [r3, #8]
      disk.nbr--;
 8010b46:	7251      	strb	r1, [r2, #9]
      disk.drv[DiskNum] = 0;
 8010b48:	6060      	str	r0, [r4, #4]
  return FATFS_UnLinkDriverEx(path, 0);
}
 8010b4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010b4e:	4770      	bx	lr
  uint8_t ret = 1;
 8010b50:	2001      	movs	r0, #1
}
 8010b52:	4770      	bx	lr
  uint8_t ret = 1;
 8010b54:	2001      	movs	r0, #1
}
 8010b56:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010b5a:	4770      	bx	lr
 8010b5c:	20001c08 	.word	0x20001c08

08010b60 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8010b60:	b538      	push	{r3, r4, r5, lr}
  Stat = STA_NOINIT;
 8010b62:	4c0a      	ldr	r4, [pc, #40]	; (8010b8c <SD_initialize+0x2c>)
 8010b64:	2501      	movs	r5, #1
 8010b66:	7025      	strb	r5, [r4, #0]
#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
 8010b68:	f7f3 ff88 	bl	8004a7c <BSP_SD_Init>
 8010b6c:	b108      	cbz	r0, 8010b72 <SD_initialize+0x12>
  }

#else
  Stat = SD_CheckStatus(lun);
#endif
  return Stat;
 8010b6e:	7820      	ldrb	r0, [r4, #0]
}
 8010b70:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
 8010b72:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 8010b74:	f7f3 ffb2 	bl	8004adc <BSP_SD_GetCardState>
 8010b78:	b918      	cbnz	r0, 8010b82 <SD_initialize+0x22>
    Stat &= ~STA_NOINIT;
 8010b7a:	7823      	ldrb	r3, [r4, #0]
 8010b7c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8010b80:	7023      	strb	r3, [r4, #0]
  return Stat;
 8010b82:	7823      	ldrb	r3, [r4, #0]
 8010b84:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
 8010b86:	7023      	strb	r3, [r4, #0]
  return Stat;
 8010b88:	7820      	ldrb	r0, [r4, #0]
}
 8010b8a:	bd38      	pop	{r3, r4, r5, pc}
 8010b8c:	20000130 	.word	0x20000130

08010b90 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8010b90:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 8010b92:	4c06      	ldr	r4, [pc, #24]	; (8010bac <SD_status+0x1c>)
 8010b94:	2301      	movs	r3, #1
 8010b96:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 8010b98:	f7f3 ffa0 	bl	8004adc <BSP_SD_GetCardState>
 8010b9c:	b918      	cbnz	r0, 8010ba6 <SD_status+0x16>
    Stat &= ~STA_NOINIT;
 8010b9e:	7823      	ldrb	r3, [r4, #0]
 8010ba0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8010ba4:	7023      	strb	r3, [r4, #0]
  return Stat;
 8010ba6:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
 8010ba8:	bd10      	pop	{r4, pc}
 8010baa:	bf00      	nop
 8010bac:	20000130 	.word	0x20000130

08010bb0 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8010bb0:	b570      	push	{r4, r5, r6, lr}
  DRESULT res = RES_ERROR;
  ReadStatus = 0;
 8010bb2:	4c16      	ldr	r4, [pc, #88]	; (8010c0c <SD_read+0x5c>)
  uint32_t timeout;
#if (ENABLE_SD_DMA_CACHE_MAINTENANCE == 1)
  uint32_t alignedAddr;
#endif

  if(BSP_SD_ReadBlocks_DMA((uint32_t*)buff,
 8010bb4:	4608      	mov	r0, r1
 8010bb6:	4611      	mov	r1, r2
 8010bb8:	461a      	mov	r2, r3
  ReadStatus = 0;
 8010bba:	2300      	movs	r3, #0
 8010bbc:	6023      	str	r3, [r4, #0]
  if(BSP_SD_ReadBlocks_DMA((uint32_t*)buff,
 8010bbe:	f7f3 fefd 	bl	80049bc <BSP_SD_ReadBlocks_DMA>
 8010bc2:	b108      	cbz	r0, 8010bc8 <SD_read+0x18>
  DRESULT res = RES_ERROR;
 8010bc4:	2001      	movs	r0, #1
      }
    }
  }

  return res;
}
 8010bc6:	bd70      	pop	{r4, r5, r6, pc}
    timeout = HAL_GetTick();
 8010bc8:	f7f4 f80a 	bl	8004be0 <HAL_GetTick>
    while((ReadStatus == 0) && ((HAL_GetTick() - timeout) < SD_TIMEOUT))
 8010bcc:	f247 562f 	movw	r6, #29999	; 0x752f
    timeout = HAL_GetTick();
 8010bd0:	4605      	mov	r5, r0
    while((ReadStatus == 0) && ((HAL_GetTick() - timeout) < SD_TIMEOUT))
 8010bd2:	e004      	b.n	8010bde <SD_read+0x2e>
 8010bd4:	f7f4 f804 	bl	8004be0 <HAL_GetTick>
 8010bd8:	1b40      	subs	r0, r0, r5
 8010bda:	42b0      	cmp	r0, r6
 8010bdc:	d802      	bhi.n	8010be4 <SD_read+0x34>
 8010bde:	6823      	ldr	r3, [r4, #0]
 8010be0:	2b00      	cmp	r3, #0
 8010be2:	d0f7      	beq.n	8010bd4 <SD_read+0x24>
    if (ReadStatus == 0)
 8010be4:	6823      	ldr	r3, [r4, #0]
 8010be6:	2b00      	cmp	r3, #0
 8010be8:	d0ec      	beq.n	8010bc4 <SD_read+0x14>
      ReadStatus = 0;
 8010bea:	2300      	movs	r3, #0
 8010bec:	6023      	str	r3, [r4, #0]
      timeout = HAL_GetTick();
 8010bee:	f7f3 fff7 	bl	8004be0 <HAL_GetTick>
      while((HAL_GetTick() - timeout) < SD_TIMEOUT)
 8010bf2:	f247 552f 	movw	r5, #29999	; 0x752f
      timeout = HAL_GetTick();
 8010bf6:	4604      	mov	r4, r0
      while((HAL_GetTick() - timeout) < SD_TIMEOUT)
 8010bf8:	f7f3 fff2 	bl	8004be0 <HAL_GetTick>
 8010bfc:	1b00      	subs	r0, r0, r4
 8010bfe:	42a8      	cmp	r0, r5
 8010c00:	d8e0      	bhi.n	8010bc4 <SD_read+0x14>
        if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8010c02:	f7f3 ff6b 	bl	8004adc <BSP_SD_GetCardState>
 8010c06:	2800      	cmp	r0, #0
 8010c08:	d1f6      	bne.n	8010bf8 <SD_read+0x48>
}
 8010c0a:	bd70      	pop	{r4, r5, r6, pc}
 8010c0c:	20001c14 	.word	0x20001c14

08010c10 <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8010c10:	b538      	push	{r3, r4, r5, lr}
  DRESULT res = RES_ERROR;
  WriteStatus = 0;
 8010c12:	4d13      	ldr	r5, [pc, #76]	; (8010c60 <SD_write+0x50>)
   */
  alignedAddr = (uint32_t)buff &  ~0x1F;
  SCB_CleanDCache_by_Addr((uint32_t*)alignedAddr, count*BLOCKSIZE + ((uint32_t)buff - alignedAddr));
#endif

  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
 8010c14:	4608      	mov	r0, r1
 8010c16:	4611      	mov	r1, r2
 8010c18:	461a      	mov	r2, r3
  WriteStatus = 0;
 8010c1a:	2300      	movs	r3, #0
 8010c1c:	606b      	str	r3, [r5, #4]
  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
 8010c1e:	f7f3 fedb 	bl	80049d8 <BSP_SD_WriteBlocks_DMA>
 8010c22:	b108      	cbz	r0, 8010c28 <SD_write+0x18>
  DRESULT res = RES_ERROR;
 8010c24:	2001      	movs	r0, #1
      }
    }
  }

  return res;
}
 8010c26:	bd38      	pop	{r3, r4, r5, pc}
    timeout = HAL_GetTick();
 8010c28:	4604      	mov	r4, r0
 8010c2a:	f7f3 ffd9 	bl	8004be0 <HAL_GetTick>
    osSemaphoreWait(sdioSem_id, SD_TIMEOUT);
 8010c2e:	4b0d      	ldr	r3, [pc, #52]	; (8010c64 <SD_write+0x54>)
 8010c30:	f247 5130 	movw	r1, #30000	; 0x7530
 8010c34:	6818      	ldr	r0, [r3, #0]
 8010c36:	f000 f8f9 	bl	8010e2c <osSemaphoreWait>
    if (WriteStatus == 0)
 8010c3a:	686b      	ldr	r3, [r5, #4]
 8010c3c:	2b00      	cmp	r3, #0
 8010c3e:	d0f1      	beq.n	8010c24 <SD_write+0x14>
      WriteStatus = 0;
 8010c40:	606c      	str	r4, [r5, #4]
      timeout = HAL_GetTick();
 8010c42:	f7f3 ffcd 	bl	8004be0 <HAL_GetTick>
      while((HAL_GetTick() - timeout) < SD_TIMEOUT)
 8010c46:	f247 552f 	movw	r5, #29999	; 0x752f
      timeout = HAL_GetTick();
 8010c4a:	4604      	mov	r4, r0
      while((HAL_GetTick() - timeout) < SD_TIMEOUT)
 8010c4c:	f7f3 ffc8 	bl	8004be0 <HAL_GetTick>
 8010c50:	1b00      	subs	r0, r0, r4
 8010c52:	42a8      	cmp	r0, r5
 8010c54:	d8e6      	bhi.n	8010c24 <SD_write+0x14>
        if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8010c56:	f7f3 ff41 	bl	8004adc <BSP_SD_GetCardState>
 8010c5a:	2800      	cmp	r0, #0
 8010c5c:	d1f6      	bne.n	8010c4c <SD_write+0x3c>
}
 8010c5e:	bd38      	pop	{r3, r4, r5, pc}
 8010c60:	20001c14 	.word	0x20001c14
 8010c64:	2001965c 	.word	0x2001965c

08010c68 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8010c68:	4b15      	ldr	r3, [pc, #84]	; (8010cc0 <SD_ioctl+0x58>)
 8010c6a:	781b      	ldrb	r3, [r3, #0]
 8010c6c:	07db      	lsls	r3, r3, #31
 8010c6e:	d411      	bmi.n	8010c94 <SD_ioctl+0x2c>
{
 8010c70:	b510      	push	{r4, lr}
 8010c72:	4608      	mov	r0, r1
 8010c74:	b08a      	sub	sp, #40	; 0x28
 8010c76:	4614      	mov	r4, r2

  switch (cmd)
 8010c78:	2903      	cmp	r1, #3
 8010c7a:	d81e      	bhi.n	8010cba <SD_ioctl+0x52>
 8010c7c:	e8df f001 	tbb	[pc, r1]
 8010c80:	0c150208 	.word	0x0c150208
    res = RES_OK;
    break;

  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    BSP_SD_GetCardInfo(&CardInfo);
 8010c84:	a801      	add	r0, sp, #4
 8010c86:	f7f3 ff33 	bl	8004af0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 8010c8a:	9b07      	ldr	r3, [sp, #28]
 8010c8c:	6023      	str	r3, [r4, #0]
    res = RES_OK;
 8010c8e:	2000      	movs	r0, #0
  default:
    res = RES_PARERR;
  }

  return res;
}
 8010c90:	b00a      	add	sp, #40	; 0x28
 8010c92:	bd10      	pop	{r4, pc}
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8010c94:	2003      	movs	r0, #3
}
 8010c96:	4770      	bx	lr
    BSP_SD_GetCardInfo(&CardInfo);
 8010c98:	a801      	add	r0, sp, #4
 8010c9a:	f7f3 ff29 	bl	8004af0 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 8010c9e:	9b08      	ldr	r3, [sp, #32]
 8010ca0:	2000      	movs	r0, #0
 8010ca2:	0a5b      	lsrs	r3, r3, #9
 8010ca4:	6023      	str	r3, [r4, #0]
}
 8010ca6:	b00a      	add	sp, #40	; 0x28
 8010ca8:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 8010caa:	a801      	add	r0, sp, #4
 8010cac:	f7f3 ff20 	bl	8004af0 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 8010cb0:	9b08      	ldr	r3, [sp, #32]
 8010cb2:	8023      	strh	r3, [r4, #0]
    res = RES_OK;
 8010cb4:	2000      	movs	r0, #0
}
 8010cb6:	b00a      	add	sp, #40	; 0x28
 8010cb8:	bd10      	pop	{r4, pc}
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8010cba:	2004      	movs	r0, #4
 8010cbc:	e7e8      	b.n	8010c90 <SD_ioctl+0x28>
 8010cbe:	bf00      	nop
 8010cc0:	20000130 	.word	0x20000130

08010cc4 <BSP_SD_WriteCpltCallback>:
  */
//void BSP_SD_WriteCpltCallback(uint32_t SdCard)
void BSP_SD_WriteCpltCallback(void)
{
  WriteStatus = 1;
  osSemaphoreRelease(sdioSem_id);
 8010cc4:	4a03      	ldr	r2, [pc, #12]	; (8010cd4 <BSP_SD_WriteCpltCallback+0x10>)
  WriteStatus = 1;
 8010cc6:	4b04      	ldr	r3, [pc, #16]	; (8010cd8 <BSP_SD_WriteCpltCallback+0x14>)
  osSemaphoreRelease(sdioSem_id);
 8010cc8:	6810      	ldr	r0, [r2, #0]
  WriteStatus = 1;
 8010cca:	2201      	movs	r2, #1
 8010ccc:	605a      	str	r2, [r3, #4]
  osSemaphoreRelease(sdioSem_id);
 8010cce:	f000 b8d9 	b.w	8010e84 <osSemaphoreRelease>
 8010cd2:	bf00      	nop
 8010cd4:	2001965c 	.word	0x2001965c
 8010cd8:	20001c14 	.word	0x20001c14

08010cdc <BSP_SD_ReadCpltCallback>:
   ===============================================================================
  */
//void BSP_SD_ReadCpltCallback(uint32_t SdCard)
void BSP_SD_ReadCpltCallback(void)
{
  ReadStatus = 1;
 8010cdc:	4b01      	ldr	r3, [pc, #4]	; (8010ce4 <BSP_SD_ReadCpltCallback+0x8>)
 8010cde:	2201      	movs	r2, #1
 8010ce0:	601a      	str	r2, [r3, #0]
}
 8010ce2:	4770      	bx	lr
 8010ce4:	20001c14 	.word	0x20001c14

08010ce8 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 8010ce8:	287f      	cmp	r0, #127	; 0x7f
 8010cea:	d912      	bls.n	8010d12 <ff_convert+0x2a>
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
 8010cec:	b991      	cbnz	r1, 8010d14 <ff_convert+0x2c>
{
 8010cee:	b410      	push	{r4}
 8010cf0:	4b0e      	ldr	r3, [pc, #56]	; (8010d2c <ff_convert+0x44>)
 8010cf2:	e001      	b.n	8010cf8 <ff_convert+0x10>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 8010cf4:	2980      	cmp	r1, #128	; 0x80
 8010cf6:	d016      	beq.n	8010d26 <ff_convert+0x3e>
				if (chr == Tbl[c]) break;
 8010cf8:	f833 2b02 	ldrh.w	r2, [r3], #2
 8010cfc:	4282      	cmp	r2, r0
 8010cfe:	b28c      	uxth	r4, r1
 8010d00:	f101 0101 	add.w	r1, r1, #1
 8010d04:	d1f6      	bne.n	8010cf4 <ff_convert+0xc>
 8010d06:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8010d0a:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 8010d0c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010d10:	4770      	bx	lr
 8010d12:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8010d14:	28ff      	cmp	r0, #255	; 0xff
 8010d16:	d804      	bhi.n	8010d22 <ff_convert+0x3a>
 8010d18:	4b04      	ldr	r3, [pc, #16]	; (8010d2c <ff_convert+0x44>)
 8010d1a:	3880      	subs	r0, #128	; 0x80
 8010d1c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8010d20:	4770      	bx	lr
 8010d22:	2000      	movs	r0, #0
 8010d24:	4770      	bx	lr
 8010d26:	2000      	movs	r0, #0
 8010d28:	e7f0      	b.n	8010d0c <ff_convert+0x24>
 8010d2a:	bf00      	nop
 8010d2c:	0801a244 	.word	0x0801a244

08010d30 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
 8010d30:	b470      	push	{r4, r5, r6}
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 8010d32:	4b24      	ldr	r3, [pc, #144]	; (8010dc4 <ff_wtoupper+0x94>)
 8010d34:	f503 72fa 	add.w	r2, r3, #500	; 0x1f4
 8010d38:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8010d3c:	bf28      	it	cs
 8010d3e:	4613      	movcs	r3, r2
 8010d40:	3304      	adds	r3, #4
 8010d42:	e00b      	b.n	8010d5c <ff_wtoupper+0x2c>
	for (;;) {
		bc = *p++;								/* Get block base */
		if (!bc || chr < bc) break;
 8010d44:	4288      	cmp	r0, r1
 8010d46:	d30e      	bcc.n	8010d66 <ff_wtoupper+0x36>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8010d48:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 8010d4c:	b2d4      	uxtb	r4, r2
		if (chr < bc + nc) {	/* In the block? */
 8010d4e:	1865      	adds	r5, r4, r1
 8010d50:	42a8      	cmp	r0, r5
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8010d52:	ea4f 2212 	mov.w	r2, r2, lsr #8
		if (chr < bc + nc) {	/* In the block? */
 8010d56:	db08      	blt.n	8010d6a <ff_wtoupper+0x3a>
 8010d58:	3304      	adds	r3, #4
			case 7: chr -= 80; break;				/* Shift -80 */
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
			}
			break;
		}
		if (!cmd) p += nc;
 8010d5a:	b17a      	cbz	r2, 8010d7c <ff_wtoupper+0x4c>
		bc = *p++;								/* Get block base */
 8010d5c:	f833 1c04 	ldrh.w	r1, [r3, #-4]
		if (!bc || chr < bc) break;
 8010d60:	461e      	mov	r6, r3
 8010d62:	2900      	cmp	r1, #0
 8010d64:	d1ee      	bne.n	8010d44 <ff_wtoupper+0x14>
	}

	return chr;
}
 8010d66:	bc70      	pop	{r4, r5, r6}
 8010d68:	4770      	bx	lr
			switch (cmd) {
 8010d6a:	2a08      	cmp	r2, #8
 8010d6c:	d8fb      	bhi.n	8010d66 <ff_wtoupper+0x36>
 8010d6e:	e8df f002 	tbb	[pc, r2]
 8010d72:	100c      	.short	0x100c
 8010d74:	1f1c1916 	.word	0x1f1c1916
 8010d78:	2522      	.short	0x2522
 8010d7a:	08          	.byte	0x08
 8010d7b:	00          	.byte	0x00
		if (!cmd) p += nc;
 8010d7c:	eb06 0344 	add.w	r3, r6, r4, lsl #1
 8010d80:	e7de      	b.n	8010d40 <ff_wtoupper+0x10>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 8010d82:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
 8010d86:	b280      	uxth	r0, r0
 8010d88:	e7ed      	b.n	8010d66 <ff_wtoupper+0x36>
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 8010d8a:	1a41      	subs	r1, r0, r1
 8010d8c:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
 8010d90:	e7e9      	b.n	8010d66 <ff_wtoupper+0x36>
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 8010d92:	1a41      	subs	r1, r0, r1
 8010d94:	f001 0301 	and.w	r3, r1, #1
 8010d98:	1ac0      	subs	r0, r0, r3
 8010d9a:	b280      	uxth	r0, r0
 8010d9c:	e7e3      	b.n	8010d66 <ff_wtoupper+0x36>
			case 2: chr -= 16; break;				/* Shift -16 */
 8010d9e:	3810      	subs	r0, #16
 8010da0:	b280      	uxth	r0, r0
 8010da2:	e7e0      	b.n	8010d66 <ff_wtoupper+0x36>
			case 3:	chr -= 32; break;				/* Shift -32 */
 8010da4:	3820      	subs	r0, #32
 8010da6:	b280      	uxth	r0, r0
 8010da8:	e7dd      	b.n	8010d66 <ff_wtoupper+0x36>
			case 4:	chr -= 48; break;				/* Shift -48 */
 8010daa:	3830      	subs	r0, #48	; 0x30
 8010dac:	b280      	uxth	r0, r0
 8010dae:	e7da      	b.n	8010d66 <ff_wtoupper+0x36>
			case 5:	chr -= 26; break;				/* Shift -26 */
 8010db0:	381a      	subs	r0, #26
 8010db2:	b280      	uxth	r0, r0
 8010db4:	e7d7      	b.n	8010d66 <ff_wtoupper+0x36>
			case 6:	chr += 8; break;				/* Shift +8 */
 8010db6:	3008      	adds	r0, #8
 8010db8:	b280      	uxth	r0, r0
 8010dba:	e7d4      	b.n	8010d66 <ff_wtoupper+0x36>
			case 7: chr -= 80; break;				/* Shift -80 */
 8010dbc:	3850      	subs	r0, #80	; 0x50
 8010dbe:	b280      	uxth	r0, r0
 8010dc0:	e7d1      	b.n	8010d66 <ff_wtoupper+0x36>
 8010dc2:	bf00      	nop
 8010dc4:	0801a344 	.word	0x0801a344

08010dc8 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8010dc8:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8010dca:	f001 fb0d 	bl	80123e8 <vTaskStartScheduler>
  
  return osOK;
}
 8010dce:	2000      	movs	r0, #0
 8010dd0:	bd08      	pop	{r3, pc}
 8010dd2:	bf00      	nop

08010dd4 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8010dd4:	b530      	push	{r4, r5, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8010dd6:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
{
 8010dda:	b085      	sub	sp, #20
  if (priority != osPriorityError) {
 8010ddc:	2c84      	cmp	r4, #132	; 0x84
{
 8010dde:	4602      	mov	r2, r0
    fpriority += (priority - osPriorityIdle);
 8010de0:	bf14      	ite	ne
 8010de2:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8010de4:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8010de6:	ad03      	add	r5, sp, #12
{
 8010de8:	460b      	mov	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8010dea:	6840      	ldr	r0, [r0, #4]
 8010dec:	6811      	ldr	r1, [r2, #0]
 8010dee:	8a12      	ldrh	r2, [r2, #16]
 8010df0:	e9cd 4500 	strd	r4, r5, [sp]
 8010df4:	f001 f918 	bl	8012028 <xTaskCreate>
 8010df8:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8010dfa:	bf0c      	ite	eq
 8010dfc:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 8010dfe:	2000      	movne	r0, #0
}
 8010e00:	b005      	add	sp, #20
 8010e02:	bd30      	pop	{r4, r5, pc}

08010e04 <osSemaphoreCreate>:
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 8010e04:	2901      	cmp	r1, #1
{ 
 8010e06:	4608      	mov	r0, r1
  if (count == 1) {
 8010e08:	d001      	beq.n	8010e0e <osSemaphoreCreate+0xa>
    vSemaphoreCreateBinary(sema);
    return sema;
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
 8010e0a:	f000 ba6d 	b.w	80112e8 <xQueueCreateCountingSemaphore>
{ 
 8010e0e:	b510      	push	{r4, lr}
    vSemaphoreCreateBinary(sema);
 8010e10:	2203      	movs	r2, #3
 8010e12:	2100      	movs	r1, #0
 8010e14:	f000 fa20 	bl	8011258 <xQueueGenericCreate>
 8010e18:	4604      	mov	r4, r0
 8010e1a:	b120      	cbz	r0, 8010e26 <osSemaphoreCreate+0x22>
 8010e1c:	2300      	movs	r3, #0
 8010e1e:	461a      	mov	r2, r3
 8010e20:	4619      	mov	r1, r3
 8010e22:	f000 faa5 	bl	8011370 <xQueueGenericSend>
#else
    return NULL;
#endif
  }
#endif
}
 8010e26:	4620      	mov	r0, r4
 8010e28:	bd10      	pop	{r4, pc}
 8010e2a:	bf00      	nop

08010e2c <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8010e2c:	b510      	push	{r4, lr}
 8010e2e:	b082      	sub	sp, #8
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8010e30:	2400      	movs	r4, #0
 8010e32:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 8010e34:	b300      	cbz	r0, 8010e78 <osSemaphoreWait+0x4c>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8010e36:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8010e3a:	b933      	cbnz	r3, 8010e4a <osSemaphoreWait+0x1e>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8010e3c:	f000 fe60 	bl	8011b00 <xQueueSemaphoreTake>
 8010e40:	2801      	cmp	r0, #1
 8010e42:	d116      	bne.n	8010e72 <osSemaphoreWait+0x46>
    return osErrorOS;
  }
  
  return osOK;
 8010e44:	2000      	movs	r0, #0
}
 8010e46:	b002      	add	sp, #8
 8010e48:	bd10      	pop	{r4, pc}
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8010e4a:	aa01      	add	r2, sp, #4
 8010e4c:	4621      	mov	r1, r4
 8010e4e:	f000 ffe7 	bl	8011e20 <xQueueReceiveFromISR>
 8010e52:	2801      	cmp	r0, #1
 8010e54:	d10d      	bne.n	8010e72 <osSemaphoreWait+0x46>
	portEND_SWITCHING_ISR(taskWoken);
 8010e56:	9b01      	ldr	r3, [sp, #4]
 8010e58:	2b00      	cmp	r3, #0
 8010e5a:	d0f3      	beq.n	8010e44 <osSemaphoreWait+0x18>
 8010e5c:	4b08      	ldr	r3, [pc, #32]	; (8010e80 <osSemaphoreWait+0x54>)
 8010e5e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8010e62:	601a      	str	r2, [r3, #0]
 8010e64:	f3bf 8f4f 	dsb	sy
 8010e68:	f3bf 8f6f 	isb	sy
  return osOK;
 8010e6c:	4620      	mov	r0, r4
}
 8010e6e:	b002      	add	sp, #8
 8010e70:	bd10      	pop	{r4, pc}
    return osErrorOS;
 8010e72:	20ff      	movs	r0, #255	; 0xff
}
 8010e74:	b002      	add	sp, #8
 8010e76:	bd10      	pop	{r4, pc}
    return osErrorParameter;
 8010e78:	2080      	movs	r0, #128	; 0x80
}
 8010e7a:	b002      	add	sp, #8
 8010e7c:	bd10      	pop	{r4, pc}
 8010e7e:	bf00      	nop
 8010e80:	e000ed04 	.word	0xe000ed04

08010e84 <osSemaphoreRelease>:
 8010e84:	b510      	push	{r4, lr}
 8010e86:	b082      	sub	sp, #8
 8010e88:	2400      	movs	r4, #0
 8010e8a:	9401      	str	r4, [sp, #4]
 8010e8c:	f3ef 8305 	mrs	r3, IPSR
 8010e90:	b18b      	cbz	r3, 8010eb6 <osSemaphoreRelease+0x32>
 8010e92:	a901      	add	r1, sp, #4
 8010e94:	f000 fc58 	bl	8011748 <xQueueGiveFromISR>
 8010e98:	2801      	cmp	r0, #1
 8010e9a:	d112      	bne.n	8010ec2 <osSemaphoreRelease+0x3e>
 8010e9c:	9b01      	ldr	r3, [sp, #4]
 8010e9e:	b19b      	cbz	r3, 8010ec8 <osSemaphoreRelease+0x44>
 8010ea0:	4b0b      	ldr	r3, [pc, #44]	; (8010ed0 <osSemaphoreRelease+0x4c>)
 8010ea2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8010ea6:	601a      	str	r2, [r3, #0]
 8010ea8:	f3bf 8f4f 	dsb	sy
 8010eac:	f3bf 8f6f 	isb	sy
 8010eb0:	4620      	mov	r0, r4
 8010eb2:	b002      	add	sp, #8
 8010eb4:	bd10      	pop	{r4, pc}
 8010eb6:	461a      	mov	r2, r3
 8010eb8:	4619      	mov	r1, r3
 8010eba:	f000 fa59 	bl	8011370 <xQueueGenericSend>
 8010ebe:	2801      	cmp	r0, #1
 8010ec0:	d002      	beq.n	8010ec8 <osSemaphoreRelease+0x44>
 8010ec2:	20ff      	movs	r0, #255	; 0xff
 8010ec4:	b002      	add	sp, #8
 8010ec6:	bd10      	pop	{r4, pc}
 8010ec8:	2000      	movs	r0, #0
 8010eca:	b002      	add	sp, #8
 8010ecc:	bd10      	pop	{r4, pc}
 8010ece:	bf00      	nop
 8010ed0:	e000ed04 	.word	0xe000ed04

08010ed4 <osPoolCreate>:
* @param  pool_def      memory pool definition referenced with \ref osPool.
* @retval  memory pool ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS.
*/
osPoolId osPoolCreate (const osPoolDef_t *pool_def)
{
 8010ed4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010ed6:	4606      	mov	r6, r0
 8010ed8:	b083      	sub	sp, #12
  osPoolId thePool;
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
  uint32_t i;
  
  /* First have to allocate memory for the pool control block. */
 thePool = pvPortMalloc(sizeof(os_pool_cb_t));
 8010eda:	2014      	movs	r0, #20
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8010edc:	6874      	ldr	r4, [r6, #4]
 thePool = pvPortMalloc(sizeof(os_pool_cb_t));
 8010ede:	f002 f9b7 	bl	8013250 <pvPortMalloc>

  
  if (thePool) {
 8010ee2:	4605      	mov	r5, r0
 8010ee4:	b1e8      	cbz	r0, 8010f22 <osPoolCreate+0x4e>
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8010ee6:	3403      	adds	r4, #3
    thePool->pool_sz = pool_def->pool_sz;
 8010ee8:	6830      	ldr	r0, [r6, #0]
 8010eea:	60a8      	str	r0, [r5, #8]
  int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
 8010eec:	f024 0703 	bic.w	r7, r4, #3
    thePool->item_sz = itemSize;
    thePool->currentIndex = 0;
 8010ef0:	2400      	movs	r4, #0
 8010ef2:	e9c5 7403 	strd	r7, r4, [r5, #12]
    
    /* Memory for markers */
    thePool->markers = pvPortMalloc(pool_def->pool_sz);
 8010ef6:	f002 f9ab 	bl	8013250 <pvPortMalloc>
 8010efa:	6068      	str	r0, [r5, #4]
   
    if (thePool->markers) {
 8010efc:	b1a0      	cbz	r0, 8010f28 <osPoolCreate+0x54>
      /* Now allocate the pool itself. */
     thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
 8010efe:	6830      	ldr	r0, [r6, #0]
 8010f00:	fb00 f007 	mul.w	r0, r0, r7
 8010f04:	f002 f9a4 	bl	8013250 <pvPortMalloc>
 8010f08:	4607      	mov	r7, r0
 8010f0a:	6028      	str	r0, [r5, #0]
      
      if (thePool->pool) {
 8010f0c:	b198      	cbz	r0, 8010f36 <osPoolCreate+0x62>
        for (i = 0; i < pool_def->pool_sz; i++) {
 8010f0e:	6833      	ldr	r3, [r6, #0]
 8010f10:	b13b      	cbz	r3, 8010f22 <osPoolCreate+0x4e>
 8010f12:	4623      	mov	r3, r4
          thePool->markers[i] = 0;
 8010f14:	4621      	mov	r1, r4
 8010f16:	686a      	ldr	r2, [r5, #4]
 8010f18:	54d1      	strb	r1, [r2, r3]
        for (i = 0; i < pool_def->pool_sz; i++) {
 8010f1a:	6832      	ldr	r2, [r6, #0]
 8010f1c:	3301      	adds	r3, #1
 8010f1e:	429a      	cmp	r2, r3
 8010f20:	d8f9      	bhi.n	8010f16 <osPoolCreate+0x42>
  return thePool;
 
#else
  return NULL;
#endif
}
 8010f22:	4628      	mov	r0, r5
 8010f24:	b003      	add	sp, #12
 8010f26:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010f28:	9001      	str	r0, [sp, #4]
      vPortFree(thePool);
 8010f2a:	4628      	mov	r0, r5
 8010f2c:	f002 fa32 	bl	8013394 <vPortFree>
      thePool = NULL;
 8010f30:	9b01      	ldr	r3, [sp, #4]
 8010f32:	461d      	mov	r5, r3
  return thePool;
 8010f34:	e7f5      	b.n	8010f22 <osPoolCreate+0x4e>
        vPortFree(thePool->markers);
 8010f36:	6868      	ldr	r0, [r5, #4]
 8010f38:	f002 fa2c 	bl	8013394 <vPortFree>
        vPortFree(thePool);
 8010f3c:	4628      	mov	r0, r5
 8010f3e:	f002 fa29 	bl	8013394 <vPortFree>
        thePool = NULL;
 8010f42:	463d      	mov	r5, r7
 8010f44:	e7ed      	b.n	8010f22 <osPoolCreate+0x4e>
 8010f46:	bf00      	nop

08010f48 <osPoolAlloc>:
* @param pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
* @retval  address of the allocated memory block or NULL in case of no memory available.
* @note   MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS.
*/
void *osPoolAlloc (osPoolId pool_id)
{
 8010f48:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010f4c:	4680      	mov	r8, r0
 8010f4e:	b083      	sub	sp, #12
 8010f50:	f3ef 8905 	mrs	r9, IPSR
  int dummy = 0;
  void *p = NULL;
  uint32_t i;
  uint32_t index;
  
  if (inHandlerMode()) {
 8010f54:	f1b9 0f00 	cmp.w	r9, #0
 8010f58:	d03b      	beq.n	8010fd2 <osPoolAlloc+0x8a>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 8010f5a:	f3ef 8911 	mrs	r9, BASEPRI
 8010f5e:	f04f 0320 	mov.w	r3, #32
 8010f62:	f383 8811 	msr	BASEPRI, r3
 8010f66:	f3bf 8f6f 	isb	sy
 8010f6a:	f3bf 8f4f 	dsb	sy
  }
  else {
    vPortEnterCritical();
  }
  
  for (i = 0; i < pool_id->pool_sz; i++) {
 8010f6e:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8010f72:	b1d0      	cbz	r0, 8010faa <osPoolAlloc+0x62>
    index = (pool_id->currentIndex + i) % pool_id->pool_sz;
 8010f74:	f8d8 2010 	ldr.w	r2, [r8, #16]
    
    if (pool_id->markers[index] == 0) {
 8010f78:	f8d8 4004 	ldr.w	r4, [r8, #4]
 8010f7c:	1887      	adds	r7, r0, r2
 8010f7e:	e001      	b.n	8010f84 <osPoolAlloc+0x3c>
  for (i = 0; i < pool_id->pool_sz; i++) {
 8010f80:	4297      	cmp	r7, r2
 8010f82:	d01a      	beq.n	8010fba <osPoolAlloc+0x72>
    index = (pool_id->currentIndex + i) % pool_id->pool_sz;
 8010f84:	fbb2 f3f0 	udiv	r3, r2, r0
 8010f88:	fb00 2313 	mls	r3, r0, r3, r2
    if (pool_id->markers[index] == 0) {
 8010f8c:	18e6      	adds	r6, r4, r3
 8010f8e:	5ce5      	ldrb	r5, [r4, r3]
 8010f90:	3201      	adds	r2, #1
 8010f92:	2d00      	cmp	r5, #0
 8010f94:	d1f4      	bne.n	8010f80 <osPoolAlloc+0x38>
      pool_id->markers[index] = 1;
 8010f96:	2201      	movs	r2, #1
 8010f98:	7032      	strb	r2, [r6, #0]
      p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
 8010f9a:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8010f9e:	f8d8 0000 	ldr.w	r0, [r8]
      pool_id->currentIndex = index;
 8010fa2:	f8c8 3010 	str.w	r3, [r8, #16]
      p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
 8010fa6:	fb02 0003 	mla	r0, r2, r3, r0
 8010faa:	f3ef 8305 	mrs	r3, IPSR
      break;
    }
  }
  
  if (inHandlerMode()) {
 8010fae:	b14b      	cbz	r3, 8010fc4 <osPoolAlloc+0x7c>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8010fb0:	f389 8811 	msr	BASEPRI, r9
  else {
    vPortExitCritical();
  }
  
  return p;
}
 8010fb4:	b003      	add	sp, #12
 8010fb6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  void *p = NULL;
 8010fba:	2000      	movs	r0, #0
 8010fbc:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 8010fc0:	2b00      	cmp	r3, #0
 8010fc2:	d1f5      	bne.n	8010fb0 <osPoolAlloc+0x68>
 8010fc4:	9001      	str	r0, [sp, #4]
    vPortExitCritical();
 8010fc6:	f002 fabf 	bl	8013548 <vPortExitCritical>
 8010fca:	9801      	ldr	r0, [sp, #4]
}
 8010fcc:	b003      	add	sp, #12
 8010fce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    vPortEnterCritical();
 8010fd2:	f002 fa97 	bl	8013504 <vPortEnterCritical>
 8010fd6:	e7ca      	b.n	8010f6e <osPoolAlloc+0x26>

08010fd8 <osPoolFree>:
*/
osStatus osPoolFree (osPoolId pool_id, void *block)
{
  uint32_t index;
  
  if (pool_id == NULL) {
 8010fd8:	b188      	cbz	r0, 8010ffe <osPoolFree+0x26>
    return osErrorParameter;
  }
  
  if (block == NULL) {
 8010fda:	b181      	cbz	r1, 8010ffe <osPoolFree+0x26>
    return osErrorParameter;
  }
  
  if (block < pool_id->pool) {
 8010fdc:	6802      	ldr	r2, [r0, #0]
 8010fde:	428a      	cmp	r2, r1
 8010fe0:	d80d      	bhi.n	8010ffe <osPoolFree+0x26>
    return osErrorParameter;
  }
  
  index = (uint32_t)block - (uint32_t)(pool_id->pool);
  if (index % pool_id->item_sz) {
 8010fe2:	68c3      	ldr	r3, [r0, #12]
  index = (uint32_t)block - (uint32_t)(pool_id->pool);
 8010fe4:	1a89      	subs	r1, r1, r2
  if (index % pool_id->item_sz) {
 8010fe6:	fbb1 f2f3 	udiv	r2, r1, r3
 8010fea:	fb03 1112 	mls	r1, r3, r2, r1
 8010fee:	b931      	cbnz	r1, 8010ffe <osPoolFree+0x26>
    return osErrorParameter;
  }
  index = index / pool_id->item_sz;
  if (index >= pool_id->pool_sz) {
 8010ff0:	6883      	ldr	r3, [r0, #8]
 8010ff2:	4293      	cmp	r3, r2
 8010ff4:	d903      	bls.n	8010ffe <osPoolFree+0x26>
    return osErrorParameter;
  }
  
  pool_id->markers[index] = 0;
 8010ff6:	6843      	ldr	r3, [r0, #4]
  
  return osOK;
}
 8010ff8:	4608      	mov	r0, r1
  pool_id->markers[index] = 0;
 8010ffa:	5499      	strb	r1, [r3, r2]
}
 8010ffc:	4770      	bx	lr
    return osErrorParameter;
 8010ffe:	2180      	movs	r1, #128	; 0x80
}
 8011000:	4608      	mov	r0, r1
 8011002:	4770      	bx	lr

08011004 <osMessageCreate>:
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 8011004:	e9d0 0100 	ldrd	r0, r1, [r0]
 8011008:	2200      	movs	r2, #0
 801100a:	f000 b925 	b.w	8011258 <xQueueGenericCreate>
 801100e:	bf00      	nop

08011010 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 8011010:	b510      	push	{r4, lr}
 8011012:	b084      	sub	sp, #16
  portBASE_TYPE taskWoken = pdFALSE;
 8011014:	2400      	movs	r4, #0
{
 8011016:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 8011018:	9403      	str	r4, [sp, #12]
 801101a:	f3ef 8305 	mrs	r3, IPSR
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
    ticks = 1;
  }
  
  if (inHandlerMode()) {
 801101e:	b15b      	cbz	r3, 8011038 <osMessagePut+0x28>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 8011020:	4623      	mov	r3, r4
 8011022:	aa03      	add	r2, sp, #12
 8011024:	a901      	add	r1, sp, #4
 8011026:	f000 fb29 	bl	801167c <xQueueGenericSendFromISR>
 801102a:	2801      	cmp	r0, #1
 801102c:	d10c      	bne.n	8011048 <osMessagePut+0x38>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 801102e:	9b03      	ldr	r3, [sp, #12]
 8011030:	b96b      	cbnz	r3, 801104e <osMessagePut+0x3e>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
      return osErrorOS;
    }
  }
  
  return osOK;
 8011032:	2000      	movs	r0, #0
}
 8011034:	b004      	add	sp, #16
 8011036:	bd10      	pop	{r4, pc}
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 8011038:	2a01      	cmp	r2, #1
 801103a:	bf38      	it	cc
 801103c:	2201      	movcc	r2, #1
 801103e:	a901      	add	r1, sp, #4
 8011040:	f000 f996 	bl	8011370 <xQueueGenericSend>
 8011044:	2801      	cmp	r0, #1
 8011046:	d0f4      	beq.n	8011032 <osMessagePut+0x22>
      return osErrorOS;
 8011048:	20ff      	movs	r0, #255	; 0xff
}
 801104a:	b004      	add	sp, #16
 801104c:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 801104e:	4b05      	ldr	r3, [pc, #20]	; (8011064 <osMessagePut+0x54>)
 8011050:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8011054:	601a      	str	r2, [r3, #0]
 8011056:	f3bf 8f4f 	dsb	sy
 801105a:	f3bf 8f6f 	isb	sy
  return osOK;
 801105e:	4620      	mov	r0, r4
}
 8011060:	b004      	add	sp, #16
 8011062:	bd10      	pop	{r4, pc}
 8011064:	e000ed04 	.word	0xe000ed04

08011068 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 8011068:	b530      	push	{r4, r5, lr}
 801106a:	b085      	sub	sp, #20
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 801106c:	2300      	movs	r3, #0
  event.def.message_id = queue_id;
 801106e:	9103      	str	r1, [sp, #12]
{
 8011070:	4604      	mov	r4, r0
  event.value.v = 0;
 8011072:	9302      	str	r3, [sp, #8]
  
  if (queue_id == NULL) {
 8011074:	b361      	cbz	r1, 80110d0 <osMessageGet+0x68>
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8011076:	9300      	str	r3, [sp, #0]
 8011078:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 801107c:	b993      	cbnz	r3, 80110a4 <osMessageGet+0x3c>
      event.status = osOK;
    }
    portEND_SWITCHING_ISR(taskWoken);
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 801107e:	4608      	mov	r0, r1
 8011080:	a902      	add	r1, sp, #8
 8011082:	4615      	mov	r5, r2
 8011084:	f000 fbb8 	bl	80117f8 <xQueueReceive>
 8011088:	2801      	cmp	r0, #1
 801108a:	d02b      	beq.n	80110e4 <osMessageGet+0x7c>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 801108c:	2d00      	cmp	r5, #0
 801108e:	bf18      	it	ne
 8011090:	2540      	movne	r5, #64	; 0x40
 8011092:	9501      	str	r5, [sp, #4]
    }
  }
  
  return event;
 8011094:	ab04      	add	r3, sp, #16
 8011096:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 801109a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 801109e:	4620      	mov	r0, r4
 80110a0:	b005      	add	sp, #20
 80110a2:	bd30      	pop	{r4, r5, pc}
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 80110a4:	466a      	mov	r2, sp
 80110a6:	4608      	mov	r0, r1
 80110a8:	a902      	add	r1, sp, #8
 80110aa:	f000 feb9 	bl	8011e20 <xQueueReceiveFromISR>
    portEND_SWITCHING_ISR(taskWoken);
 80110ae:	9b00      	ldr	r3, [sp, #0]
      event.status = osOK;
 80110b0:	2801      	cmp	r0, #1
 80110b2:	bf0c      	ite	eq
 80110b4:	2210      	moveq	r2, #16
 80110b6:	2200      	movne	r2, #0
 80110b8:	9201      	str	r2, [sp, #4]
    portEND_SWITCHING_ISR(taskWoken);
 80110ba:	2b00      	cmp	r3, #0
 80110bc:	d0ea      	beq.n	8011094 <osMessageGet+0x2c>
 80110be:	4b0b      	ldr	r3, [pc, #44]	; (80110ec <osMessageGet+0x84>)
 80110c0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80110c4:	601a      	str	r2, [r3, #0]
 80110c6:	f3bf 8f4f 	dsb	sy
 80110ca:	f3bf 8f6f 	isb	sy
 80110ce:	e7e1      	b.n	8011094 <osMessageGet+0x2c>
    event.status = osErrorParameter;
 80110d0:	2380      	movs	r3, #128	; 0x80
 80110d2:	9301      	str	r3, [sp, #4]
    return event;
 80110d4:	ab04      	add	r3, sp, #16
 80110d6:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80110da:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 80110de:	4620      	mov	r0, r4
 80110e0:	b005      	add	sp, #20
 80110e2:	bd30      	pop	{r4, r5, pc}
      event.status = osEventMessage;
 80110e4:	2310      	movs	r3, #16
 80110e6:	9301      	str	r3, [sp, #4]
 80110e8:	e7d4      	b.n	8011094 <osMessageGet+0x2c>
 80110ea:	bf00      	nop
 80110ec:	e000ed04 	.word	0xe000ed04

080110f0 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 80110f0:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 80110f2:	f001 fdc1 	bl	8012c78 <xTaskGetSchedulerState>
 80110f6:	2801      	cmp	r0, #1
 80110f8:	d100      	bne.n	80110fc <osSystickHandler+0xc>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 80110fa:	bd08      	pop	{r3, pc}
 80110fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 8011100:	f002 ba68 	b.w	80135d4 <xPortSysTickHandler>

08011104 <osThreadSuspend>:
* @brief  Suspend execution of a thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
*/
osStatus osThreadSuspend (osThreadId thread_id)
{
 8011104:	b508      	push	{r3, lr}
#if (INCLUDE_vTaskSuspend == 1)
    vTaskSuspend(thread_id);
 8011106:	f001 fbf3 	bl	80128f0 <vTaskSuspend>
  
  return osOK;
#else
  return osErrorResource;
#endif
}
 801110a:	2000      	movs	r0, #0
 801110c:	bd08      	pop	{r3, pc}
 801110e:	bf00      	nop

08011110 <osThreadResume>:
* @brief  Resume execution of a suspended thread.
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
*/
osStatus osThreadResume (osThreadId thread_id)
{
 8011110:	b508      	push	{r3, lr}
 8011112:	f3ef 8305 	mrs	r3, IPSR
#if (INCLUDE_vTaskSuspend == 1)  
  if(inHandlerMode())
 8011116:	b12b      	cbz	r3, 8011124 <osThreadResume+0x14>
  {
    if (xTaskResumeFromISR(thread_id) == pdTRUE)
 8011118:	f001 f90c 	bl	8012334 <xTaskResumeFromISR>
 801111c:	2801      	cmp	r0, #1
 801111e:	d005      	beq.n	801112c <osThreadResume+0x1c>
  }
  return osOK;
#else
  return osErrorResource;
#endif
}
 8011120:	2000      	movs	r0, #0
 8011122:	bd08      	pop	{r3, pc}
    vTaskResume(thread_id);
 8011124:	f001 f8b6 	bl	8012294 <vTaskResume>
}
 8011128:	2000      	movs	r0, #0
 801112a:	bd08      	pop	{r3, pc}
      portYIELD_FROM_ISR(pdTRUE);
 801112c:	4b04      	ldr	r3, [pc, #16]	; (8011140 <osThreadResume+0x30>)
 801112e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8011132:	601a      	str	r2, [r3, #0]
 8011134:	f3bf 8f4f 	dsb	sy
 8011138:	f3bf 8f6f 	isb	sy
}
 801113c:	2000      	movs	r0, #0
 801113e:	bd08      	pop	{r3, pc}
 8011140:	e000ed04 	.word	0xe000ed04

08011144 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8011144:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8011148:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 801114c:	2200      	movs	r2, #0
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 801114e:	e9c0 3303 	strd	r3, r3, [r0, #12]
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8011152:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8011154:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8011156:	6043      	str	r3, [r0, #4]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8011158:	4770      	bx	lr
 801115a:	bf00      	nop

0801115c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 801115c:	2300      	movs	r3, #0
 801115e:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8011160:	4770      	bx	lr
 8011162:	bf00      	nop

08011164 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8011164:	6843      	ldr	r3, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 8011166:	6802      	ldr	r2, [r0, #0]
{
 8011168:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 801116a:	689c      	ldr	r4, [r3, #8]
 801116c:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 801116e:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 8011170:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8011172:	3201      	adds	r2, #1
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8011174:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8011176:	6099      	str	r1, [r3, #8]
}
 8011178:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
 801117c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 801117e:	6002      	str	r2, [r0, #0]
}
 8011180:	4770      	bx	lr
 8011182:	bf00      	nop

08011184 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8011184:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8011186:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8011188:	1c6b      	adds	r3, r5, #1
 801118a:	d010      	beq.n	80111ae <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 801118c:	f100 0308 	add.w	r3, r0, #8
 8011190:	461c      	mov	r4, r3
 8011192:	685b      	ldr	r3, [r3, #4]
 8011194:	681a      	ldr	r2, [r3, #0]
 8011196:	42aa      	cmp	r2, r5
 8011198:	d9fa      	bls.n	8011190 <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 801119a:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 801119c:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 801119e:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80111a0:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80111a2:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80111a4:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
 80111a6:	6108      	str	r0, [r1, #16]
}
 80111a8:	bc30      	pop	{r4, r5}
	( pxList->uxNumberOfItems )++;
 80111aa:	6002      	str	r2, [r0, #0]
}
 80111ac:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 80111ae:	6904      	ldr	r4, [r0, #16]
 80111b0:	6863      	ldr	r3, [r4, #4]
 80111b2:	e7f2      	b.n	801119a <vListInsert+0x16>

080111b4 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 80111b4:	6903      	ldr	r3, [r0, #16]
{
 80111b6:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80111b8:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80111bc:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80111be:	608a      	str	r2, [r1, #8]
	if( pxList->pxIndex == pxItemToRemove )
 80111c0:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80111c2:	6051      	str	r1, [r2, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80111c4:	bf08      	it	eq
 80111c6:	605a      	streq	r2, [r3, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
 80111c8:	681a      	ldr	r2, [r3, #0]

	return pxList->uxNumberOfItems;
}
 80111ca:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxContainer = NULL;
 80111ce:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
 80111d0:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
 80111d2:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 80111d4:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 80111d6:	6818      	ldr	r0, [r3, #0]
}
 80111d8:	4770      	bx	lr
 80111da:	bf00      	nop

080111dc <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 80111dc:	b570      	push	{r4, r5, r6, lr}
 80111de:	4604      	mov	r4, r0

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80111e0:	6c00      	ldr	r0, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80111e2:	6ba6      	ldr	r6, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80111e4:	b920      	cbnz	r0, 80111f0 <prvCopyDataToQueue+0x14>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80111e6:	6825      	ldr	r5, [r4, #0]
 80111e8:	b35d      	cbz	r5, 8011242 <prvCopyDataToQueue+0x66>
 80111ea:	3601      	adds	r6, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80111ec:	63a6      	str	r6, [r4, #56]	; 0x38

	return xReturn;
}
 80111ee:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 80111f0:	4615      	mov	r5, r2
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80111f2:	4602      	mov	r2, r0
	else if( xPosition == queueSEND_TO_BACK )
 80111f4:	b985      	cbnz	r5, 8011218 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80111f6:	6860      	ldr	r0, [r4, #4]
 80111f8:	f004 fea2 	bl	8015f40 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80111fc:	6863      	ldr	r3, [r4, #4]
 80111fe:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8011200:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8011202:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8011204:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8011206:	6063      	str	r3, [r4, #4]
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8011208:	f106 0601 	add.w	r6, r6, #1
 801120c:	bf24      	itt	cs
 801120e:	6823      	ldrcs	r3, [r4, #0]
 8011210:	6063      	strcs	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
 8011212:	4628      	mov	r0, r5
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8011214:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8011216:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8011218:	68e0      	ldr	r0, [r4, #12]
 801121a:	f004 fe91 	bl	8015f40 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 801121e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8011220:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8011222:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8011224:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8011226:	428b      	cmp	r3, r1
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8011228:	60e3      	str	r3, [r4, #12]
 801122a:	f1c2 0200 	rsb	r2, r2, #0
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 801122e:	d202      	bcs.n	8011236 <prvCopyDataToQueue+0x5a>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8011230:	68a3      	ldr	r3, [r4, #8]
 8011232:	441a      	add	r2, r3
 8011234:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8011236:	2d02      	cmp	r5, #2
 8011238:	d008      	beq.n	801124c <prvCopyDataToQueue+0x70>
 801123a:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 801123c:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801123e:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8011240:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8011242:	68a0      	ldr	r0, [r4, #8]
 8011244:	f001 fd84 	bl	8012d50 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8011248:	60a5      	str	r5, [r4, #8]
 801124a:	e7ce      	b.n	80111ea <prvCopyDataToQueue+0xe>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801124c:	2e01      	cmp	r6, #1
 801124e:	bf38      	it	cc
 8011250:	2601      	movcc	r6, #1
BaseType_t xReturn = pdFALSE;
 8011252:	2000      	movs	r0, #0
 8011254:	e7ca      	b.n	80111ec <prvCopyDataToQueue+0x10>
 8011256:	bf00      	nop

08011258 <xQueueGenericCreate>:
	{
 8011258:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 801125a:	b940      	cbnz	r0, 801126e <xQueueGenericCreate+0x16>
	__asm volatile
 801125c:	f04f 0320 	mov.w	r3, #32
 8011260:	f383 8811 	msr	BASEPRI, r3
 8011264:	f3bf 8f6f 	isb	sy
 8011268:	f3bf 8f4f 	dsb	sy
 801126c:	e7fe      	b.n	801126c <xQueueGenericCreate+0x14>
 801126e:	460e      	mov	r6, r1
 8011270:	4617      	mov	r7, r2
		if( uxItemSize == ( UBaseType_t ) 0 )
 8011272:	4605      	mov	r5, r0
 8011274:	b931      	cbnz	r1, 8011284 <xQueueGenericCreate+0x2c>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8011276:	2050      	movs	r0, #80	; 0x50
 8011278:	f001 ffea 	bl	8013250 <pvPortMalloc>
		if( pxNewQueue != NULL )
 801127c:	4604      	mov	r4, r0
 801127e:	b378      	cbz	r0, 80112e0 <xQueueGenericCreate+0x88>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8011280:	6024      	str	r4, [r4, #0]
 8011282:	e009      	b.n	8011298 <xQueueGenericCreate+0x40>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8011284:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8011288:	3050      	adds	r0, #80	; 0x50
 801128a:	f001 ffe1 	bl	8013250 <pvPortMalloc>
		if( pxNewQueue != NULL )
 801128e:	4604      	mov	r4, r0
 8011290:	b330      	cbz	r0, 80112e0 <xQueueGenericCreate+0x88>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8011292:	f100 0350 	add.w	r3, r0, #80	; 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8011296:	6003      	str	r3, [r0, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 8011298:	e9c4 560f 	strd	r5, r6, [r4, #60]	; 0x3c
	taskENTER_CRITICAL();
 801129c:	f002 f932 	bl	8013504 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80112a0:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
 80112a4:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80112a6:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80112a8:	fb01 f103 	mul.w	r1, r1, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80112ac:	1acb      	subs	r3, r1, r3
 80112ae:	4413      	add	r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80112b0:	2000      	movs	r0, #0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80112b2:	440a      	add	r2, r1
		pxQueue->cRxLock = queueUNLOCKED;
 80112b4:	21ff      	movs	r1, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80112b6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80112b8:	e9c4 2302 	strd	r2, r3, [r4, #8]
		pxQueue->cRxLock = queueUNLOCKED;
 80112bc:	f884 1044 	strb.w	r1, [r4, #68]	; 0x44
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80112c0:	f104 0010 	add.w	r0, r4, #16
		pxQueue->cTxLock = queueUNLOCKED;
 80112c4:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80112c8:	f7ff ff3c 	bl	8011144 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80112cc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80112d0:	f7ff ff38 	bl	8011144 <vListInitialise>
	taskEXIT_CRITICAL();
 80112d4:	f002 f938 	bl	8013548 <vPortExitCritical>
		pxNewQueue->ucQueueType = ucQueueType;
 80112d8:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
	}
 80112dc:	4620      	mov	r0, r4
 80112de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 80112e0:	2400      	movs	r4, #0
	}
 80112e2:	4620      	mov	r0, r4
 80112e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80112e6:	bf00      	nop

080112e8 <xQueueCreateCountingSemaphore>:
	{
 80112e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( uxMaxCount != 0 );
 80112ea:	b940      	cbnz	r0, 80112fe <xQueueCreateCountingSemaphore+0x16>
 80112ec:	f04f 0320 	mov.w	r3, #32
 80112f0:	f383 8811 	msr	BASEPRI, r3
 80112f4:	f3bf 8f6f 	isb	sy
 80112f8:	f3bf 8f4f 	dsb	sy
 80112fc:	e7fe      	b.n	80112fc <xQueueCreateCountingSemaphore+0x14>
		configASSERT( uxInitialCount <= uxMaxCount );
 80112fe:	4288      	cmp	r0, r1
 8011300:	460d      	mov	r5, r1
 8011302:	4606      	mov	r6, r0
 8011304:	d208      	bcs.n	8011318 <xQueueCreateCountingSemaphore+0x30>
 8011306:	f04f 0320 	mov.w	r3, #32
 801130a:	f383 8811 	msr	BASEPRI, r3
 801130e:	f3bf 8f6f 	isb	sy
 8011312:	f3bf 8f4f 	dsb	sy
 8011316:	e7fe      	b.n	8011316 <xQueueCreateCountingSemaphore+0x2e>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8011318:	2050      	movs	r0, #80	; 0x50
 801131a:	f001 ff99 	bl	8013250 <pvPortMalloc>
		if( pxNewQueue != NULL )
 801131e:	4604      	mov	r4, r0
 8011320:	b320      	cbz	r0, 801136c <xQueueCreateCountingSemaphore+0x84>
	pxNewQueue->uxItemSize = uxItemSize;
 8011322:	2700      	movs	r7, #0
 8011324:	e9c0 670f 	strd	r6, r7, [r0, #60]	; 0x3c
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8011328:	6000      	str	r0, [r0, #0]
	taskENTER_CRITICAL();
 801132a:	f002 f8eb 	bl	8013504 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801132e:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
 8011332:	6821      	ldr	r1, [r4, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8011334:	63a7      	str	r7, [r4, #56]	; 0x38
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8011336:	fb03 f302 	mul.w	r3, r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801133a:	1a9a      	subs	r2, r3, r2
 801133c:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 801133e:	440b      	add	r3, r1
		pxQueue->cRxLock = queueUNLOCKED;
 8011340:	26ff      	movs	r6, #255	; 0xff
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8011342:	e9c4 3202 	strd	r3, r2, [r4, #8]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8011346:	6061      	str	r1, [r4, #4]
		pxQueue->cRxLock = queueUNLOCKED;
 8011348:	f884 6044 	strb.w	r6, [r4, #68]	; 0x44
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 801134c:	f104 0010 	add.w	r0, r4, #16
		pxQueue->cTxLock = queueUNLOCKED;
 8011350:	f884 6045 	strb.w	r6, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8011354:	f7ff fef6 	bl	8011144 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8011358:	f104 0024 	add.w	r0, r4, #36	; 0x24
 801135c:	f7ff fef2 	bl	8011144 <vListInitialise>
	taskEXIT_CRITICAL();
 8011360:	f002 f8f2 	bl	8013548 <vPortExitCritical>
		pxNewQueue->ucQueueType = ucQueueType;
 8011364:	2302      	movs	r3, #2
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8011366:	63a5      	str	r5, [r4, #56]	; 0x38
		pxNewQueue->ucQueueType = ucQueueType;
 8011368:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
	}
 801136c:	4620      	mov	r0, r4
 801136e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08011370 <xQueueGenericSend>:
{
 8011370:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011374:	b084      	sub	sp, #16
 8011376:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8011378:	2800      	cmp	r0, #0
 801137a:	f000 80ac 	beq.w	80114d6 <xQueueGenericSend+0x166>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 801137e:	4688      	mov	r8, r1
 8011380:	461f      	mov	r7, r3
 8011382:	4604      	mov	r4, r0
 8011384:	2900      	cmp	r1, #0
 8011386:	f000 8099 	beq.w	80114bc <xQueueGenericSend+0x14c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 801138a:	2f02      	cmp	r7, #2
 801138c:	d10b      	bne.n	80113a6 <xQueueGenericSend+0x36>
 801138e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8011390:	2b01      	cmp	r3, #1
 8011392:	d008      	beq.n	80113a6 <xQueueGenericSend+0x36>
 8011394:	f04f 0320 	mov.w	r3, #32
 8011398:	f383 8811 	msr	BASEPRI, r3
 801139c:	f3bf 8f6f 	isb	sy
 80113a0:	f3bf 8f4f 	dsb	sy
 80113a4:	e7fe      	b.n	80113a4 <xQueueGenericSend+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80113a6:	f001 fc67 	bl	8012c78 <xTaskGetSchedulerState>
 80113aa:	4682      	mov	sl, r0
 80113ac:	2800      	cmp	r0, #0
 80113ae:	f000 809b 	beq.w	80114e8 <xQueueGenericSend+0x178>
 80113b2:	f04f 0a00 	mov.w	sl, #0
					portYIELD_WITHIN_API();
 80113b6:	f8df 92c0 	ldr.w	r9, [pc, #704]	; 8011678 <xQueueGenericSend+0x308>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80113ba:	f104 0624 	add.w	r6, r4, #36	; 0x24
		taskENTER_CRITICAL();
 80113be:	f002 f8a1 	bl	8013504 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80113c2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80113c4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80113c6:	429a      	cmp	r2, r3
 80113c8:	f0c0 80f4 	bcc.w	80115b4 <xQueueGenericSend+0x244>
 80113cc:	2f02      	cmp	r7, #2
 80113ce:	f000 80f1 	beq.w	80115b4 <xQueueGenericSend+0x244>
				if( xTicksToWait == ( TickType_t ) 0 )
 80113d2:	9d01      	ldr	r5, [sp, #4]
 80113d4:	2d00      	cmp	r5, #0
 80113d6:	f000 814a 	beq.w	801166e <xQueueGenericSend+0x2fe>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80113da:	ad02      	add	r5, sp, #8
				else if( xEntryTimeSet == pdFALSE )
 80113dc:	f1ba 0f00 	cmp.w	sl, #0
 80113e0:	f000 80e4 	beq.w	80115ac <xQueueGenericSend+0x23c>
		taskEXIT_CRITICAL();
 80113e4:	f002 f8b0 	bl	8013548 <vPortExitCritical>
		vTaskSuspendAll();
 80113e8:	f001 f8f2 	bl	80125d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80113ec:	f002 f88a 	bl	8013504 <vPortEnterCritical>
 80113f0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80113f4:	2bff      	cmp	r3, #255	; 0xff
 80113f6:	bf04      	itt	eq
 80113f8:	2300      	moveq	r3, #0
 80113fa:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 80113fe:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8011402:	2bff      	cmp	r3, #255	; 0xff
 8011404:	bf04      	itt	eq
 8011406:	2300      	moveq	r3, #0
 8011408:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 801140c:	f002 f89c 	bl	8013548 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8011410:	4628      	mov	r0, r5
 8011412:	a901      	add	r1, sp, #4
 8011414:	f001 fbe2 	bl	8012bdc <xTaskCheckForTimeOut>
 8011418:	2800      	cmp	r0, #0
 801141a:	f040 80e8 	bne.w	80115ee <xQueueGenericSend+0x27e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 801141e:	f002 f871 	bl	8013504 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8011422:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8011424:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8011426:	429a      	cmp	r2, r3
 8011428:	d06b      	beq.n	8011502 <xQueueGenericSend+0x192>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 801142a:	f002 f88d 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 801142e:	f002 f869 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011432:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 8011436:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011438:	2d00      	cmp	r5, #0
 801143a:	dc05      	bgt.n	8011448 <xQueueGenericSend+0xd8>
 801143c:	e012      	b.n	8011464 <xQueueGenericSend+0xf4>
			--cTxLock;
 801143e:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011440:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011444:	b25d      	sxtb	r5, r3
 8011446:	d00d      	beq.n	8011464 <xQueueGenericSend+0xf4>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011448:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801144a:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801144c:	b153      	cbz	r3, 8011464 <xQueueGenericSend+0xf4>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801144e:	f001 fb79 	bl	8012b44 <xTaskRemoveFromEventList>
 8011452:	2800      	cmp	r0, #0
 8011454:	d0f3      	beq.n	801143e <xQueueGenericSend+0xce>
						vTaskMissedYield();
 8011456:	f001 fc07 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 801145a:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801145c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011460:	b25d      	sxtb	r5, r3
 8011462:	d1f1      	bne.n	8011448 <xQueueGenericSend+0xd8>
		pxQueue->cTxLock = queueUNLOCKED;
 8011464:	23ff      	movs	r3, #255	; 0xff
 8011466:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 801146a:	f002 f86d 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 801146e:	f002 f849 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011472:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8011476:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011478:	2d00      	cmp	r5, #0
 801147a:	dd15      	ble.n	80114a8 <xQueueGenericSend+0x138>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801147c:	f104 0a10 	add.w	sl, r4, #16
 8011480:	e004      	b.n	801148c <xQueueGenericSend+0x11c>
				--cRxLock;
 8011482:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011484:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011488:	b25d      	sxtb	r5, r3
 801148a:	d00d      	beq.n	80114a8 <xQueueGenericSend+0x138>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801148c:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801148e:	4650      	mov	r0, sl
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011490:	b153      	cbz	r3, 80114a8 <xQueueGenericSend+0x138>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011492:	f001 fb57 	bl	8012b44 <xTaskRemoveFromEventList>
 8011496:	2800      	cmp	r0, #0
 8011498:	d0f3      	beq.n	8011482 <xQueueGenericSend+0x112>
					vTaskMissedYield();
 801149a:	f001 fbe5 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 801149e:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80114a0:	f013 0fff 	tst.w	r3, #255	; 0xff
 80114a4:	b25d      	sxtb	r5, r3
 80114a6:	d1f1      	bne.n	801148c <xQueueGenericSend+0x11c>
		pxQueue->cRxLock = queueUNLOCKED;
 80114a8:	23ff      	movs	r3, #255	; 0xff
 80114aa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 80114ae:	f002 f84b 	bl	8013548 <vPortExitCritical>
				( void ) xTaskResumeAll();
 80114b2:	f001 f9b7 	bl	8012824 <xTaskResumeAll>
 80114b6:	f04f 0a01 	mov.w	sl, #1
 80114ba:	e780      	b.n	80113be <xQueueGenericSend+0x4e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80114bc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80114be:	2b00      	cmp	r3, #0
 80114c0:	f43f af63 	beq.w	801138a <xQueueGenericSend+0x1a>
 80114c4:	f04f 0320 	mov.w	r3, #32
 80114c8:	f383 8811 	msr	BASEPRI, r3
 80114cc:	f3bf 8f6f 	isb	sy
 80114d0:	f3bf 8f4f 	dsb	sy
 80114d4:	e7fe      	b.n	80114d4 <xQueueGenericSend+0x164>
 80114d6:	f04f 0320 	mov.w	r3, #32
 80114da:	f383 8811 	msr	BASEPRI, r3
 80114de:	f3bf 8f6f 	isb	sy
 80114e2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80114e6:	e7fe      	b.n	80114e6 <xQueueGenericSend+0x176>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80114e8:	9b01      	ldr	r3, [sp, #4]
 80114ea:	2b00      	cmp	r3, #0
 80114ec:	f43f af63 	beq.w	80113b6 <xQueueGenericSend+0x46>
 80114f0:	f04f 0320 	mov.w	r3, #32
 80114f4:	f383 8811 	msr	BASEPRI, r3
 80114f8:	f3bf 8f6f 	isb	sy
 80114fc:	f3bf 8f4f 	dsb	sy
 8011500:	e7fe      	b.n	8011500 <xQueueGenericSend+0x190>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8011502:	f104 0a10 	add.w	sl, r4, #16
	taskEXIT_CRITICAL();
 8011506:	f002 f81f 	bl	8013548 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 801150a:	9901      	ldr	r1, [sp, #4]
 801150c:	4650      	mov	r0, sl
 801150e:	f001 fa69 	bl	80129e4 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 8011512:	f001 fff7 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011516:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 801151a:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801151c:	2d00      	cmp	r5, #0
 801151e:	dc05      	bgt.n	801152c <xQueueGenericSend+0x1bc>
 8011520:	e012      	b.n	8011548 <xQueueGenericSend+0x1d8>
			--cTxLock;
 8011522:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011524:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011528:	b25d      	sxtb	r5, r3
 801152a:	d00d      	beq.n	8011548 <xQueueGenericSend+0x1d8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801152c:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801152e:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011530:	b153      	cbz	r3, 8011548 <xQueueGenericSend+0x1d8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011532:	f001 fb07 	bl	8012b44 <xTaskRemoveFromEventList>
 8011536:	2800      	cmp	r0, #0
 8011538:	d0f3      	beq.n	8011522 <xQueueGenericSend+0x1b2>
						vTaskMissedYield();
 801153a:	f001 fb95 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 801153e:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011540:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011544:	b25d      	sxtb	r5, r3
 8011546:	d1f1      	bne.n	801152c <xQueueGenericSend+0x1bc>
		pxQueue->cTxLock = queueUNLOCKED;
 8011548:	23ff      	movs	r3, #255	; 0xff
 801154a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 801154e:	f001 fffb 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011552:	f001 ffd7 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011556:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 801155a:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 801155c:	2d00      	cmp	r5, #0
 801155e:	dc05      	bgt.n	801156c <xQueueGenericSend+0x1fc>
 8011560:	e012      	b.n	8011588 <xQueueGenericSend+0x218>
				--cRxLock;
 8011562:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011564:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011568:	b25d      	sxtb	r5, r3
 801156a:	d00d      	beq.n	8011588 <xQueueGenericSend+0x218>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801156c:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801156e:	4650      	mov	r0, sl
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011570:	b153      	cbz	r3, 8011588 <xQueueGenericSend+0x218>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011572:	f001 fae7 	bl	8012b44 <xTaskRemoveFromEventList>
 8011576:	2800      	cmp	r0, #0
 8011578:	d0f3      	beq.n	8011562 <xQueueGenericSend+0x1f2>
					vTaskMissedYield();
 801157a:	f001 fb75 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 801157e:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011580:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011584:	b25d      	sxtb	r5, r3
 8011586:	d1f1      	bne.n	801156c <xQueueGenericSend+0x1fc>
		pxQueue->cRxLock = queueUNLOCKED;
 8011588:	23ff      	movs	r3, #255	; 0xff
 801158a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 801158e:	f001 ffdb 	bl	8013548 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 8011592:	f001 f947 	bl	8012824 <xTaskResumeAll>
 8011596:	2800      	cmp	r0, #0
 8011598:	d18d      	bne.n	80114b6 <xQueueGenericSend+0x146>
					portYIELD_WITHIN_API();
 801159a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 801159e:	f8c9 3000 	str.w	r3, [r9]
 80115a2:	f3bf 8f4f 	dsb	sy
 80115a6:	f3bf 8f6f 	isb	sy
 80115aa:	e784      	b.n	80114b6 <xQueueGenericSend+0x146>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80115ac:	4628      	mov	r0, r5
 80115ae:	f001 fb0b 	bl	8012bc8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80115b2:	e717      	b.n	80113e4 <xQueueGenericSend+0x74>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80115b4:	463a      	mov	r2, r7
 80115b6:	4641      	mov	r1, r8
 80115b8:	4620      	mov	r0, r4
 80115ba:	f7ff fe0f 	bl	80111dc <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80115be:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80115c0:	b973      	cbnz	r3, 80115e0 <xQueueGenericSend+0x270>
					else if( xYieldRequired != pdFALSE )
 80115c2:	b138      	cbz	r0, 80115d4 <xQueueGenericSend+0x264>
						queueYIELD_IF_USING_PREEMPTION();
 80115c4:	4b2c      	ldr	r3, [pc, #176]	; (8011678 <xQueueGenericSend+0x308>)
 80115c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80115ca:	601a      	str	r2, [r3, #0]
 80115cc:	f3bf 8f4f 	dsb	sy
 80115d0:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80115d4:	f001 ffb8 	bl	8013548 <vPortExitCritical>
				return pdPASS;
 80115d8:	2001      	movs	r0, #1
}
 80115da:	b004      	add	sp, #16
 80115dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80115e0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80115e4:	f001 faae 	bl	8012b44 <xTaskRemoveFromEventList>
 80115e8:	2800      	cmp	r0, #0
 80115ea:	d0f3      	beq.n	80115d4 <xQueueGenericSend+0x264>
 80115ec:	e7ea      	b.n	80115c4 <xQueueGenericSend+0x254>
	taskENTER_CRITICAL();
 80115ee:	f001 ff89 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 80115f2:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 80115f6:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80115f8:	2d00      	cmp	r5, #0
 80115fa:	dd11      	ble.n	8011620 <xQueueGenericSend+0x2b0>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80115fc:	f104 0624 	add.w	r6, r4, #36	; 0x24
 8011600:	e004      	b.n	801160c <xQueueGenericSend+0x29c>
			--cTxLock;
 8011602:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011604:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011608:	b25d      	sxtb	r5, r3
 801160a:	d009      	beq.n	8011620 <xQueueGenericSend+0x2b0>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801160c:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801160e:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011610:	b133      	cbz	r3, 8011620 <xQueueGenericSend+0x2b0>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011612:	f001 fa97 	bl	8012b44 <xTaskRemoveFromEventList>
 8011616:	2800      	cmp	r0, #0
 8011618:	d0f3      	beq.n	8011602 <xQueueGenericSend+0x292>
						vTaskMissedYield();
 801161a:	f001 fb25 	bl	8012c68 <vTaskMissedYield>
 801161e:	e7f0      	b.n	8011602 <xQueueGenericSend+0x292>
		pxQueue->cTxLock = queueUNLOCKED;
 8011620:	23ff      	movs	r3, #255	; 0xff
 8011622:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8011626:	f001 ff8f 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 801162a:	f001 ff6b 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 801162e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8011632:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011634:	2d00      	cmp	r5, #0
 8011636:	dd11      	ble.n	801165c <xQueueGenericSend+0x2ec>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011638:	f104 0610 	add.w	r6, r4, #16
 801163c:	e004      	b.n	8011648 <xQueueGenericSend+0x2d8>
				--cRxLock;
 801163e:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011640:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011644:	b25d      	sxtb	r5, r3
 8011646:	d009      	beq.n	801165c <xQueueGenericSend+0x2ec>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011648:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801164a:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801164c:	b133      	cbz	r3, 801165c <xQueueGenericSend+0x2ec>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801164e:	f001 fa79 	bl	8012b44 <xTaskRemoveFromEventList>
 8011652:	2800      	cmp	r0, #0
 8011654:	d0f3      	beq.n	801163e <xQueueGenericSend+0x2ce>
					vTaskMissedYield();
 8011656:	f001 fb07 	bl	8012c68 <vTaskMissedYield>
 801165a:	e7f0      	b.n	801163e <xQueueGenericSend+0x2ce>
		pxQueue->cRxLock = queueUNLOCKED;
 801165c:	23ff      	movs	r3, #255	; 0xff
 801165e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8011662:	f001 ff71 	bl	8013548 <vPortExitCritical>
			( void ) xTaskResumeAll();
 8011666:	f001 f8dd 	bl	8012824 <xTaskResumeAll>
			return errQUEUE_FULL;
 801166a:	2000      	movs	r0, #0
 801166c:	e7b5      	b.n	80115da <xQueueGenericSend+0x26a>
					taskEXIT_CRITICAL();
 801166e:	f001 ff6b 	bl	8013548 <vPortExitCritical>
					return errQUEUE_FULL;
 8011672:	4628      	mov	r0, r5
 8011674:	e7b1      	b.n	80115da <xQueueGenericSend+0x26a>
 8011676:	bf00      	nop
 8011678:	e000ed04 	.word	0xe000ed04

0801167c <xQueueGenericSendFromISR>:
{
 801167c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8011680:	2800      	cmp	r0, #0
 8011682:	d035      	beq.n	80116f0 <xQueueGenericSendFromISR+0x74>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8011684:	4689      	mov	r9, r1
 8011686:	4690      	mov	r8, r2
 8011688:	461f      	mov	r7, r3
 801168a:	4604      	mov	r4, r0
 801168c:	b321      	cbz	r1, 80116d8 <xQueueGenericSendFromISR+0x5c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 801168e:	2f02      	cmp	r7, #2
 8011690:	d10b      	bne.n	80116aa <xQueueGenericSendFromISR+0x2e>
 8011692:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8011694:	2b01      	cmp	r3, #1
 8011696:	d008      	beq.n	80116aa <xQueueGenericSendFromISR+0x2e>
 8011698:	f04f 0320 	mov.w	r3, #32
 801169c:	f383 8811 	msr	BASEPRI, r3
 80116a0:	f3bf 8f6f 	isb	sy
 80116a4:	f3bf 8f4f 	dsb	sy
 80116a8:	e7fe      	b.n	80116a8 <xQueueGenericSendFromISR+0x2c>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80116aa:	f002 f861 	bl	8013770 <vPortValidateInterruptPriority>
	__asm volatile
 80116ae:	f3ef 8611 	mrs	r6, BASEPRI
 80116b2:	f04f 0320 	mov.w	r3, #32
 80116b6:	f383 8811 	msr	BASEPRI, r3
 80116ba:	f3bf 8f6f 	isb	sy
 80116be:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80116c2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80116c4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80116c6:	429a      	cmp	r2, r3
 80116c8:	d31b      	bcc.n	8011702 <xQueueGenericSendFromISR+0x86>
 80116ca:	2f02      	cmp	r7, #2
 80116cc:	d019      	beq.n	8011702 <xQueueGenericSendFromISR+0x86>
			xReturn = errQUEUE_FULL;
 80116ce:	2000      	movs	r0, #0
	__asm volatile
 80116d0:	f386 8811 	msr	BASEPRI, r6
}
 80116d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80116d8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80116da:	2b00      	cmp	r3, #0
 80116dc:	d0d7      	beq.n	801168e <xQueueGenericSendFromISR+0x12>
	__asm volatile
 80116de:	f04f 0320 	mov.w	r3, #32
 80116e2:	f383 8811 	msr	BASEPRI, r3
 80116e6:	f3bf 8f6f 	isb	sy
 80116ea:	f3bf 8f4f 	dsb	sy
 80116ee:	e7fe      	b.n	80116ee <xQueueGenericSendFromISR+0x72>
 80116f0:	f04f 0320 	mov.w	r3, #32
 80116f4:	f383 8811 	msr	BASEPRI, r3
 80116f8:	f3bf 8f6f 	isb	sy
 80116fc:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8011700:	e7fe      	b.n	8011700 <xQueueGenericSendFromISR+0x84>
			const int8_t cTxLock = pxQueue->cTxLock;
 8011702:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8011706:	463a      	mov	r2, r7
 8011708:	4649      	mov	r1, r9
			const int8_t cTxLock = pxQueue->cTxLock;
 801170a:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 801170c:	4620      	mov	r0, r4
 801170e:	f7ff fd65 	bl	80111dc <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8011712:	1c6b      	adds	r3, r5, #1
 8011714:	d008      	beq.n	8011728 <xQueueGenericSendFromISR+0xac>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8011716:	1c6b      	adds	r3, r5, #1
 8011718:	b25b      	sxtb	r3, r3
 801171a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 801171e:	2001      	movs	r0, #1
	__asm volatile
 8011720:	f386 8811 	msr	BASEPRI, r6
}
 8011724:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011728:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801172a:	2b00      	cmp	r3, #0
 801172c:	d0f7      	beq.n	801171e <xQueueGenericSendFromISR+0xa2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801172e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8011732:	f001 fa07 	bl	8012b44 <xTaskRemoveFromEventList>
 8011736:	2800      	cmp	r0, #0
 8011738:	d0f1      	beq.n	801171e <xQueueGenericSendFromISR+0xa2>
							if( pxHigherPriorityTaskWoken != NULL )
 801173a:	f1b8 0f00 	cmp.w	r8, #0
 801173e:	d0ee      	beq.n	801171e <xQueueGenericSendFromISR+0xa2>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8011740:	2001      	movs	r0, #1
 8011742:	f8c8 0000 	str.w	r0, [r8]
 8011746:	e7c3      	b.n	80116d0 <xQueueGenericSendFromISR+0x54>

08011748 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 8011748:	b370      	cbz	r0, 80117a8 <xQueueGiveFromISR+0x60>
	configASSERT( pxQueue->uxItemSize == 0 );
 801174a:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
 801174c:	b570      	push	{r4, r5, r6, lr}
 801174e:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 8011750:	b143      	cbz	r3, 8011764 <xQueueGiveFromISR+0x1c>
	__asm volatile
 8011752:	f04f 0320 	mov.w	r3, #32
 8011756:	f383 8811 	msr	BASEPRI, r3
 801175a:	f3bf 8f6f 	isb	sy
 801175e:	f3bf 8f4f 	dsb	sy
 8011762:	e7fe      	b.n	8011762 <xQueueGiveFromISR+0x1a>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8011764:	6803      	ldr	r3, [r0, #0]
 8011766:	460d      	mov	r5, r1
 8011768:	b33b      	cbz	r3, 80117ba <xQueueGiveFromISR+0x72>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 801176a:	f002 f801 	bl	8013770 <vPortValidateInterruptPriority>
	__asm volatile
 801176e:	f3ef 8611 	mrs	r6, BASEPRI
 8011772:	f04f 0320 	mov.w	r3, #32
 8011776:	f383 8811 	msr	BASEPRI, r3
 801177a:	f3bf 8f6f 	isb	sy
 801177e:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8011782:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8011784:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8011786:	429a      	cmp	r2, r3
 8011788:	d923      	bls.n	80117d2 <xQueueGiveFromISR+0x8a>
			const int8_t cTxLock = pxQueue->cTxLock;
 801178a:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 801178e:	3301      	adds	r3, #1
			if( cTxLock == queueUNLOCKED )
 8011790:	2aff      	cmp	r2, #255	; 0xff
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8011792:	63a3      	str	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
 8011794:	b253      	sxtb	r3, r2
			if( cTxLock == queueUNLOCKED )
 8011796:	d020      	beq.n	80117da <xQueueGiveFromISR+0x92>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8011798:	3301      	adds	r3, #1
 801179a:	b25b      	sxtb	r3, r3
 801179c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 80117a0:	2001      	movs	r0, #1
	__asm volatile
 80117a2:	f386 8811 	msr	BASEPRI, r6
}
 80117a6:	bd70      	pop	{r4, r5, r6, pc}
	__asm volatile
 80117a8:	f04f 0320 	mov.w	r3, #32
 80117ac:	f383 8811 	msr	BASEPRI, r3
 80117b0:	f3bf 8f6f 	isb	sy
 80117b4:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80117b8:	e7fe      	b.n	80117b8 <xQueueGiveFromISR+0x70>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 80117ba:	6883      	ldr	r3, [r0, #8]
 80117bc:	2b00      	cmp	r3, #0
 80117be:	d0d4      	beq.n	801176a <xQueueGiveFromISR+0x22>
 80117c0:	f04f 0320 	mov.w	r3, #32
 80117c4:	f383 8811 	msr	BASEPRI, r3
 80117c8:	f3bf 8f6f 	isb	sy
 80117cc:	f3bf 8f4f 	dsb	sy
 80117d0:	e7fe      	b.n	80117d0 <xQueueGiveFromISR+0x88>
			xReturn = errQUEUE_FULL;
 80117d2:	2000      	movs	r0, #0
	__asm volatile
 80117d4:	f386 8811 	msr	BASEPRI, r6
}
 80117d8:	bd70      	pop	{r4, r5, r6, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80117da:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80117dc:	2b00      	cmp	r3, #0
 80117de:	d0df      	beq.n	80117a0 <xQueueGiveFromISR+0x58>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80117e0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80117e4:	f001 f9ae 	bl	8012b44 <xTaskRemoveFromEventList>
 80117e8:	2800      	cmp	r0, #0
 80117ea:	d0d9      	beq.n	80117a0 <xQueueGiveFromISR+0x58>
							if( pxHigherPriorityTaskWoken != NULL )
 80117ec:	2d00      	cmp	r5, #0
 80117ee:	d0d7      	beq.n	80117a0 <xQueueGiveFromISR+0x58>
								*pxHigherPriorityTaskWoken = pdTRUE;
 80117f0:	2001      	movs	r0, #1
 80117f2:	6028      	str	r0, [r5, #0]
 80117f4:	e7ee      	b.n	80117d4 <xQueueGiveFromISR+0x8c>
 80117f6:	bf00      	nop

080117f8 <xQueueReceive>:
{
 80117f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80117fc:	b085      	sub	sp, #20
 80117fe:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 8011800:	2800      	cmp	r0, #0
 8011802:	f000 80f5 	beq.w	80119f0 <xQueueReceive+0x1f8>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8011806:	460e      	mov	r6, r1
 8011808:	4604      	mov	r4, r0
 801180a:	2900      	cmp	r1, #0
 801180c:	f000 808a 	beq.w	8011924 <xQueueReceive+0x12c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8011810:	f001 fa32 	bl	8012c78 <xTaskGetSchedulerState>
 8011814:	2800      	cmp	r0, #0
 8011816:	d079      	beq.n	801190c <xQueueReceive+0x114>
		taskENTER_CRITICAL();
 8011818:	f001 fe74 	bl	8013504 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 801181c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 801181e:	2d00      	cmp	r5, #0
 8011820:	f040 8148 	bne.w	8011ab4 <xQueueReceive+0x2bc>
				if( xTicksToWait == ( TickType_t ) 0 )
 8011824:	9b01      	ldr	r3, [sp, #4]
 8011826:	2b00      	cmp	r3, #0
 8011828:	f000 80dc 	beq.w	80119e4 <xQueueReceive+0x1ec>
					vTaskInternalSetTimeOutState( &xTimeOut );
 801182c:	a802      	add	r0, sp, #8
 801182e:	f001 f9cb 	bl	8012bc8 <vTaskInternalSetTimeOutState>
					portYIELD_WITHIN_API();
 8011832:	f8df 82c8 	ldr.w	r8, [pc, #712]	; 8011afc <xQueueReceive+0x304>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011836:	f104 0724 	add.w	r7, r4, #36	; 0x24
		taskEXIT_CRITICAL();
 801183a:	f001 fe85 	bl	8013548 <vPortExitCritical>
		vTaskSuspendAll();
 801183e:	f000 fec7 	bl	80125d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8011842:	f001 fe5f 	bl	8013504 <vPortEnterCritical>
 8011846:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 801184a:	2bff      	cmp	r3, #255	; 0xff
 801184c:	bf04      	itt	eq
 801184e:	2300      	moveq	r3, #0
 8011850:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8011854:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8011858:	2bff      	cmp	r3, #255	; 0xff
 801185a:	bf04      	itt	eq
 801185c:	2300      	moveq	r3, #0
 801185e:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8011862:	f001 fe71 	bl	8013548 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8011866:	a901      	add	r1, sp, #4
 8011868:	a802      	add	r0, sp, #8
 801186a:	f001 f9b7 	bl	8012bdc <xTaskCheckForTimeOut>
 801186e:	2800      	cmp	r0, #0
 8011870:	d165      	bne.n	801193e <xQueueReceive+0x146>
	taskENTER_CRITICAL();
 8011872:	f001 fe47 	bl	8013504 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8011876:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8011878:	2b00      	cmp	r3, #0
 801187a:	f000 80c2 	beq.w	8011a02 <xQueueReceive+0x20a>
	taskEXIT_CRITICAL();
 801187e:	f001 fe63 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011882:	f001 fe3f 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011886:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 801188a:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801188c:	2d00      	cmp	r5, #0
 801188e:	dc05      	bgt.n	801189c <xQueueReceive+0xa4>
 8011890:	e012      	b.n	80118b8 <xQueueReceive+0xc0>
			--cTxLock;
 8011892:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011894:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011898:	b25d      	sxtb	r5, r3
 801189a:	d00d      	beq.n	80118b8 <xQueueReceive+0xc0>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801189c:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801189e:	4638      	mov	r0, r7
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80118a0:	b153      	cbz	r3, 80118b8 <xQueueReceive+0xc0>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80118a2:	f001 f94f 	bl	8012b44 <xTaskRemoveFromEventList>
 80118a6:	2800      	cmp	r0, #0
 80118a8:	d0f3      	beq.n	8011892 <xQueueReceive+0x9a>
						vTaskMissedYield();
 80118aa:	f001 f9dd 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 80118ae:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 80118b0:	f013 0fff 	tst.w	r3, #255	; 0xff
 80118b4:	b25d      	sxtb	r5, r3
 80118b6:	d1f1      	bne.n	801189c <xQueueReceive+0xa4>
		pxQueue->cTxLock = queueUNLOCKED;
 80118b8:	23ff      	movs	r3, #255	; 0xff
 80118ba:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 80118be:	f001 fe43 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 80118c2:	f001 fe1f 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 80118c6:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 80118ca:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80118cc:	2d00      	cmp	r5, #0
 80118ce:	dd15      	ble.n	80118fc <xQueueReceive+0x104>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80118d0:	f104 0910 	add.w	r9, r4, #16
 80118d4:	e004      	b.n	80118e0 <xQueueReceive+0xe8>
				--cRxLock;
 80118d6:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80118d8:	f013 0fff 	tst.w	r3, #255	; 0xff
 80118dc:	b25d      	sxtb	r5, r3
 80118de:	d00d      	beq.n	80118fc <xQueueReceive+0x104>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80118e0:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80118e2:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80118e4:	b153      	cbz	r3, 80118fc <xQueueReceive+0x104>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80118e6:	f001 f92d 	bl	8012b44 <xTaskRemoveFromEventList>
 80118ea:	2800      	cmp	r0, #0
 80118ec:	d0f3      	beq.n	80118d6 <xQueueReceive+0xde>
					vTaskMissedYield();
 80118ee:	f001 f9bb 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 80118f2:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80118f4:	f013 0fff 	tst.w	r3, #255	; 0xff
 80118f8:	b25d      	sxtb	r5, r3
 80118fa:	d1f1      	bne.n	80118e0 <xQueueReceive+0xe8>
		pxQueue->cRxLock = queueUNLOCKED;
 80118fc:	23ff      	movs	r3, #255	; 0xff
 80118fe:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8011902:	f001 fe21 	bl	8013548 <vPortExitCritical>
				( void ) xTaskResumeAll();
 8011906:	f000 ff8d 	bl	8012824 <xTaskResumeAll>
		taskENTER_CRITICAL();
 801190a:	e062      	b.n	80119d2 <xQueueReceive+0x1da>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 801190c:	9b01      	ldr	r3, [sp, #4]
 801190e:	2b00      	cmp	r3, #0
 8011910:	d082      	beq.n	8011818 <xQueueReceive+0x20>
	__asm volatile
 8011912:	f04f 0320 	mov.w	r3, #32
 8011916:	f383 8811 	msr	BASEPRI, r3
 801191a:	f3bf 8f6f 	isb	sy
 801191e:	f3bf 8f4f 	dsb	sy
 8011922:	e7fe      	b.n	8011922 <xQueueReceive+0x12a>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8011924:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8011926:	2b00      	cmp	r3, #0
 8011928:	f43f af72 	beq.w	8011810 <xQueueReceive+0x18>
 801192c:	f04f 0320 	mov.w	r3, #32
 8011930:	f383 8811 	msr	BASEPRI, r3
 8011934:	f3bf 8f6f 	isb	sy
 8011938:	f3bf 8f4f 	dsb	sy
 801193c:	e7fe      	b.n	801193c <xQueueReceive+0x144>
	taskENTER_CRITICAL();
 801193e:	f001 fde1 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011942:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 8011946:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011948:	2d00      	cmp	r5, #0
 801194a:	dc05      	bgt.n	8011958 <xQueueReceive+0x160>
 801194c:	e012      	b.n	8011974 <xQueueReceive+0x17c>
			--cTxLock;
 801194e:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011950:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011954:	b25d      	sxtb	r5, r3
 8011956:	d00d      	beq.n	8011974 <xQueueReceive+0x17c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011958:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801195a:	4638      	mov	r0, r7
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 801195c:	b153      	cbz	r3, 8011974 <xQueueReceive+0x17c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 801195e:	f001 f8f1 	bl	8012b44 <xTaskRemoveFromEventList>
 8011962:	2800      	cmp	r0, #0
 8011964:	d0f3      	beq.n	801194e <xQueueReceive+0x156>
						vTaskMissedYield();
 8011966:	f001 f97f 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 801196a:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 801196c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011970:	b25d      	sxtb	r5, r3
 8011972:	d1f1      	bne.n	8011958 <xQueueReceive+0x160>
		pxQueue->cTxLock = queueUNLOCKED;
 8011974:	23ff      	movs	r3, #255	; 0xff
 8011976:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 801197a:	f001 fde5 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 801197e:	f001 fdc1 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011982:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8011986:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011988:	2d00      	cmp	r5, #0
 801198a:	dd15      	ble.n	80119b8 <xQueueReceive+0x1c0>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801198c:	f104 0910 	add.w	r9, r4, #16
 8011990:	e004      	b.n	801199c <xQueueReceive+0x1a4>
				--cRxLock;
 8011992:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011994:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011998:	b25d      	sxtb	r5, r3
 801199a:	d00d      	beq.n	80119b8 <xQueueReceive+0x1c0>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 801199c:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 801199e:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80119a0:	b153      	cbz	r3, 80119b8 <xQueueReceive+0x1c0>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80119a2:	f001 f8cf 	bl	8012b44 <xTaskRemoveFromEventList>
 80119a6:	2800      	cmp	r0, #0
 80119a8:	d0f3      	beq.n	8011992 <xQueueReceive+0x19a>
					vTaskMissedYield();
 80119aa:	f001 f95d 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 80119ae:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80119b0:	f013 0fff 	tst.w	r3, #255	; 0xff
 80119b4:	b25d      	sxtb	r5, r3
 80119b6:	d1f1      	bne.n	801199c <xQueueReceive+0x1a4>
		pxQueue->cRxLock = queueUNLOCKED;
 80119b8:	23ff      	movs	r3, #255	; 0xff
 80119ba:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 80119be:	f001 fdc3 	bl	8013548 <vPortExitCritical>
			( void ) xTaskResumeAll();
 80119c2:	f000 ff2f 	bl	8012824 <xTaskResumeAll>
	taskENTER_CRITICAL();
 80119c6:	f001 fd9d 	bl	8013504 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80119ca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80119cc:	b153      	cbz	r3, 80119e4 <xQueueReceive+0x1ec>
	taskEXIT_CRITICAL();
 80119ce:	f001 fdbb 	bl	8013548 <vPortExitCritical>
		taskENTER_CRITICAL();
 80119d2:	f001 fd97 	bl	8013504 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80119d6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80119d8:	2d00      	cmp	r5, #0
 80119da:	d16b      	bne.n	8011ab4 <xQueueReceive+0x2bc>
				if( xTicksToWait == ( TickType_t ) 0 )
 80119dc:	9b01      	ldr	r3, [sp, #4]
 80119de:	2b00      	cmp	r3, #0
 80119e0:	f47f af2b 	bne.w	801183a <xQueueReceive+0x42>
					taskEXIT_CRITICAL();
 80119e4:	f001 fdb0 	bl	8013548 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80119e8:	2000      	movs	r0, #0
}
 80119ea:	b005      	add	sp, #20
 80119ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80119f0:	f04f 0320 	mov.w	r3, #32
 80119f4:	f383 8811 	msr	BASEPRI, r3
 80119f8:	f3bf 8f6f 	isb	sy
 80119fc:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8011a00:	e7fe      	b.n	8011a00 <xQueueReceive+0x208>
	taskEXIT_CRITICAL();
 8011a02:	f001 fda1 	bl	8013548 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8011a06:	9901      	ldr	r1, [sp, #4]
 8011a08:	4638      	mov	r0, r7
 8011a0a:	f000 ffeb 	bl	80129e4 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 8011a0e:	f001 fd79 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011a12:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 8011a16:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011a18:	2d00      	cmp	r5, #0
 8011a1a:	dc05      	bgt.n	8011a28 <xQueueReceive+0x230>
 8011a1c:	e012      	b.n	8011a44 <xQueueReceive+0x24c>
			--cTxLock;
 8011a1e:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011a20:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011a24:	b25d      	sxtb	r5, r3
 8011a26:	d00d      	beq.n	8011a44 <xQueueReceive+0x24c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011a28:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011a2a:	4638      	mov	r0, r7
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011a2c:	b153      	cbz	r3, 8011a44 <xQueueReceive+0x24c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011a2e:	f001 f889 	bl	8012b44 <xTaskRemoveFromEventList>
 8011a32:	2800      	cmp	r0, #0
 8011a34:	d0f3      	beq.n	8011a1e <xQueueReceive+0x226>
						vTaskMissedYield();
 8011a36:	f001 f917 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 8011a3a:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011a3c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011a40:	b25d      	sxtb	r5, r3
 8011a42:	d1f1      	bne.n	8011a28 <xQueueReceive+0x230>
		pxQueue->cTxLock = queueUNLOCKED;
 8011a44:	23ff      	movs	r3, #255	; 0xff
 8011a46:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8011a4a:	f001 fd7d 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011a4e:	f001 fd59 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011a52:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8011a56:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011a58:	2d00      	cmp	r5, #0
 8011a5a:	dd15      	ble.n	8011a88 <xQueueReceive+0x290>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011a5c:	f104 0910 	add.w	r9, r4, #16
 8011a60:	e004      	b.n	8011a6c <xQueueReceive+0x274>
				--cRxLock;
 8011a62:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011a64:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011a68:	b25d      	sxtb	r5, r3
 8011a6a:	d00d      	beq.n	8011a88 <xQueueReceive+0x290>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011a6c:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011a6e:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011a70:	b153      	cbz	r3, 8011a88 <xQueueReceive+0x290>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011a72:	f001 f867 	bl	8012b44 <xTaskRemoveFromEventList>
 8011a76:	2800      	cmp	r0, #0
 8011a78:	d0f3      	beq.n	8011a62 <xQueueReceive+0x26a>
					vTaskMissedYield();
 8011a7a:	f001 f8f5 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 8011a7e:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011a80:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011a84:	b25d      	sxtb	r5, r3
 8011a86:	d1f1      	bne.n	8011a6c <xQueueReceive+0x274>
		pxQueue->cRxLock = queueUNLOCKED;
 8011a88:	23ff      	movs	r3, #255	; 0xff
 8011a8a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8011a8e:	f001 fd5b 	bl	8013548 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 8011a92:	f000 fec7 	bl	8012824 <xTaskResumeAll>
 8011a96:	2800      	cmp	r0, #0
 8011a98:	d19b      	bne.n	80119d2 <xQueueReceive+0x1da>
					portYIELD_WITHIN_API();
 8011a9a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8011a9e:	f8c8 3000 	str.w	r3, [r8]
 8011aa2:	f3bf 8f4f 	dsb	sy
 8011aa6:	f3bf 8f6f 	isb	sy
		taskENTER_CRITICAL();
 8011aaa:	f001 fd2b 	bl	8013504 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8011aae:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8011ab0:	2d00      	cmp	r5, #0
 8011ab2:	d093      	beq.n	80119dc <xQueueReceive+0x1e4>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8011ab4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8011ab6:	b152      	cbz	r2, 8011ace <xQueueReceive+0x2d6>
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8011ab8:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8011abc:	1899      	adds	r1, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8011abe:	4281      	cmp	r1, r0
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8011ac0:	60e1      	str	r1, [r4, #12]
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8011ac2:	bf24      	itt	cs
 8011ac4:	6821      	ldrcs	r1, [r4, #0]
 8011ac6:	60e1      	strcs	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8011ac8:	4630      	mov	r0, r6
 8011aca:	f004 fa39 	bl	8015f40 <memcpy>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8011ace:	3d01      	subs	r5, #1
 8011ad0:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011ad2:	6923      	ldr	r3, [r4, #16]
 8011ad4:	b91b      	cbnz	r3, 8011ade <xQueueReceive+0x2e6>
				taskEXIT_CRITICAL();
 8011ad6:	f001 fd37 	bl	8013548 <vPortExitCritical>
				return pdPASS;
 8011ada:	2001      	movs	r0, #1
 8011adc:	e785      	b.n	80119ea <xQueueReceive+0x1f2>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011ade:	f104 0010 	add.w	r0, r4, #16
 8011ae2:	f001 f82f 	bl	8012b44 <xTaskRemoveFromEventList>
 8011ae6:	2800      	cmp	r0, #0
 8011ae8:	d0f5      	beq.n	8011ad6 <xQueueReceive+0x2de>
						queueYIELD_IF_USING_PREEMPTION();
 8011aea:	4b04      	ldr	r3, [pc, #16]	; (8011afc <xQueueReceive+0x304>)
 8011aec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8011af0:	601a      	str	r2, [r3, #0]
 8011af2:	f3bf 8f4f 	dsb	sy
 8011af6:	f3bf 8f6f 	isb	sy
 8011afa:	e7ec      	b.n	8011ad6 <xQueueReceive+0x2de>
 8011afc:	e000ed04 	.word	0xe000ed04

08011b00 <xQueueSemaphoreTake>:
{
 8011b00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8011b04:	b085      	sub	sp, #20
 8011b06:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 8011b08:	b158      	cbz	r0, 8011b22 <xQueueSemaphoreTake+0x22>
	configASSERT( pxQueue->uxItemSize == 0 );
 8011b0a:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8011b0c:	4604      	mov	r4, r0
 8011b0e:	b18d      	cbz	r5, 8011b34 <xQueueSemaphoreTake+0x34>
 8011b10:	f04f 0320 	mov.w	r3, #32
 8011b14:	f383 8811 	msr	BASEPRI, r3
 8011b18:	f3bf 8f6f 	isb	sy
 8011b1c:	f3bf 8f4f 	dsb	sy
 8011b20:	e7fe      	b.n	8011b20 <xQueueSemaphoreTake+0x20>
 8011b22:	f04f 0320 	mov.w	r3, #32
 8011b26:	f383 8811 	msr	BASEPRI, r3
 8011b2a:	f3bf 8f6f 	isb	sy
 8011b2e:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8011b32:	e7fe      	b.n	8011b32 <xQueueSemaphoreTake+0x32>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8011b34:	f001 f8a0 	bl	8012c78 <xTaskGetSchedulerState>
 8011b38:	4606      	mov	r6, r0
 8011b3a:	2800      	cmp	r0, #0
 8011b3c:	f000 80c7 	beq.w	8011cce <xQueueSemaphoreTake+0x1ce>
 8011b40:	462e      	mov	r6, r5
					portYIELD_WITHIN_API();
 8011b42:	f8df 82d8 	ldr.w	r8, [pc, #728]	; 8011e1c <xQueueSemaphoreTake+0x31c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011b46:	f104 0724 	add.w	r7, r4, #36	; 0x24
		taskENTER_CRITICAL();
 8011b4a:	f001 fcdb 	bl	8013504 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 8011b4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 8011b50:	2b00      	cmp	r3, #0
 8011b52:	f040 8121 	bne.w	8011d98 <xQueueSemaphoreTake+0x298>
				if( xTicksToWait == ( TickType_t ) 0 )
 8011b56:	9b01      	ldr	r3, [sp, #4]
 8011b58:	2b00      	cmp	r3, #0
 8011b5a:	f000 8152 	beq.w	8011e02 <xQueueSemaphoreTake+0x302>
				else if( xEntryTimeSet == pdFALSE )
 8011b5e:	2e00      	cmp	r6, #0
 8011b60:	f000 80b0 	beq.w	8011cc4 <xQueueSemaphoreTake+0x1c4>
 8011b64:	ae02      	add	r6, sp, #8
		taskEXIT_CRITICAL();
 8011b66:	f001 fcef 	bl	8013548 <vPortExitCritical>
		vTaskSuspendAll();
 8011b6a:	f000 fd31 	bl	80125d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8011b6e:	f001 fcc9 	bl	8013504 <vPortEnterCritical>
 8011b72:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8011b76:	2bff      	cmp	r3, #255	; 0xff
 8011b78:	bf04      	itt	eq
 8011b7a:	2300      	moveq	r3, #0
 8011b7c:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8011b80:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8011b84:	2bff      	cmp	r3, #255	; 0xff
 8011b86:	bf04      	itt	eq
 8011b88:	2300      	moveq	r3, #0
 8011b8a:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8011b8e:	f001 fcdb 	bl	8013548 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8011b92:	4630      	mov	r0, r6
 8011b94:	a901      	add	r1, sp, #4
 8011b96:	f001 f821 	bl	8012bdc <xTaskCheckForTimeOut>
 8011b9a:	b9f8      	cbnz	r0, 8011bdc <xQueueSemaphoreTake+0xdc>
	taskENTER_CRITICAL();
 8011b9c:	f001 fcb2 	bl	8013504 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8011ba0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8011ba2:	2b00      	cmp	r3, #0
 8011ba4:	f000 80a0 	beq.w	8011ce8 <xQueueSemaphoreTake+0x1e8>
	taskEXIT_CRITICAL();
 8011ba8:	f001 fcce 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011bac:	f001 fcaa 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011bb0:	f894 6045 	ldrb.w	r6, [r4, #69]	; 0x45
 8011bb4:	b276      	sxtb	r6, r6
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011bb6:	2e00      	cmp	r6, #0
 8011bb8:	dc05      	bgt.n	8011bc6 <xQueueSemaphoreTake+0xc6>
 8011bba:	e05d      	b.n	8011c78 <xQueueSemaphoreTake+0x178>
			--cTxLock;
 8011bbc:	1e73      	subs	r3, r6, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011bbe:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011bc2:	b25e      	sxtb	r6, r3
 8011bc4:	d058      	beq.n	8011c78 <xQueueSemaphoreTake+0x178>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011bc6:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011bc8:	4638      	mov	r0, r7
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011bca:	2b00      	cmp	r3, #0
 8011bcc:	d054      	beq.n	8011c78 <xQueueSemaphoreTake+0x178>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011bce:	f000 ffb9 	bl	8012b44 <xTaskRemoveFromEventList>
 8011bd2:	2800      	cmp	r0, #0
 8011bd4:	d0f2      	beq.n	8011bbc <xQueueSemaphoreTake+0xbc>
						vTaskMissedYield();
 8011bd6:	f001 f847 	bl	8012c68 <vTaskMissedYield>
 8011bda:	e7ef      	b.n	8011bbc <xQueueSemaphoreTake+0xbc>
	taskENTER_CRITICAL();
 8011bdc:	f001 fc92 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011be0:	f894 6045 	ldrb.w	r6, [r4, #69]	; 0x45
 8011be4:	b276      	sxtb	r6, r6
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011be6:	2e00      	cmp	r6, #0
 8011be8:	dc05      	bgt.n	8011bf6 <xQueueSemaphoreTake+0xf6>
 8011bea:	e012      	b.n	8011c12 <xQueueSemaphoreTake+0x112>
			--cTxLock;
 8011bec:	1e73      	subs	r3, r6, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011bee:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011bf2:	b25e      	sxtb	r6, r3
 8011bf4:	d00d      	beq.n	8011c12 <xQueueSemaphoreTake+0x112>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011bf6:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011bf8:	4638      	mov	r0, r7
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011bfa:	b153      	cbz	r3, 8011c12 <xQueueSemaphoreTake+0x112>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011bfc:	f000 ffa2 	bl	8012b44 <xTaskRemoveFromEventList>
 8011c00:	2800      	cmp	r0, #0
 8011c02:	d0f3      	beq.n	8011bec <xQueueSemaphoreTake+0xec>
						vTaskMissedYield();
 8011c04:	f001 f830 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 8011c08:	1e73      	subs	r3, r6, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011c0a:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011c0e:	b25e      	sxtb	r6, r3
 8011c10:	d1f1      	bne.n	8011bf6 <xQueueSemaphoreTake+0xf6>
		pxQueue->cTxLock = queueUNLOCKED;
 8011c12:	23ff      	movs	r3, #255	; 0xff
 8011c14:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8011c18:	f001 fc96 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011c1c:	f001 fc72 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011c20:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 8011c24:	b276      	sxtb	r6, r6
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011c26:	2e00      	cmp	r6, #0
 8011c28:	dd15      	ble.n	8011c56 <xQueueSemaphoreTake+0x156>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011c2a:	f104 0910 	add.w	r9, r4, #16
 8011c2e:	e004      	b.n	8011c3a <xQueueSemaphoreTake+0x13a>
				--cRxLock;
 8011c30:	1e73      	subs	r3, r6, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011c32:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011c36:	b25e      	sxtb	r6, r3
 8011c38:	d00d      	beq.n	8011c56 <xQueueSemaphoreTake+0x156>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011c3a:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011c3c:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011c3e:	b153      	cbz	r3, 8011c56 <xQueueSemaphoreTake+0x156>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011c40:	f000 ff80 	bl	8012b44 <xTaskRemoveFromEventList>
 8011c44:	2800      	cmp	r0, #0
 8011c46:	d0f3      	beq.n	8011c30 <xQueueSemaphoreTake+0x130>
					vTaskMissedYield();
 8011c48:	f001 f80e 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 8011c4c:	1e73      	subs	r3, r6, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011c4e:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011c52:	b25e      	sxtb	r6, r3
 8011c54:	d1f1      	bne.n	8011c3a <xQueueSemaphoreTake+0x13a>
		pxQueue->cRxLock = queueUNLOCKED;
 8011c56:	23ff      	movs	r3, #255	; 0xff
 8011c58:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8011c5c:	f001 fc74 	bl	8013548 <vPortExitCritical>
			( void ) xTaskResumeAll();
 8011c60:	f000 fde0 	bl	8012824 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8011c64:	f001 fc4e 	bl	8013504 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8011c68:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8011c6a:	2b00      	cmp	r3, #0
 8011c6c:	f000 808d 	beq.w	8011d8a <xQueueSemaphoreTake+0x28a>
	taskEXIT_CRITICAL();
 8011c70:	f001 fc6a 	bl	8013548 <vPortExitCritical>
	return xReturn;
 8011c74:	2601      	movs	r6, #1
 8011c76:	e768      	b.n	8011b4a <xQueueSemaphoreTake+0x4a>
		pxQueue->cTxLock = queueUNLOCKED;
 8011c78:	23ff      	movs	r3, #255	; 0xff
 8011c7a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8011c7e:	f001 fc63 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011c82:	f001 fc3f 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011c86:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 8011c8a:	b276      	sxtb	r6, r6
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011c8c:	2e00      	cmp	r6, #0
 8011c8e:	dd11      	ble.n	8011cb4 <xQueueSemaphoreTake+0x1b4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011c90:	f104 0910 	add.w	r9, r4, #16
 8011c94:	e004      	b.n	8011ca0 <xQueueSemaphoreTake+0x1a0>
				--cRxLock;
 8011c96:	1e73      	subs	r3, r6, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011c98:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011c9c:	b25e      	sxtb	r6, r3
 8011c9e:	d009      	beq.n	8011cb4 <xQueueSemaphoreTake+0x1b4>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011ca0:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011ca2:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011ca4:	b133      	cbz	r3, 8011cb4 <xQueueSemaphoreTake+0x1b4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011ca6:	f000 ff4d 	bl	8012b44 <xTaskRemoveFromEventList>
 8011caa:	2800      	cmp	r0, #0
 8011cac:	d0f3      	beq.n	8011c96 <xQueueSemaphoreTake+0x196>
					vTaskMissedYield();
 8011cae:	f000 ffdb 	bl	8012c68 <vTaskMissedYield>
 8011cb2:	e7f0      	b.n	8011c96 <xQueueSemaphoreTake+0x196>
		pxQueue->cRxLock = queueUNLOCKED;
 8011cb4:	23ff      	movs	r3, #255	; 0xff
 8011cb6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8011cba:	f001 fc45 	bl	8013548 <vPortExitCritical>
				( void ) xTaskResumeAll();
 8011cbe:	f000 fdb1 	bl	8012824 <xTaskResumeAll>
 8011cc2:	e7d7      	b.n	8011c74 <xQueueSemaphoreTake+0x174>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8011cc4:	ae02      	add	r6, sp, #8
 8011cc6:	4630      	mov	r0, r6
 8011cc8:	f000 ff7e 	bl	8012bc8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8011ccc:	e74b      	b.n	8011b66 <xQueueSemaphoreTake+0x66>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8011cce:	9b01      	ldr	r3, [sp, #4]
 8011cd0:	b143      	cbz	r3, 8011ce4 <xQueueSemaphoreTake+0x1e4>
 8011cd2:	f04f 0320 	mov.w	r3, #32
 8011cd6:	f383 8811 	msr	BASEPRI, r3
 8011cda:	f3bf 8f6f 	isb	sy
 8011cde:	f3bf 8f4f 	dsb	sy
 8011ce2:	e7fe      	b.n	8011ce2 <xQueueSemaphoreTake+0x1e2>
 8011ce4:	4605      	mov	r5, r0
 8011ce6:	e72c      	b.n	8011b42 <xQueueSemaphoreTake+0x42>
	taskEXIT_CRITICAL();
 8011ce8:	f001 fc2e 	bl	8013548 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8011cec:	6823      	ldr	r3, [r4, #0]
 8011cee:	2b00      	cmp	r3, #0
 8011cf0:	d07e      	beq.n	8011df0 <xQueueSemaphoreTake+0x2f0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8011cf2:	9901      	ldr	r1, [sp, #4]
 8011cf4:	4638      	mov	r0, r7
 8011cf6:	f000 fe75 	bl	80129e4 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 8011cfa:	f001 fc03 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011cfe:	f894 6045 	ldrb.w	r6, [r4, #69]	; 0x45
 8011d02:	b276      	sxtb	r6, r6
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011d04:	2e00      	cmp	r6, #0
 8011d06:	dc05      	bgt.n	8011d14 <xQueueSemaphoreTake+0x214>
 8011d08:	e00e      	b.n	8011d28 <xQueueSemaphoreTake+0x228>
			--cTxLock;
 8011d0a:	1e73      	subs	r3, r6, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011d0c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011d10:	b25e      	sxtb	r6, r3
 8011d12:	d009      	beq.n	8011d28 <xQueueSemaphoreTake+0x228>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011d14:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011d16:	4638      	mov	r0, r7
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011d18:	b133      	cbz	r3, 8011d28 <xQueueSemaphoreTake+0x228>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011d1a:	f000 ff13 	bl	8012b44 <xTaskRemoveFromEventList>
 8011d1e:	2800      	cmp	r0, #0
 8011d20:	d0f3      	beq.n	8011d0a <xQueueSemaphoreTake+0x20a>
						vTaskMissedYield();
 8011d22:	f000 ffa1 	bl	8012c68 <vTaskMissedYield>
 8011d26:	e7f0      	b.n	8011d0a <xQueueSemaphoreTake+0x20a>
		pxQueue->cTxLock = queueUNLOCKED;
 8011d28:	23ff      	movs	r3, #255	; 0xff
 8011d2a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8011d2e:	f001 fc0b 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011d32:	f001 fbe7 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011d36:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
 8011d3a:	b276      	sxtb	r6, r6
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011d3c:	2e00      	cmp	r6, #0
 8011d3e:	dd11      	ble.n	8011d64 <xQueueSemaphoreTake+0x264>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011d40:	f104 0910 	add.w	r9, r4, #16
 8011d44:	e004      	b.n	8011d50 <xQueueSemaphoreTake+0x250>
				--cRxLock;
 8011d46:	1e73      	subs	r3, r6, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011d48:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011d4c:	b25e      	sxtb	r6, r3
 8011d4e:	d009      	beq.n	8011d64 <xQueueSemaphoreTake+0x264>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011d50:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011d52:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011d54:	b133      	cbz	r3, 8011d64 <xQueueSemaphoreTake+0x264>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011d56:	f000 fef5 	bl	8012b44 <xTaskRemoveFromEventList>
 8011d5a:	2800      	cmp	r0, #0
 8011d5c:	d0f3      	beq.n	8011d46 <xQueueSemaphoreTake+0x246>
					vTaskMissedYield();
 8011d5e:	f000 ff83 	bl	8012c68 <vTaskMissedYield>
 8011d62:	e7f0      	b.n	8011d46 <xQueueSemaphoreTake+0x246>
		pxQueue->cRxLock = queueUNLOCKED;
 8011d64:	23ff      	movs	r3, #255	; 0xff
 8011d66:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8011d6a:	f001 fbed 	bl	8013548 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 8011d6e:	f000 fd59 	bl	8012824 <xTaskResumeAll>
 8011d72:	2800      	cmp	r0, #0
 8011d74:	f47f af7e 	bne.w	8011c74 <xQueueSemaphoreTake+0x174>
					portYIELD_WITHIN_API();
 8011d78:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8011d7c:	f8c8 3000 	str.w	r3, [r8]
 8011d80:	f3bf 8f4f 	dsb	sy
 8011d84:	f3bf 8f6f 	isb	sy
 8011d88:	e774      	b.n	8011c74 <xQueueSemaphoreTake+0x174>
	taskEXIT_CRITICAL();
 8011d8a:	f001 fbdd 	bl	8013548 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
 8011d8e:	b96d      	cbnz	r5, 8011dac <xQueueSemaphoreTake+0x2ac>
}
 8011d90:	4628      	mov	r0, r5
 8011d92:	b005      	add	sp, #20
 8011d94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8011d98:	6822      	ldr	r2, [r4, #0]
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8011d9a:	3b01      	subs	r3, #1
 8011d9c:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8011d9e:	b31a      	cbz	r2, 8011de8 <xQueueSemaphoreTake+0x2e8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011da0:	6923      	ldr	r3, [r4, #16]
 8011da2:	b993      	cbnz	r3, 8011dca <xQueueSemaphoreTake+0x2ca>
				taskEXIT_CRITICAL();
 8011da4:	f001 fbd0 	bl	8013548 <vPortExitCritical>
				return pdPASS;
 8011da8:	2501      	movs	r5, #1
 8011daa:	e7f1      	b.n	8011d90 <xQueueSemaphoreTake+0x290>
						taskENTER_CRITICAL();
 8011dac:	f001 fbaa 	bl	8013504 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8011db0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8011db2:	b119      	cbz	r1, 8011dbc <xQueueSemaphoreTake+0x2bc>
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8011db4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8011db6:	6819      	ldr	r1, [r3, #0]
 8011db8:	f1c1 0107 	rsb	r1, r1, #7
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8011dbc:	68a0      	ldr	r0, [r4, #8]
 8011dbe:	f001 f821 	bl	8012e04 <vTaskPriorityDisinheritAfterTimeout>
				return errQUEUE_EMPTY;
 8011dc2:	2500      	movs	r5, #0
						taskEXIT_CRITICAL();
 8011dc4:	f001 fbc0 	bl	8013548 <vPortExitCritical>
 8011dc8:	e7e2      	b.n	8011d90 <xQueueSemaphoreTake+0x290>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011dca:	f104 0010 	add.w	r0, r4, #16
 8011dce:	f000 feb9 	bl	8012b44 <xTaskRemoveFromEventList>
 8011dd2:	2800      	cmp	r0, #0
 8011dd4:	d0e6      	beq.n	8011da4 <xQueueSemaphoreTake+0x2a4>
						queueYIELD_IF_USING_PREEMPTION();
 8011dd6:	4b11      	ldr	r3, [pc, #68]	; (8011e1c <xQueueSemaphoreTake+0x31c>)
 8011dd8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8011ddc:	601a      	str	r2, [r3, #0]
 8011dde:	f3bf 8f4f 	dsb	sy
 8011de2:	f3bf 8f6f 	isb	sy
 8011de6:	e7dd      	b.n	8011da4 <xQueueSemaphoreTake+0x2a4>
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8011de8:	f001 f874 	bl	8012ed4 <pvTaskIncrementMutexHeldCount>
 8011dec:	60a0      	str	r0, [r4, #8]
 8011dee:	e7d7      	b.n	8011da0 <xQueueSemaphoreTake+0x2a0>
						taskENTER_CRITICAL();
 8011df0:	f001 fb88 	bl	8013504 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 8011df4:	68a0      	ldr	r0, [r4, #8]
 8011df6:	f000 ff4f 	bl	8012c98 <xTaskPriorityInherit>
 8011dfa:	4605      	mov	r5, r0
						taskEXIT_CRITICAL();
 8011dfc:	f001 fba4 	bl	8013548 <vPortExitCritical>
 8011e00:	e777      	b.n	8011cf2 <xQueueSemaphoreTake+0x1f2>
						configASSERT( xInheritanceOccurred == pdFALSE );
 8011e02:	b145      	cbz	r5, 8011e16 <xQueueSemaphoreTake+0x316>
 8011e04:	f04f 0320 	mov.w	r3, #32
 8011e08:	f383 8811 	msr	BASEPRI, r3
 8011e0c:	f3bf 8f6f 	isb	sy
 8011e10:	f3bf 8f4f 	dsb	sy
 8011e14:	e7fe      	b.n	8011e14 <xQueueSemaphoreTake+0x314>
					taskEXIT_CRITICAL();
 8011e16:	f001 fb97 	bl	8013548 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8011e1a:	e7b9      	b.n	8011d90 <xQueueSemaphoreTake+0x290>
 8011e1c:	e000ed04 	.word	0xe000ed04

08011e20 <xQueueReceiveFromISR>:
{
 8011e20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8011e24:	b310      	cbz	r0, 8011e6c <xQueueReceiveFromISR+0x4c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8011e26:	4689      	mov	r9, r1
 8011e28:	4690      	mov	r8, r2
 8011e2a:	4604      	mov	r4, r0
 8011e2c:	b191      	cbz	r1, 8011e54 <xQueueReceiveFromISR+0x34>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8011e2e:	f001 fc9f 	bl	8013770 <vPortValidateInterruptPriority>
	__asm volatile
 8011e32:	f3ef 8711 	mrs	r7, BASEPRI
 8011e36:	f04f 0320 	mov.w	r3, #32
 8011e3a:	f383 8811 	msr	BASEPRI, r3
 8011e3e:	f3bf 8f6f 	isb	sy
 8011e42:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8011e46:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8011e48:	b9cd      	cbnz	r5, 8011e7e <xQueueReceiveFromISR+0x5e>
			xReturn = pdFAIL;
 8011e4a:	4628      	mov	r0, r5
	__asm volatile
 8011e4c:	f387 8811 	msr	BASEPRI, r7
}
 8011e50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8011e54:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8011e56:	2b00      	cmp	r3, #0
 8011e58:	d0e9      	beq.n	8011e2e <xQueueReceiveFromISR+0xe>
	__asm volatile
 8011e5a:	f04f 0320 	mov.w	r3, #32
 8011e5e:	f383 8811 	msr	BASEPRI, r3
 8011e62:	f3bf 8f6f 	isb	sy
 8011e66:	f3bf 8f4f 	dsb	sy
 8011e6a:	e7fe      	b.n	8011e6a <xQueueReceiveFromISR+0x4a>
 8011e6c:	f04f 0320 	mov.w	r3, #32
 8011e70:	f383 8811 	msr	BASEPRI, r3
 8011e74:	f3bf 8f6f 	isb	sy
 8011e78:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8011e7c:	e7fe      	b.n	8011e7c <xQueueReceiveFromISR+0x5c>
			const int8_t cRxLock = pxQueue->cRxLock;
 8011e7e:	f894 6044 	ldrb.w	r6, [r4, #68]	; 0x44
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8011e82:	6c22      	ldr	r2, [r4, #64]	; 0x40
			const int8_t cRxLock = pxQueue->cRxLock;
 8011e84:	b276      	sxtb	r6, r6
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8011e86:	b152      	cbz	r2, 8011e9e <xQueueReceiveFromISR+0x7e>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8011e88:	68e3      	ldr	r3, [r4, #12]
 8011e8a:	1899      	adds	r1, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8011e8c:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8011e8e:	60e1      	str	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8011e90:	4299      	cmp	r1, r3
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8011e92:	bf24      	itt	cs
 8011e94:	6821      	ldrcs	r1, [r4, #0]
 8011e96:	60e1      	strcs	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8011e98:	4648      	mov	r0, r9
 8011e9a:	f004 f851 	bl	8015f40 <memcpy>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8011e9e:	3d01      	subs	r5, #1
			if( cRxLock == queueUNLOCKED )
 8011ea0:	1c73      	adds	r3, r6, #1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8011ea2:	63a5      	str	r5, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 8011ea4:	d008      	beq.n	8011eb8 <xQueueReceiveFromISR+0x98>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8011ea6:	1c73      	adds	r3, r6, #1
 8011ea8:	b25b      	sxtb	r3, r3
 8011eaa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
			xReturn = pdPASS;
 8011eae:	2001      	movs	r0, #1
	__asm volatile
 8011eb0:	f387 8811 	msr	BASEPRI, r7
}
 8011eb4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011eb8:	6923      	ldr	r3, [r4, #16]
 8011eba:	2b00      	cmp	r3, #0
 8011ebc:	d0f7      	beq.n	8011eae <xQueueReceiveFromISR+0x8e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011ebe:	f104 0010 	add.w	r0, r4, #16
 8011ec2:	f000 fe3f 	bl	8012b44 <xTaskRemoveFromEventList>
 8011ec6:	2800      	cmp	r0, #0
 8011ec8:	d0f1      	beq.n	8011eae <xQueueReceiveFromISR+0x8e>
						if( pxHigherPriorityTaskWoken != NULL )
 8011eca:	f1b8 0f00 	cmp.w	r8, #0
 8011ece:	d0ee      	beq.n	8011eae <xQueueReceiveFromISR+0x8e>
							*pxHigherPriorityTaskWoken = pdTRUE;
 8011ed0:	2001      	movs	r0, #1
 8011ed2:	f8c8 0000 	str.w	r0, [r8]
 8011ed6:	e7b9      	b.n	8011e4c <xQueueReceiveFromISR+0x2c>

08011ed8 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8011ed8:	b430      	push	{r4, r5}
 8011eda:	4a08      	ldr	r2, [pc, #32]	; (8011efc <vQueueAddToRegistry+0x24>)
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8011edc:	2300      	movs	r3, #0
 8011ede:	e002      	b.n	8011ee6 <vQueueAddToRegistry+0xe>
 8011ee0:	3301      	adds	r3, #1
 8011ee2:	2b64      	cmp	r3, #100	; 0x64
 8011ee4:	d008      	beq.n	8011ef8 <vQueueAddToRegistry+0x20>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8011ee6:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
 8011eea:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 8011eee:	2c00      	cmp	r4, #0
 8011ef0:	d1f6      	bne.n	8011ee0 <vQueueAddToRegistry+0x8>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8011ef2:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8011ef6:	6068      	str	r0, [r5, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8011ef8:	bc30      	pop	{r4, r5}
 8011efa:	4770      	bx	lr
 8011efc:	20019e4c 	.word	0x20019e4c

08011f00 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8011f00:	b570      	push	{r4, r5, r6, lr}
 8011f02:	4604      	mov	r4, r0
 8011f04:	460e      	mov	r6, r1
 8011f06:	4615      	mov	r5, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8011f08:	f001 fafc 	bl	8013504 <vPortEnterCritical>
 8011f0c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8011f10:	2bff      	cmp	r3, #255	; 0xff
 8011f12:	bf04      	itt	eq
 8011f14:	2300      	moveq	r3, #0
 8011f16:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8011f1a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8011f1e:	2bff      	cmp	r3, #255	; 0xff
 8011f20:	bf04      	itt	eq
 8011f22:	2300      	moveq	r3, #0
 8011f24:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8011f28:	f001 fb0e 	bl	8013548 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8011f2c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8011f2e:	2b00      	cmp	r3, #0
 8011f30:	d045      	beq.n	8011fbe <vQueueWaitForMessageRestricted+0xbe>
	taskENTER_CRITICAL();
 8011f32:	f001 fae7 	bl	8013504 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8011f36:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 8011f3a:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011f3c:	2d00      	cmp	r5, #0
 8011f3e:	dd15      	ble.n	8011f6c <vQueueWaitForMessageRestricted+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011f40:	f104 0624 	add.w	r6, r4, #36	; 0x24
 8011f44:	e004      	b.n	8011f50 <vQueueWaitForMessageRestricted+0x50>
			--cTxLock;
 8011f46:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011f48:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011f4c:	b25d      	sxtb	r5, r3
 8011f4e:	d00d      	beq.n	8011f6c <vQueueWaitForMessageRestricted+0x6c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011f50:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011f52:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8011f54:	b153      	cbz	r3, 8011f6c <vQueueWaitForMessageRestricted+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8011f56:	f000 fdf5 	bl	8012b44 <xTaskRemoveFromEventList>
 8011f5a:	2800      	cmp	r0, #0
 8011f5c:	d0f3      	beq.n	8011f46 <vQueueWaitForMessageRestricted+0x46>
						vTaskMissedYield();
 8011f5e:	f000 fe83 	bl	8012c68 <vTaskMissedYield>
			--cTxLock;
 8011f62:	1e6b      	subs	r3, r5, #1
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8011f64:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011f68:	b25d      	sxtb	r5, r3
 8011f6a:	d1f1      	bne.n	8011f50 <vQueueWaitForMessageRestricted+0x50>
		pxQueue->cTxLock = queueUNLOCKED;
 8011f6c:	23ff      	movs	r3, #255	; 0xff
 8011f6e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8011f72:	f001 fae9 	bl	8013548 <vPortExitCritical>
	taskENTER_CRITICAL();
 8011f76:	f001 fac5 	bl	8013504 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8011f7a:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
 8011f7e:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011f80:	2d00      	cmp	r5, #0
 8011f82:	dd15      	ble.n	8011fb0 <vQueueWaitForMessageRestricted+0xb0>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011f84:	f104 0610 	add.w	r6, r4, #16
 8011f88:	e004      	b.n	8011f94 <vQueueWaitForMessageRestricted+0x94>
				--cRxLock;
 8011f8a:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011f8c:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011f90:	b25d      	sxtb	r5, r3
 8011f92:	d00d      	beq.n	8011fb0 <vQueueWaitForMessageRestricted+0xb0>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011f94:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011f96:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8011f98:	b153      	cbz	r3, 8011fb0 <vQueueWaitForMessageRestricted+0xb0>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8011f9a:	f000 fdd3 	bl	8012b44 <xTaskRemoveFromEventList>
 8011f9e:	2800      	cmp	r0, #0
 8011fa0:	d0f3      	beq.n	8011f8a <vQueueWaitForMessageRestricted+0x8a>
					vTaskMissedYield();
 8011fa2:	f000 fe61 	bl	8012c68 <vTaskMissedYield>
				--cRxLock;
 8011fa6:	1e6b      	subs	r3, r5, #1
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8011fa8:	f013 0fff 	tst.w	r3, #255	; 0xff
 8011fac:	b25d      	sxtb	r5, r3
 8011fae:	d1f1      	bne.n	8011f94 <vQueueWaitForMessageRestricted+0x94>
		pxQueue->cRxLock = queueUNLOCKED;
 8011fb0:	23ff      	movs	r3, #255	; 0xff
 8011fb2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
 8011fb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8011fba:	f001 bac5 	b.w	8013548 <vPortExitCritical>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8011fbe:	462a      	mov	r2, r5
 8011fc0:	4631      	mov	r1, r6
 8011fc2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8011fc6:	f000 fd5d 	bl	8012a84 <vTaskPlaceOnEventListRestricted>
 8011fca:	e7b2      	b.n	8011f32 <vQueueWaitForMessageRestricted+0x32>

08011fcc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8011fcc:	b580      	push	{r7, lr}
 8011fce:	4c14      	ldr	r4, [pc, #80]	; (8012020 <prvIdleTask+0x54>)
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
			{
				taskYIELD();
 8011fd0:	4f14      	ldr	r7, [pc, #80]	; (8012024 <prvIdleTask+0x58>)
 8011fd2:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 8011fd6:	e014      	b.n	8012002 <prvIdleTask+0x36>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
 8011fd8:	f001 fa94 	bl	8013504 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8011fdc:	6923      	ldr	r3, [r4, #16]
 8011fde:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8011fe0:	1d28      	adds	r0, r5, #4
 8011fe2:	f7ff f8e7 	bl	80111b4 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8011fe6:	69a3      	ldr	r3, [r4, #24]
 8011fe8:	3b01      	subs	r3, #1
 8011fea:	61a3      	str	r3, [r4, #24]
				--uxDeletedTasksWaitingCleanUp;
 8011fec:	6823      	ldr	r3, [r4, #0]
 8011fee:	3b01      	subs	r3, #1
 8011ff0:	6023      	str	r3, [r4, #0]
			}
			taskEXIT_CRITICAL();
 8011ff2:	f001 faa9 	bl	8013548 <vPortExitCritical>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 8011ff6:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8011ff8:	f001 f9cc 	bl	8013394 <vPortFree>
			vPortFree( pxTCB );
 8011ffc:	4628      	mov	r0, r5
 8011ffe:	f001 f9c9 	bl	8013394 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8012002:	6823      	ldr	r3, [r4, #0]
 8012004:	2b00      	cmp	r3, #0
 8012006:	d1e7      	bne.n	8011fd8 <prvIdleTask+0xc>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8012008:	69e3      	ldr	r3, [r4, #28]
 801200a:	2b01      	cmp	r3, #1
 801200c:	d904      	bls.n	8012018 <prvIdleTask+0x4c>
				taskYIELD();
 801200e:	603e      	str	r6, [r7, #0]
 8012010:	f3bf 8f4f 	dsb	sy
 8012014:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 8012018:	f7f0 fb9e 	bl	8002758 <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
 801201c:	e7f1      	b.n	8012002 <prvIdleTask+0x36>
 801201e:	bf00      	nop
 8012020:	20001c1c 	.word	0x20001c1c
 8012024:	e000ed04 	.word	0xe000ed04

08012028 <xTaskCreate>:
	{
 8012028:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 801202c:	0096      	lsls	r6, r2, #2
	{
 801202e:	4680      	mov	r8, r0
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8012030:	4630      	mov	r0, r6
	{
 8012032:	460d      	mov	r5, r1
 8012034:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8012036:	f001 f90b 	bl	8013250 <pvPortMalloc>
			if( pxStack != NULL )
 801203a:	2800      	cmp	r0, #0
 801203c:	f000 80cd 	beq.w	80121da <xTaskCreate+0x1b2>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8012040:	4607      	mov	r7, r0
 8012042:	2060      	movs	r0, #96	; 0x60
 8012044:	f001 f904 	bl	8013250 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8012048:	4604      	mov	r4, r0
 801204a:	2800      	cmp	r0, #0
 801204c:	f000 80d4 	beq.w	80121f8 <xTaskCreate+0x1d0>
					pxNewTCB->pxStack = pxStack;
 8012050:	6307      	str	r7, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8012052:	4632      	mov	r2, r6
 8012054:	4638      	mov	r0, r7
 8012056:	21a5      	movs	r1, #165	; 0xa5
 8012058:	f003 ff9a 	bl	8015f90 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801205c:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
	if( pcName != NULL )
 8012060:	2d00      	cmp	r5, #0
 8012062:	f000 810f 	beq.w	8012284 <xTaskCreate+0x25c>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8012066:	782b      	ldrb	r3, [r5, #0]
 8012068:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 801206c:	782b      	ldrb	r3, [r5, #0]
 801206e:	2b00      	cmp	r3, #0
 8012070:	d04d      	beq.n	801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8012072:	786b      	ldrb	r3, [r5, #1]
 8012074:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 8012078:	786b      	ldrb	r3, [r5, #1]
 801207a:	2b00      	cmp	r3, #0
 801207c:	d047      	beq.n	801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801207e:	78ab      	ldrb	r3, [r5, #2]
 8012080:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 8012084:	78ab      	ldrb	r3, [r5, #2]
 8012086:	2b00      	cmp	r3, #0
 8012088:	d041      	beq.n	801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 801208a:	78eb      	ldrb	r3, [r5, #3]
 801208c:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 8012090:	78eb      	ldrb	r3, [r5, #3]
 8012092:	2b00      	cmp	r3, #0
 8012094:	d03b      	beq.n	801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8012096:	792b      	ldrb	r3, [r5, #4]
 8012098:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 801209c:	792b      	ldrb	r3, [r5, #4]
 801209e:	2b00      	cmp	r3, #0
 80120a0:	d035      	beq.n	801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120a2:	796b      	ldrb	r3, [r5, #5]
 80120a4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 80120a8:	796b      	ldrb	r3, [r5, #5]
 80120aa:	2b00      	cmp	r3, #0
 80120ac:	d02f      	beq.n	801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120ae:	79ab      	ldrb	r3, [r5, #6]
 80120b0:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 80120b4:	79ab      	ldrb	r3, [r5, #6]
 80120b6:	b353      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120b8:	79eb      	ldrb	r3, [r5, #7]
 80120ba:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 80120be:	79eb      	ldrb	r3, [r5, #7]
 80120c0:	b32b      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120c2:	7a2b      	ldrb	r3, [r5, #8]
 80120c4:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 80120c8:	7a2b      	ldrb	r3, [r5, #8]
 80120ca:	b303      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120cc:	7a6b      	ldrb	r3, [r5, #9]
 80120ce:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 80120d2:	7a6b      	ldrb	r3, [r5, #9]
 80120d4:	b1db      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120d6:	7aab      	ldrb	r3, [r5, #10]
 80120d8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 80120dc:	7aab      	ldrb	r3, [r5, #10]
 80120de:	b1b3      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120e0:	7aeb      	ldrb	r3, [r5, #11]
 80120e2:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 80120e6:	7aeb      	ldrb	r3, [r5, #11]
 80120e8:	b18b      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120ea:	7b2b      	ldrb	r3, [r5, #12]
 80120ec:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 80120f0:	7b2b      	ldrb	r3, [r5, #12]
 80120f2:	b163      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120f4:	7b6b      	ldrb	r3, [r5, #13]
 80120f6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 80120fa:	7b6b      	ldrb	r3, [r5, #13]
 80120fc:	b13b      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80120fe:	7bab      	ldrb	r3, [r5, #14]
 8012100:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			if( pcName[ x ] == ( char ) 0x00 )
 8012104:	7bab      	ldrb	r3, [r5, #14]
 8012106:	b113      	cbz	r3, 801210e <xTaskCreate+0xe6>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8012108:	7beb      	ldrb	r3, [r5, #15]
 801210a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 801210e:	2300      	movs	r3, #0
 8012110:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8012114:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8012116:	2d06      	cmp	r5, #6
 8012118:	bf28      	it	cs
 801211a:	2506      	movcs	r5, #6
		pxNewTCB->uxMutexesHeld = 0;
 801211c:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8012120:	1d27      	adds	r7, r4, #4
		pxNewTCB->uxMutexesHeld = 0;
 8012122:	e9c4 5a13 	strd	r5, sl, [r4, #76]	; 0x4c
	pxNewTCB->uxPriority = uxPriority;
 8012126:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8012128:	4638      	mov	r0, r7
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801212a:	3e04      	subs	r6, #4
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801212c:	f7ff f816 	bl	801115c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012130:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8012134:	f104 0018 	add.w	r0, r4, #24
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8012138:	445e      	add	r6, fp
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 801213a:	f7ff f80f 	bl	801115c <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 801213e:	f8c4 a058 	str.w	sl, [r4, #88]	; 0x58
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012142:	61a5      	str	r5, [r4, #24]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8012144:	f026 0007 	bic.w	r0, r6, #7
		pxNewTCB->pxTaskTag = NULL;
 8012148:	f8c4 a054 	str.w	sl, [r4, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 801214c:	f884 a05c 	strb.w	sl, [r4, #92]	; 0x5c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8012150:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8012152:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8012154:	464a      	mov	r2, r9
 8012156:	4641      	mov	r1, r8
 8012158:	f001 f9aa 	bl	80134b0 <pxPortInitialiseStack>
	if( pxCreatedTask != NULL )
 801215c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801215e:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8012160:	b103      	cbz	r3, 8012164 <xTaskCreate+0x13c>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8012162:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
 8012164:	4e49      	ldr	r6, [pc, #292]	; (801228c <xTaskCreate+0x264>)
	taskENTER_CRITICAL();
 8012166:	f001 f9cd 	bl	8013504 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 801216a:	69b3      	ldr	r3, [r6, #24]
 801216c:	3301      	adds	r3, #1
 801216e:	61b3      	str	r3, [r6, #24]
		if( pxCurrentTCB == NULL )
 8012170:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8012174:	2b00      	cmp	r3, #0
 8012176:	d048      	beq.n	801220a <xTaskCreate+0x1e2>
			if( xSchedulerRunning == pdFALSE )
 8012178:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
 801217c:	b38b      	cbz	r3, 80121e2 <xTaskCreate+0x1ba>
 801217e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8012180:	f106 081c 	add.w	r8, r6, #28
		uxTaskNumber++;
 8012184:	f8d6 3114 	ldr.w	r3, [r6, #276]	; 0x114
		prvAddTaskToReadyList( pxNewTCB );
 8012188:	f8d6 c0b0 	ldr.w	ip, [r6, #176]	; 0xb0
 801218c:	2501      	movs	r5, #1
		uxTaskNumber++;
 801218e:	442b      	add	r3, r5
		prvAddTaskToReadyList( pxNewTCB );
 8012190:	fa05 f200 	lsl.w	r2, r5, r0
 8012194:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8012198:	ea42 020c 	orr.w	r2, r2, ip
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 801219c:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 801219e:	4639      	mov	r1, r7
 80121a0:	eb08 0080 	add.w	r0, r8, r0, lsl #2
		uxTaskNumber++;
 80121a4:	f8c6 3114 	str.w	r3, [r6, #276]	; 0x114
		prvAddTaskToReadyList( pxNewTCB );
 80121a8:	f8c6 20b0 	str.w	r2, [r6, #176]	; 0xb0
 80121ac:	f7fe ffda 	bl	8011164 <vListInsertEnd>
	taskEXIT_CRITICAL();
 80121b0:	f001 f9ca 	bl	8013548 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80121b4:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
 80121b8:	b323      	cbz	r3, 8012204 <xTaskCreate+0x1dc>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80121ba:	f8d6 20ac 	ldr.w	r2, [r6, #172]	; 0xac
 80121be:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80121c0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80121c2:	429a      	cmp	r2, r3
 80121c4:	d21e      	bcs.n	8012204 <xTaskCreate+0x1dc>
			taskYIELD_IF_USING_PREEMPTION();
 80121c6:	4b32      	ldr	r3, [pc, #200]	; (8012290 <xTaskCreate+0x268>)
 80121c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80121cc:	601a      	str	r2, [r3, #0]
 80121ce:	f3bf 8f4f 	dsb	sy
 80121d2:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 80121d6:	4628      	mov	r0, r5
 80121d8:	e001      	b.n	80121de <xTaskCreate+0x1b6>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80121da:	f04f 30ff 	mov.w	r0, #4294967295
	}
 80121de:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80121e2:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 80121e6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80121e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80121ea:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 80121ec:	bf98      	it	ls
 80121ee:	f8c6 40ac 	strls.w	r4, [r6, #172]	; 0xac
 80121f2:	f106 081c 	add.w	r8, r6, #28
 80121f6:	e7c5      	b.n	8012184 <xTaskCreate+0x15c>
					vPortFree( pxStack );
 80121f8:	4638      	mov	r0, r7
 80121fa:	f001 f8cb 	bl	8013394 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80121fe:	f04f 30ff 	mov.w	r0, #4294967295
 8012202:	e7ec      	b.n	80121de <xTaskCreate+0x1b6>
			xReturn = pdPASS;
 8012204:	4628      	mov	r0, r5
	}
 8012206:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			pxCurrentTCB = pxNewTCB;
 801220a:	f8c6 40ac 	str.w	r4, [r6, #172]	; 0xac
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 801220e:	69b3      	ldr	r3, [r6, #24]
 8012210:	2b01      	cmp	r3, #1
 8012212:	d1b4      	bne.n	801217e <xTaskCreate+0x156>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8012214:	f106 081c 	add.w	r8, r6, #28
 8012218:	4640      	mov	r0, r8
 801221a:	f7fe ff93 	bl	8011144 <vListInitialise>
 801221e:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8012222:	f7fe ff8f 	bl	8011144 <vListInitialise>
 8012226:	f106 0044 	add.w	r0, r6, #68	; 0x44
 801222a:	f7fe ff8b 	bl	8011144 <vListInitialise>
 801222e:	f106 0058 	add.w	r0, r6, #88	; 0x58
 8012232:	f7fe ff87 	bl	8011144 <vListInitialise>
 8012236:	f106 006c 	add.w	r0, r6, #108	; 0x6c
 801223a:	f7fe ff83 	bl	8011144 <vListInitialise>
 801223e:	f106 0080 	add.w	r0, r6, #128	; 0x80
 8012242:	f7fe ff7f 	bl	8011144 <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
 8012246:	f106 09d4 	add.w	r9, r6, #212	; 0xd4
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 801224a:	f106 0094 	add.w	r0, r6, #148	; 0x94
 801224e:	f7fe ff79 	bl	8011144 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8012252:	f106 05e8 	add.w	r5, r6, #232	; 0xe8
	vListInitialise( &xDelayedTaskList1 );
 8012256:	4648      	mov	r0, r9
 8012258:	f7fe ff74 	bl	8011144 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 801225c:	4628      	mov	r0, r5
 801225e:	f7fe ff71 	bl	8011144 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8012262:	f106 00fc 	add.w	r0, r6, #252	; 0xfc
 8012266:	f7fe ff6d 	bl	8011144 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 801226a:	1d30      	adds	r0, r6, #4
 801226c:	f7fe ff6a 	bl	8011144 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8012270:	f106 00b4 	add.w	r0, r6, #180	; 0xb4
 8012274:	f7fe ff66 	bl	8011144 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8012278:	f8c6 90cc 	str.w	r9, [r6, #204]	; 0xcc
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 801227c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 801227e:	f8c6 50c8 	str.w	r5, [r6, #200]	; 0xc8
}
 8012282:	e77f      	b.n	8012184 <xTaskCreate+0x15c>
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8012284:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
 8012288:	e744      	b.n	8012114 <xTaskCreate+0xec>
 801228a:	bf00      	nop
 801228c:	20001c1c 	.word	0x20001c1c
 8012290:	e000ed04 	.word	0xe000ed04

08012294 <vTaskResume>:
		configASSERT( xTaskToResume );
 8012294:	b1a8      	cbz	r0, 80122c2 <vTaskResume+0x2e>
	{
 8012296:	b570      	push	{r4, r5, r6, lr}
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 8012298:	4d24      	ldr	r5, [pc, #144]	; (801232c <vTaskResume+0x98>)
 801229a:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
 801229e:	4283      	cmp	r3, r0
	{
 80122a0:	b082      	sub	sp, #8
 80122a2:	4604      	mov	r4, r0
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 80122a4:	d00b      	beq.n	80122be <vTaskResume+0x2a>
			taskENTER_CRITICAL();
 80122a6:	f001 f92d 	bl	8013504 <vPortEnterCritical>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 80122aa:	6962      	ldr	r2, [r4, #20]
 80122ac:	f105 03b4 	add.w	r3, r5, #180	; 0xb4
 80122b0:	429a      	cmp	r2, r3
 80122b2:	d00f      	beq.n	80122d4 <vTaskResume+0x40>
	}
 80122b4:	b002      	add	sp, #8
 80122b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			taskEXIT_CRITICAL();
 80122ba:	f001 b945 	b.w	8013548 <vPortExitCritical>
	}
 80122be:	b002      	add	sp, #8
 80122c0:	bd70      	pop	{r4, r5, r6, pc}
	__asm volatile
 80122c2:	f04f 0320 	mov.w	r3, #32
 80122c6:	f383 8811 	msr	BASEPRI, r3
 80122ca:	f3bf 8f6f 	isb	sy
 80122ce:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToResume );
 80122d2:	e7fe      	b.n	80122d2 <vTaskResume+0x3e>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80122d4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80122d6:	f105 02fc 	add.w	r2, r5, #252	; 0xfc
 80122da:	4293      	cmp	r3, r2
 80122dc:	d0ea      	beq.n	80122b4 <vTaskResume+0x20>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 80122de:	2b00      	cmp	r3, #0
 80122e0:	d1e8      	bne.n	80122b4 <vTaskResume+0x20>
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 80122e2:	1d21      	adds	r1, r4, #4
 80122e4:	4608      	mov	r0, r1
 80122e6:	9101      	str	r1, [sp, #4]
 80122e8:	f7fe ff64 	bl	80111b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80122ec:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80122ee:	f8d5 60b0 	ldr.w	r6, [r5, #176]	; 0xb0
 80122f2:	9901      	ldr	r1, [sp, #4]
 80122f4:	2301      	movs	r3, #1
 80122f6:	f105 021c 	add.w	r2, r5, #28
 80122fa:	4083      	lsls	r3, r0
 80122fc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8012300:	4333      	orrs	r3, r6
 8012302:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8012306:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
 801230a:	f7fe ff2b 	bl	8011164 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801230e:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
 8012312:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8012314:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012316:	429a      	cmp	r2, r3
 8012318:	d3cc      	bcc.n	80122b4 <vTaskResume+0x20>
						taskYIELD_IF_USING_PREEMPTION();
 801231a:	4b05      	ldr	r3, [pc, #20]	; (8012330 <vTaskResume+0x9c>)
 801231c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8012320:	601a      	str	r2, [r3, #0]
 8012322:	f3bf 8f4f 	dsb	sy
 8012326:	f3bf 8f6f 	isb	sy
 801232a:	e7c3      	b.n	80122b4 <vTaskResume+0x20>
 801232c:	20001c1c 	.word	0x20001c1c
 8012330:	e000ed04 	.word	0xe000ed04

08012334 <xTaskResumeFromISR>:
		configASSERT( xTaskToResume );
 8012334:	b1d0      	cbz	r0, 801236c <xTaskResumeFromISR+0x38>
	{
 8012336:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012338:	b083      	sub	sp, #12
 801233a:	4605      	mov	r5, r0
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 801233c:	f001 fa18 	bl	8013770 <vPortValidateInterruptPriority>
	__asm volatile
 8012340:	f3ef 8611 	mrs	r6, BASEPRI
 8012344:	f04f 0320 	mov.w	r3, #32
 8012348:	f383 8811 	msr	BASEPRI, r3
 801234c:	f3bf 8f6f 	isb	sy
 8012350:	f3bf 8f4f 	dsb	sy
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8012354:	4f23      	ldr	r7, [pc, #140]	; (80123e4 <xTaskResumeFromISR+0xb0>)
 8012356:	696a      	ldr	r2, [r5, #20]
 8012358:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 801235c:	429a      	cmp	r2, r3
 801235e:	d00e      	beq.n	801237e <xTaskResumeFromISR+0x4a>
	BaseType_t xYieldRequired = pdFALSE;
 8012360:	2400      	movs	r4, #0
	__asm volatile
 8012362:	f386 8811 	msr	BASEPRI, r6
	}
 8012366:	4620      	mov	r0, r4
 8012368:	b003      	add	sp, #12
 801236a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	__asm volatile
 801236c:	f04f 0320 	mov.w	r3, #32
 8012370:	f383 8811 	msr	BASEPRI, r3
 8012374:	f3bf 8f6f 	isb	sy
 8012378:	f3bf 8f4f 	dsb	sy
		configASSERT( xTaskToResume );
 801237c:	e7fe      	b.n	801237c <xTaskResumeFromISR+0x48>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 801237e:	6aac      	ldr	r4, [r5, #40]	; 0x28
 8012380:	f107 00fc 	add.w	r0, r7, #252	; 0xfc
 8012384:	4284      	cmp	r4, r0
 8012386:	d0eb      	beq.n	8012360 <xTaskResumeFromISR+0x2c>
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 8012388:	2c00      	cmp	r4, #0
 801238a:	d1e9      	bne.n	8012360 <xTaskResumeFromISR+0x2c>
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801238c:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8012390:	bb13      	cbnz	r3, 80123d8 <xTaskResumeFromISR+0xa4>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8012392:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8012396:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 8012398:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801239a:	1d29      	adds	r1, r5, #4
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801239c:	429c      	cmp	r4, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801239e:	4608      	mov	r0, r1
 80123a0:	9101      	str	r1, [sp, #4]
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80123a2:	bf34      	ite	cc
 80123a4:	2400      	movcc	r4, #0
 80123a6:	2401      	movcs	r4, #1
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80123a8:	f7fe ff04 	bl	80111b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80123ac:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80123ae:	f8d7 50b0 	ldr.w	r5, [r7, #176]	; 0xb0
 80123b2:	9901      	ldr	r1, [sp, #4]
 80123b4:	2301      	movs	r3, #1
 80123b6:	f107 021c 	add.w	r2, r7, #28
 80123ba:	4083      	lsls	r3, r0
 80123bc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80123c0:	432b      	orrs	r3, r5
 80123c2:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 80123c6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80123ca:	f7fe fecb 	bl	8011164 <vListInsertEnd>
	__asm volatile
 80123ce:	f386 8811 	msr	BASEPRI, r6
	}
 80123d2:	4620      	mov	r0, r4
 80123d4:	b003      	add	sp, #12
 80123d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80123d8:	f105 0118 	add.w	r1, r5, #24
 80123dc:	f7fe fec2 	bl	8011164 <vListInsertEnd>
 80123e0:	e7bf      	b.n	8012362 <xTaskResumeFromISR+0x2e>
 80123e2:	bf00      	nop
 80123e4:	20001c1c 	.word	0x20001c1c

080123e8 <vTaskStartScheduler>:
{
 80123e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 80123ec:	f44f 7000 	mov.w	r0, #512	; 0x200
 80123f0:	f000 ff2e 	bl	8013250 <pvPortMalloc>
			if( pxStack != NULL )
 80123f4:	2800      	cmp	r0, #0
 80123f6:	d078      	beq.n	80124ea <vTaskStartScheduler+0x102>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 80123f8:	4604      	mov	r4, r0
 80123fa:	2060      	movs	r0, #96	; 0x60
 80123fc:	f000 ff28 	bl	8013250 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8012400:	4605      	mov	r5, r0
 8012402:	2800      	cmp	r0, #0
 8012404:	d06e      	beq.n	80124e4 <vTaskStartScheduler+0xfc>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8012406:	f44f 7200 	mov.w	r2, #512	; 0x200
 801240a:	21a5      	movs	r1, #165	; 0xa5
					pxNewTCB->pxStack = pxStack;
 801240c:	6304      	str	r4, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 801240e:	4620      	mov	r0, r4
 8012410:	f003 fdbe 	bl	8015f90 <memset>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8012414:	2600      	movs	r6, #0
 8012416:	4b6a      	ldr	r3, [pc, #424]	; (80125c0 <vTaskStartScheduler+0x1d8>)
 8012418:	636b      	str	r3, [r5, #52]	; 0x34
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 801241a:	1d2f      	adds	r7, r5, #4
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801241c:	f8d5 8030 	ldr.w	r8, [r5, #48]	; 0x30
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8012420:	f885 6038 	strb.w	r6, [r5, #56]	; 0x38
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8012424:	4638      	mov	r0, r7
		pxNewTCB->uxMutexesHeld = 0;
 8012426:	e9c5 6613 	strd	r6, r6, [r5, #76]	; 0x4c
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 801242a:	f885 6043 	strb.w	r6, [r5, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
 801242e:	62ee      	str	r6, [r5, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8012430:	f7fe fe94 	bl	801115c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8012434:	f105 0018 	add.w	r0, r5, #24
 8012438:	f7fe fe90 	bl	801115c <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801243c:	2307      	movs	r3, #7
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 801243e:	f508 70fe 	add.w	r0, r8, #508	; 0x1fc
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012442:	61ab      	str	r3, [r5, #24]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8012444:	495f      	ldr	r1, [pc, #380]	; (80125c4 <vTaskStartScheduler+0x1dc>)
		pxNewTCB->ulNotifiedValue = 0;
 8012446:	65ae      	str	r6, [r5, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8012448:	4632      	mov	r2, r6
 801244a:	f020 0007 	bic.w	r0, r0, #7
		pxNewTCB->pxTaskTag = NULL;
 801244e:	656e      	str	r6, [r5, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8012450:	f885 605c 	strb.w	r6, [r5, #92]	; 0x5c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8012454:	612d      	str	r5, [r5, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8012456:	626d      	str	r5, [r5, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8012458:	f001 f82a 	bl	80134b0 <pxPortInitialiseStack>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 801245c:	4c5a      	ldr	r4, [pc, #360]	; (80125c8 <vTaskStartScheduler+0x1e0>)
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 801245e:	6028      	str	r0, [r5, #0]
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8012460:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
	taskENTER_CRITICAL();
 8012464:	f001 f84e 	bl	8013504 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8012468:	69a3      	ldr	r3, [r4, #24]
 801246a:	3301      	adds	r3, #1
 801246c:	61a3      	str	r3, [r4, #24]
		if( pxCurrentTCB == NULL )
 801246e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012472:	2b00      	cmp	r3, #0
 8012474:	d067      	beq.n	8012546 <vTaskStartScheduler+0x15e>
			if( xSchedulerRunning == pdFALSE )
 8012476:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 801247a:	2b00      	cmp	r3, #0
 801247c:	d058      	beq.n	8012530 <vTaskStartScheduler+0x148>
 801247e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8012480:	f104 061c 	add.w	r6, r4, #28
		uxTaskNumber++;
 8012484:	f8d4 2114 	ldr.w	r2, [r4, #276]	; 0x114
		prvAddTaskToReadyList( pxNewTCB );
 8012488:	f8d4 c0b0 	ldr.w	ip, [r4, #176]	; 0xb0
 801248c:	2301      	movs	r3, #1
		uxTaskNumber++;
 801248e:	3201      	adds	r2, #1
		prvAddTaskToReadyList( pxNewTCB );
 8012490:	4083      	lsls	r3, r0
 8012492:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8012496:	ea43 030c 	orr.w	r3, r3, ip
 801249a:	4639      	mov	r1, r7
 801249c:	eb06 0080 	add.w	r0, r6, r0, lsl #2
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 80124a0:	646a      	str	r2, [r5, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 80124a2:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
		uxTaskNumber++;
 80124a6:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
		prvAddTaskToReadyList( pxNewTCB );
 80124aa:	f7fe fe5b 	bl	8011164 <vListInsertEnd>
	taskEXIT_CRITICAL();
 80124ae:	f001 f84b 	bl	8013548 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80124b2:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 80124b6:	b16b      	cbz	r3, 80124d4 <vTaskStartScheduler+0xec>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80124b8:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 80124bc:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80124be:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80124c0:	429a      	cmp	r2, r3
 80124c2:	d207      	bcs.n	80124d4 <vTaskStartScheduler+0xec>
			taskYIELD_IF_USING_PREEMPTION();
 80124c4:	4b41      	ldr	r3, [pc, #260]	; (80125cc <vTaskStartScheduler+0x1e4>)
 80124c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80124ca:	601a      	str	r2, [r3, #0]
 80124cc:	f3bf 8f4f 	dsb	sy
 80124d0:	f3bf 8f6f 	isb	sy
			xReturn = xTimerCreateTimerTask();
 80124d4:	f000 fe78 	bl	80131c8 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 80124d8:	2801      	cmp	r0, #1
 80124da:	d00f      	beq.n	80124fc <vTaskStartScheduler+0x114>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80124dc:	3001      	adds	r0, #1
 80124de:	d004      	beq.n	80124ea <vTaskStartScheduler+0x102>
}
 80124e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 80124e4:	4620      	mov	r0, r4
 80124e6:	f000 ff55 	bl	8013394 <vPortFree>
	__asm volatile
 80124ea:	f04f 0320 	mov.w	r3, #32
 80124ee:	f383 8811 	msr	BASEPRI, r3
 80124f2:	f3bf 8f6f 	isb	sy
 80124f6:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80124fa:	e7fe      	b.n	80124fa <vTaskStartScheduler+0x112>
 80124fc:	f04f 0320 	mov.w	r3, #32
 8012500:	f383 8811 	msr	BASEPRI, r3
 8012504:	f3bf 8f6f 	isb	sy
 8012508:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 801250c:	f04f 32ff 	mov.w	r2, #4294967295
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8012510:	2300      	movs	r3, #0
		xNextTaskUnblockTime = portMAX_DELAY;
 8012512:	f8c4 20d0 	str.w	r2, [r4, #208]	; 0xd0
		xSchedulerRunning = pdTRUE;
 8012516:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 801251a:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
		traceTASK_SWITCHED_IN();
 801251e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012522:	6d58      	ldr	r0, [r3, #84]	; 0x54
 8012524:	f7f2 f9fa 	bl	800491c <BSP_DEBUG_PIN_On>
}
 8012528:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		if( xPortStartScheduler() != pdFALSE )
 801252c:	f001 b886 	b.w	801363c <xPortStartScheduler>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8012530:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012534:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8012536:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012538:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 801253a:	bf98      	it	ls
 801253c:	f8c4 50ac 	strls.w	r5, [r4, #172]	; 0xac
 8012540:	f104 061c 	add.w	r6, r4, #28
 8012544:	e79e      	b.n	8012484 <vTaskStartScheduler+0x9c>
			pxCurrentTCB = pxNewTCB;
 8012546:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 801254a:	69a3      	ldr	r3, [r4, #24]
 801254c:	2b01      	cmp	r3, #1
 801254e:	d196      	bne.n	801247e <vTaskStartScheduler+0x96>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8012550:	f104 061c 	add.w	r6, r4, #28
 8012554:	4630      	mov	r0, r6
 8012556:	f7fe fdf5 	bl	8011144 <vListInitialise>
 801255a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 801255e:	f7fe fdf1 	bl	8011144 <vListInitialise>
 8012562:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8012566:	f7fe fded 	bl	8011144 <vListInitialise>
 801256a:	f104 0058 	add.w	r0, r4, #88	; 0x58
 801256e:	f7fe fde9 	bl	8011144 <vListInitialise>
 8012572:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8012576:	f7fe fde5 	bl	8011144 <vListInitialise>
 801257a:	f104 0080 	add.w	r0, r4, #128	; 0x80
 801257e:	f7fe fde1 	bl	8011144 <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
 8012582:	f104 09d4 	add.w	r9, r4, #212	; 0xd4
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8012586:	f104 0094 	add.w	r0, r4, #148	; 0x94
 801258a:	f7fe fddb 	bl	8011144 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 801258e:	f104 08e8 	add.w	r8, r4, #232	; 0xe8
	vListInitialise( &xDelayedTaskList1 );
 8012592:	4648      	mov	r0, r9
 8012594:	f7fe fdd6 	bl	8011144 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8012598:	4640      	mov	r0, r8
 801259a:	f7fe fdd3 	bl	8011144 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 801259e:	f104 00fc 	add.w	r0, r4, #252	; 0xfc
 80125a2:	f7fe fdcf 	bl	8011144 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 80125a6:	1d20      	adds	r0, r4, #4
 80125a8:	f7fe fdcc 	bl	8011144 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 80125ac:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
 80125b0:	f7fe fdc8 	bl	8011144 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 80125b4:	f8c4 90cc 	str.w	r9, [r4, #204]	; 0xcc
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80125b8:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80125ba:	f8c4 80c8 	str.w	r8, [r4, #200]	; 0xc8
}
 80125be:	e761      	b.n	8012484 <vTaskStartScheduler+0x9c>
 80125c0:	454c4449 	.word	0x454c4449
 80125c4:	08011fcd 	.word	0x08011fcd
 80125c8:	20001c1c 	.word	0x20001c1c
 80125cc:	e000ed04 	.word	0xe000ed04

080125d0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 80125d0:	4a03      	ldr	r2, [pc, #12]	; (80125e0 <vTaskSuspendAll+0x10>)
 80125d2:	f8d2 3118 	ldr.w	r3, [r2, #280]	; 0x118
 80125d6:	3301      	adds	r3, #1
 80125d8:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
}
 80125dc:	4770      	bx	lr
 80125de:	bf00      	nop
 80125e0:	20001c1c 	.word	0x20001c1c

080125e4 <xTaskGetTickCount>:
		xTicks = xTickCount;
 80125e4:	4b01      	ldr	r3, [pc, #4]	; (80125ec <xTaskGetTickCount+0x8>)
 80125e6:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
}
 80125ea:	4770      	bx	lr
 80125ec:	20001c1c 	.word	0x20001c1c

080125f0 <xTaskIncrementTick>:
{
 80125f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80125f4:	4c4a      	ldr	r4, [pc, #296]	; (8012720 <xTaskIncrementTick+0x130>)
 80125f6:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 80125fa:	2b00      	cmp	r3, #0
 80125fc:	d15e      	bne.n	80126bc <xTaskIncrementTick+0xcc>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80125fe:	f8d4 60a8 	ldr.w	r6, [r4, #168]	; 0xa8
 8012602:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
 8012604:	f8c4 60a8 	str.w	r6, [r4, #168]	; 0xa8
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8012608:	b9d6      	cbnz	r6, 8012640 <xTaskIncrementTick+0x50>
			taskSWITCH_DELAYED_LISTS();
 801260a:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 801260e:	681b      	ldr	r3, [r3, #0]
 8012610:	2b00      	cmp	r3, #0
 8012612:	d16e      	bne.n	80126f2 <xTaskIncrementTick+0x102>
 8012614:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8012618:	f8d4 20c8 	ldr.w	r2, [r4, #200]	; 0xc8
 801261c:	f8c4 20cc 	str.w	r2, [r4, #204]	; 0xcc
 8012620:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
 8012624:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
 8012628:	3301      	adds	r3, #1
 801262a:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801262e:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8012632:	681b      	ldr	r3, [r3, #0]
 8012634:	2b00      	cmp	r3, #0
 8012636:	d16a      	bne.n	801270e <xTaskIncrementTick+0x11e>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8012638:	f04f 33ff 	mov.w	r3, #4294967295
 801263c:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		if( xConstTickCount >= xNextTaskUnblockTime )
 8012640:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8012644:	42b3      	cmp	r3, r6
 8012646:	d847      	bhi.n	80126d8 <xTaskIncrementTick+0xe8>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8012648:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 801264c:	681d      	ldr	r5, [r3, #0]
 801264e:	2d00      	cmp	r5, #0
 8012650:	d058      	beq.n	8012704 <xTaskIncrementTick+0x114>
					prvAddTaskToReadyList( pxTCB );
 8012652:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8012724 <xTaskIncrementTick+0x134>
BaseType_t xSwitchRequired = pdFALSE;
 8012656:	2500      	movs	r5, #0
					prvAddTaskToReadyList( pxTCB );
 8012658:	f04f 0901 	mov.w	r9, #1
 801265c:	e021      	b.n	80126a2 <xTaskIncrementTick+0xb2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801265e:	f7fe fda9 	bl	80111b4 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8012662:	6abb      	ldr	r3, [r7, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8012664:	f107 0018 	add.w	r0, r7, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8012668:	b10b      	cbz	r3, 801266e <xTaskIncrementTick+0x7e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801266a:	f7fe fda3 	bl	80111b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801266e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8012670:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8012674:	fa09 f300 	lsl.w	r3, r9, r0
 8012678:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801267c:	4313      	orrs	r3, r2
 801267e:	4651      	mov	r1, sl
 8012680:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8012684:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
 8012688:	f7fe fd6c 	bl	8011164 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801268c:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8012690:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8012694:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8012696:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8012698:	681b      	ldr	r3, [r3, #0]
							xSwitchRequired = pdTRUE;
 801269a:	4291      	cmp	r1, r2
 801269c:	bf28      	it	cs
 801269e:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80126a0:	b383      	cbz	r3, 8012704 <xTaskIncrementTick+0x114>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80126a2:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 80126a6:	68db      	ldr	r3, [r3, #12]
 80126a8:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80126aa:	687b      	ldr	r3, [r7, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80126ac:	f107 0a04 	add.w	sl, r7, #4
					if( xConstTickCount < xItemValue )
 80126b0:	429e      	cmp	r6, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80126b2:	4650      	mov	r0, sl
					if( xConstTickCount < xItemValue )
 80126b4:	d2d3      	bcs.n	801265e <xTaskIncrementTick+0x6e>
						xNextTaskUnblockTime = xItemValue;
 80126b6:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 80126ba:	e00e      	b.n	80126da <xTaskIncrementTick+0xea>
		++uxPendedTicks;
 80126bc:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 80126c0:	3301      	adds	r3, #1
 80126c2:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
BaseType_t xSwitchRequired = pdFALSE;
 80126c6:	2500      	movs	r5, #0
		if( xYieldPending != pdFALSE )
 80126c8:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
			xSwitchRequired = pdTRUE;
 80126cc:	2b00      	cmp	r3, #0
}
 80126ce:	bf0c      	ite	eq
 80126d0:	4628      	moveq	r0, r5
 80126d2:	2001      	movne	r0, #1
 80126d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
BaseType_t xSwitchRequired = pdFALSE;
 80126d8:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80126da:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 80126de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80126e0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80126e4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80126e8:	69db      	ldr	r3, [r3, #28]
				xSwitchRequired = pdTRUE;
 80126ea:	2b02      	cmp	r3, #2
 80126ec:	bf28      	it	cs
 80126ee:	2501      	movcs	r5, #1
 80126f0:	e7ea      	b.n	80126c8 <xTaskIncrementTick+0xd8>
 80126f2:	f04f 0320 	mov.w	r3, #32
 80126f6:	f383 8811 	msr	BASEPRI, r3
 80126fa:	f3bf 8f6f 	isb	sy
 80126fe:	f3bf 8f4f 	dsb	sy
			taskSWITCH_DELAYED_LISTS();
 8012702:	e7fe      	b.n	8012702 <xTaskIncrementTick+0x112>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012704:	f04f 33ff 	mov.w	r3, #4294967295
 8012708:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
					break;
 801270c:	e7e5      	b.n	80126da <xTaskIncrementTick+0xea>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801270e:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8012712:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8012714:	68db      	ldr	r3, [r3, #12]
 8012716:	685b      	ldr	r3, [r3, #4]
 8012718:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	}
}
 801271c:	e790      	b.n	8012640 <xTaskIncrementTick+0x50>
 801271e:	bf00      	nop
 8012720:	20001c1c 	.word	0x20001c1c
 8012724:	20001c38 	.word	0x20001c38

08012728 <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 8012728:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		--uxSchedulerSuspended;
 801272c:	4c3b      	ldr	r4, [pc, #236]	; (801281c <xTaskResumeAll.part.0+0xf4>)
BaseType_t xTaskResumeAll( void )
 801272e:	b082      	sub	sp, #8
	taskENTER_CRITICAL();
 8012730:	f000 fee8 	bl	8013504 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8012734:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8012738:	3b01      	subs	r3, #1
 801273a:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801273e:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8012742:	2b00      	cmp	r3, #0
 8012744:	d147      	bne.n	80127d6 <xTaskResumeAll.part.0+0xae>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8012746:	69a3      	ldr	r3, [r4, #24]
 8012748:	2b00      	cmp	r3, #0
 801274a:	d044      	beq.n	80127d6 <xTaskResumeAll.part.0+0xae>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801274c:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 8012750:	b38b      	cbz	r3, 80127b6 <xTaskResumeAll.part.0+0x8e>
 8012752:	f104 071c 	add.w	r7, r4, #28
					prvAddTaskToReadyList( pxTCB );
 8012756:	2601      	movs	r6, #1
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8012758:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 801275c:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801275e:	f105 0804 	add.w	r8, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8012762:	f105 0018 	add.w	r0, r5, #24
 8012766:	f7fe fd25 	bl	80111b4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801276a:	4640      	mov	r0, r8
 801276c:	f7fe fd22 	bl	80111b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8012770:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8012772:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8012776:	fa06 f300 	lsl.w	r3, r6, r0
 801277a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801277e:	4313      	orrs	r3, r2
 8012780:	4641      	mov	r1, r8
 8012782:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8012786:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
 801278a:	f7fe fceb 	bl	8011164 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801278e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012792:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8012794:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012796:	429a      	cmp	r2, r3
 8012798:	d325      	bcc.n	80127e6 <xTaskResumeAll.part.0+0xbe>
						xYieldPending = pdTRUE;
 801279a:	f8c4 6128 	str.w	r6, [r4, #296]	; 0x128
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 801279e:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 80127a2:	2b00      	cmp	r3, #0
 80127a4:	d1d8      	bne.n	8012758 <xTaskResumeAll.part.0+0x30>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80127a6:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 80127aa:	681b      	ldr	r3, [r3, #0]
 80127ac:	bb73      	cbnz	r3, 801280c <xTaskResumeAll.part.0+0xe4>
		xNextTaskUnblockTime = portMAX_DELAY;
 80127ae:	f04f 33ff 	mov.w	r3, #4294967295
 80127b2:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80127b6:	f8d4 5124 	ldr.w	r5, [r4, #292]	; 0x124
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80127ba:	b14d      	cbz	r5, 80127d0 <xTaskResumeAll.part.0+0xa8>
								xYieldPending = pdTRUE;
 80127bc:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 80127be:	f7ff ff17 	bl	80125f0 <xTaskIncrementTick>
 80127c2:	b108      	cbz	r0, 80127c8 <xTaskResumeAll.part.0+0xa0>
								xYieldPending = pdTRUE;
 80127c4:	f8c4 6128 	str.w	r6, [r4, #296]	; 0x128
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80127c8:	3d01      	subs	r5, #1
 80127ca:	d1f8      	bne.n	80127be <xTaskResumeAll.part.0+0x96>
						uxPendedTicks = 0;
 80127cc:	f8c4 5124 	str.w	r5, [r4, #292]	; 0x124
				if( xYieldPending != pdFALSE )
 80127d0:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 80127d4:	b983      	cbnz	r3, 80127f8 <xTaskResumeAll.part.0+0xd0>
BaseType_t xAlreadyYielded = pdFALSE;
 80127d6:	2000      	movs	r0, #0
 80127d8:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
 80127da:	f000 feb5 	bl	8013548 <vPortExitCritical>
}
 80127de:	9801      	ldr	r0, [sp, #4]
 80127e0:	b002      	add	sp, #8
 80127e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80127e6:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 80127ea:	2b00      	cmp	r3, #0
 80127ec:	d1b4      	bne.n	8012758 <xTaskResumeAll.part.0+0x30>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80127ee:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 80127f2:	681b      	ldr	r3, [r3, #0]
 80127f4:	b953      	cbnz	r3, 801280c <xTaskResumeAll.part.0+0xe4>
 80127f6:	e7da      	b.n	80127ae <xTaskResumeAll.part.0+0x86>
					taskYIELD_IF_USING_PREEMPTION();
 80127f8:	4b09      	ldr	r3, [pc, #36]	; (8012820 <xTaskResumeAll.part.0+0xf8>)
 80127fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80127fe:	601a      	str	r2, [r3, #0]
 8012800:	f3bf 8f4f 	dsb	sy
 8012804:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8012808:	2001      	movs	r0, #1
 801280a:	e7e5      	b.n	80127d8 <xTaskResumeAll.part.0+0xb0>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 801280c:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8012810:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8012812:	68db      	ldr	r3, [r3, #12]
 8012814:	685b      	ldr	r3, [r3, #4]
 8012816:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
}
 801281a:	e7cc      	b.n	80127b6 <xTaskResumeAll.part.0+0x8e>
 801281c:	20001c1c 	.word	0x20001c1c
 8012820:	e000ed04 	.word	0xe000ed04

08012824 <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 8012824:	4b07      	ldr	r3, [pc, #28]	; (8012844 <xTaskResumeAll+0x20>)
 8012826:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 801282a:	b943      	cbnz	r3, 801283e <xTaskResumeAll+0x1a>
 801282c:	f04f 0320 	mov.w	r3, #32
 8012830:	f383 8811 	msr	BASEPRI, r3
 8012834:	f3bf 8f6f 	isb	sy
 8012838:	f3bf 8f4f 	dsb	sy
 801283c:	e7fe      	b.n	801283c <xTaskResumeAll+0x18>
 801283e:	f7ff bf73 	b.w	8012728 <xTaskResumeAll.part.0>
 8012842:	bf00      	nop
 8012844:	20001c1c 	.word	0x20001c1c

08012848 <vTaskSetApplicationTaskTag>:
	{
 8012848:	b538      	push	{r3, r4, r5, lr}
 801284a:	460d      	mov	r5, r1
		if( xTask == NULL )
 801284c:	b138      	cbz	r0, 801285e <vTaskSetApplicationTaskTag+0x16>
 801284e:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 8012850:	f000 fe58 	bl	8013504 <vPortEnterCritical>
			xTCB->pxTaskTag = pxHookFunction;
 8012854:	6565      	str	r5, [r4, #84]	; 0x54
	}
 8012856:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		taskEXIT_CRITICAL();
 801285a:	f000 be75 	b.w	8013548 <vPortExitCritical>
			xTCB = ( TCB_t * ) pxCurrentTCB;
 801285e:	4b05      	ldr	r3, [pc, #20]	; (8012874 <vTaskSetApplicationTaskTag+0x2c>)
 8012860:	f8d3 40ac 	ldr.w	r4, [r3, #172]	; 0xac
		taskENTER_CRITICAL();
 8012864:	f000 fe4e 	bl	8013504 <vPortEnterCritical>
			xTCB->pxTaskTag = pxHookFunction;
 8012868:	6565      	str	r5, [r4, #84]	; 0x54
	}
 801286a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		taskEXIT_CRITICAL();
 801286e:	f000 be6b 	b.w	8013548 <vPortExitCritical>
 8012872:	bf00      	nop
 8012874:	20001c1c 	.word	0x20001c1c

08012878 <vTaskSwitchContext>:
{
 8012878:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 801287a:	4c1c      	ldr	r4, [pc, #112]	; (80128ec <vTaskSwitchContext+0x74>)
 801287c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8012880:	b11b      	cbz	r3, 801288a <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 8012882:	2301      	movs	r3, #1
 8012884:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
}
 8012888:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 801288a:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
		traceTASK_SWITCHED_OUT();
 801288e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012892:	6d58      	ldr	r0, [r3, #84]	; 0x54
 8012894:	f7f2 f850 	bl	8004938 <BSP_DEBUG_PIN_Off>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8012898:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 801289c:	fab3 f383 	clz	r3, r3
 80128a0:	b2db      	uxtb	r3, r3
 80128a2:	f1c3 031f 	rsb	r3, r3, #31
 80128a6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80128aa:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 80128ae:	009b      	lsls	r3, r3, #2
 80128b0:	69ca      	ldr	r2, [r1, #28]
 80128b2:	b942      	cbnz	r2, 80128c6 <vTaskSwitchContext+0x4e>
	__asm volatile
 80128b4:	f04f 0320 	mov.w	r3, #32
 80128b8:	f383 8811 	msr	BASEPRI, r3
 80128bc:	f3bf 8f6f 	isb	sy
 80128c0:	f3bf 8f4f 	dsb	sy
 80128c4:	e7fe      	b.n	80128c4 <vTaskSwitchContext+0x4c>
 80128c6:	6a0a      	ldr	r2, [r1, #32]
 80128c8:	4423      	add	r3, r4
 80128ca:	6852      	ldr	r2, [r2, #4]
 80128cc:	620a      	str	r2, [r1, #32]
 80128ce:	3324      	adds	r3, #36	; 0x24
 80128d0:	429a      	cmp	r2, r3
 80128d2:	bf04      	itt	eq
 80128d4:	6852      	ldreq	r2, [r2, #4]
 80128d6:	620a      	streq	r2, [r1, #32]
 80128d8:	68d3      	ldr	r3, [r2, #12]
 80128da:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
		traceTASK_SWITCHED_IN();
 80128de:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
}
 80128e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		traceTASK_SWITCHED_IN();
 80128e6:	6d58      	ldr	r0, [r3, #84]	; 0x54
 80128e8:	f7f2 b818 	b.w	800491c <BSP_DEBUG_PIN_On>
 80128ec:	20001c1c 	.word	0x20001c1c

080128f0 <vTaskSuspend>:
	{
 80128f0:	b570      	push	{r4, r5, r6, lr}
 80128f2:	4605      	mov	r5, r0
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 80128f4:	4c38      	ldr	r4, [pc, #224]	; (80129d8 <vTaskSuspend+0xe8>)
		taskENTER_CRITICAL();
 80128f6:	f000 fe05 	bl	8013504 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 80128fa:	2d00      	cmp	r5, #0
 80128fc:	d04e      	beq.n	801299c <vTaskSuspend+0xac>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80128fe:	1d2e      	adds	r6, r5, #4
 8012900:	4630      	mov	r0, r6
 8012902:	f7fe fc57 	bl	80111b4 <uxListRemove>
 8012906:	b930      	cbnz	r0, 8012916 <vTaskSuspend+0x26>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8012908:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 801290a:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 801290e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8012912:	69db      	ldr	r3, [r3, #28]
 8012914:	b34b      	cbz	r3, 801296a <vTaskSuspend+0x7a>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8012916:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8012918:	b11b      	cbz	r3, 8012922 <vTaskSuspend+0x32>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 801291a:	f105 0018 	add.w	r0, r5, #24
 801291e:	f7fe fc49 	bl	80111b4 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 8012922:	482e      	ldr	r0, [pc, #184]	; (80129dc <vTaskSuspend+0xec>)
 8012924:	4631      	mov	r1, r6
 8012926:	f7fe fc1d 	bl	8011164 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 801292a:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
 801292e:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8012930:	bf04      	itt	eq
 8012932:	2300      	moveq	r3, #0
 8012934:	f885 305c 	strbeq.w	r3, [r5, #92]	; 0x5c
		taskEXIT_CRITICAL();
 8012938:	f000 fe06 	bl	8013548 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 801293c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8012940:	b9e3      	cbnz	r3, 801297c <vTaskSuspend+0x8c>
		if( pxTCB == pxCurrentTCB )
 8012942:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012946:	42ab      	cmp	r3, r5
 8012948:	d000      	beq.n	801294c <vTaskSuspend+0x5c>
	}
 801294a:	bd70      	pop	{r4, r5, r6, pc}
			if( xSchedulerRunning != pdFALSE )
 801294c:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 8012950:	b363      	cbz	r3, 80129ac <vTaskSuspend+0xbc>
				configASSERT( uxSchedulerSuspended == 0 );
 8012952:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8012956:	b38b      	cbz	r3, 80129bc <vTaskSuspend+0xcc>
 8012958:	f04f 0320 	mov.w	r3, #32
 801295c:	f383 8811 	msr	BASEPRI, r3
 8012960:	f3bf 8f6f 	isb	sy
 8012964:	f3bf 8f4f 	dsb	sy
 8012968:	e7fe      	b.n	8012968 <vTaskSuspend+0x78>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 801296a:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 801296e:	2201      	movs	r2, #1
 8012970:	4082      	lsls	r2, r0
 8012972:	ea23 0302 	bic.w	r3, r3, r2
 8012976:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
 801297a:	e7cc      	b.n	8012916 <vTaskSuspend+0x26>
			taskENTER_CRITICAL();
 801297c:	f000 fdc2 	bl	8013504 <vPortEnterCritical>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8012980:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8012984:	681b      	ldr	r3, [r3, #0]
 8012986:	b163      	cbz	r3, 80129a2 <vTaskSuspend+0xb2>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8012988:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 801298c:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801298e:	68db      	ldr	r3, [r3, #12]
 8012990:	685b      	ldr	r3, [r3, #4]
 8012992:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
			taskEXIT_CRITICAL();
 8012996:	f000 fdd7 	bl	8013548 <vPortExitCritical>
 801299a:	e7d2      	b.n	8012942 <vTaskSuspend+0x52>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 801299c:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
 80129a0:	e7ad      	b.n	80128fe <vTaskSuspend+0xe>
		xNextTaskUnblockTime = portMAX_DELAY;
 80129a2:	f04f 33ff 	mov.w	r3, #4294967295
 80129a6:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
 80129aa:	e7f4      	b.n	8012996 <vTaskSuspend+0xa6>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 80129ac:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
 80129b0:	69a2      	ldr	r2, [r4, #24]
 80129b2:	4291      	cmp	r1, r2
 80129b4:	d10b      	bne.n	80129ce <vTaskSuspend+0xde>
					pxCurrentTCB = NULL;
 80129b6:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
	}
 80129ba:	bd70      	pop	{r4, r5, r6, pc}
				portYIELD_WITHIN_API();
 80129bc:	4b08      	ldr	r3, [pc, #32]	; (80129e0 <vTaskSuspend+0xf0>)
 80129be:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80129c2:	601a      	str	r2, [r3, #0]
 80129c4:	f3bf 8f4f 	dsb	sy
 80129c8:	f3bf 8f6f 	isb	sy
	}
 80129cc:	bd70      	pop	{r4, r5, r6, pc}
 80129ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					vTaskSwitchContext();
 80129d2:	f7ff bf51 	b.w	8012878 <vTaskSwitchContext>
 80129d6:	bf00      	nop
 80129d8:	20001c1c 	.word	0x20001c1c
 80129dc:	20001cd0 	.word	0x20001cd0
 80129e0:	e000ed04 	.word	0xe000ed04

080129e4 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 80129e4:	b350      	cbz	r0, 8012a3c <vTaskPlaceOnEventList+0x58>
{
 80129e6:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80129e8:	4c24      	ldr	r4, [pc, #144]	; (8012a7c <vTaskPlaceOnEventList+0x98>)
 80129ea:	460d      	mov	r5, r1
 80129ec:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 80129f0:	3118      	adds	r1, #24
 80129f2:	f7fe fbc7 	bl	8011184 <vListInsert>
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80129f6:	f8d4 60a8 	ldr.w	r6, [r4, #168]	; 0xa8
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80129fa:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 80129fe:	3004      	adds	r0, #4
 8012a00:	f7fe fbd8 	bl	80111b4 <uxListRemove>
 8012a04:	b950      	cbnz	r0, 8012a1c <vTaskPlaceOnEventList+0x38>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8012a06:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8012a0a:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 8012a0e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8012a10:	2201      	movs	r2, #1
 8012a12:	408a      	lsls	r2, r1
 8012a14:	ea23 0302 	bic.w	r3, r3, r2
 8012a18:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8012a1c:	1c6b      	adds	r3, r5, #1
 8012a1e:	d016      	beq.n	8012a4e <vTaskPlaceOnEventList+0x6a>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8012a20:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012a24:	19ad      	adds	r5, r5, r6
 8012a26:	605d      	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8012a28:	d319      	bcc.n	8012a5e <vTaskPlaceOnEventList+0x7a>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012a2a:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 8012a2e:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
}
 8012a32:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012a36:	3104      	adds	r1, #4
 8012a38:	f7fe bba4 	b.w	8011184 <vListInsert>
 8012a3c:	f04f 0320 	mov.w	r3, #32
 8012a40:	f383 8811 	msr	BASEPRI, r3
 8012a44:	f3bf 8f6f 	isb	sy
 8012a48:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 8012a4c:	e7fe      	b.n	8012a4c <vTaskPlaceOnEventList+0x68>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012a4e:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 8012a52:	480b      	ldr	r0, [pc, #44]	; (8012a80 <vTaskPlaceOnEventList+0x9c>)
}
 8012a54:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012a58:	3104      	adds	r1, #4
 8012a5a:	f7fe bb83 	b.w	8011164 <vListInsertEnd>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012a5e:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 8012a62:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 8012a66:	3104      	adds	r1, #4
 8012a68:	f7fe fb8c 	bl	8011184 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 8012a6c:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8012a70:	429d      	cmp	r5, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
 8012a72:	bf38      	it	cc
 8012a74:	f8c4 50d0 	strcc.w	r5, [r4, #208]	; 0xd0
}
 8012a78:	bd70      	pop	{r4, r5, r6, pc}
 8012a7a:	bf00      	nop
 8012a7c:	20001c1c 	.word	0x20001c1c
 8012a80:	20001cd0 	.word	0x20001cd0

08012a84 <vTaskPlaceOnEventListRestricted>:
	{
 8012a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( pxEventList );
 8012a86:	2800      	cmp	r0, #0
 8012a88:	d045      	beq.n	8012b16 <vTaskPlaceOnEventListRestricted+0x92>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8012a8a:	4c2c      	ldr	r4, [pc, #176]	; (8012b3c <vTaskPlaceOnEventListRestricted+0xb8>)
 8012a8c:	460d      	mov	r5, r1
 8012a8e:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 8012a92:	3118      	adds	r1, #24
 8012a94:	4617      	mov	r7, r2
 8012a96:	f7fe fb65 	bl	8011164 <vListInsertEnd>
const TickType_t xConstTickCount = xTickCount;
 8012a9a:	f8d4 60a8 	ldr.w	r6, [r4, #168]	; 0xa8
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012a9e:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 8012aa2:	3004      	adds	r0, #4
		if( xWaitIndefinitely != pdFALSE )
 8012aa4:	b307      	cbz	r7, 8012ae8 <vTaskPlaceOnEventListRestricted+0x64>
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012aa6:	f7fe fb85 	bl	80111b4 <uxListRemove>
 8012aaa:	2800      	cmp	r0, #0
 8012aac:	d13e      	bne.n	8012b2c <vTaskPlaceOnEventListRestricted+0xa8>
			xTicksToWait = portMAX_DELAY;
 8012aae:	f04f 35ff 	mov.w	r5, #4294967295
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8012ab2:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8012ab6:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 8012aba:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8012abc:	2201      	movs	r2, #1
 8012abe:	408a      	lsls	r2, r1
 8012ac0:	ea23 0302 	bic.w	r3, r3, r2
 8012ac4:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8012ac8:	1c6b      	adds	r3, r5, #1
 8012aca:	d02d      	beq.n	8012b28 <vTaskPlaceOnEventListRestricted+0xa4>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8012acc:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012ad0:	1975      	adds	r5, r6, r5
 8012ad2:	605d      	str	r5, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8012ad4:	d311      	bcc.n	8012afa <vTaskPlaceOnEventListRestricted+0x76>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012ad6:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 8012ada:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
	}
 8012ade:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012ae2:	3104      	adds	r1, #4
 8012ae4:	f7fe bb4e 	b.w	8011184 <vListInsert>
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012ae8:	f7fe fb64 	bl	80111b4 <uxListRemove>
 8012aec:	2800      	cmp	r0, #0
 8012aee:	d0e0      	beq.n	8012ab2 <vTaskPlaceOnEventListRestricted+0x2e>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8012af0:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012af4:	1975      	adds	r5, r6, r5
 8012af6:	605d      	str	r5, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8012af8:	d2ed      	bcs.n	8012ad6 <vTaskPlaceOnEventListRestricted+0x52>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012afa:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 8012afe:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 8012b02:	3104      	adds	r1, #4
 8012b04:	f7fe fb3e 	bl	8011184 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8012b08:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8012b0c:	429d      	cmp	r5, r3
 8012b0e:	d201      	bcs.n	8012b14 <vTaskPlaceOnEventListRestricted+0x90>
					xNextTaskUnblockTime = xTimeToWake;
 8012b10:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
	}
 8012b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012b16:	f04f 0320 	mov.w	r3, #32
 8012b1a:	f383 8811 	msr	BASEPRI, r3
 8012b1e:	f3bf 8f6f 	isb	sy
 8012b22:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 8012b26:	e7fe      	b.n	8012b26 <vTaskPlaceOnEventListRestricted+0xa2>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8012b28:	2f00      	cmp	r7, #0
 8012b2a:	d0cf      	beq.n	8012acc <vTaskPlaceOnEventListRestricted+0x48>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012b2c:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 8012b30:	4803      	ldr	r0, [pc, #12]	; (8012b40 <vTaskPlaceOnEventListRestricted+0xbc>)
	}
 8012b32:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8012b36:	3104      	adds	r1, #4
 8012b38:	f7fe bb14 	b.w	8011164 <vListInsertEnd>
 8012b3c:	20001c1c 	.word	0x20001c1c
 8012b40:	20001cd0 	.word	0x20001cd0

08012b44 <xTaskRemoveFromEventList>:
{
 8012b44:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8012b46:	68c3      	ldr	r3, [r0, #12]
 8012b48:	68dd      	ldr	r5, [r3, #12]
{
 8012b4a:	b082      	sub	sp, #8
	configASSERT( pxUnblockedTCB );
 8012b4c:	b38d      	cbz	r5, 8012bb2 <xTaskRemoveFromEventList+0x6e>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8012b4e:	f105 0118 	add.w	r1, r5, #24
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8012b52:	4c1c      	ldr	r4, [pc, #112]	; (8012bc4 <xTaskRemoveFromEventList+0x80>)
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8012b54:	9101      	str	r1, [sp, #4]
 8012b56:	4608      	mov	r0, r1
 8012b58:	f7fe fb2c 	bl	80111b4 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8012b5c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
 8012b60:	9901      	ldr	r1, [sp, #4]
 8012b62:	b17b      	cbz	r3, 8012b84 <xTaskRemoveFromEventList+0x40>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8012b64:	f104 00fc 	add.w	r0, r4, #252	; 0xfc
 8012b68:	f7fe fafc 	bl	8011164 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8012b6c:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8012b70:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8012b72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012b74:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8012b76:	bf8a      	itet	hi
 8012b78:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
 8012b7a:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
 8012b7c:	f8c4 0128 	strhi.w	r0, [r4, #296]	; 0x128
}
 8012b80:	b002      	add	sp, #8
 8012b82:	bd70      	pop	{r4, r5, r6, pc}
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8012b84:	1d29      	adds	r1, r5, #4
 8012b86:	4608      	mov	r0, r1
 8012b88:	9101      	str	r1, [sp, #4]
 8012b8a:	f7fe fb13 	bl	80111b4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8012b8e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8012b90:	f8d4 60b0 	ldr.w	r6, [r4, #176]	; 0xb0
 8012b94:	9901      	ldr	r1, [sp, #4]
 8012b96:	2301      	movs	r3, #1
 8012b98:	4083      	lsls	r3, r0
 8012b9a:	f104 021c 	add.w	r2, r4, #28
 8012b9e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8012ba2:	4333      	orrs	r3, r6
 8012ba4:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8012ba8:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
 8012bac:	f7fe fada 	bl	8011164 <vListInsertEnd>
 8012bb0:	e7dc      	b.n	8012b6c <xTaskRemoveFromEventList+0x28>
 8012bb2:	f04f 0320 	mov.w	r3, #32
 8012bb6:	f383 8811 	msr	BASEPRI, r3
 8012bba:	f3bf 8f6f 	isb	sy
 8012bbe:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 8012bc2:	e7fe      	b.n	8012bc2 <xTaskRemoveFromEventList+0x7e>
 8012bc4:	20001c1c 	.word	0x20001c1c

08012bc8 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8012bc8:	4b03      	ldr	r3, [pc, #12]	; (8012bd8 <vTaskInternalSetTimeOutState+0x10>)
 8012bca:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
	pxTimeOut->xTimeOnEntering = xTickCount;
 8012bce:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8012bd2:	e9c0 2300 	strd	r2, r3, [r0]
}
 8012bd6:	4770      	bx	lr
 8012bd8:	20001c1c 	.word	0x20001c1c

08012bdc <xTaskCheckForTimeOut>:
{
 8012bdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 8012bde:	b300      	cbz	r0, 8012c22 <xTaskCheckForTimeOut+0x46>
	configASSERT( pxTicksToWait );
 8012be0:	460d      	mov	r5, r1
 8012be2:	b1a9      	cbz	r1, 8012c10 <xTaskCheckForTimeOut+0x34>
 8012be4:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8012be6:	f000 fc8d 	bl	8013504 <vPortEnterCritical>
			if( *pxTicksToWait == portMAX_DELAY )
 8012bea:	682b      	ldr	r3, [r5, #0]
		const TickType_t xConstTickCount = xTickCount;
 8012bec:	4a1d      	ldr	r2, [pc, #116]	; (8012c64 <xTaskCheckForTimeOut+0x88>)
			if( *pxTicksToWait == portMAX_DELAY )
 8012bee:	1c59      	adds	r1, r3, #1
		const TickType_t xConstTickCount = xTickCount;
 8012bf0:	f8d2 00a8 	ldr.w	r0, [r2, #168]	; 0xa8
			if( *pxTicksToWait == portMAX_DELAY )
 8012bf4:	d02c      	beq.n	8012c50 <xTaskCheckForTimeOut+0x74>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8012bf6:	e9d4 7100 	ldrd	r7, r1, [r4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8012bfa:	f8d2 6120 	ldr.w	r6, [r2, #288]	; 0x120
 8012bfe:	42b7      	cmp	r7, r6
 8012c00:	d018      	beq.n	8012c34 <xTaskCheckForTimeOut+0x58>
 8012c02:	4281      	cmp	r1, r0
 8012c04:	d816      	bhi.n	8012c34 <xTaskCheckForTimeOut+0x58>
			xReturn = pdTRUE;
 8012c06:	2501      	movs	r5, #1
	taskEXIT_CRITICAL();
 8012c08:	f000 fc9e 	bl	8013548 <vPortExitCritical>
}
 8012c0c:	4628      	mov	r0, r5
 8012c0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012c10:	f04f 0320 	mov.w	r3, #32
 8012c14:	f383 8811 	msr	BASEPRI, r3
 8012c18:	f3bf 8f6f 	isb	sy
 8012c1c:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 8012c20:	e7fe      	b.n	8012c20 <xTaskCheckForTimeOut+0x44>
 8012c22:	f04f 0320 	mov.w	r3, #32
 8012c26:	f383 8811 	msr	BASEPRI, r3
 8012c2a:	f3bf 8f6f 	isb	sy
 8012c2e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 8012c32:	e7fe      	b.n	8012c32 <xTaskCheckForTimeOut+0x56>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8012c34:	1a46      	subs	r6, r0, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8012c36:	42b3      	cmp	r3, r6
 8012c38:	d90f      	bls.n	8012c5a <xTaskCheckForTimeOut+0x7e>
			*pxTicksToWait -= xElapsedTime;
 8012c3a:	1a1b      	subs	r3, r3, r0
 8012c3c:	440b      	add	r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8012c3e:	f8d2 1120 	ldr.w	r1, [r2, #288]	; 0x120
	pxTimeOut->xTimeOnEntering = xTickCount;
 8012c42:	f8d2 20a8 	ldr.w	r2, [r2, #168]	; 0xa8
			*pxTicksToWait -= xElapsedTime;
 8012c46:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8012c48:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
 8012c4c:	2500      	movs	r5, #0
 8012c4e:	e7db      	b.n	8012c08 <xTaskCheckForTimeOut+0x2c>
				xReturn = pdFALSE;
 8012c50:	2500      	movs	r5, #0
	taskEXIT_CRITICAL();
 8012c52:	f000 fc79 	bl	8013548 <vPortExitCritical>
}
 8012c56:	4628      	mov	r0, r5
 8012c58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			*pxTicksToWait = 0;
 8012c5a:	2300      	movs	r3, #0
 8012c5c:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 8012c5e:	2501      	movs	r5, #1
 8012c60:	e7d2      	b.n	8012c08 <xTaskCheckForTimeOut+0x2c>
 8012c62:	bf00      	nop
 8012c64:	20001c1c 	.word	0x20001c1c

08012c68 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8012c68:	4b02      	ldr	r3, [pc, #8]	; (8012c74 <vTaskMissedYield+0xc>)
 8012c6a:	2201      	movs	r2, #1
 8012c6c:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
}
 8012c70:	4770      	bx	lr
 8012c72:	bf00      	nop
 8012c74:	20001c1c 	.word	0x20001c1c

08012c78 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8012c78:	4b06      	ldr	r3, [pc, #24]	; (8012c94 <xTaskGetSchedulerState+0x1c>)
 8012c7a:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 8012c7e:	b132      	cbz	r2, 8012c8e <xTaskGetSchedulerState+0x16>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8012c80:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8012c84:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8012c86:	bf0c      	ite	eq
 8012c88:	2002      	moveq	r0, #2
 8012c8a:	2000      	movne	r0, #0
 8012c8c:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8012c8e:	2001      	movs	r0, #1
	}
 8012c90:	4770      	bx	lr
 8012c92:	bf00      	nop
 8012c94:	20001c1c 	.word	0x20001c1c

08012c98 <xTaskPriorityInherit>:
	{
 8012c98:	b570      	push	{r4, r5, r6, lr}
		if( pxMutexHolder != NULL )
 8012c9a:	4604      	mov	r4, r0
	{
 8012c9c:	b082      	sub	sp, #8
		if( pxMutexHolder != NULL )
 8012c9e:	b1e0      	cbz	r0, 8012cda <xTaskPriorityInherit+0x42>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8012ca0:	4d29      	ldr	r5, [pc, #164]	; (8012d48 <xTaskPriorityInherit+0xb0>)
 8012ca2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8012ca4:	f8d5 20ac 	ldr.w	r2, [r5, #172]	; 0xac
 8012ca8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8012caa:	4293      	cmp	r3, r2
 8012cac:	d217      	bcs.n	8012cde <xTaskPriorityInherit+0x46>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8012cae:	6982      	ldr	r2, [r0, #24]
 8012cb0:	2a00      	cmp	r2, #0
 8012cb2:	db05      	blt.n	8012cc0 <xTaskPriorityInherit+0x28>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012cb4:	f8d5 20ac 	ldr.w	r2, [r5, #172]	; 0xac
 8012cb8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8012cba:	f1c2 0207 	rsb	r2, r2, #7
 8012cbe:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8012cc0:	4e22      	ldr	r6, [pc, #136]	; (8012d4c <xTaskPriorityInherit+0xb4>)
 8012cc2:	6962      	ldr	r2, [r4, #20]
 8012cc4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8012cc8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8012ccc:	429a      	cmp	r2, r3
 8012cce:	d010      	beq.n	8012cf2 <xTaskPriorityInherit+0x5a>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8012cd0:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
 8012cd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012cd6:	62e3      	str	r3, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
 8012cd8:	2001      	movs	r0, #1
	}
 8012cda:	b002      	add	sp, #8
 8012cdc:	bd70      	pop	{r4, r5, r6, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8012cde:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
 8012ce2:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8012ce4:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 8012ce6:	42a0      	cmp	r0, r4
 8012ce8:	bf2c      	ite	cs
 8012cea:	2000      	movcs	r0, #0
 8012cec:	2001      	movcc	r0, #1
	}
 8012cee:	b002      	add	sp, #8
 8012cf0:	bd70      	pop	{r4, r5, r6, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012cf2:	1d21      	adds	r1, r4, #4
 8012cf4:	4608      	mov	r0, r1
 8012cf6:	9101      	str	r1, [sp, #4]
 8012cf8:	f7fe fa5c 	bl	80111b4 <uxListRemove>
 8012cfc:	9901      	ldr	r1, [sp, #4]
 8012cfe:	b978      	cbnz	r0, 8012d20 <xTaskPriorityInherit+0x88>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 8012d00:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8012d02:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8012d06:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8012d0a:	69db      	ldr	r3, [r3, #28]
 8012d0c:	b943      	cbnz	r3, 8012d20 <xTaskPriorityInherit+0x88>
 8012d0e:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
 8012d12:	2001      	movs	r0, #1
 8012d14:	fa00 f202 	lsl.w	r2, r0, r2
 8012d18:	ea23 0302 	bic.w	r3, r3, r2
 8012d1c:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8012d20:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8012d24:	f8d5 20b0 	ldr.w	r2, [r5, #176]	; 0xb0
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8012d28:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8012d2a:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8012d2c:	2401      	movs	r4, #1
 8012d2e:	fa04 f300 	lsl.w	r3, r4, r0
 8012d32:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8012d36:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8012d3a:	4313      	orrs	r3, r2
 8012d3c:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
 8012d40:	f7fe fa10 	bl	8011164 <vListInsertEnd>
				xReturn = pdTRUE;
 8012d44:	4620      	mov	r0, r4
 8012d46:	e7c8      	b.n	8012cda <xTaskPriorityInherit+0x42>
 8012d48:	20001c1c 	.word	0x20001c1c
 8012d4c:	20001c38 	.word	0x20001c38

08012d50 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8012d50:	b1e0      	cbz	r0, 8012d8c <xTaskPriorityDisinherit+0x3c>
	{
 8012d52:	b5f0      	push	{r4, r5, r6, r7, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 8012d54:	4d29      	ldr	r5, [pc, #164]	; (8012dfc <xTaskPriorityDisinherit+0xac>)
 8012d56:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
 8012d5a:	4283      	cmp	r3, r0
	{
 8012d5c:	b083      	sub	sp, #12
 8012d5e:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 8012d60:	d008      	beq.n	8012d74 <xTaskPriorityDisinherit+0x24>
 8012d62:	f04f 0320 	mov.w	r3, #32
 8012d66:	f383 8811 	msr	BASEPRI, r3
 8012d6a:	f3bf 8f6f 	isb	sy
 8012d6e:	f3bf 8f4f 	dsb	sy
 8012d72:	e7fe      	b.n	8012d72 <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 8012d74:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8012d76:	b15b      	cbz	r3, 8012d90 <xTaskPriorityDisinherit+0x40>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8012d78:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8012d7a:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 8012d7c:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8012d7e:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8012d80:	6503      	str	r3, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8012d82:	d000      	beq.n	8012d86 <xTaskPriorityDisinherit+0x36>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8012d84:	b16b      	cbz	r3, 8012da2 <xTaskPriorityDisinherit+0x52>
	BaseType_t xReturn = pdFALSE;
 8012d86:	2000      	movs	r0, #0
	}
 8012d88:	b003      	add	sp, #12
 8012d8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BaseType_t xReturn = pdFALSE;
 8012d8c:	2000      	movs	r0, #0
	}
 8012d8e:	4770      	bx	lr
 8012d90:	f04f 0320 	mov.w	r3, #32
 8012d94:	f383 8811 	msr	BASEPRI, r3
 8012d98:	f3bf 8f6f 	isb	sy
 8012d9c:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTCB->uxMutexesHeld );
 8012da0:	e7fe      	b.n	8012da0 <xTaskPriorityDisinherit+0x50>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012da2:	1d01      	adds	r1, r0, #4
 8012da4:	4608      	mov	r0, r1
 8012da6:	9101      	str	r1, [sp, #4]
 8012da8:	f7fe fa04 	bl	80111b4 <uxListRemove>
 8012dac:	9901      	ldr	r1, [sp, #4]
 8012dae:	b970      	cbnz	r0, 8012dce <xTaskPriorityDisinherit+0x7e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8012db0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8012db2:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8012db6:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8012dba:	69db      	ldr	r3, [r3, #28]
 8012dbc:	b93b      	cbnz	r3, 8012dce <xTaskPriorityDisinherit+0x7e>
 8012dbe:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
 8012dc2:	2201      	movs	r2, #1
 8012dc4:	4082      	lsls	r2, r0
 8012dc6:	ea23 0302 	bic.w	r3, r3, r2
 8012dca:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8012dce:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
					prvAddTaskToReadyList( pxTCB );
 8012dd0:	f8d5 70b0 	ldr.w	r7, [r5, #176]	; 0xb0
 8012dd4:	480a      	ldr	r0, [pc, #40]	; (8012e00 <xTaskPriorityDisinherit+0xb0>)
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8012dd6:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8012dd8:	2601      	movs	r6, #1
 8012dda:	fa06 f203 	lsl.w	r2, r6, r3
 8012dde:	433a      	orrs	r2, r7
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012de0:	f1c3 0707 	rsb	r7, r3, #7
					prvAddTaskToReadyList( pxTCB );
 8012de4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8012de8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012dec:	61a7      	str	r7, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8012dee:	f8c5 20b0 	str.w	r2, [r5, #176]	; 0xb0
 8012df2:	f7fe f9b7 	bl	8011164 <vListInsertEnd>
					xReturn = pdTRUE;
 8012df6:	4630      	mov	r0, r6
		return xReturn;
 8012df8:	e7c6      	b.n	8012d88 <xTaskPriorityDisinherit+0x38>
 8012dfa:	bf00      	nop
 8012dfc:	20001c1c 	.word	0x20001c1c
 8012e00:	20001c38 	.word	0x20001c38

08012e04 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 8012e04:	b1c0      	cbz	r0, 8012e38 <vTaskPriorityDisinheritAfterTimeout+0x34>
	{
 8012e06:	b570      	push	{r4, r5, r6, lr}
 8012e08:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 8012e0a:	6d00      	ldr	r0, [r0, #80]	; 0x50
	{
 8012e0c:	b082      	sub	sp, #8
			configASSERT( pxTCB->uxMutexesHeld );
 8012e0e:	b150      	cbz	r0, 8012e26 <vTaskPriorityDisinheritAfterTimeout+0x22>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8012e10:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
			if( pxTCB->uxPriority != uxPriorityToUse )
 8012e12:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8012e14:	428b      	cmp	r3, r1
 8012e16:	bf38      	it	cc
 8012e18:	460b      	movcc	r3, r1
 8012e1a:	429a      	cmp	r2, r3
 8012e1c:	d001      	beq.n	8012e22 <vTaskPriorityDisinheritAfterTimeout+0x1e>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8012e1e:	2801      	cmp	r0, #1
 8012e20:	d00b      	beq.n	8012e3a <vTaskPriorityDisinheritAfterTimeout+0x36>
	}
 8012e22:	b002      	add	sp, #8
 8012e24:	bd70      	pop	{r4, r5, r6, pc}
 8012e26:	f04f 0320 	mov.w	r3, #32
 8012e2a:	f383 8811 	msr	BASEPRI, r3
 8012e2e:	f3bf 8f6f 	isb	sy
 8012e32:	f3bf 8f4f 	dsb	sy
			configASSERT( pxTCB->uxMutexesHeld );
 8012e36:	e7fe      	b.n	8012e36 <vTaskPriorityDisinheritAfterTimeout+0x32>
 8012e38:	4770      	bx	lr
					configASSERT( pxTCB != pxCurrentTCB );
 8012e3a:	4d24      	ldr	r5, [pc, #144]	; (8012ecc <vTaskPriorityDisinheritAfterTimeout+0xc8>)
 8012e3c:	f8d5 10ac 	ldr.w	r1, [r5, #172]	; 0xac
 8012e40:	42a1      	cmp	r1, r4
 8012e42:	d027      	beq.n	8012e94 <vTaskPriorityDisinheritAfterTimeout+0x90>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8012e44:	69a1      	ldr	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8012e46:	4e22      	ldr	r6, [pc, #136]	; (8012ed0 <vTaskPriorityDisinheritAfterTimeout+0xcc>)
					pxTCB->uxPriority = uxPriorityToUse;
 8012e48:	62e3      	str	r3, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8012e4a:	2900      	cmp	r1, #0
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012e4c:	bfa8      	it	ge
 8012e4e:	f1c3 0307 	rsbge	r3, r3, #7
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8012e52:	6961      	ldr	r1, [r4, #20]
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8012e54:	bfa8      	it	ge
 8012e56:	61a3      	strge	r3, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8012e58:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8012e5c:	eb06 0382 	add.w	r3, r6, r2, lsl #2
 8012e60:	4299      	cmp	r1, r3
 8012e62:	d1de      	bne.n	8012e22 <vTaskPriorityDisinheritAfterTimeout+0x1e>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012e64:	1d21      	adds	r1, r4, #4
 8012e66:	4608      	mov	r0, r1
 8012e68:	9101      	str	r1, [sp, #4]
 8012e6a:	f7fe f9a3 	bl	80111b4 <uxListRemove>
 8012e6e:	9901      	ldr	r1, [sp, #4]
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8012e70:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8012e72:	b1c0      	cbz	r0, 8012ea6 <vTaskPriorityDisinheritAfterTimeout+0xa2>
 8012e74:	2301      	movs	r3, #1
 8012e76:	4093      	lsls	r3, r2
 8012e78:	0090      	lsls	r0, r2, #2
						prvAddTaskToReadyList( pxTCB );
 8012e7a:	f8d5 40b0 	ldr.w	r4, [r5, #176]	; 0xb0
 8012e7e:	4410      	add	r0, r2
 8012e80:	4323      	orrs	r3, r4
 8012e82:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8012e86:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
	}
 8012e8a:	b002      	add	sp, #8
 8012e8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						prvAddTaskToReadyList( pxTCB );
 8012e90:	f7fe b968 	b.w	8011164 <vListInsertEnd>
 8012e94:	f04f 0320 	mov.w	r3, #32
 8012e98:	f383 8811 	msr	BASEPRI, r3
 8012e9c:	f3bf 8f6f 	isb	sy
 8012ea0:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 8012ea4:	e7fe      	b.n	8012ea4 <vTaskPriorityDisinheritAfterTimeout+0xa0>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8012ea6:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8012eaa:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8012eae:	0090      	lsls	r0, r2, #2
 8012eb0:	69db      	ldr	r3, [r3, #28]
 8012eb2:	b113      	cbz	r3, 8012eba <vTaskPriorityDisinheritAfterTimeout+0xb6>
 8012eb4:	2301      	movs	r3, #1
 8012eb6:	4093      	lsls	r3, r2
 8012eb8:	e7df      	b.n	8012e7a <vTaskPriorityDisinheritAfterTimeout+0x76>
 8012eba:	f8d5 40b0 	ldr.w	r4, [r5, #176]	; 0xb0
 8012ebe:	2301      	movs	r3, #1
 8012ec0:	4093      	lsls	r3, r2
 8012ec2:	ea24 0403 	bic.w	r4, r4, r3
 8012ec6:	f8c5 40b0 	str.w	r4, [r5, #176]	; 0xb0
 8012eca:	e7d6      	b.n	8012e7a <vTaskPriorityDisinheritAfterTimeout+0x76>
 8012ecc:	20001c1c 	.word	0x20001c1c
 8012ed0:	20001c38 	.word	0x20001c38

08012ed4 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8012ed4:	4b05      	ldr	r3, [pc, #20]	; (8012eec <pvTaskIncrementMutexHeldCount+0x18>)
 8012ed6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8012eda:	b122      	cbz	r2, 8012ee6 <pvTaskIncrementMutexHeldCount+0x12>
			( pxCurrentTCB->uxMutexesHeld )++;
 8012edc:	f8d3 10ac 	ldr.w	r1, [r3, #172]	; 0xac
 8012ee0:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 8012ee2:	3201      	adds	r2, #1
 8012ee4:	650a      	str	r2, [r1, #80]	; 0x50
		return pxCurrentTCB;
 8012ee6:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
	}
 8012eea:	4770      	bx	lr
 8012eec:	20001c1c 	.word	0x20001c1c

08012ef0 <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8012ef0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012ef4:	4e1f      	ldr	r6, [pc, #124]	; (8012f74 <prvSwitchTimerLists+0x84>)
 8012ef6:	b084      	sub	sp, #16
		xMessage.xMessageID = xCommandID;
 8012ef8:	f04f 0800 	mov.w	r8, #0

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8012efc:	e00d      	b.n	8012f1a <prvSwitchTimerLists+0x2a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8012efe:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8012f00:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8012f02:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8012f04:	1d25      	adds	r5, r4, #4
 8012f06:	4628      	mov	r0, r5
 8012f08:	f7fe f954 	bl	80111b4 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8012f0c:	6a23      	ldr	r3, [r4, #32]
 8012f0e:	4620      	mov	r0, r4
 8012f10:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8012f12:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8012f16:	075b      	lsls	r3, r3, #29
 8012f18:	d409      	bmi.n	8012f2e <prvSwitchTimerLists+0x3e>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8012f1a:	6833      	ldr	r3, [r6, #0]
 8012f1c:	681a      	ldr	r2, [r3, #0]
 8012f1e:	2a00      	cmp	r2, #0
 8012f20:	d1ed      	bne.n	8012efe <prvSwitchTimerLists+0xe>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8012f22:	68b2      	ldr	r2, [r6, #8]
 8012f24:	6032      	str	r2, [r6, #0]
	pxOverflowTimerList = pxTemp;
 8012f26:	60b3      	str	r3, [r6, #8]
}
 8012f28:	b004      	add	sp, #16
 8012f2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8012f2e:	69a3      	ldr	r3, [r4, #24]
 8012f30:	443b      	add	r3, r7
			if( xReloadTime > xNextExpireTime )
 8012f32:	429f      	cmp	r7, r3
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8012f34:	4629      	mov	r1, r5
			if( xReloadTime > xNextExpireTime )
 8012f36:	d205      	bcs.n	8012f44 <prvSwitchTimerLists+0x54>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8012f38:	6830      	ldr	r0, [r6, #0]
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8012f3a:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8012f3c:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8012f3e:	f7fe f921 	bl	8011184 <vListInsert>
 8012f42:	e7ea      	b.n	8012f1a <prvSwitchTimerLists+0x2a>
	if( xTimerQueue != NULL )
 8012f44:	6873      	ldr	r3, [r6, #4]
 8012f46:	b163      	cbz	r3, 8012f62 <prvSwitchTimerLists+0x72>
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8012f48:	e9cd 8701 	strd	r8, r7, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8012f4c:	9403      	str	r4, [sp, #12]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8012f4e:	f7ff fe93 	bl	8012c78 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8012f52:	2300      	movs	r3, #0
 8012f54:	6870      	ldr	r0, [r6, #4]
 8012f56:	461a      	mov	r2, r3
 8012f58:	a901      	add	r1, sp, #4
 8012f5a:	f7fe fa09 	bl	8011370 <xQueueGenericSend>
				configASSERT( xResult );
 8012f5e:	2800      	cmp	r0, #0
 8012f60:	d1db      	bne.n	8012f1a <prvSwitchTimerLists+0x2a>
 8012f62:	f04f 0320 	mov.w	r3, #32
 8012f66:	f383 8811 	msr	BASEPRI, r3
 8012f6a:	f3bf 8f6f 	isb	sy
 8012f6e:	f3bf 8f4f 	dsb	sy
 8012f72:	e7fe      	b.n	8012f72 <prvSwitchTimerLists+0x82>
 8012f74:	20001d48 	.word	0x20001d48

08012f78 <prvTimerTask>:
{
 8012f78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8012f7c:	4c90      	ldr	r4, [pc, #576]	; (80131c0 <prvTimerTask+0x248>)
					portYIELD_WITHIN_API();
 8012f7e:	f8df 8244 	ldr.w	r8, [pc, #580]	; 80131c4 <prvTimerTask+0x24c>
{
 8012f82:	b088      	sub	sp, #32
					portYIELD_WITHIN_API();
 8012f84:	f04f 5980 	mov.w	r9, #268435456	; 0x10000000
 8012f88:	2600      	movs	r6, #0
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8012f8a:	6823      	ldr	r3, [r4, #0]
 8012f8c:	681f      	ldr	r7, [r3, #0]
 8012f8e:	2f00      	cmp	r7, #0
 8012f90:	f000 809a 	beq.w	80130c8 <prvTimerTask+0x150>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8012f94:	68db      	ldr	r3, [r3, #12]
 8012f96:	681f      	ldr	r7, [r3, #0]
	vTaskSuspendAll();
 8012f98:	f7ff fb1a 	bl	80125d0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 8012f9c:	f7ff fb22 	bl	80125e4 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8012fa0:	68e3      	ldr	r3, [r4, #12]
 8012fa2:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
 8012fa4:	4605      	mov	r5, r0
	if( xTimeNow < xLastTime )
 8012fa6:	f200 809e 	bhi.w	80130e6 <prvTimerTask+0x16e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8012faa:	4287      	cmp	r7, r0
	xLastTime = xTimeNow;
 8012fac:	60e0      	str	r0, [r4, #12]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8012fae:	f240 80a3 	bls.w	80130f8 <prvTimerTask+0x180>
 8012fb2:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8012fb4:	6860      	ldr	r0, [r4, #4]
 8012fb6:	1b79      	subs	r1, r7, r5
 8012fb8:	f7fe ffa2 	bl	8011f00 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8012fbc:	f7ff fc32 	bl	8012824 <xTaskResumeAll>
 8012fc0:	b928      	cbnz	r0, 8012fce <prvTimerTask+0x56>
					portYIELD_WITHIN_API();
 8012fc2:	f8c8 9000 	str.w	r9, [r8]
 8012fc6:	f3bf 8f4f 	dsb	sy
 8012fca:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8012fce:	6860      	ldr	r0, [r4, #4]
 8012fd0:	2200      	movs	r2, #0
 8012fd2:	a902      	add	r1, sp, #8
 8012fd4:	f7fe fc10 	bl	80117f8 <xQueueReceive>
 8012fd8:	2800      	cmp	r0, #0
 8012fda:	d0d6      	beq.n	8012f8a <prvTimerTask+0x12>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8012fdc:	9b02      	ldr	r3, [sp, #8]
 8012fde:	2b00      	cmp	r3, #0
 8012fe0:	dbf5      	blt.n	8012fce <prvTimerTask+0x56>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8012fe2:	9d04      	ldr	r5, [sp, #16]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8012fe4:	696b      	ldr	r3, [r5, #20]
 8012fe6:	b113      	cbz	r3, 8012fee <prvTimerTask+0x76>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8012fe8:	1d28      	adds	r0, r5, #4
 8012fea:	f7fe f8e3 	bl	80111b4 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 8012fee:	f7ff faf9 	bl	80125e4 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8012ff2:	68e3      	ldr	r3, [r4, #12]
 8012ff4:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
 8012ff6:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
 8012ff8:	d37b      	bcc.n	80130f2 <prvTimerTask+0x17a>
	xLastTime = xTimeNow;
 8012ffa:	9b02      	ldr	r3, [sp, #8]
 8012ffc:	60e7      	str	r7, [r4, #12]
			switch( xMessage.xMessageID )
 8012ffe:	2b09      	cmp	r3, #9
 8013000:	d8e5      	bhi.n	8012fce <prvTimerTask+0x56>
 8013002:	e8df f003 	tbb	[pc, r3]
 8013006:	0505      	.short	0x0505
 8013008:	583b5105 	.word	0x583b5105
 801300c:	3b510505 	.word	0x3b510505
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8013010:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8013014:	9b03      	ldr	r3, [sp, #12]
 8013016:	69aa      	ldr	r2, [r5, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8013018:	612d      	str	r5, [r5, #16]
 801301a:	1898      	adds	r0, r3, r2
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801301c:	f041 0101 	orr.w	r1, r1, #1
 8013020:	f885 1028 	strb.w	r1, [r5, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8013024:	bf2c      	ite	cs
 8013026:	2101      	movcs	r1, #1
 8013028:	2100      	movcc	r1, #0
	if( xNextExpiryTime <= xTimeNow )
 801302a:	42b8      	cmp	r0, r7
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801302c:	6068      	str	r0, [r5, #4]
	if( xNextExpiryTime <= xTimeNow )
 801302e:	d87e      	bhi.n	801312e <prvTimerTask+0x1b6>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013030:	1afb      	subs	r3, r7, r3
 8013032:	429a      	cmp	r2, r3
 8013034:	f200 8088 	bhi.w	8013148 <prvTimerTask+0x1d0>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8013038:	6a2b      	ldr	r3, [r5, #32]
 801303a:	4628      	mov	r0, r5
 801303c:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 801303e:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8013042:	075b      	lsls	r3, r3, #29
 8013044:	d5c3      	bpl.n	8012fce <prvTimerTask+0x56>
	if( xTimerQueue != NULL )
 8013046:	6863      	ldr	r3, [r4, #4]
 8013048:	b17b      	cbz	r3, 801306a <prvTimerTask+0xf2>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 801304a:	69aa      	ldr	r2, [r5, #24]
 801304c:	9b03      	ldr	r3, [sp, #12]
		xMessage.xMessageID = xCommandID;
 801304e:	9605      	str	r6, [sp, #20]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8013050:	4413      	add	r3, r2
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 8013052:	e9cd 3506 	strd	r3, r5, [sp, #24]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8013056:	f7ff fe0f 	bl	8012c78 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 801305a:	2300      	movs	r3, #0
 801305c:	6860      	ldr	r0, [r4, #4]
 801305e:	461a      	mov	r2, r3
 8013060:	a905      	add	r1, sp, #20
 8013062:	f7fe f985 	bl	8011370 <xQueueGenericSend>
							configASSERT( xResult );
 8013066:	2800      	cmp	r0, #0
 8013068:	d1b1      	bne.n	8012fce <prvTimerTask+0x56>
 801306a:	f04f 0320 	mov.w	r3, #32
 801306e:	f383 8811 	msr	BASEPRI, r3
 8013072:	f3bf 8f6f 	isb	sy
 8013076:	f3bf 8f4f 	dsb	sy
 801307a:	e7fe      	b.n	801307a <prvTimerTask+0x102>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 801307c:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8013080:	9b03      	ldr	r3, [sp, #12]
 8013082:	61ab      	str	r3, [r5, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8013084:	f042 0201 	orr.w	r2, r2, #1
 8013088:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 801308c:	2b00      	cmp	r3, #0
 801308e:	f000 8089 	beq.w	80131a4 <prvTimerTask+0x22c>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8013092:	443b      	add	r3, r7
	if( xNextExpiryTime <= xTimeNow )
 8013094:	42bb      	cmp	r3, r7
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8013096:	bf94      	ite	ls
 8013098:	68a0      	ldrls	r0, [r4, #8]
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 801309a:	6820      	ldrhi	r0, [r4, #0]
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801309c:	606b      	str	r3, [r5, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 801309e:	612d      	str	r5, [r5, #16]
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80130a0:	1d29      	adds	r1, r5, #4
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80130a2:	f7fe f86f 	bl	8011184 <vListInsert>
 80130a6:	e792      	b.n	8012fce <prvTimerTask+0x56>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80130a8:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 80130ac:	f023 0301 	bic.w	r3, r3, #1
 80130b0:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
					break;
 80130b4:	e78b      	b.n	8012fce <prvTimerTask+0x56>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 80130b6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 80130ba:	079a      	lsls	r2, r3, #30
 80130bc:	d540      	bpl.n	8013140 <prvTimerTask+0x1c8>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80130be:	f023 0301 	bic.w	r3, r3, #1
 80130c2:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
 80130c6:	e782      	b.n	8012fce <prvTimerTask+0x56>
	vTaskSuspendAll();
 80130c8:	f7ff fa82 	bl	80125d0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 80130cc:	f7ff fa8a 	bl	80125e4 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 80130d0:	68e3      	ldr	r3, [r4, #12]
 80130d2:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
 80130d4:	4605      	mov	r5, r0
	if( xTimeNow < xLastTime )
 80130d6:	d806      	bhi.n	80130e6 <prvTimerTask+0x16e>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80130d8:	68a3      	ldr	r3, [r4, #8]
	xLastTime = xTimeNow;
 80130da:	60e5      	str	r5, [r4, #12]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80130dc:	681a      	ldr	r2, [r3, #0]
 80130de:	fab2 f282 	clz	r2, r2
 80130e2:	0952      	lsrs	r2, r2, #5
 80130e4:	e766      	b.n	8012fb4 <prvTimerTask+0x3c>
		prvSwitchTimerLists();
 80130e6:	f7ff ff03 	bl	8012ef0 <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 80130ea:	60e5      	str	r5, [r4, #12]
			( void ) xTaskResumeAll();
 80130ec:	f7ff fb9a 	bl	8012824 <xTaskResumeAll>
 80130f0:	e76d      	b.n	8012fce <prvTimerTask+0x56>
		prvSwitchTimerLists();
 80130f2:	f7ff fefd 	bl	8012ef0 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 80130f6:	e780      	b.n	8012ffa <prvTimerTask+0x82>
				( void ) xTaskResumeAll();
 80130f8:	f7ff fb94 	bl	8012824 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80130fc:	6823      	ldr	r3, [r4, #0]
 80130fe:	68db      	ldr	r3, [r3, #12]
 8013100:	f8d3 a00c 	ldr.w	sl, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8013104:	f10a 0104 	add.w	r1, sl, #4
 8013108:	4608      	mov	r0, r1
 801310a:	9101      	str	r1, [sp, #4]
 801310c:	f7fe f852 	bl	80111b4 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8013110:	f89a 3028 	ldrb.w	r3, [sl, #40]	; 0x28
 8013114:	9901      	ldr	r1, [sp, #4]
 8013116:	f013 0f04 	tst.w	r3, #4
 801311a:	d11a      	bne.n	8013152 <prvTimerTask+0x1da>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 801311c:	f023 0301 	bic.w	r3, r3, #1
 8013120:	f88a 3028 	strb.w	r3, [sl, #40]	; 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8013124:	f8da 3020 	ldr.w	r3, [sl, #32]
 8013128:	4650      	mov	r0, sl
 801312a:	4798      	blx	r3
}
 801312c:	e74f      	b.n	8012fce <prvTimerTask+0x56>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 801312e:	42bb      	cmp	r3, r7
 8013130:	d901      	bls.n	8013136 <prvTimerTask+0x1be>
 8013132:	2900      	cmp	r1, #0
 8013134:	d080      	beq.n	8013038 <prvTimerTask+0xc0>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8013136:	6820      	ldr	r0, [r4, #0]
 8013138:	1d29      	adds	r1, r5, #4
 801313a:	f7fe f823 	bl	8011184 <vListInsert>
	return xProcessTimerNow;
 801313e:	e746      	b.n	8012fce <prvTimerTask+0x56>
							vPortFree( pxTimer );
 8013140:	4628      	mov	r0, r5
 8013142:	f000 f927 	bl	8013394 <vPortFree>
 8013146:	e742      	b.n	8012fce <prvTimerTask+0x56>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8013148:	68a0      	ldr	r0, [r4, #8]
 801314a:	1d29      	adds	r1, r5, #4
 801314c:	f7fe f81a 	bl	8011184 <vListInsert>
	return xProcessTimerNow;
 8013150:	e73d      	b.n	8012fce <prvTimerTask+0x56>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8013152:	f8da 3018 	ldr.w	r3, [sl, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8013156:	f8ca a010 	str.w	sl, [sl, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 801315a:	18fa      	adds	r2, r7, r3
	if( xNextExpiryTime <= xTimeNow )
 801315c:	42aa      	cmp	r2, r5
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 801315e:	f8ca 2004 	str.w	r2, [sl, #4]
	if( xNextExpiryTime <= xTimeNow )
 8013162:	d903      	bls.n	801316c <prvTimerTask+0x1f4>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8013164:	6820      	ldr	r0, [r4, #0]
 8013166:	f7fe f80d 	bl	8011184 <vListInsert>
	return xProcessTimerNow;
 801316a:	e7db      	b.n	8013124 <prvTimerTask+0x1ac>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 801316c:	1bed      	subs	r5, r5, r7
 801316e:	42ab      	cmp	r3, r5
 8013170:	d821      	bhi.n	80131b6 <prvTimerTask+0x23e>
	if( xTimerQueue != NULL )
 8013172:	6863      	ldr	r3, [r4, #4]
 8013174:	b16b      	cbz	r3, 8013192 <prvTimerTask+0x21a>
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8013176:	e9cd 6705 	strd	r6, r7, [sp, #20]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 801317a:	f8cd a01c 	str.w	sl, [sp, #28]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 801317e:	f7ff fd7b 	bl	8012c78 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8013182:	2300      	movs	r3, #0
 8013184:	6860      	ldr	r0, [r4, #4]
 8013186:	461a      	mov	r2, r3
 8013188:	a905      	add	r1, sp, #20
 801318a:	f7fe f8f1 	bl	8011370 <xQueueGenericSend>
			configASSERT( xResult );
 801318e:	2800      	cmp	r0, #0
 8013190:	d1c8      	bne.n	8013124 <prvTimerTask+0x1ac>
 8013192:	f04f 0320 	mov.w	r3, #32
 8013196:	f383 8811 	msr	BASEPRI, r3
 801319a:	f3bf 8f6f 	isb	sy
 801319e:	f3bf 8f4f 	dsb	sy
 80131a2:	e7fe      	b.n	80131a2 <prvTimerTask+0x22a>
 80131a4:	f04f 0320 	mov.w	r3, #32
 80131a8:	f383 8811 	msr	BASEPRI, r3
 80131ac:	f3bf 8f6f 	isb	sy
 80131b0:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80131b4:	e7fe      	b.n	80131b4 <prvTimerTask+0x23c>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80131b6:	68a0      	ldr	r0, [r4, #8]
 80131b8:	f7fd ffe4 	bl	8011184 <vListInsert>
	return xProcessTimerNow;
 80131bc:	e7b2      	b.n	8013124 <prvTimerTask+0x1ac>
 80131be:	bf00      	nop
 80131c0:	20001d48 	.word	0x20001d48
 80131c4:	e000ed04 	.word	0xe000ed04

080131c8 <xTimerCreateTimerTask>:
{
 80131c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 80131ca:	4c1c      	ldr	r4, [pc, #112]	; (801323c <xTimerCreateTimerTask+0x74>)
{
 80131cc:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
 80131ce:	f000 f999 	bl	8013504 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 80131d2:	6867      	ldr	r7, [r4, #4]
 80131d4:	b1d7      	cbz	r7, 801320c <xTimerCreateTimerTask+0x44>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 80131d6:	f000 f9b7 	bl	8013548 <vPortExitCritical>
	if( xTimerQueue != NULL )
 80131da:	6863      	ldr	r3, [r4, #4]
 80131dc:	b15b      	cbz	r3, 80131f6 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
 80131de:	4b18      	ldr	r3, [pc, #96]	; (8013240 <xTimerCreateTimerTask+0x78>)
 80131e0:	9301      	str	r3, [sp, #4]
 80131e2:	2306      	movs	r3, #6
 80131e4:	9300      	str	r3, [sp, #0]
 80131e6:	4917      	ldr	r1, [pc, #92]	; (8013244 <xTimerCreateTimerTask+0x7c>)
 80131e8:	4817      	ldr	r0, [pc, #92]	; (8013248 <xTimerCreateTimerTask+0x80>)
 80131ea:	2300      	movs	r3, #0
 80131ec:	f44f 7280 	mov.w	r2, #256	; 0x100
 80131f0:	f7fe ff1a 	bl	8012028 <xTaskCreate>
	configASSERT( xReturn );
 80131f4:	b940      	cbnz	r0, 8013208 <xTimerCreateTimerTask+0x40>
 80131f6:	f04f 0320 	mov.w	r3, #32
 80131fa:	f383 8811 	msr	BASEPRI, r3
 80131fe:	f3bf 8f6f 	isb	sy
 8013202:	f3bf 8f4f 	dsb	sy
 8013206:	e7fe      	b.n	8013206 <xTimerCreateTimerTask+0x3e>
}
 8013208:	b003      	add	sp, #12
 801320a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
 801320c:	f104 0610 	add.w	r6, r4, #16
 8013210:	4630      	mov	r0, r6
			vListInitialise( &xActiveTimerList2 );
 8013212:	f104 0524 	add.w	r5, r4, #36	; 0x24
			vListInitialise( &xActiveTimerList1 );
 8013216:	f7fd ff95 	bl	8011144 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 801321a:	4628      	mov	r0, r5
 801321c:	f7fd ff92 	bl	8011144 <vListInitialise>
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8013220:	463a      	mov	r2, r7
 8013222:	210c      	movs	r1, #12
 8013224:	2064      	movs	r0, #100	; 0x64
			pxCurrentTimerList = &xActiveTimerList1;
 8013226:	6026      	str	r6, [r4, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 8013228:	60a5      	str	r5, [r4, #8]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 801322a:	f7fe f815 	bl	8011258 <xQueueGenericCreate>
 801322e:	6060      	str	r0, [r4, #4]
				if( xTimerQueue != NULL )
 8013230:	2800      	cmp	r0, #0
 8013232:	d0d0      	beq.n	80131d6 <xTimerCreateTimerTask+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8013234:	4905      	ldr	r1, [pc, #20]	; (801324c <xTimerCreateTimerTask+0x84>)
 8013236:	f7fe fe4f 	bl	8011ed8 <vQueueAddToRegistry>
 801323a:	e7cc      	b.n	80131d6 <xTimerCreateTimerTask+0xe>
 801323c:	20001d48 	.word	0x20001d48
 8013240:	20001d80 	.word	0x20001d80
 8013244:	0801ab00 	.word	0x0801ab00
 8013248:	08012f79 	.word	0x08012f79
 801324c:	0801aaf8 	.word	0x0801aaf8

08013250 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8013250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	vTaskSuspendAll();
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 8013254:	4d4d      	ldr	r5, [pc, #308]	; (801338c <pvPortMalloc+0x13c>)
{
 8013256:	4607      	mov	r7, r0
	vTaskSuspendAll();
 8013258:	f7ff f9ba 	bl	80125d0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 801325c:	68ab      	ldr	r3, [r5, #8]
 801325e:	2b00      	cmp	r3, #0
 8013260:	d037      	beq.n	80132d2 <pvPortMalloc+0x82>
 8013262:	68ee      	ldr	r6, [r5, #12]

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8013264:	4237      	tst	r7, r6
 8013266:	d12e      	bne.n	80132c6 <pvPortMalloc+0x76>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 8013268:	b36f      	cbz	r7, 80132c6 <pvPortMalloc+0x76>
			{
				xWantedSize += xHeapStructSize;
 801326a:	f107 0408 	add.w	r4, r7, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 801326e:	077f      	lsls	r7, r7, #29
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8013270:	bf1c      	itt	ne
 8013272:	f024 0407 	bicne.w	r4, r4, #7
 8013276:	3408      	addne	r4, #8
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8013278:	b32c      	cbz	r4, 80132c6 <pvPortMalloc+0x76>
 801327a:	f8d5 c014 	ldr.w	ip, [r5, #20]
 801327e:	45a4      	cmp	ip, r4
 8013280:	d321      	bcc.n	80132c6 <pvPortMalloc+0x76>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 8013282:	6829      	ldr	r1, [r5, #0]
				pxPreviousBlock = &xStart;
 8013284:	4a41      	ldr	r2, [pc, #260]	; (801338c <pvPortMalloc+0x13c>)
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8013286:	e003      	b.n	8013290 <pvPortMalloc+0x40>
 8013288:	680f      	ldr	r7, [r1, #0]
 801328a:	b127      	cbz	r7, 8013296 <pvPortMalloc+0x46>
 801328c:	460a      	mov	r2, r1
 801328e:	4639      	mov	r1, r7
 8013290:	6848      	ldr	r0, [r1, #4]
 8013292:	42a0      	cmp	r0, r4
 8013294:	d3f8      	bcc.n	8013288 <pvPortMalloc+0x38>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 8013296:	4299      	cmp	r1, r3
 8013298:	d015      	beq.n	80132c6 <pvPortMalloc+0x76>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 801329a:	460f      	mov	r7, r1
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 801329c:	eba0 0e04 	sub.w	lr, r0, r4
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80132a0:	f857 8b08 	ldr.w	r8, [r7], #8
 80132a4:	f8c2 8000 	str.w	r8, [r2]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80132a8:	f1be 0f10 	cmp.w	lr, #16
 80132ac:	d94c      	bls.n	8013348 <pvPortMalloc+0xf8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80132ae:	190a      	adds	r2, r1, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80132b0:	0750      	lsls	r0, r2, #29
 80132b2:	d02c      	beq.n	801330e <pvPortMalloc+0xbe>
 80132b4:	f04f 0320 	mov.w	r3, #32
 80132b8:	f383 8811 	msr	BASEPRI, r3
 80132bc:	f3bf 8f6f 	isb	sy
 80132c0:	f3bf 8f4f 	dsb	sy
 80132c4:	e7fe      	b.n	80132c4 <pvPortMalloc+0x74>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 80132c6:	f7ff faad 	bl	8012824 <xTaskResumeAll>
 80132ca:	2700      	movs	r7, #0
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 80132cc:	4638      	mov	r0, r7
 80132ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 80132d2:	4b2f      	ldr	r3, [pc, #188]	; (8013390 <pvPortMalloc+0x140>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80132d4:	075a      	lsls	r2, r3, #29
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80132d6:	bf14      	ite	ne
 80132d8:	1dda      	addne	r2, r3, #7
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80132da:	461a      	moveq	r2, r3
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80132dc:	f503 4370 	add.w	r3, r3, #61440	; 0xf000
	xStart.xBlockSize = ( size_t ) 0;

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
 80132e0:	f1a3 0308 	sub.w	r3, r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80132e4:	f023 0307 	bic.w	r3, r3, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80132e8:	bf18      	it	ne
 80132ea:	f022 0207 	bicne.w	r2, r2, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80132ee:	4611      	mov	r1, r2
	xStart.xBlockSize = ( size_t ) 0;
 80132f0:	2000      	movs	r0, #0
	pxEnd->pxNextFreeBlock = NULL;

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80132f2:	1a9a      	subs	r2, r3, r2
	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80132f4:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
	xStart.xBlockSize = ( size_t ) 0;
 80132f8:	e9c5 1000 	strd	r1, r0, [r5]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80132fc:	e9c5 2204 	strd	r2, r2, [r5, #16]
	pxEnd->pxNextFreeBlock = NULL;
 8013300:	e9c3 0000 	strd	r0, r0, [r3]
	pxEnd = ( void * ) uxAddress;
 8013304:	60ab      	str	r3, [r5, #8]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8013306:	e9c1 3200 	strd	r3, r2, [r1]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 801330a:	60ee      	str	r6, [r5, #12]
}
 801330c:	e7aa      	b.n	8013264 <pvPortMalloc+0x14>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 801330e:	481f      	ldr	r0, [pc, #124]	; (801338c <pvPortMalloc+0x13c>)
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8013310:	f8c2 e004 	str.w	lr, [r2, #4]
						pxBlock->xBlockSize = xWantedSize;
 8013314:	604c      	str	r4, [r1, #4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8013316:	4686      	mov	lr, r0
 8013318:	6800      	ldr	r0, [r0, #0]
 801331a:	4282      	cmp	r2, r0
 801331c:	d8fb      	bhi.n	8013316 <pvPortMalloc+0xc6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 801331e:	f8de 4004 	ldr.w	r4, [lr, #4]
 8013322:	eb0e 0804 	add.w	r8, lr, r4
 8013326:	4542      	cmp	r2, r8
 8013328:	d126      	bne.n	8013378 <pvPortMalloc+0x128>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801332a:	6852      	ldr	r2, [r2, #4]
 801332c:	4414      	add	r4, r2
 801332e:	f8ce 4004 	str.w	r4, [lr, #4]
		pxBlockToInsert = pxIterator;
 8013332:	4672      	mov	r2, lr
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8013334:	eb02 0804 	add.w	r8, r2, r4
 8013338:	4540      	cmp	r0, r8
 801333a:	d01f      	beq.n	801337c <pvPortMalloc+0x12c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 801333c:	6010      	str	r0, [r2, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 801333e:	4596      	cmp	lr, r2
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8013340:	6848      	ldr	r0, [r1, #4]
 8013342:	bf18      	it	ne
 8013344:	f8ce 2000 	strne.w	r2, [lr]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8013348:	692a      	ldr	r2, [r5, #16]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 801334a:	ebac 0300 	sub.w	r3, ip, r0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801334e:	4293      	cmp	r3, r2
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8013350:	bf38      	it	cc
 8013352:	612b      	strcc	r3, [r5, #16]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8013354:	616b      	str	r3, [r5, #20]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8013356:	4330      	orrs	r0, r6
					pxBlock->pxNextFreeBlock = NULL;
 8013358:	2300      	movs	r3, #0
 801335a:	e9c1 3000 	strd	r3, r0, [r1]
	( void ) xTaskResumeAll();
 801335e:	f7ff fa61 	bl	8012824 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8013362:	077b      	lsls	r3, r7, #29
 8013364:	d0b2      	beq.n	80132cc <pvPortMalloc+0x7c>
 8013366:	f04f 0320 	mov.w	r3, #32
 801336a:	f383 8811 	msr	BASEPRI, r3
 801336e:	f3bf 8f6f 	isb	sy
 8013372:	f3bf 8f4f 	dsb	sy
 8013376:	e7fe      	b.n	8013376 <pvPortMalloc+0x126>
 8013378:	6854      	ldr	r4, [r2, #4]
 801337a:	e7db      	b.n	8013334 <pvPortMalloc+0xe4>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 801337c:	4298      	cmp	r0, r3
 801337e:	d0dd      	beq.n	801333c <pvPortMalloc+0xec>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8013380:	e9d0 0300 	ldrd	r0, r3, [r0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8013384:	441c      	add	r4, r3
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8013386:	6010      	str	r0, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8013388:	6054      	str	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801338a:	e7d8      	b.n	801333e <pvPortMalloc+0xee>
 801338c:	20001d84 	.word	0x20001d84
 8013390:	20001d9c 	.word	0x20001d9c

08013394 <vPortFree>:
	if( pv != NULL )
 8013394:	b1e0      	cbz	r0, 80133d0 <vPortFree+0x3c>
{
 8013396:	b570      	push	{r4, r5, r6, lr}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8013398:	4d25      	ldr	r5, [pc, #148]	; (8013430 <vPortFree+0x9c>)
 801339a:	f850 3c04 	ldr.w	r3, [r0, #-4]
 801339e:	68ea      	ldr	r2, [r5, #12]
 80133a0:	4213      	tst	r3, r2
 80133a2:	4604      	mov	r4, r0
 80133a4:	d00b      	beq.n	80133be <vPortFree+0x2a>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 80133a6:	f850 1c08 	ldr.w	r1, [r0, #-8]
 80133aa:	b191      	cbz	r1, 80133d2 <vPortFree+0x3e>
 80133ac:	f04f 0320 	mov.w	r3, #32
 80133b0:	f383 8811 	msr	BASEPRI, r3
 80133b4:	f3bf 8f6f 	isb	sy
 80133b8:	f3bf 8f4f 	dsb	sy
 80133bc:	e7fe      	b.n	80133bc <vPortFree+0x28>
 80133be:	f04f 0320 	mov.w	r3, #32
 80133c2:	f383 8811 	msr	BASEPRI, r3
 80133c6:	f3bf 8f6f 	isb	sy
 80133ca:	f3bf 8f4f 	dsb	sy
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80133ce:	e7fe      	b.n	80133ce <vPortFree+0x3a>
 80133d0:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80133d2:	ea23 0302 	bic.w	r3, r3, r2
 80133d6:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 80133da:	f7ff f8f9 	bl	80125d0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80133de:	696b      	ldr	r3, [r5, #20]
 80133e0:	f854 0c04 	ldr.w	r0, [r4, #-4]
 80133e4:	181a      	adds	r2, r3, r0
 80133e6:	616a      	str	r2, [r5, #20]
		puc -= xHeapStructSize;
 80133e8:	f1a4 0308 	sub.w	r3, r4, #8
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80133ec:	462a      	mov	r2, r5
 80133ee:	4611      	mov	r1, r2
 80133f0:	6812      	ldr	r2, [r2, #0]
 80133f2:	4293      	cmp	r3, r2
 80133f4:	d8fb      	bhi.n	80133ee <vPortFree+0x5a>
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80133f6:	684c      	ldr	r4, [r1, #4]
 80133f8:	190e      	adds	r6, r1, r4
 80133fa:	42b3      	cmp	r3, r6
 80133fc:	d00a      	beq.n	8013414 <vPortFree+0x80>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80133fe:	181c      	adds	r4, r3, r0
 8013400:	42a2      	cmp	r2, r4
 8013402:	d00b      	beq.n	801341c <vPortFree+0x88>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8013404:	601a      	str	r2, [r3, #0]
	if( pxIterator != pxBlockToInsert )
 8013406:	4299      	cmp	r1, r3
}
 8013408:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 801340c:	bf18      	it	ne
 801340e:	600b      	strne	r3, [r1, #0]
				( void ) xTaskResumeAll();
 8013410:	f7ff ba08 	b.w	8012824 <xTaskResumeAll>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8013414:	4420      	add	r0, r4
 8013416:	6048      	str	r0, [r1, #4]
		pxBlockToInsert = pxIterator;
 8013418:	460b      	mov	r3, r1
 801341a:	e7f0      	b.n	80133fe <vPortFree+0x6a>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 801341c:	68ac      	ldr	r4, [r5, #8]
 801341e:	42a2      	cmp	r2, r4
 8013420:	d0f0      	beq.n	8013404 <vPortFree+0x70>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8013422:	e9d2 2400 	ldrd	r2, r4, [r2]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8013426:	4420      	add	r0, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8013428:	601a      	str	r2, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 801342a:	6058      	str	r0, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801342c:	e7eb      	b.n	8013406 <vPortFree+0x72>
 801342e:	bf00      	nop
 8013430:	20001d84 	.word	0x20001d84

08013434 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8013434:	4808      	ldr	r0, [pc, #32]	; (8013458 <prvPortStartFirstTask+0x24>)
 8013436:	6800      	ldr	r0, [r0, #0]
 8013438:	6800      	ldr	r0, [r0, #0]
 801343a:	f380 8808 	msr	MSP, r0
 801343e:	f04f 0000 	mov.w	r0, #0
 8013442:	f380 8814 	msr	CONTROL, r0
 8013446:	b662      	cpsie	i
 8013448:	b661      	cpsie	f
 801344a:	f3bf 8f4f 	dsb	sy
 801344e:	f3bf 8f6f 	isb	sy
 8013452:	df00      	svc	0
 8013454:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8013456:	0000      	.short	0x0000
 8013458:	e000ed08 	.word	0xe000ed08

0801345c <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 801345c:	f8df 000c 	ldr.w	r0, [pc, #12]	; 801346c <vPortEnableVFP+0x10>
 8013460:	6801      	ldr	r1, [r0, #0]
 8013462:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8013466:	6001      	str	r1, [r0, #0]
 8013468:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 801346a:	0000      	.short	0x0000
 801346c:	e000ed88 	.word	0xe000ed88

08013470 <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
 8013470:	4b0e      	ldr	r3, [pc, #56]	; (80134ac <prvTaskExitError+0x3c>)
 8013472:	681b      	ldr	r3, [r3, #0]
{
 8013474:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8013476:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 8013478:	3301      	adds	r3, #1
volatile uint32_t ulDummy = 0;
 801347a:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 801347c:	d008      	beq.n	8013490 <prvTaskExitError+0x20>
 801347e:	f04f 0320 	mov.w	r3, #32
 8013482:	f383 8811 	msr	BASEPRI, r3
 8013486:	f3bf 8f6f 	isb	sy
 801348a:	f3bf 8f4f 	dsb	sy
 801348e:	e7fe      	b.n	801348e <prvTaskExitError+0x1e>
 8013490:	f04f 0320 	mov.w	r3, #32
 8013494:	f383 8811 	msr	BASEPRI, r3
 8013498:	f3bf 8f6f 	isb	sy
 801349c:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 80134a0:	9b01      	ldr	r3, [sp, #4]
 80134a2:	2b00      	cmp	r3, #0
 80134a4:	d0fc      	beq.n	80134a0 <prvTaskExitError+0x30>
}
 80134a6:	b002      	add	sp, #8
 80134a8:	4770      	bx	lr
 80134aa:	bf00      	nop
 80134ac:	20000134 	.word	0x20000134

080134b0 <pxPortInitialiseStack>:
{
 80134b0:	b430      	push	{r4, r5}
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80134b2:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80134b6:	4c09      	ldr	r4, [pc, #36]	; (80134dc <pxPortInitialiseStack+0x2c>)
 80134b8:	f840 4c0c 	str.w	r4, [r0, #-12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80134bc:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80134c0:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80134c4:	f840 5c04 	str.w	r5, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80134c8:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80134cc:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80134d0:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80134d4:	bc30      	pop	{r4, r5}
 80134d6:	3844      	subs	r0, #68	; 0x44
 80134d8:	4770      	bx	lr
 80134da:	bf00      	nop
 80134dc:	08013471 	.word	0x08013471

080134e0 <SVC_Handler>:
	__asm volatile (
 80134e0:	4b07      	ldr	r3, [pc, #28]	; (8013500 <pxCurrentTCBConst2>)
 80134e2:	6819      	ldr	r1, [r3, #0]
 80134e4:	6808      	ldr	r0, [r1, #0]
 80134e6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80134ea:	f380 8809 	msr	PSP, r0
 80134ee:	f3bf 8f6f 	isb	sy
 80134f2:	f04f 0000 	mov.w	r0, #0
 80134f6:	f380 8811 	msr	BASEPRI, r0
 80134fa:	4770      	bx	lr
 80134fc:	f3af 8000 	nop.w

08013500 <pxCurrentTCBConst2>:
 8013500:	20001cc8 	.word	0x20001cc8

08013504 <vPortEnterCritical>:
 8013504:	f04f 0320 	mov.w	r3, #32
 8013508:	f383 8811 	msr	BASEPRI, r3
 801350c:	f3bf 8f6f 	isb	sy
 8013510:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8013514:	4a0a      	ldr	r2, [pc, #40]	; (8013540 <vPortEnterCritical+0x3c>)
 8013516:	6813      	ldr	r3, [r2, #0]
 8013518:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 801351a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 801351c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 801351e:	d000      	beq.n	8013522 <vPortEnterCritical+0x1e>
}
 8013520:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8013522:	4b08      	ldr	r3, [pc, #32]	; (8013544 <vPortEnterCritical+0x40>)
 8013524:	681b      	ldr	r3, [r3, #0]
 8013526:	f013 0fff 	tst.w	r3, #255	; 0xff
 801352a:	d0f9      	beq.n	8013520 <vPortEnterCritical+0x1c>
 801352c:	f04f 0320 	mov.w	r3, #32
 8013530:	f383 8811 	msr	BASEPRI, r3
 8013534:	f3bf 8f6f 	isb	sy
 8013538:	f3bf 8f4f 	dsb	sy
 801353c:	e7fe      	b.n	801353c <vPortEnterCritical+0x38>
 801353e:	bf00      	nop
 8013540:	20000134 	.word	0x20000134
 8013544:	e000ed04 	.word	0xe000ed04

08013548 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8013548:	4a08      	ldr	r2, [pc, #32]	; (801356c <vPortExitCritical+0x24>)
 801354a:	6813      	ldr	r3, [r2, #0]
 801354c:	b943      	cbnz	r3, 8013560 <vPortExitCritical+0x18>
 801354e:	f04f 0320 	mov.w	r3, #32
 8013552:	f383 8811 	msr	BASEPRI, r3
 8013556:	f3bf 8f6f 	isb	sy
 801355a:	f3bf 8f4f 	dsb	sy
 801355e:	e7fe      	b.n	801355e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8013560:	3b01      	subs	r3, #1
 8013562:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8013564:	b90b      	cbnz	r3, 801356a <vPortExitCritical+0x22>
	__asm volatile
 8013566:	f383 8811 	msr	BASEPRI, r3
}
 801356a:	4770      	bx	lr
 801356c:	20000134 	.word	0x20000134

08013570 <PendSV_Handler>:
	__asm volatile
 8013570:	f3ef 8009 	mrs	r0, PSP
 8013574:	f3bf 8f6f 	isb	sy
 8013578:	4b15      	ldr	r3, [pc, #84]	; (80135d0 <pxCurrentTCBConst>)
 801357a:	681a      	ldr	r2, [r3, #0]
 801357c:	f01e 0f10 	tst.w	lr, #16
 8013580:	bf08      	it	eq
 8013582:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8013586:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801358a:	6010      	str	r0, [r2, #0]
 801358c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8013590:	f04f 0020 	mov.w	r0, #32
 8013594:	f380 8811 	msr	BASEPRI, r0
 8013598:	f3bf 8f4f 	dsb	sy
 801359c:	f3bf 8f6f 	isb	sy
 80135a0:	f7ff f96a 	bl	8012878 <vTaskSwitchContext>
 80135a4:	f04f 0000 	mov.w	r0, #0
 80135a8:	f380 8811 	msr	BASEPRI, r0
 80135ac:	bc09      	pop	{r0, r3}
 80135ae:	6819      	ldr	r1, [r3, #0]
 80135b0:	6808      	ldr	r0, [r1, #0]
 80135b2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80135b6:	f01e 0f10 	tst.w	lr, #16
 80135ba:	bf08      	it	eq
 80135bc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80135c0:	f380 8809 	msr	PSP, r0
 80135c4:	f3bf 8f6f 	isb	sy
 80135c8:	4770      	bx	lr
 80135ca:	bf00      	nop
 80135cc:	f3af 8000 	nop.w

080135d0 <pxCurrentTCBConst>:
 80135d0:	20001cc8 	.word	0x20001cc8

080135d4 <xPortSysTickHandler>:
{
 80135d4:	b508      	push	{r3, lr}
	__asm volatile
 80135d6:	f04f 0320 	mov.w	r3, #32
 80135da:	f383 8811 	msr	BASEPRI, r3
 80135de:	f3bf 8f6f 	isb	sy
 80135e2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80135e6:	f7ff f803 	bl	80125f0 <xTaskIncrementTick>
 80135ea:	b118      	cbz	r0, 80135f4 <xPortSysTickHandler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80135ec:	4b03      	ldr	r3, [pc, #12]	; (80135fc <xPortSysTickHandler+0x28>)
 80135ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80135f2:	601a      	str	r2, [r3, #0]
	__asm volatile
 80135f4:	2300      	movs	r3, #0
 80135f6:	f383 8811 	msr	BASEPRI, r3
}
 80135fa:	bd08      	pop	{r3, pc}
 80135fc:	e000ed04 	.word	0xe000ed04

08013600 <vPortSetupTimerInterrupt>:
{
 8013600:	b430      	push	{r4, r5}
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8013602:	4a09      	ldr	r2, [pc, #36]	; (8013628 <vPortSetupTimerInterrupt+0x28>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8013604:	4d09      	ldr	r5, [pc, #36]	; (801362c <vPortSetupTimerInterrupt+0x2c>)
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8013606:	4b0a      	ldr	r3, [pc, #40]	; (8013630 <vPortSetupTimerInterrupt+0x30>)
 8013608:	4c0a      	ldr	r4, [pc, #40]	; (8013634 <vPortSetupTimerInterrupt+0x34>)
 801360a:	480b      	ldr	r0, [pc, #44]	; (8013638 <vPortSetupTimerInterrupt+0x38>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 801360c:	2100      	movs	r1, #0
 801360e:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8013610:	6029      	str	r1, [r5, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8013612:	681b      	ldr	r3, [r3, #0]
 8013614:	fba4 1303 	umull	r1, r3, r4, r3
 8013618:	099b      	lsrs	r3, r3, #6
 801361a:	3b01      	subs	r3, #1
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 801361c:	2107      	movs	r1, #7
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 801361e:	6003      	str	r3, [r0, #0]
}
 8013620:	bc30      	pop	{r4, r5}
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8013622:	6011      	str	r1, [r2, #0]
}
 8013624:	4770      	bx	lr
 8013626:	bf00      	nop
 8013628:	e000e010 	.word	0xe000e010
 801362c:	e000e018 	.word	0xe000e018
 8013630:	20000124 	.word	0x20000124
 8013634:	10624dd3 	.word	0x10624dd3
 8013638:	e000e014 	.word	0xe000e014

0801363c <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 801363c:	4b44      	ldr	r3, [pc, #272]	; (8013750 <xPortStartScheduler+0x114>)
 801363e:	4a45      	ldr	r2, [pc, #276]	; (8013754 <xPortStartScheduler+0x118>)
 8013640:	6819      	ldr	r1, [r3, #0]
 8013642:	4291      	cmp	r1, r2
 8013644:	d03f      	beq.n	80136c6 <xPortStartScheduler+0x8a>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8013646:	681a      	ldr	r2, [r3, #0]
 8013648:	4b43      	ldr	r3, [pc, #268]	; (8013758 <xPortStartScheduler+0x11c>)
 801364a:	429a      	cmp	r2, r3
 801364c:	d032      	beq.n	80136b4 <xPortStartScheduler+0x78>
{
 801364e:	b530      	push	{r4, r5, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8013650:	4b42      	ldr	r3, [pc, #264]	; (801375c <xPortStartScheduler+0x120>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8013652:	4a43      	ldr	r2, [pc, #268]	; (8013760 <xPortStartScheduler+0x124>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8013654:	7819      	ldrb	r1, [r3, #0]
{
 8013656:	b085      	sub	sp, #20
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8013658:	20ff      	movs	r0, #255	; 0xff
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 801365a:	b2c9      	uxtb	r1, r1
 801365c:	9102      	str	r1, [sp, #8]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 801365e:	7018      	strb	r0, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8013660:	781b      	ldrb	r3, [r3, #0]
 8013662:	b2db      	uxtb	r3, r3
 8013664:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8013668:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801366c:	f89d 1007 	ldrb.w	r1, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8013670:	f003 0320 	and.w	r3, r3, #32
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8013674:	2007      	movs	r0, #7
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8013676:	060c      	lsls	r4, r1, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8013678:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 801367a:	6050      	str	r0, [r2, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801367c:	bf48      	it	mi
 801367e:	2106      	movmi	r1, #6
 8013680:	d50f      	bpl.n	80136a2 <xPortStartScheduler+0x66>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8013682:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8013686:	005b      	lsls	r3, r3, #1
 8013688:	b2db      	uxtb	r3, r3
 801368a:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 801368e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8013692:	0600      	lsls	r0, r0, #24
 8013694:	460b      	mov	r3, r1
 8013696:	f101 31ff 	add.w	r1, r1, #4294967295
 801369a:	d4f2      	bmi.n	8013682 <xPortStartScheduler+0x46>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 801369c:	2b03      	cmp	r3, #3
 801369e:	d01b      	beq.n	80136d8 <xPortStartScheduler+0x9c>
 80136a0:	6053      	str	r3, [r2, #4]
	__asm volatile
 80136a2:	f04f 0320 	mov.w	r3, #32
 80136a6:	f383 8811 	msr	BASEPRI, r3
 80136aa:	f3bf 8f6f 	isb	sy
 80136ae:	f3bf 8f4f 	dsb	sy
 80136b2:	e7fe      	b.n	80136b2 <xPortStartScheduler+0x76>
 80136b4:	f04f 0320 	mov.w	r3, #32
 80136b8:	f383 8811 	msr	BASEPRI, r3
 80136bc:	f3bf 8f6f 	isb	sy
 80136c0:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80136c4:	e7fe      	b.n	80136c4 <xPortStartScheduler+0x88>
 80136c6:	f04f 0320 	mov.w	r3, #32
 80136ca:	f383 8811 	msr	BASEPRI, r3
 80136ce:	f3bf 8f6f 	isb	sy
 80136d2:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80136d6:	e7fe      	b.n	80136d6 <xPortStartScheduler+0x9a>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80136d8:	9902      	ldr	r1, [sp, #8]
 80136da:	4820      	ldr	r0, [pc, #128]	; (801375c <xPortStartScheduler+0x120>)
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80136dc:	4b21      	ldr	r3, [pc, #132]	; (8013764 <xPortStartScheduler+0x128>)
	uxCriticalNesting = 0;
 80136de:	4c22      	ldr	r4, [pc, #136]	; (8013768 <xPortStartScheduler+0x12c>)
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80136e0:	b2c9      	uxtb	r1, r1
 80136e2:	7001      	strb	r1, [r0, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80136e4:	6819      	ldr	r1, [r3, #0]
 80136e6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80136ea:	6019      	str	r1, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80136ec:	6819      	ldr	r1, [r3, #0]
 80136ee:	f041 4170 	orr.w	r1, r1, #4026531840	; 0xf0000000
 80136f2:	6019      	str	r1, [r3, #0]
	uxCriticalNesting = 0;
 80136f4:	2500      	movs	r5, #0
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80136f6:	f44f 7340 	mov.w	r3, #768	; 0x300
 80136fa:	6053      	str	r3, [r2, #4]
	vPortSetupTimerInterrupt();
 80136fc:	f7ff ff80 	bl	8013600 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8013700:	6025      	str	r5, [r4, #0]
	vPortEnableVFP();
 8013702:	f7ff feab 	bl	801345c <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8013706:	4a19      	ldr	r2, [pc, #100]	; (801376c <xPortStartScheduler+0x130>)
 8013708:	6813      	ldr	r3, [r2, #0]
 801370a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 801370e:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8013710:	f7ff fe90 	bl	8013434 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8013714:	f7ff f8b0 	bl	8012878 <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
 8013718:	6823      	ldr	r3, [r4, #0]
volatile uint32_t ulDummy = 0;
 801371a:	9503      	str	r5, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
 801371c:	3301      	adds	r3, #1
 801371e:	d008      	beq.n	8013732 <xPortStartScheduler+0xf6>
 8013720:	f04f 0320 	mov.w	r3, #32
 8013724:	f383 8811 	msr	BASEPRI, r3
 8013728:	f3bf 8f6f 	isb	sy
 801372c:	f3bf 8f4f 	dsb	sy
 8013730:	e7fe      	b.n	8013730 <xPortStartScheduler+0xf4>
 8013732:	f04f 0320 	mov.w	r3, #32
 8013736:	f383 8811 	msr	BASEPRI, r3
 801373a:	f3bf 8f6f 	isb	sy
 801373e:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
 8013742:	9b03      	ldr	r3, [sp, #12]
 8013744:	2b00      	cmp	r3, #0
 8013746:	d0fc      	beq.n	8013742 <xPortStartScheduler+0x106>
}
 8013748:	2000      	movs	r0, #0
 801374a:	b005      	add	sp, #20
 801374c:	bd30      	pop	{r4, r5, pc}
 801374e:	bf00      	nop
 8013750:	e000ed00 	.word	0xe000ed00
 8013754:	410fc271 	.word	0x410fc271
 8013758:	410fc270 	.word	0x410fc270
 801375c:	e000e400 	.word	0xe000e400
 8013760:	20010d9c 	.word	0x20010d9c
 8013764:	e000ed20 	.word	0xe000ed20
 8013768:	20000134 	.word	0x20000134
 801376c:	e000ef34 	.word	0xe000ef34

08013770 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8013770:	f3ef 8205 	mrs	r2, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8013774:	2a0f      	cmp	r2, #15
 8013776:	d811      	bhi.n	801379c <vPortValidateInterruptPriority+0x2c>
 8013778:	4b10      	ldr	r3, [pc, #64]	; (80137bc <vPortValidateInterruptPriority+0x4c>)
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 801377a:	4911      	ldr	r1, [pc, #68]	; (80137c0 <vPortValidateInterruptPriority+0x50>)
 801377c:	685a      	ldr	r2, [r3, #4]
 801377e:	680b      	ldr	r3, [r1, #0]
 8013780:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8013784:	4293      	cmp	r3, r2
 8013786:	d908      	bls.n	801379a <vPortValidateInterruptPriority+0x2a>
 8013788:	f04f 0320 	mov.w	r3, #32
 801378c:	f383 8811 	msr	BASEPRI, r3
 8013790:	f3bf 8f6f 	isb	sy
 8013794:	f3bf 8f4f 	dsb	sy
 8013798:	e7fe      	b.n	8013798 <vPortValidateInterruptPriority+0x28>
	}
 801379a:	4770      	bx	lr
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 801379c:	4909      	ldr	r1, [pc, #36]	; (80137c4 <vPortValidateInterruptPriority+0x54>)
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 801379e:	4b07      	ldr	r3, [pc, #28]	; (80137bc <vPortValidateInterruptPriority+0x4c>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 80137a0:	5c52      	ldrb	r2, [r2, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 80137a2:	7819      	ldrb	r1, [r3, #0]
 80137a4:	4291      	cmp	r1, r2
 80137a6:	d9e8      	bls.n	801377a <vPortValidateInterruptPriority+0xa>
 80137a8:	f04f 0320 	mov.w	r3, #32
 80137ac:	f383 8811 	msr	BASEPRI, r3
 80137b0:	f3bf 8f6f 	isb	sy
 80137b4:	f3bf 8f4f 	dsb	sy
 80137b8:	e7fe      	b.n	80137b8 <vPortValidateInterruptPriority+0x48>
 80137ba:	bf00      	nop
 80137bc:	20010d9c 	.word	0x20010d9c
 80137c0:	e000ed0c 	.word	0xe000ed0c
 80137c4:	e000e3f0 	.word	0xe000e3f0

080137c8 <json_object_resize>:

static JSON_Status json_object_resize(JSON_Object *object, size_t new_capacity) {
    char **temp_names = NULL;
    JSON_Value **temp_values = NULL;

    if ((object->names == NULL && object->values != NULL) ||
 80137c8:	6843      	ldr	r3, [r0, #4]
static JSON_Status json_object_resize(JSON_Object *object, size_t new_capacity) {
 80137ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80137ce:	4604      	mov	r4, r0
 80137d0:	460d      	mov	r5, r1
    if ((object->names == NULL && object->values != NULL) ||
 80137d2:	b323      	cbz	r3, 801381e <json_object_resize+0x56>
        (object->names != NULL && object->values == NULL) ||
 80137d4:	6883      	ldr	r3, [r0, #8]
 80137d6:	b32b      	cbz	r3, 8013824 <json_object_resize+0x5c>
 80137d8:	b325      	cbz	r5, 8013824 <json_object_resize+0x5c>
        new_capacity == 0) {
            return JSONFailure; /* Shouldn't happen */
    }
    temp_names = (char**)parson_malloc(new_capacity * sizeof(char*));
 80137da:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8013850 <json_object_resize+0x88>
 80137de:	00af      	lsls	r7, r5, #2
 80137e0:	f8d8 3000 	ldr.w	r3, [r8]
 80137e4:	4638      	mov	r0, r7
 80137e6:	4798      	blx	r3
    if (temp_names == NULL) {
 80137e8:	4606      	mov	r6, r0
 80137ea:	b1d8      	cbz	r0, 8013824 <json_object_resize+0x5c>
        return JSONFailure;
    }
    temp_values = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 80137ec:	4638      	mov	r0, r7
 80137ee:	f8d8 3000 	ldr.w	r3, [r8]
 80137f2:	4798      	blx	r3
    if (temp_values == NULL) {
 80137f4:	4607      	mov	r7, r0
 80137f6:	b328      	cbz	r0, 8013844 <json_object_resize+0x7c>
        parson_free(temp_names);
        return JSONFailure;
    }
    if (object->names != NULL && object->values != NULL && object->count > 0) {
 80137f8:	6860      	ldr	r0, [r4, #4]
 80137fa:	b118      	cbz	r0, 8013804 <json_object_resize+0x3c>
 80137fc:	68a3      	ldr	r3, [r4, #8]
 80137fe:	b10b      	cbz	r3, 8013804 <json_object_resize+0x3c>
 8013800:	68e2      	ldr	r2, [r4, #12]
 8013802:	b992      	cbnz	r2, 801382a <json_object_resize+0x62>
        memcpy(temp_names, object->names, object->count * sizeof(char*));
        memcpy(temp_values, object->values, object->count * sizeof(JSON_Value*));
    }
    parson_free(object->names);
 8013804:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8013808:	4798      	blx	r3
    parson_free(object->values);
 801380a:	68a0      	ldr	r0, [r4, #8]
 801380c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8013810:	4798      	blx	r3
    object->names = temp_names;
    object->values = temp_values;
 8013812:	e9c4 6701 	strd	r6, r7, [r4, #4]
    object->capacity = new_capacity;
 8013816:	6125      	str	r5, [r4, #16]
    return JSONSuccess;
 8013818:	2000      	movs	r0, #0
}
 801381a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((object->names == NULL && object->values != NULL) ||
 801381e:	6883      	ldr	r3, [r0, #8]
 8013820:	2b00      	cmp	r3, #0
 8013822:	d0d9      	beq.n	80137d8 <json_object_resize+0x10>
        return JSONFailure;
 8013824:	f04f 30ff 	mov.w	r0, #4294967295
 8013828:	e7f7      	b.n	801381a <json_object_resize+0x52>
        memcpy(temp_names, object->names, object->count * sizeof(char*));
 801382a:	4601      	mov	r1, r0
 801382c:	0092      	lsls	r2, r2, #2
 801382e:	4630      	mov	r0, r6
 8013830:	f002 fb86 	bl	8015f40 <memcpy>
        memcpy(temp_values, object->values, object->count * sizeof(JSON_Value*));
 8013834:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8013838:	4638      	mov	r0, r7
 801383a:	0092      	lsls	r2, r2, #2
 801383c:	f002 fb80 	bl	8015f40 <memcpy>
 8013840:	6860      	ldr	r0, [r4, #4]
 8013842:	e7df      	b.n	8013804 <json_object_resize+0x3c>
        parson_free(temp_names);
 8013844:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8013848:	4630      	mov	r0, r6
 801384a:	4798      	blx	r3
 801384c:	e7ea      	b.n	8013824 <json_object_resize+0x5c>
 801384e:	bf00      	nop
 8013850:	20000138 	.word	0x20000138

08013854 <json_object_addn>:
    if (object == NULL || name == NULL || value == NULL) {
 8013854:	2800      	cmp	r0, #0
 8013856:	d05b      	beq.n	8013910 <json_object_addn+0xbc>
static JSON_Status json_object_addn(JSON_Object *object, const char *name, size_t name_len, JSON_Value *value) {
 8013858:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801385c:	4688      	mov	r8, r1
    if (object == NULL || name == NULL || value == NULL) {
 801385e:	2900      	cmp	r1, #0
 8013860:	d053      	beq.n	801390a <json_object_addn+0xb6>
 8013862:	461f      	mov	r7, r3
 8013864:	2b00      	cmp	r3, #0
 8013866:	d050      	beq.n	801390a <json_object_addn+0xb6>
int json_object_dotget_boolean(const JSON_Object *object, const char *name) {
    return json_value_get_boolean(json_object_dotget_value(object, name));
}

size_t json_object_get_count(const JSON_Object *object) {
    return object ? object->count : 0;
 8013868:	68c5      	ldr	r5, [r0, #12]
 801386a:	4616      	mov	r6, r2
 801386c:	4604      	mov	r4, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 801386e:	b1c5      	cbz	r5, 80138a2 <json_object_addn+0x4e>
 8013870:	6843      	ldr	r3, [r0, #4]
 8013872:	f04f 0900 	mov.w	r9, #0
 8013876:	f1a3 0a04 	sub.w	sl, r3, #4
        name_length = strlen(object->names[i]);
 801387a:	f85a bf04 	ldr.w	fp, [sl, #4]!
 801387e:	4658      	mov	r0, fp
 8013880:	f7ec fcc8 	bl	8000214 <strlen>
 8013884:	4603      	mov	r3, r0
        if (name_length != name_len) {
 8013886:	429e      	cmp	r6, r3
        if (strncmp(object->names[i], name, name_len) == 0) {
 8013888:	4658      	mov	r0, fp
 801388a:	4632      	mov	r2, r6
 801388c:	ea4f 0b89 	mov.w	fp, r9, lsl #2
 8013890:	4641      	mov	r1, r8
    for (i = 0; i < json_object_get_count(object); i++) {
 8013892:	f109 0901 	add.w	r9, r9, #1
        if (name_length != name_len) {
 8013896:	d102      	bne.n	801389e <json_object_addn+0x4a>
        if (strncmp(object->names[i], name, name_len) == 0) {
 8013898:	f003 f93e 	bl	8016b18 <strncmp>
 801389c:	b380      	cbz	r0, 8013900 <json_object_addn+0xac>
    for (i = 0; i < json_object_get_count(object); i++) {
 801389e:	45a9      	cmp	r9, r5
 80138a0:	d1eb      	bne.n	801387a <json_object_addn+0x26>
    if (object->count >= object->capacity) {
 80138a2:	6921      	ldr	r1, [r4, #16]
 80138a4:	42a9      	cmp	r1, r5
 80138a6:	d920      	bls.n	80138ea <json_object_addn+0x96>
    char *output_string = (char*)parson_malloc(n + 1);
 80138a8:	4b1b      	ldr	r3, [pc, #108]	; (8013918 <json_object_addn+0xc4>)
    object->names[index] = parson_strndup(name, name_len);
 80138aa:	f8d4 9004 	ldr.w	r9, [r4, #4]
    char *output_string = (char*)parson_malloc(n + 1);
 80138ae:	681b      	ldr	r3, [r3, #0]
 80138b0:	1c70      	adds	r0, r6, #1
 80138b2:	4798      	blx	r3
    object->names[index] = parson_strndup(name, name_len);
 80138b4:	ea4f 0a85 	mov.w	sl, r5, lsl #2
    if (!output_string) {
 80138b8:	4605      	mov	r5, r0
 80138ba:	b128      	cbz	r0, 80138c8 <json_object_addn+0x74>
    output_string[n] = '\0';
 80138bc:	2300      	movs	r3, #0
 80138be:	5583      	strb	r3, [r0, r6]
    strncpy(output_string, string, n);
 80138c0:	4641      	mov	r1, r8
 80138c2:	4632      	mov	r2, r6
 80138c4:	f003 f93a 	bl	8016b3c <strncpy>
    object->names[index] = parson_strndup(name, name_len);
 80138c8:	f849 500a 	str.w	r5, [r9, sl]
    if (object->names[index] == NULL) {
 80138cc:	6863      	ldr	r3, [r4, #4]
 80138ce:	f853 300a 	ldr.w	r3, [r3, sl]
 80138d2:	b1d3      	cbz	r3, 801390a <json_object_addn+0xb6>
    object->values[index] = value;
 80138d4:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
    value->parent = json_object_get_wrapping_value(object);
 80138d8:	6821      	ldr	r1, [r4, #0]
 80138da:	6039      	str	r1, [r7, #0]
    object->count++;
 80138dc:	3301      	adds	r3, #1
    object->values[index] = value;
 80138de:	f842 700a 	str.w	r7, [r2, sl]
    return JSONSuccess;
 80138e2:	2000      	movs	r0, #0
    object->count++;
 80138e4:	60e3      	str	r3, [r4, #12]
}
 80138e6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        size_t new_capacity = MAX(object->capacity * 2, STARTING_CAPACITY);
 80138ea:	0049      	lsls	r1, r1, #1
        if (json_object_resize(object, new_capacity) == JSONFailure) {
 80138ec:	2910      	cmp	r1, #16
 80138ee:	bf38      	it	cc
 80138f0:	2110      	movcc	r1, #16
 80138f2:	4620      	mov	r0, r4
 80138f4:	f7ff ff68 	bl	80137c8 <json_object_resize>
 80138f8:	3001      	adds	r0, #1
 80138fa:	d006      	beq.n	801390a <json_object_addn+0xb6>
 80138fc:	68e5      	ldr	r5, [r4, #12]
 80138fe:	e7d3      	b.n	80138a8 <json_object_addn+0x54>
            return object->values[i];
 8013900:	68a3      	ldr	r3, [r4, #8]
    if (json_object_getn_value(object, name, name_len) != NULL) {
 8013902:	f853 300b 	ldr.w	r3, [r3, fp]
 8013906:	2b00      	cmp	r3, #0
 8013908:	d0cb      	beq.n	80138a2 <json_object_addn+0x4e>
        return JSONFailure;
 801390a:	f04f 30ff 	mov.w	r0, #4294967295
 801390e:	e7ea      	b.n	80138e6 <json_object_addn+0x92>
 8013910:	f04f 30ff 	mov.w	r0, #4294967295
}
 8013914:	4770      	bx	lr
 8013916:	bf00      	nop
 8013918:	20000138 	.word	0x20000138

0801391c <json_array_add>:
static JSON_Status json_array_add(JSON_Array *array, JSON_Value *value) {
 801391c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (array->count >= array->capacity) {
 8013920:	e9d0 3702 	ldrd	r3, r7, [r0, #8]
 8013924:	42bb      	cmp	r3, r7
static JSON_Status json_array_add(JSON_Array *array, JSON_Value *value) {
 8013926:	4604      	mov	r4, r0
 8013928:	460d      	mov	r5, r1
    if (array->count >= array->capacity) {
 801392a:	d209      	bcs.n	8013940 <json_array_add+0x24>
 801392c:	6846      	ldr	r6, [r0, #4]
    value->parent = json_array_get_wrapping_value(array);
 801392e:	6822      	ldr	r2, [r4, #0]
 8013930:	602a      	str	r2, [r5, #0]
    array->count++;
 8013932:	1c5a      	adds	r2, r3, #1
    array->items[array->count] = value;
 8013934:	f846 5023 	str.w	r5, [r6, r3, lsl #2]
    return JSONSuccess;
 8013938:	2000      	movs	r0, #0
    array->count++;
 801393a:	60a2      	str	r2, [r4, #8]
}
 801393c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        size_t new_capacity = MAX(array->capacity * 2, STARTING_CAPACITY);
 8013940:	007f      	lsls	r7, r7, #1
 8013942:	2f10      	cmp	r7, #16
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 8013944:	f8df 8038 	ldr.w	r8, [pc, #56]	; 8013980 <json_array_add+0x64>
        size_t new_capacity = MAX(array->capacity * 2, STARTING_CAPACITY);
 8013948:	bf38      	it	cc
 801394a:	2710      	movcc	r7, #16
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 801394c:	f8d8 3000 	ldr.w	r3, [r8]
 8013950:	00b8      	lsls	r0, r7, #2
 8013952:	4798      	blx	r3
    if (new_items == NULL) {
 8013954:	4606      	mov	r6, r0
 8013956:	b180      	cbz	r0, 801397a <json_array_add+0x5e>
    if (array->items != NULL && array->count > 0) {
 8013958:	6861      	ldr	r1, [r4, #4]
 801395a:	b109      	cbz	r1, 8013960 <json_array_add+0x44>
 801395c:	68a2      	ldr	r2, [r4, #8]
 801395e:	b93a      	cbnz	r2, 8013970 <json_array_add+0x54>
    parson_free(array->items);
 8013960:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8013964:	4608      	mov	r0, r1
 8013966:	4798      	blx	r3
    array->items = new_items;
 8013968:	68a3      	ldr	r3, [r4, #8]
 801396a:	6066      	str	r6, [r4, #4]
    array->capacity = new_capacity;
 801396c:	60e7      	str	r7, [r4, #12]
    return JSONSuccess;
 801396e:	e7de      	b.n	801392e <json_array_add+0x12>
        memcpy(new_items, array->items, array->count * sizeof(JSON_Value*));
 8013970:	0092      	lsls	r2, r2, #2
 8013972:	f002 fae5 	bl	8015f40 <memcpy>
 8013976:	6861      	ldr	r1, [r4, #4]
 8013978:	e7f2      	b.n	8013960 <json_array_add+0x44>
            return JSONFailure;
 801397a:	f04f 30ff 	mov.w	r0, #4294967295
 801397e:	e7dd      	b.n	801393c <json_array_add+0x20>
 8013980:	20000138 	.word	0x20000138

08013984 <parse_utf16_hex>:
    if (s[0] == '\0' || s[1] == '\0' || s[2] == '\0' || s[3] == '\0') {
 8013984:	7803      	ldrb	r3, [r0, #0]
 8013986:	2b00      	cmp	r3, #0
 8013988:	d05d      	beq.n	8013a46 <parse_utf16_hex+0xc2>
static int parse_utf16_hex(const char *s, unsigned int *result) {
 801398a:	b470      	push	{r4, r5, r6}
    if (s[0] == '\0' || s[1] == '\0' || s[2] == '\0' || s[3] == '\0') {
 801398c:	7844      	ldrb	r4, [r0, #1]
 801398e:	2c00      	cmp	r4, #0
 8013990:	d056      	beq.n	8013a40 <parse_utf16_hex+0xbc>
 8013992:	7885      	ldrb	r5, [r0, #2]
 8013994:	2d00      	cmp	r5, #0
 8013996:	d053      	beq.n	8013a40 <parse_utf16_hex+0xbc>
 8013998:	78c0      	ldrb	r0, [r0, #3]
 801399a:	2800      	cmp	r0, #0
 801399c:	d051      	beq.n	8013a42 <parse_utf16_hex+0xbe>
    if (c >= '0' && c <= '9') {
 801399e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 80139a2:	b2d6      	uxtb	r6, r2
 80139a4:	2e09      	cmp	r6, #9
 80139a6:	d90b      	bls.n	80139c0 <parse_utf16_hex+0x3c>
    } else if (c >= 'a' && c <= 'f') {
 80139a8:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 80139ac:	2a05      	cmp	r2, #5
 80139ae:	d94c      	bls.n	8013a4a <parse_utf16_hex+0xc6>
    } else if (c >= 'A' && c <= 'F') {
 80139b0:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 80139b4:	2a05      	cmp	r2, #5
        return c - 'A' + 10;
 80139b6:	bf94      	ite	ls
 80139b8:	f1a3 0237 	subls.w	r2, r3, #55	; 0x37
    return -1;
 80139bc:	f04f 32ff 	movhi.w	r2, #4294967295
    if (c >= '0' && c <= '9') {
 80139c0:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 80139c4:	b2de      	uxtb	r6, r3
 80139c6:	2e09      	cmp	r6, #9
 80139c8:	d90b      	bls.n	80139e2 <parse_utf16_hex+0x5e>
    } else if (c >= 'a' && c <= 'f') {
 80139ca:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 80139ce:	2b05      	cmp	r3, #5
 80139d0:	d944      	bls.n	8013a5c <parse_utf16_hex+0xd8>
    } else if (c >= 'A' && c <= 'F') {
 80139d2:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 80139d6:	2b05      	cmp	r3, #5
        return c - 'A' + 10;
 80139d8:	bf94      	ite	ls
 80139da:	f1a4 0337 	subls.w	r3, r4, #55	; 0x37
    return -1;
 80139de:	f04f 33ff 	movhi.w	r3, #4294967295
    if (c >= '0' && c <= '9') {
 80139e2:	f1a5 0630 	sub.w	r6, r5, #48	; 0x30
 80139e6:	b2f4      	uxtb	r4, r6
 80139e8:	2c09      	cmp	r4, #9
 80139ea:	d90b      	bls.n	8013a04 <parse_utf16_hex+0x80>
    } else if (c >= 'a' && c <= 'f') {
 80139ec:	f1a5 0461 	sub.w	r4, r5, #97	; 0x61
 80139f0:	2c05      	cmp	r4, #5
 80139f2:	d930      	bls.n	8013a56 <parse_utf16_hex+0xd2>
    } else if (c >= 'A' && c <= 'F') {
 80139f4:	f1a5 0441 	sub.w	r4, r5, #65	; 0x41
 80139f8:	2c05      	cmp	r4, #5
        return c - 'A' + 10;
 80139fa:	bf94      	ite	ls
 80139fc:	f1a5 0637 	subls.w	r6, r5, #55	; 0x37
    return -1;
 8013a00:	f04f 36ff 	movhi.w	r6, #4294967295
    if (c >= '0' && c <= '9') {
 8013a04:	f1a0 0530 	sub.w	r5, r0, #48	; 0x30
 8013a08:	b2ec      	uxtb	r4, r5
 8013a0a:	2c09      	cmp	r4, #9
 8013a0c:	d909      	bls.n	8013a22 <parse_utf16_hex+0x9e>
    } else if (c >= 'a' && c <= 'f') {
 8013a0e:	f1a0 0461 	sub.w	r4, r0, #97	; 0x61
 8013a12:	2c05      	cmp	r4, #5
 8013a14:	d91c      	bls.n	8013a50 <parse_utf16_hex+0xcc>
    } else if (c >= 'A' && c <= 'F') {
 8013a16:	f1a0 0441 	sub.w	r4, r0, #65	; 0x41
 8013a1a:	2c05      	cmp	r4, #5
 8013a1c:	d810      	bhi.n	8013a40 <parse_utf16_hex+0xbc>
        return c - 'A' + 10;
 8013a1e:	f1a0 0537 	sub.w	r5, r0, #55	; 0x37
    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {
 8013a22:	1c50      	adds	r0, r2, #1
 8013a24:	d00c      	beq.n	8013a40 <parse_utf16_hex+0xbc>
 8013a26:	1c5c      	adds	r4, r3, #1
 8013a28:	d00a      	beq.n	8013a40 <parse_utf16_hex+0xbc>
 8013a2a:	1c70      	adds	r0, r6, #1
 8013a2c:	d008      	beq.n	8013a40 <parse_utf16_hex+0xbc>
    *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);
 8013a2e:	021b      	lsls	r3, r3, #8
 8013a30:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 8013a34:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 8013a38:	432b      	orrs	r3, r5
 8013a3a:	600b      	str	r3, [r1, #0]
    return 1;
 8013a3c:	2001      	movs	r0, #1
 8013a3e:	e000      	b.n	8013a42 <parse_utf16_hex+0xbe>
        return 0;
 8013a40:	2000      	movs	r0, #0
}
 8013a42:	bc70      	pop	{r4, r5, r6}
 8013a44:	4770      	bx	lr
        return 0;
 8013a46:	4618      	mov	r0, r3
}
 8013a48:	4770      	bx	lr
        return c - 'a' + 10;
 8013a4a:	f1a3 0257 	sub.w	r2, r3, #87	; 0x57
 8013a4e:	e7b7      	b.n	80139c0 <parse_utf16_hex+0x3c>
 8013a50:	f1a0 0557 	sub.w	r5, r0, #87	; 0x57
 8013a54:	e7e5      	b.n	8013a22 <parse_utf16_hex+0x9e>
 8013a56:	f1a5 0657 	sub.w	r6, r5, #87	; 0x57
 8013a5a:	e7d3      	b.n	8013a04 <parse_utf16_hex+0x80>
 8013a5c:	f1a4 0357 	sub.w	r3, r4, #87	; 0x57
 8013a60:	e7bf      	b.n	80139e2 <parse_utf16_hex+0x5e>
 8013a62:	bf00      	nop

08013a64 <get_quoted_string>:
static char * get_quoted_string(const char **string) {
 8013a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const char *string_start = *string;
 8013a68:	6805      	ldr	r5, [r0, #0]
    if (**string != '\"') {
 8013a6a:	782b      	ldrb	r3, [r5, #0]
 8013a6c:	2b22      	cmp	r3, #34	; 0x22
static char * get_quoted_string(const char **string) {
 8013a6e:	b085      	sub	sp, #20
    if (**string != '\"') {
 8013a70:	d157      	bne.n	8013b22 <get_quoted_string+0xbe>
    SKIP_CHAR(string);
 8013a72:	1c6e      	adds	r6, r5, #1
 8013a74:	6006      	str	r6, [r0, #0]
    while (**string != '\"') {
 8013a76:	786a      	ldrb	r2, [r5, #1]
 8013a78:	2a22      	cmp	r2, #34	; 0x22
 8013a7a:	4634      	mov	r4, r6
 8013a7c:	d009      	beq.n	8013a92 <get_quoted_string+0x2e>
        if (**string == '\0') {
 8013a7e:	2a00      	cmp	r2, #0
 8013a80:	d04f      	beq.n	8013b22 <get_quoted_string+0xbe>
        } else if (**string == '\\') {
 8013a82:	2a5c      	cmp	r2, #92	; 0x5c
 8013a84:	d052      	beq.n	8013b2c <get_quoted_string+0xc8>
 8013a86:	6802      	ldr	r2, [r0, #0]
        SKIP_CHAR(string);
 8013a88:	1c54      	adds	r4, r2, #1
 8013a8a:	6004      	str	r4, [r0, #0]
    while (**string != '\"') {
 8013a8c:	7852      	ldrb	r2, [r2, #1]
 8013a8e:	2a22      	cmp	r2, #34	; 0x22
 8013a90:	d1f5      	bne.n	8013a7e <get_quoted_string+0x1a>
    SKIP_CHAR(string);
 8013a92:	3401      	adds	r4, #1
    output = (char*)parson_malloc(initial_size);
 8013a94:	4f79      	ldr	r7, [pc, #484]	; (8013c7c <get_quoted_string+0x218>)
    SKIP_CHAR(string);
 8013a96:	6004      	str	r4, [r0, #0]
    string_len = *string - string_start - 2; /* length without quotes */
 8013a98:	1b64      	subs	r4, r4, r5
    output = (char*)parson_malloc(initial_size);
 8013a9a:	1e60      	subs	r0, r4, #1
 8013a9c:	683b      	ldr	r3, [r7, #0]
 8013a9e:	4798      	blx	r3
    string_len = *string - string_start - 2; /* length without quotes */
 8013aa0:	3c02      	subs	r4, #2
    if (output == NULL) {
 8013aa2:	4681      	mov	r9, r0
 8013aa4:	2800      	cmp	r0, #0
 8013aa6:	d039      	beq.n	8013b1c <get_quoted_string+0xb8>
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013aa8:	786b      	ldrb	r3, [r5, #1]
 8013aaa:	2b00      	cmp	r3, #0
 8013aac:	f000 80e3 	beq.w	8013c76 <get_quoted_string+0x212>
 8013ab0:	2c00      	cmp	r4, #0
 8013ab2:	f000 80e0 	beq.w	8013c76 <get_quoted_string+0x212>
        cp = ((((lead - 0xD800) & 0x3FF) << 10) | ((trail - 0xDC00) & 0x3FF)) + 0x010000;
 8013ab6:	f8df a1c8 	ldr.w	sl, [pc, #456]	; 8013c80 <get_quoted_string+0x21c>
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013aba:	4605      	mov	r5, r0
    const char *input_ptr = input;
 8013abc:	46b0      	mov	r8, r6
 8013abe:	e00d      	b.n	8013adc <get_quoted_string+0x78>
        } else if ((unsigned char)*input_ptr < 0x20) {
 8013ac0:	2b1f      	cmp	r3, #31
 8013ac2:	d92b      	bls.n	8013b1c <get_quoted_string+0xb8>
            *output_ptr = *input_ptr;
 8013ac4:	702b      	strb	r3, [r5, #0]
 8013ac6:	4640      	mov	r0, r8
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013ac8:	7843      	ldrb	r3, [r0, #1]
        output_ptr++;
 8013aca:	3501      	adds	r5, #1
        input_ptr++;
 8013acc:	f100 0801 	add.w	r8, r0, #1
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013ad0:	2b00      	cmp	r3, #0
 8013ad2:	d039      	beq.n	8013b48 <get_quoted_string+0xe4>
 8013ad4:	eba8 0206 	sub.w	r2, r8, r6
 8013ad8:	4294      	cmp	r4, r2
 8013ada:	d935      	bls.n	8013b48 <get_quoted_string+0xe4>
        if (*input_ptr == '\\') {
 8013adc:	2b5c      	cmp	r3, #92	; 0x5c
 8013ade:	d1ef      	bne.n	8013ac0 <get_quoted_string+0x5c>
            switch (*input_ptr) {
 8013ae0:	f898 3001 	ldrb.w	r3, [r8, #1]
 8013ae4:	2b75      	cmp	r3, #117	; 0x75
            input_ptr++;
 8013ae6:	f108 0001 	add.w	r0, r8, #1
            switch (*input_ptr) {
 8013aea:	d817      	bhi.n	8013b1c <get_quoted_string+0xb8>
 8013aec:	2b5b      	cmp	r3, #91	; 0x5b
 8013aee:	d911      	bls.n	8013b14 <get_quoted_string+0xb0>
 8013af0:	3b5c      	subs	r3, #92	; 0x5c
 8013af2:	2b19      	cmp	r3, #25
 8013af4:	d812      	bhi.n	8013b1c <get_quoted_string+0xb8>
 8013af6:	e8df f003 	tbb	[pc, r3]
 8013afa:	111f      	.short	0x111f
 8013afc:	11111111 	.word	0x11111111
 8013b00:	11111166 	.word	0x11111166
 8013b04:	11111163 	.word	0x11111163
 8013b08:	11111111 	.word	0x11111111
 8013b0c:	11111160 	.word	0x11111160
 8013b10:	3e5a115d 	.word	0x3e5a115d
 8013b14:	2b22      	cmp	r3, #34	; 0x22
 8013b16:	d010      	beq.n	8013b3a <get_quoted_string+0xd6>
 8013b18:	2b2f      	cmp	r3, #47	; 0x2f
 8013b1a:	d00e      	beq.n	8013b3a <get_quoted_string+0xd6>
    parson_free(output);
 8013b1c:	687b      	ldr	r3, [r7, #4]
 8013b1e:	4648      	mov	r0, r9
 8013b20:	4798      	blx	r3
    return NULL;
 8013b22:	2400      	movs	r4, #0
}
 8013b24:	4620      	mov	r0, r4
 8013b26:	b005      	add	sp, #20
 8013b28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SKIP_CHAR(string);
 8013b2c:	1c62      	adds	r2, r4, #1
 8013b2e:	6002      	str	r2, [r0, #0]
            if (**string == '\0') {
 8013b30:	7863      	ldrb	r3, [r4, #1]
 8013b32:	2b00      	cmp	r3, #0
 8013b34:	d1a8      	bne.n	8013a88 <get_quoted_string+0x24>
 8013b36:	e7f4      	b.n	8013b22 <get_quoted_string+0xbe>
                case '\\': *output_ptr = '\\'; break;
 8013b38:	235c      	movs	r3, #92	; 0x5c
 8013b3a:	702b      	strb	r3, [r5, #0]
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013b3c:	7843      	ldrb	r3, [r0, #1]
        output_ptr++;
 8013b3e:	3501      	adds	r5, #1
        input_ptr++;
 8013b40:	f100 0801 	add.w	r8, r0, #1
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013b44:	2b00      	cmp	r3, #0
 8013b46:	d1c5      	bne.n	8013ad4 <get_quoted_string+0x70>
 8013b48:	eba5 0209 	sub.w	r2, r5, r9
 8013b4c:	3201      	adds	r2, #1
    *output_ptr = '\0';
 8013b4e:	2300      	movs	r3, #0
 8013b50:	702b      	strb	r3, [r5, #0]
    resized_output = (char*)parson_malloc(final_size);
 8013b52:	4610      	mov	r0, r2
 8013b54:	683b      	ldr	r3, [r7, #0]
 8013b56:	9201      	str	r2, [sp, #4]
 8013b58:	4798      	blx	r3
    if (resized_output == NULL) {
 8013b5a:	4604      	mov	r4, r0
 8013b5c:	2800      	cmp	r0, #0
 8013b5e:	d0dd      	beq.n	8013b1c <get_quoted_string+0xb8>
    memcpy(resized_output, output, final_size);
 8013b60:	9a01      	ldr	r2, [sp, #4]
 8013b62:	4649      	mov	r1, r9
 8013b64:	f002 f9ec 	bl	8015f40 <memcpy>
    parson_free(output);
 8013b68:	4648      	mov	r0, r9
 8013b6a:	687b      	ldr	r3, [r7, #4]
 8013b6c:	4798      	blx	r3
}
 8013b6e:	4620      	mov	r0, r4
 8013b70:	b005      	add	sp, #20
 8013b72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    unprocessed_ptr++; /* skips u */
 8013b76:	f108 0b02 	add.w	fp, r8, #2
    parse_succeeded = parse_utf16_hex(unprocessed_ptr, &cp);
 8013b7a:	4658      	mov	r0, fp
 8013b7c:	a902      	add	r1, sp, #8
 8013b7e:	f7ff ff01 	bl	8013984 <parse_utf16_hex>
    if (!parse_succeeded) {
 8013b82:	2800      	cmp	r0, #0
 8013b84:	d0ca      	beq.n	8013b1c <get_quoted_string+0xb8>
    if (cp < 0x80) {
 8013b86:	9b02      	ldr	r3, [sp, #8]
 8013b88:	2b7f      	cmp	r3, #127	; 0x7f
 8013b8a:	d91f      	bls.n	8013bcc <get_quoted_string+0x168>
    } else if (cp < 0x800) {
 8013b8c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8013b90:	d21e      	bcs.n	8013bd0 <get_quoted_string+0x16c>
        processed_ptr[0] = ((cp >> 6) & 0x1F) | 0xC0; /* 110xxxxx */
 8013b92:	099b      	lsrs	r3, r3, #6
 8013b94:	f063 033f 	orn	r3, r3, #63	; 0x3f
 8013b98:	702b      	strb	r3, [r5, #0]
        processed_ptr[1] = ((cp)      & 0x3F) | 0x80; /* 10xxxxxx */
 8013b9a:	9b02      	ldr	r3, [sp, #8]
 8013b9c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8013ba0:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013ba4:	f805 3f01 	strb.w	r3, [r5, #1]!
    unprocessed_ptr += 3;
 8013ba8:	f10b 0003 	add.w	r0, fp, #3
    return JSONSuccess;
 8013bac:	e78c      	b.n	8013ac8 <get_quoted_string+0x64>
                case 't':  *output_ptr = '\t'; break;
 8013bae:	2309      	movs	r3, #9
 8013bb0:	702b      	strb	r3, [r5, #0]
 8013bb2:	e789      	b.n	8013ac8 <get_quoted_string+0x64>
                case 'r':  *output_ptr = '\r'; break;
 8013bb4:	230d      	movs	r3, #13
 8013bb6:	702b      	strb	r3, [r5, #0]
 8013bb8:	e786      	b.n	8013ac8 <get_quoted_string+0x64>
                case 'n':  *output_ptr = '\n'; break;
 8013bba:	230a      	movs	r3, #10
 8013bbc:	702b      	strb	r3, [r5, #0]
 8013bbe:	e783      	b.n	8013ac8 <get_quoted_string+0x64>
                case 'f':  *output_ptr = '\f'; break;
 8013bc0:	230c      	movs	r3, #12
 8013bc2:	702b      	strb	r3, [r5, #0]
 8013bc4:	e780      	b.n	8013ac8 <get_quoted_string+0x64>
                case 'b':  *output_ptr = '\b'; break;
 8013bc6:	2308      	movs	r3, #8
 8013bc8:	702b      	strb	r3, [r5, #0]
 8013bca:	e77d      	b.n	8013ac8 <get_quoted_string+0x64>
        processed_ptr[0] = (char)cp; /* 0xxxxxxx */
 8013bcc:	702b      	strb	r3, [r5, #0]
 8013bce:	e7eb      	b.n	8013ba8 <get_quoted_string+0x144>
    } else if (cp < 0xD800 || cp > 0xDFFF) {
 8013bd0:	f5a3 4258 	sub.w	r2, r3, #55296	; 0xd800
 8013bd4:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8013bd8:	d23a      	bcs.n	8013c50 <get_quoted_string+0x1ec>
    } else if (cp >= 0xD800 && cp <= 0xDBFF) { /* lead surrogate (0xD800..0xDBFF) */
 8013bda:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8013bde:	9301      	str	r3, [sp, #4]
 8013be0:	d29c      	bcs.n	8013b1c <get_quoted_string+0xb8>
        if (*unprocessed_ptr++ != '\\' || *unprocessed_ptr++ != 'u') {
 8013be2:	f898 2006 	ldrb.w	r2, [r8, #6]
 8013be6:	2a5c      	cmp	r2, #92	; 0x5c
 8013be8:	d198      	bne.n	8013b1c <get_quoted_string+0xb8>
 8013bea:	f898 2007 	ldrb.w	r2, [r8, #7]
 8013bee:	2a75      	cmp	r2, #117	; 0x75
 8013bf0:	f108 0b08 	add.w	fp, r8, #8
 8013bf4:	d192      	bne.n	8013b1c <get_quoted_string+0xb8>
        parse_succeeded = parse_utf16_hex(unprocessed_ptr, &trail);
 8013bf6:	a903      	add	r1, sp, #12
 8013bf8:	4658      	mov	r0, fp
 8013bfa:	f7ff fec3 	bl	8013984 <parse_utf16_hex>
        if (!parse_succeeded || trail < 0xDC00 || trail > 0xDFFF) { /* valid trail surrogate? (0xDC00..0xDFFF) */
 8013bfe:	2800      	cmp	r0, #0
 8013c00:	d08c      	beq.n	8013b1c <get_quoted_string+0xb8>
 8013c02:	9a03      	ldr	r2, [sp, #12]
 8013c04:	f5a2 415c 	sub.w	r1, r2, #56320	; 0xdc00
 8013c08:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8013c0c:	d286      	bcs.n	8013b1c <get_quoted_string+0xb8>
        cp = ((((lead - 0xD800) & 0x3FF) << 10) | ((trail - 0xDC00) & 0x3FF)) + 0x010000;
 8013c0e:	9b01      	ldr	r3, [sp, #4]
 8013c10:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8013c14:	ea0a 2383 	and.w	r3, sl, r3, lsl #10
 8013c18:	4313      	orrs	r3, r2
 8013c1a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
        processed_ptr[0] = (((cp >> 18) & 0x07) | 0xF0); /* 11110xxx */
 8013c1e:	0c9a      	lsrs	r2, r3, #18
 8013c20:	f062 020f 	orn	r2, r2, #15
        cp = ((((lead - 0xD800) & 0x3FF) << 10) | ((trail - 0xDC00) & 0x3FF)) + 0x010000;
 8013c24:	9302      	str	r3, [sp, #8]
        processed_ptr[0] = (((cp >> 18) & 0x07) | 0xF0); /* 11110xxx */
 8013c26:	702a      	strb	r2, [r5, #0]
        processed_ptr[1] = (((cp >> 12) & 0x3F) | 0x80); /* 10xxxxxx */
 8013c28:	9b02      	ldr	r3, [sp, #8]
 8013c2a:	f3c3 3305 	ubfx	r3, r3, #12, #6
 8013c2e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013c32:	706b      	strb	r3, [r5, #1]
        processed_ptr[2] = (((cp >> 6)  & 0x3F) | 0x80); /* 10xxxxxx */
 8013c34:	9b02      	ldr	r3, [sp, #8]
 8013c36:	f3c3 1385 	ubfx	r3, r3, #6, #6
 8013c3a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013c3e:	70ab      	strb	r3, [r5, #2]
        processed_ptr[3] = (((cp)       & 0x3F) | 0x80); /* 10xxxxxx */
 8013c40:	9b02      	ldr	r3, [sp, #8]
 8013c42:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8013c46:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013c4a:	f805 3f03 	strb.w	r3, [r5, #3]!
        processed_ptr += 3;
 8013c4e:	e7ab      	b.n	8013ba8 <get_quoted_string+0x144>
        processed_ptr[0] = ((cp >> 12) & 0x0F) | 0xE0; /* 1110xxxx */
 8013c50:	f3c3 3303 	ubfx	r3, r3, #12, #4
 8013c54:	f063 031f 	orn	r3, r3, #31
 8013c58:	702b      	strb	r3, [r5, #0]
        processed_ptr[1] = ((cp >> 6)  & 0x3F) | 0x80; /* 10xxxxxx */
 8013c5a:	9b02      	ldr	r3, [sp, #8]
 8013c5c:	f3c3 1385 	ubfx	r3, r3, #6, #6
 8013c60:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013c64:	706b      	strb	r3, [r5, #1]
        processed_ptr[2] = ((cp)       & 0x3F) | 0x80; /* 10xxxxxx */
 8013c66:	9b02      	ldr	r3, [sp, #8]
 8013c68:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8013c6c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013c70:	f805 3f02 	strb.w	r3, [r5, #2]!
        processed_ptr += 2;
 8013c74:	e798      	b.n	8013ba8 <get_quoted_string+0x144>
    while ((*input_ptr != '\0') && (size_t)(input_ptr - input) < len) {
 8013c76:	464d      	mov	r5, r9
 8013c78:	2201      	movs	r2, #1
 8013c7a:	e768      	b.n	8013b4e <get_quoted_string+0xea>
 8013c7c:	20000138 	.word	0x20000138
 8013c80:	000ffc00 	.word	0x000ffc00

08013c84 <json_serialize_string>:
static int json_serialize_string(const char *string, char *buf) {
 8013c84:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013c88:	460c      	mov	r4, r1
 8013c8a:	4605      	mov	r5, r0
    size_t i = 0, len = strlen(string);
 8013c8c:	f7ec fac2 	bl	8000214 <strlen>
 8013c90:	4606      	mov	r6, r0
    if (buf == NULL) {
 8013c92:	2c00      	cmp	r4, #0
 8013c94:	f000 81e0 	beq.w	8014058 <json_serialize_string+0x3d4>
    return sprintf(buf, "%s", string);
 8013c98:	4b98      	ldr	r3, [pc, #608]	; (8013efc <json_serialize_string+0x278>)
 8013c9a:	881a      	ldrh	r2, [r3, #0]
 8013c9c:	f824 2b01 	strh.w	r2, [r4], #1
    for (i = 0; i < len; i++) {
 8013ca0:	2800      	cmp	r0, #0
 8013ca2:	f000 81de 	beq.w	8014062 <json_serialize_string+0x3de>
    return sprintf(buf, "%s", string);
 8013ca6:	f8df 9278 	ldr.w	r9, [pc, #632]	; 8013f20 <json_serialize_string+0x29c>
 8013caa:	f8df 8278 	ldr.w	r8, [pc, #632]	; 8013f24 <json_serialize_string+0x2a0>
 8013cae:	f8df e278 	ldr.w	lr, [pc, #632]	; 8013f28 <json_serialize_string+0x2a4>
 8013cb2:	f8df c278 	ldr.w	ip, [pc, #632]	; 8013f2c <json_serialize_string+0x2a8>
 8013cb6:	1e6a      	subs	r2, r5, #1
static int json_serialize_string(const char *string, char *buf) {
 8013cb8:	2101      	movs	r1, #1
        c = string[i];
 8013cba:	4613      	mov	r3, r2
 8013cbc:	f812 0f01 	ldrb.w	r0, [r2, #1]!
        switch (c) {
 8013cc0:	285c      	cmp	r0, #92	; 0x5c
 8013cc2:	d85e      	bhi.n	8013d82 <json_serialize_string+0xfe>
 8013cc4:	e8df f010 	tbh	[pc, r0, lsl #1]
 8013cc8:	01b101b7 	.word	0x01b101b7
 8013ccc:	01a501ab 	.word	0x01a501ab
 8013cd0:	0199019f 	.word	0x0199019f
 8013cd4:	018d0193 	.word	0x018d0193
 8013cd8:	01730180 	.word	0x01730180
 8013cdc:	01600166 	.word	0x01600166
 8013ce0:	01460153 	.word	0x01460153
 8013ce4:	010f0114 	.word	0x010f0114
 8013ce8:	0105010a 	.word	0x0105010a
 8013cec:	00fb0100 	.word	0x00fb0100
 8013cf0:	00f100f6 	.word	0x00f100f6
 8013cf4:	00de00ec 	.word	0x00de00ec
 8013cf8:	00d500d9 	.word	0x00d500d9
 8013cfc:	00cd00d1 	.word	0x00cd00d1
 8013d00:	00b100bf 	.word	0x00b100bf
 8013d04:	009000a3 	.word	0x009000a3
 8013d08:	005d005d 	.word	0x005d005d
 8013d0c:	005d0084 	.word	0x005d0084
 8013d10:	005d005d 	.word	0x005d005d
 8013d14:	005d005d 	.word	0x005d005d
 8013d18:	005d005d 	.word	0x005d005d
 8013d1c:	005d005d 	.word	0x005d005d
 8013d20:	005d005d 	.word	0x005d005d
 8013d24:	0078005d 	.word	0x0078005d
 8013d28:	005d005d 	.word	0x005d005d
 8013d2c:	005d005d 	.word	0x005d005d
 8013d30:	005d005d 	.word	0x005d005d
 8013d34:	005d005d 	.word	0x005d005d
 8013d38:	005d005d 	.word	0x005d005d
 8013d3c:	005d005d 	.word	0x005d005d
 8013d40:	005d005d 	.word	0x005d005d
 8013d44:	005d005d 	.word	0x005d005d
 8013d48:	005d005d 	.word	0x005d005d
 8013d4c:	005d005d 	.word	0x005d005d
 8013d50:	005d005d 	.word	0x005d005d
 8013d54:	005d005d 	.word	0x005d005d
 8013d58:	005d005d 	.word	0x005d005d
 8013d5c:	005d005d 	.word	0x005d005d
 8013d60:	005d005d 	.word	0x005d005d
 8013d64:	005d005d 	.word	0x005d005d
 8013d68:	005d005d 	.word	0x005d005d
 8013d6c:	005d005d 	.word	0x005d005d
 8013d70:	005d005d 	.word	0x005d005d
 8013d74:	005d005d 	.word	0x005d005d
 8013d78:	005d005d 	.word	0x005d005d
 8013d7c:	005d005d 	.word	0x005d005d
 8013d80:	006d      	.short	0x006d
                if (buf != NULL) {
 8013d82:	b10c      	cbz	r4, 8013d88 <json_serialize_string+0x104>
                    buf[0] = c;
 8013d84:	f804 0b01 	strb.w	r0, [r4], #1
    for (i = 0; i < len; i++) {
 8013d88:	3302      	adds	r3, #2
 8013d8a:	1b5b      	subs	r3, r3, r5
 8013d8c:	429e      	cmp	r6, r3
                written_total += 1;
 8013d8e:	f101 0101 	add.w	r1, r1, #1
    for (i = 0; i < len; i++) {
 8013d92:	d892      	bhi.n	8013cba <json_serialize_string+0x36>
    if (buf == NULL) {
 8013d94:	b114      	cbz	r4, 8013d9c <json_serialize_string+0x118>
 8013d96:	4b59      	ldr	r3, [pc, #356]	; (8013efc <json_serialize_string+0x278>)
    return sprintf(buf, "%s", string);
 8013d98:	881b      	ldrh	r3, [r3, #0]
 8013d9a:	8023      	strh	r3, [r4, #0]
    APPEND_STRING("\"");
 8013d9c:	1c48      	adds	r0, r1, #1
}
 8013d9e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (buf == NULL) {
 8013da2:	b13c      	cbz	r4, 8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013da4:	4856      	ldr	r0, [pc, #344]	; (8013f00 <json_serialize_string+0x27c>)
 8013da6:	f8b0 a000 	ldrh.w	sl, [r0]
 8013daa:	7880      	ldrb	r0, [r0, #2]
 8013dac:	f8a4 a000 	strh.w	sl, [r4]
 8013db0:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013db4:	3102      	adds	r1, #2
 8013db6:	e024      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013db8:	2c00      	cmp	r4, #0
 8013dba:	d0fb      	beq.n	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013dbc:	4851      	ldr	r0, [pc, #324]	; (8013f04 <json_serialize_string+0x280>)
 8013dbe:	f8b0 a000 	ldrh.w	sl, [r0]
 8013dc2:	7880      	ldrb	r0, [r0, #2]
 8013dc4:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013dc8:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013dca:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013dce:	e018      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013dd0:	2c00      	cmp	r4, #0
 8013dd2:	d0ef      	beq.n	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013dd4:	484c      	ldr	r0, [pc, #304]	; (8013f08 <json_serialize_string+0x284>)
 8013dd6:	f8b0 a000 	ldrh.w	sl, [r0]
 8013dda:	7880      	ldrb	r0, [r0, #2]
 8013ddc:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013de0:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013de2:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013de6:	e00c      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013de8:	b154      	cbz	r4, 8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013dea:	f8d9 0000 	ldr.w	r0, [r9]
 8013dee:	6020      	str	r0, [r4, #0]
 8013df0:	f8b9 a004 	ldrh.w	sl, [r9, #4]
 8013df4:	f899 0006 	ldrb.w	r0, [r9, #6]
 8013df8:	f8a4 a004 	strh.w	sl, [r4, #4]
 8013dfc:	f804 0f06 	strb.w	r0, [r4, #6]!
            case '\x1f': APPEND_STRING("\\u001f"); break;
 8013e00:	3106      	adds	r1, #6
    for (i = 0; i < len; i++) {
 8013e02:	3302      	adds	r3, #2
 8013e04:	1b5b      	subs	r3, r3, r5
 8013e06:	429e      	cmp	r6, r3
 8013e08:	f63f af57 	bhi.w	8013cba <json_serialize_string+0x36>
 8013e0c:	e7c2      	b.n	8013d94 <json_serialize_string+0x110>
    if (buf == NULL) {
 8013e0e:	2c00      	cmp	r4, #0
 8013e10:	d0f6      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e12:	f8d8 0000 	ldr.w	r0, [r8]
 8013e16:	6020      	str	r0, [r4, #0]
 8013e18:	f8b8 a004 	ldrh.w	sl, [r8, #4]
 8013e1c:	f898 0006 	ldrb.w	r0, [r8, #6]
 8013e20:	f8a4 a004 	strh.w	sl, [r4, #4]
 8013e24:	f804 0f06 	strb.w	r0, [r4, #6]!
            case '\x1e': APPEND_STRING("\\u001e"); break;
 8013e28:	e7ea      	b.n	8013e00 <json_serialize_string+0x17c>
    if (buf == NULL) {
 8013e2a:	2c00      	cmp	r4, #0
 8013e2c:	d0e8      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e2e:	f8de 0000 	ldr.w	r0, [lr]
 8013e32:	6020      	str	r0, [r4, #0]
 8013e34:	f8be a004 	ldrh.w	sl, [lr, #4]
 8013e38:	f89e 0006 	ldrb.w	r0, [lr, #6]
 8013e3c:	f8a4 a004 	strh.w	sl, [r4, #4]
 8013e40:	f804 0f06 	strb.w	r0, [r4, #6]!
            case '\x1d': APPEND_STRING("\\u001d"); break;
 8013e44:	e7dc      	b.n	8013e00 <json_serialize_string+0x17c>
    if (buf == NULL) {
 8013e46:	2c00      	cmp	r4, #0
 8013e48:	d0da      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e4a:	f8dc 0000 	ldr.w	r0, [ip]
 8013e4e:	6020      	str	r0, [r4, #0]
 8013e50:	f8bc a004 	ldrh.w	sl, [ip, #4]
 8013e54:	f89c 0006 	ldrb.w	r0, [ip, #6]
 8013e58:	f8a4 a004 	strh.w	sl, [r4, #4]
 8013e5c:	f804 0f06 	strb.w	r0, [r4, #6]!
            case '\x1c': APPEND_STRING("\\u001c"); break;
 8013e60:	e7ce      	b.n	8013e00 <json_serialize_string+0x17c>
    if (buf == NULL) {
 8013e62:	2c00      	cmp	r4, #0
 8013e64:	d0cc      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e66:	4f29      	ldr	r7, [pc, #164]	; (8013f0c <json_serialize_string+0x288>)
 8013e68:	e00a      	b.n	8013e80 <json_serialize_string+0x1fc>
    if (buf == NULL) {
 8013e6a:	2c00      	cmp	r4, #0
 8013e6c:	d0c8      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e6e:	4f28      	ldr	r7, [pc, #160]	; (8013f10 <json_serialize_string+0x28c>)
 8013e70:	e006      	b.n	8013e80 <json_serialize_string+0x1fc>
    if (buf == NULL) {
 8013e72:	2c00      	cmp	r4, #0
 8013e74:	d0c4      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e76:	4f27      	ldr	r7, [pc, #156]	; (8013f14 <json_serialize_string+0x290>)
 8013e78:	e002      	b.n	8013e80 <json_serialize_string+0x1fc>
    if (buf == NULL) {
 8013e7a:	2c00      	cmp	r4, #0
 8013e7c:	d0c0      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e7e:	4f26      	ldr	r7, [pc, #152]	; (8013f18 <json_serialize_string+0x294>)
 8013e80:	6838      	ldr	r0, [r7, #0]
 8013e82:	e004      	b.n	8013e8e <json_serialize_string+0x20a>
    if (buf == NULL) {
 8013e84:	2c00      	cmp	r4, #0
 8013e86:	d0bb      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013e88:	4824      	ldr	r0, [pc, #144]	; (8013f1c <json_serialize_string+0x298>)
 8013e8a:	4607      	mov	r7, r0
 8013e8c:	6800      	ldr	r0, [r0, #0]
 8013e8e:	6020      	str	r0, [r4, #0]
 8013e90:	f8b7 a004 	ldrh.w	sl, [r7, #4]
 8013e94:	79b8      	ldrb	r0, [r7, #6]
 8013e96:	f8a4 a004 	strh.w	sl, [r4, #4]
 8013e9a:	f804 0f06 	strb.w	r0, [r4, #6]!
            case '\x1b': APPEND_STRING("\\u001b"); break;
 8013e9e:	e7af      	b.n	8013e00 <json_serialize_string+0x17c>
    if (buf == NULL) {
 8013ea0:	2c00      	cmp	r4, #0
 8013ea2:	d0ad      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ea4:	f8df a088 	ldr.w	sl, [pc, #136]	; 8013f30 <json_serialize_string+0x2ac>
 8013ea8:	e0ca      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013eaa:	2c00      	cmp	r4, #0
 8013eac:	d0a8      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013eae:	f8df a084 	ldr.w	sl, [pc, #132]	; 8013f34 <json_serialize_string+0x2b0>
 8013eb2:	e0c5      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013eb4:	2c00      	cmp	r4, #0
 8013eb6:	d0a3      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013eb8:	f8df a07c 	ldr.w	sl, [pc, #124]	; 8013f38 <json_serialize_string+0x2b4>
 8013ebc:	e0c0      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013ebe:	2c00      	cmp	r4, #0
 8013ec0:	d09e      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ec2:	f8df a078 	ldr.w	sl, [pc, #120]	; 8013f3c <json_serialize_string+0x2b8>
 8013ec6:	e0bb      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013ec8:	2c00      	cmp	r4, #0
 8013eca:	d099      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ecc:	f8df a070 	ldr.w	sl, [pc, #112]	; 8013f40 <json_serialize_string+0x2bc>
 8013ed0:	e0b6      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013ed2:	2c00      	cmp	r4, #0
 8013ed4:	d094      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ed6:	f8df a06c 	ldr.w	sl, [pc, #108]	; 8013f44 <json_serialize_string+0x2c0>
 8013eda:	e0b1      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013edc:	2c00      	cmp	r4, #0
 8013ede:	d08f      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ee0:	f8df a064 	ldr.w	sl, [pc, #100]	; 8013f48 <json_serialize_string+0x2c4>
 8013ee4:	e0ac      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013ee6:	2c00      	cmp	r4, #0
 8013ee8:	d08a      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013eea:	f8df a060 	ldr.w	sl, [pc, #96]	; 8013f4c <json_serialize_string+0x2c8>
 8013eee:	e0a7      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013ef0:	2c00      	cmp	r4, #0
 8013ef2:	d085      	beq.n	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ef4:	f8df a058 	ldr.w	sl, [pc, #88]	; 8013f50 <json_serialize_string+0x2cc>
 8013ef8:	e0a2      	b.n	8014040 <json_serialize_string+0x3bc>
 8013efa:	bf00      	nop
 8013efc:	0801ab08 	.word	0x0801ab08
 8013f00:	0801ab10 	.word	0x0801ab10
 8013f04:	0801ab14 	.word	0x0801ab14
 8013f08:	0801ab0c 	.word	0x0801ab0c
 8013f0c:	0801abdc 	.word	0x0801abdc
 8013f10:	0801abd4 	.word	0x0801abd4
 8013f14:	0801abcc 	.word	0x0801abcc
 8013f18:	0801abc4 	.word	0x0801abc4
 8013f1c:	0801abbc 	.word	0x0801abbc
 8013f20:	0801abfc 	.word	0x0801abfc
 8013f24:	0801abf4 	.word	0x0801abf4
 8013f28:	0801abec 	.word	0x0801abec
 8013f2c:	0801abe4 	.word	0x0801abe4
 8013f30:	0801abb4 	.word	0x0801abb4
 8013f34:	0801abac 	.word	0x0801abac
 8013f38:	0801aba4 	.word	0x0801aba4
 8013f3c:	0801ab9c 	.word	0x0801ab9c
 8013f40:	0801ab94 	.word	0x0801ab94
 8013f44:	0801ab8c 	.word	0x0801ab8c
 8013f48:	0801ab84 	.word	0x0801ab84
 8013f4c:	0801ab7c 	.word	0x0801ab7c
 8013f50:	0801ab74 	.word	0x0801ab74
    if (buf == NULL) {
 8013f54:	2c00      	cmp	r4, #0
 8013f56:	f43f af2d 	beq.w	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013f5a:	4843      	ldr	r0, [pc, #268]	; (8014068 <json_serialize_string+0x3e4>)
 8013f5c:	f8b0 a000 	ldrh.w	sl, [r0]
 8013f60:	7880      	ldrb	r0, [r0, #2]
 8013f62:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013f66:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013f68:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013f6c:	e749      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013f6e:	2c00      	cmp	r4, #0
 8013f70:	f43f af20 	beq.w	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013f74:	483d      	ldr	r0, [pc, #244]	; (801406c <json_serialize_string+0x3e8>)
 8013f76:	f8b0 a000 	ldrh.w	sl, [r0]
 8013f7a:	7880      	ldrb	r0, [r0, #2]
 8013f7c:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013f80:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013f82:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013f86:	e73c      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013f88:	2c00      	cmp	r4, #0
 8013f8a:	f43f af39 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013f8e:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 801407c <json_serialize_string+0x3f8>
 8013f92:	e055      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013f94:	2c00      	cmp	r4, #0
 8013f96:	f43f af0d 	beq.w	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013f9a:	4835      	ldr	r0, [pc, #212]	; (8014070 <json_serialize_string+0x3ec>)
 8013f9c:	f8b0 a000 	ldrh.w	sl, [r0]
 8013fa0:	7880      	ldrb	r0, [r0, #2]
 8013fa2:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013fa6:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013fa8:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013fac:	e729      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013fae:	2c00      	cmp	r4, #0
 8013fb0:	f43f af00 	beq.w	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013fb4:	482f      	ldr	r0, [pc, #188]	; (8014074 <json_serialize_string+0x3f0>)
 8013fb6:	f8b0 a000 	ldrh.w	sl, [r0]
 8013fba:	7880      	ldrb	r0, [r0, #2]
 8013fbc:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013fc0:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013fc2:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013fc6:	e71c      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013fc8:	2c00      	cmp	r4, #0
 8013fca:	f43f aef3 	beq.w	8013db4 <json_serialize_string+0x130>
    return sprintf(buf, "%s", string);
 8013fce:	482a      	ldr	r0, [pc, #168]	; (8014078 <json_serialize_string+0x3f4>)
 8013fd0:	f8b0 a000 	ldrh.w	sl, [r0]
 8013fd4:	7880      	ldrb	r0, [r0, #2]
 8013fd6:	f8a4 a000 	strh.w	sl, [r4]
            case '\t': APPEND_STRING("\\t"); break;
 8013fda:	3102      	adds	r1, #2
    return sprintf(buf, "%s", string);
 8013fdc:	f804 0f02 	strb.w	r0, [r4, #2]!
            case '\t': APPEND_STRING("\\t"); break;
 8013fe0:	e70f      	b.n	8013e02 <json_serialize_string+0x17e>
    if (buf == NULL) {
 8013fe2:	2c00      	cmp	r4, #0
 8013fe4:	f43f af0c 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013fe8:	f8df a094 	ldr.w	sl, [pc, #148]	; 8014080 <json_serialize_string+0x3fc>
 8013fec:	e028      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013fee:	2c00      	cmp	r4, #0
 8013ff0:	f43f af06 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8013ff4:	f8df a08c 	ldr.w	sl, [pc, #140]	; 8014084 <json_serialize_string+0x400>
 8013ff8:	e022      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8013ffa:	2c00      	cmp	r4, #0
 8013ffc:	f43f af00 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8014000:	f8df a084 	ldr.w	sl, [pc, #132]	; 8014088 <json_serialize_string+0x404>
 8014004:	e01c      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8014006:	2c00      	cmp	r4, #0
 8014008:	f43f aefa 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 801400c:	f8df a07c 	ldr.w	sl, [pc, #124]	; 801408c <json_serialize_string+0x408>
 8014010:	e016      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8014012:	2c00      	cmp	r4, #0
 8014014:	f43f aef4 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8014018:	f8df a074 	ldr.w	sl, [pc, #116]	; 8014090 <json_serialize_string+0x40c>
 801401c:	e010      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 801401e:	2c00      	cmp	r4, #0
 8014020:	f43f aeee 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8014024:	f8df a06c 	ldr.w	sl, [pc, #108]	; 8014094 <json_serialize_string+0x410>
 8014028:	e00a      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 801402a:	2c00      	cmp	r4, #0
 801402c:	f43f aee8 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 8014030:	f8df a064 	ldr.w	sl, [pc, #100]	; 8014098 <json_serialize_string+0x414>
 8014034:	e004      	b.n	8014040 <json_serialize_string+0x3bc>
    if (buf == NULL) {
 8014036:	2c00      	cmp	r4, #0
 8014038:	f43f aee2 	beq.w	8013e00 <json_serialize_string+0x17c>
    return sprintf(buf, "%s", string);
 801403c:	f8df a05c 	ldr.w	sl, [pc, #92]	; 801409c <json_serialize_string+0x418>
 8014040:	f8da 0000 	ldr.w	r0, [sl]
 8014044:	f8ba b004 	ldrh.w	fp, [sl, #4]
 8014048:	f89a a006 	ldrb.w	sl, [sl, #6]
 801404c:	6020      	str	r0, [r4, #0]
 801404e:	f8a4 b004 	strh.w	fp, [r4, #4]
 8014052:	f804 af06 	strb.w	sl, [r4, #6]!
            case '\x16': APPEND_STRING("\\u0016"); break;
 8014056:	e6d3      	b.n	8013e00 <json_serialize_string+0x17c>
    for (i = 0; i < len; i++) {
 8014058:	2002      	movs	r0, #2
 801405a:	2e00      	cmp	r6, #0
 801405c:	f47f ae23 	bne.w	8013ca6 <json_serialize_string+0x22>
 8014060:	e69d      	b.n	8013d9e <json_serialize_string+0x11a>
 8014062:	2101      	movs	r1, #1
 8014064:	e698      	b.n	8013d98 <json_serialize_string+0x114>
 8014066:	bf00      	nop
 8014068:	0801ab24 	.word	0x0801ab24
 801406c:	0801ab1c 	.word	0x0801ab1c
 8014070:	0801ab20 	.word	0x0801ab20
 8014074:	0801ab28 	.word	0x0801ab28
 8014078:	0801ab18 	.word	0x0801ab18
 801407c:	0801ab6c 	.word	0x0801ab6c
 8014080:	0801ab64 	.word	0x0801ab64
 8014084:	0801ab5c 	.word	0x0801ab5c
 8014088:	0801ab54 	.word	0x0801ab54
 801408c:	0801ab4c 	.word	0x0801ab4c
 8014090:	0801ab44 	.word	0x0801ab44
 8014094:	0801ab3c 	.word	0x0801ab3c
 8014098:	0801ab34 	.word	0x0801ab34
 801409c:	0801ab2c 	.word	0x0801ab2c

080140a0 <json_serialize_to_buffer_r>:
{
 80140a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80140a4:	b089      	sub	sp, #36	; 0x24
 80140a6:	4614      	mov	r4, r2
 80140a8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80140aa:	9202      	str	r2, [sp, #8]
    return array->wrapping_value;
}

/* JSON Value API */
JSON_Value_Type json_value_get_type(const JSON_Value *value) {
    return value ? value->type : JSONError;
 80140ac:	b168      	cbz	r0, 80140ca <json_serialize_to_buffer_r+0x2a>
 80140ae:	6842      	ldr	r2, [r0, #4]
 80140b0:	3a01      	subs	r2, #1
 80140b2:	461d      	mov	r5, r3
 80140b4:	4603      	mov	r3, r0
 80140b6:	2a05      	cmp	r2, #5
 80140b8:	d807      	bhi.n	80140ca <json_serialize_to_buffer_r+0x2a>
 80140ba:	e8df f012 	tbh	[pc, r2, lsl #1]
 80140be:	0018      	.short	0x0018
 80140c0:	000b0124 	.word	0x000b0124
 80140c4:	00dd002e 	.word	0x00dd002e
 80140c8:	0022      	.short	0x0022
 80140ca:	f04f 30ff 	mov.w	r0, #4294967295
}
 80140ce:	b009      	add	sp, #36	; 0x24
 80140d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            written = sprintf(num_buf, FLOAT_FORMAT, num);
 80140d4:	9a02      	ldr	r2, [sp, #8]
 80140d6:	2900      	cmp	r1, #0
 80140d8:	bf18      	it	ne
 80140da:	460a      	movne	r2, r1
 80140dc:	4610      	mov	r0, r2
 80140de:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80140e2:	49be      	ldr	r1, [pc, #760]	; (80143dc <json_serialize_to_buffer_r+0x33c>)
}
 80140e4:	b009      	add	sp, #36	; 0x24
 80140e6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            written = sprintf(num_buf, FLOAT_FORMAT, num);
 80140ea:	f002 bc8d 	b.w	8016a08 <siprintf>
    if (buf == NULL) {
 80140ee:	b121      	cbz	r1, 80140fa <json_serialize_to_buffer_r+0x5a>
    return sprintf(buf, "%s", string);
 80140f0:	4bbb      	ldr	r3, [pc, #748]	; (80143e0 <json_serialize_to_buffer_r+0x340>)
 80140f2:	6818      	ldr	r0, [r3, #0]
 80140f4:	791b      	ldrb	r3, [r3, #4]
 80140f6:	6008      	str	r0, [r1, #0]
 80140f8:	710b      	strb	r3, [r1, #4]
            return written_total;
 80140fa:	2004      	movs	r0, #4
}
 80140fc:	b009      	add	sp, #36	; 0x24
 80140fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if (json_value_get_boolean(value)) {
 8014102:	689b      	ldr	r3, [r3, #8]
 8014104:	2b00      	cmp	r3, #0
 8014106:	f000 81a0 	beq.w	801444a <json_serialize_to_buffer_r+0x3aa>
    if (buf == NULL) {
 801410a:	2900      	cmp	r1, #0
 801410c:	d0f5      	beq.n	80140fa <json_serialize_to_buffer_r+0x5a>
    return sprintf(buf, "%s", string);
 801410e:	4bb5      	ldr	r3, [pc, #724]	; (80143e4 <json_serialize_to_buffer_r+0x344>)
 8014110:	6818      	ldr	r0, [r3, #0]
 8014112:	791b      	ldrb	r3, [r3, #4]
 8014114:	6008      	str	r0, [r1, #0]
 8014116:	710b      	strb	r3, [r1, #4]
                APPEND_STRING("true");
 8014118:	e7ef      	b.n	80140fa <json_serialize_to_buffer_r+0x5a>
}

JSON_Object * json_value_get_object(const JSON_Value *value) {
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 801411a:	689b      	ldr	r3, [r3, #8]
 801411c:	4618      	mov	r0, r3
    return object ? object->count : 0;
 801411e:	2b00      	cmp	r3, #0
 8014120:	f000 81b8 	beq.w	8014494 <json_serialize_to_buffer_r+0x3f4>
 8014124:	68db      	ldr	r3, [r3, #12]
 8014126:	9305      	str	r3, [sp, #20]
    if (buf == NULL) {
 8014128:	2900      	cmp	r1, #0
 801412a:	f000 81a8 	beq.w	801447e <json_serialize_to_buffer_r+0x3de>
    return sprintf(buf, "%s", string);
 801412e:	4aae      	ldr	r2, [pc, #696]	; (80143e8 <json_serialize_to_buffer_r+0x348>)
 8014130:	4689      	mov	r9, r1
 8014132:	8812      	ldrh	r2, [r2, #0]
 8014134:	f829 2b01 	strh.w	r2, [r9], #1
            if (count > 0 && is_pretty) {
 8014138:	2b00      	cmp	r3, #0
 801413a:	f000 81b1 	beq.w	80144a0 <json_serialize_to_buffer_r+0x400>
 801413e:	2d00      	cmp	r5, #0
 8014140:	f040 80fc 	bne.w	801433c <json_serialize_to_buffer_r+0x29c>
 8014144:	68c3      	ldr	r3, [r0, #12]
 8014146:	f04f 0a01 	mov.w	sl, #1
    if (object == NULL || index >= json_object_get_count(object)) {
 801414a:	2200      	movs	r2, #0
 801414c:	464f      	mov	r7, r9
 801414e:	9203      	str	r2, [sp, #12]
 8014150:	4683      	mov	fp, r0
 8014152:	46a1      	mov	r9, r4
 8014154:	9504      	str	r5, [sp, #16]
 8014156:	9a03      	ldr	r2, [sp, #12]
 8014158:	429a      	cmp	r2, r3
 801415a:	d2b6      	bcs.n	80140ca <json_serialize_to_buffer_r+0x2a>
    return object->names[index];
 801415c:	f8db 3004 	ldr.w	r3, [fp, #4]
 8014160:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
                if (key == NULL) {
 8014164:	2c00      	cmp	r4, #0
 8014166:	d0b0      	beq.n	80140ca <json_serialize_to_buffer_r+0x2a>
                if (is_pretty) {
 8014168:	9b04      	ldr	r3, [sp, #16]
 801416a:	2b00      	cmp	r3, #0
 801416c:	f000 8123 	beq.w	80143b6 <json_serialize_to_buffer_r+0x316>
    for (i = 0; i < level; i++) {
 8014170:	f1b9 0f00 	cmp.w	r9, #0
 8014174:	f2c0 81cc 	blt.w	8014510 <json_serialize_to_buffer_r+0x470>
 8014178:	2300      	movs	r3, #0
    int written = -1, written_total = 0;
 801417a:	4619      	mov	r1, r3
    for (i = 0; i < level; i++) {
 801417c:	463a      	mov	r2, r7
    if (buf == NULL) {
 801417e:	2a00      	cmp	r2, #0
 8014180:	f000 80e6 	beq.w	8014350 <json_serialize_to_buffer_r+0x2b0>
    return sprintf(buf, "%s", string);
 8014184:	4899      	ldr	r0, [pc, #612]	; (80143ec <json_serialize_to_buffer_r+0x34c>)
 8014186:	4605      	mov	r5, r0
 8014188:	6800      	ldr	r0, [r0, #0]
 801418a:	792d      	ldrb	r5, [r5, #4]
 801418c:	6010      	str	r0, [r2, #0]
 801418e:	f802 5f04 	strb.w	r5, [r2, #4]!
    for (i = 0; i < level; i++) {
 8014192:	3301      	adds	r3, #1
 8014194:	4599      	cmp	r9, r3
        APPEND_STRING("    ");
 8014196:	f101 0104 	add.w	r1, r1, #4
    for (i = 0; i < level; i++) {
 801419a:	daf0      	bge.n	801417e <json_serialize_to_buffer_r+0xde>
 801419c:	448a      	add	sl, r1
                    APPEND_INDENT(level+1);
 801419e:	2f00      	cmp	r7, #0
 80141a0:	f000 815b 	beq.w	801445a <json_serialize_to_buffer_r+0x3ba>
 80141a4:	440f      	add	r7, r1
                written = json_serialize_string(key, buf);
 80141a6:	4639      	mov	r1, r7
 80141a8:	4620      	mov	r0, r4
 80141aa:	f7ff fd6b 	bl	8013c84 <json_serialize_string>
                if (written < 0) {
 80141ae:	2800      	cmp	r0, #0
 80141b0:	db8b      	blt.n	80140ca <json_serialize_to_buffer_r+0x2a>
    return sprintf(buf, "%s", string);
 80141b2:	4a8f      	ldr	r2, [pc, #572]	; (80143f0 <json_serialize_to_buffer_r+0x350>)
 80141b4:	4b8f      	ldr	r3, [pc, #572]	; (80143f4 <json_serialize_to_buffer_r+0x354>)
 80141b6:	8812      	ldrh	r2, [r2, #0]
 80141b8:	523a      	strh	r2, [r7, r0]
                    buf += written;
 80141ba:	4407      	add	r7, r0
    return sprintf(buf, "%s", string);
 80141bc:	881b      	ldrh	r3, [r3, #0]
 80141be:	f8a7 3001 	strh.w	r3, [r7, #1]
                written_total += written;
 80141c2:	4482      	add	sl, r0
                APPEND_STRING(":");
 80141c4:	f10a 0a01 	add.w	sl, sl, #1
                    APPEND_STRING(" ");
 80141c8:	3702      	adds	r7, #2
 80141ca:	f10a 0301 	add.w	r3, sl, #1
 80141ce:	9306      	str	r3, [sp, #24]
    return json_object_getn_value(object, name, strlen(name));
 80141d0:	4620      	mov	r0, r4
 80141d2:	f7ec f81f 	bl	8000214 <strlen>
    return object ? object->count : 0;
 80141d6:	f8db 300c 	ldr.w	r3, [fp, #12]
    return json_object_getn_value(object, name, strlen(name));
 80141da:	4605      	mov	r5, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 80141dc:	2b00      	cmp	r3, #0
 80141de:	f000 8177 	beq.w	80144d0 <json_serialize_to_buffer_r+0x430>
 80141e2:	f8db 6004 	ldr.w	r6, [fp, #4]
 80141e6:	9707      	str	r7, [sp, #28]
 80141e8:	f04f 0800 	mov.w	r8, #0
 80141ec:	3e04      	subs	r6, #4
 80141ee:	4647      	mov	r7, r8
 80141f0:	469a      	mov	sl, r3
        name_length = strlen(object->names[i]);
 80141f2:	f856 8f04 	ldr.w	r8, [r6, #4]!
 80141f6:	4640      	mov	r0, r8
 80141f8:	f7ec f80c 	bl	8000214 <strlen>
 80141fc:	4684      	mov	ip, r0
        if (name_length != name_len) {
 80141fe:	4565      	cmp	r5, ip
        if (strncmp(object->names[i], name, name_len) == 0) {
 8014200:	4640      	mov	r0, r8
 8014202:	462a      	mov	r2, r5
 8014204:	ea4f 0887 	mov.w	r8, r7, lsl #2
 8014208:	4621      	mov	r1, r4
    for (i = 0; i < json_object_get_count(object); i++) {
 801420a:	f107 0701 	add.w	r7, r7, #1
        if (name_length != name_len) {
 801420e:	d104      	bne.n	801421a <json_serialize_to_buffer_r+0x17a>
        if (strncmp(object->names[i], name, name_len) == 0) {
 8014210:	f002 fc82 	bl	8016b18 <strncmp>
 8014214:	2800      	cmp	r0, #0
 8014216:	f000 8109 	beq.w	801442c <json_serialize_to_buffer_r+0x38c>
    for (i = 0; i < json_object_get_count(object); i++) {
 801421a:	4557      	cmp	r7, sl
 801421c:	d1e9      	bne.n	80141f2 <json_serialize_to_buffer_r+0x152>
 801421e:	9f07      	ldr	r7, [sp, #28]
    return NULL;
 8014220:	2000      	movs	r0, #0
                written = json_serialize_to_buffer_r(temp_value, buf, level+1, is_pretty, num_buf);
 8014222:	9b02      	ldr	r3, [sp, #8]
 8014224:	9300      	str	r3, [sp, #0]
 8014226:	f109 0201 	add.w	r2, r9, #1
 801422a:	9b04      	ldr	r3, [sp, #16]
 801422c:	4639      	mov	r1, r7
 801422e:	f7ff ff37 	bl	80140a0 <json_serialize_to_buffer_r>
                if (written < 0) {
 8014232:	2800      	cmp	r0, #0
 8014234:	f6ff af49 	blt.w	80140ca <json_serialize_to_buffer_r+0x2a>
                if (i < (count - 1)) {
 8014238:	9b05      	ldr	r3, [sp, #20]
 801423a:	3b01      	subs	r3, #1
                if (buf != NULL) {
 801423c:	2f00      	cmp	r7, #0
 801423e:	f000 80e8 	beq.w	8014412 <json_serialize_to_buffer_r+0x372>
                written_total += written;
 8014242:	9a06      	ldr	r2, [sp, #24]
 8014244:	4402      	add	r2, r0
 8014246:	4692      	mov	sl, r2
                if (i < (count - 1)) {
 8014248:	9a03      	ldr	r2, [sp, #12]
 801424a:	429a      	cmp	r2, r3
                    buf += written;
 801424c:	4407      	add	r7, r0
                if (i < (count - 1)) {
 801424e:	d205      	bcs.n	801425c <json_serialize_to_buffer_r+0x1bc>
    return sprintf(buf, "%s", string);
 8014250:	4b69      	ldr	r3, [pc, #420]	; (80143f8 <json_serialize_to_buffer_r+0x358>)
 8014252:	881b      	ldrh	r3, [r3, #0]
 8014254:	f827 3b01 	strh.w	r3, [r7], #1
                    APPEND_STRING(",");
 8014258:	f10a 0a01 	add.w	sl, sl, #1
                if (is_pretty) {
 801425c:	9b04      	ldr	r3, [sp, #16]
 801425e:	2b00      	cmp	r3, #0
 8014260:	f040 80ea 	bne.w	8014438 <json_serialize_to_buffer_r+0x398>
            for (i = 0; i < count; i++) {
 8014264:	9b03      	ldr	r3, [sp, #12]
 8014266:	9a05      	ldr	r2, [sp, #20]
 8014268:	3301      	adds	r3, #1
 801426a:	4293      	cmp	r3, r2
 801426c:	9303      	str	r3, [sp, #12]
 801426e:	f000 8151 	beq.w	8014514 <json_serialize_to_buffer_r+0x474>
 8014272:	f8db 300c 	ldr.w	r3, [fp, #12]
 8014276:	e76e      	b.n	8014156 <json_serialize_to_buffer_r+0xb6>
}

JSON_Array * json_value_get_array(const JSON_Value *value) {
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 8014278:	f8d3 b008 	ldr.w	fp, [r3, #8]
    return array ? array->count : 0;
 801427c:	f1bb 0f00 	cmp.w	fp, #0
 8014280:	f000 8117 	beq.w	80144b2 <json_serialize_to_buffer_r+0x412>
 8014284:	f8db a008 	ldr.w	sl, [fp, #8]
    if (buf == NULL) {
 8014288:	2900      	cmp	r1, #0
 801428a:	f000 80fd 	beq.w	8014488 <json_serialize_to_buffer_r+0x3e8>
    return sprintf(buf, "%s", string);
 801428e:	4b5b      	ldr	r3, [pc, #364]	; (80143fc <json_serialize_to_buffer_r+0x35c>)
 8014290:	460f      	mov	r7, r1
 8014292:	881b      	ldrh	r3, [r3, #0]
 8014294:	f827 3b01 	strh.w	r3, [r7], #1
            if (count > 0 && is_pretty) {
 8014298:	f1ba 0f00 	cmp.w	sl, #0
 801429c:	f000 810f 	beq.w	80144be <json_serialize_to_buffer_r+0x41e>
 80142a0:	2d00      	cmp	r5, #0
 80142a2:	d145      	bne.n	8014330 <json_serialize_to_buffer_r+0x290>
 80142a4:	2601      	movs	r6, #1
    return sprintf(buf, "%s", string);
 80142a6:	f8df 9144 	ldr.w	r9, [pc, #324]	; 80143ec <json_serialize_to_buffer_r+0x34c>
            if (count > 0 && is_pretty) {
 80142aa:	f04f 0800 	mov.w	r8, #0
 80142ae:	1c62      	adds	r2, r4, #1
                if (is_pretty) {
 80142b0:	2d00      	cmp	r5, #0
 80142b2:	d155      	bne.n	8014360 <json_serialize_to_buffer_r+0x2c0>
    if (array == NULL || index >= json_array_get_count(array)) {
 80142b4:	f8db 3008 	ldr.w	r3, [fp, #8]
 80142b8:	4598      	cmp	r8, r3
 80142ba:	d26d      	bcs.n	8014398 <json_serialize_to_buffer_r+0x2f8>
    return array->items[index];
 80142bc:	f8db 3004 	ldr.w	r3, [fp, #4]
 80142c0:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
                written = json_serialize_to_buffer_r(temp_value, buf, level+1, is_pretty, num_buf);
 80142c4:	9b02      	ldr	r3, [sp, #8]
 80142c6:	9300      	str	r3, [sp, #0]
 80142c8:	4639      	mov	r1, r7
 80142ca:	462b      	mov	r3, r5
 80142cc:	9203      	str	r2, [sp, #12]
 80142ce:	f7ff fee7 	bl	80140a0 <json_serialize_to_buffer_r>
                if (written < 0) {
 80142d2:	2800      	cmp	r0, #0
 80142d4:	f6ff aef9 	blt.w	80140ca <json_serialize_to_buffer_r+0x2a>
                if (buf != NULL) {
 80142d8:	9a03      	ldr	r2, [sp, #12]
                if (i < (count - 1)) {
 80142da:	f10a 33ff 	add.w	r3, sl, #4294967295
                if (buf != NULL) {
 80142de:	2f00      	cmp	r7, #0
 80142e0:	d062      	beq.n	80143a8 <json_serialize_to_buffer_r+0x308>
                if (i < (count - 1)) {
 80142e2:	4598      	cmp	r8, r3
                    buf += written;
 80142e4:	4407      	add	r7, r0
                written_total += written;
 80142e6:	4406      	add	r6, r0
                if (i < (count - 1)) {
 80142e8:	d316      	bcc.n	8014318 <json_serialize_to_buffer_r+0x278>
                if (is_pretty) {
 80142ea:	b9e5      	cbnz	r5, 8014326 <json_serialize_to_buffer_r+0x286>
            for (i = 0; i < count; i++) {
 80142ec:	f108 0801 	add.w	r8, r8, #1
 80142f0:	45d0      	cmp	r8, sl
 80142f2:	d1dd      	bne.n	80142b0 <json_serialize_to_buffer_r+0x210>
            if (count > 0 && is_pretty) {
 80142f4:	2d00      	cmp	r5, #0
 80142f6:	f040 80ed 	bne.w	80144d4 <json_serialize_to_buffer_r+0x434>
    if (buf == NULL) {
 80142fa:	b117      	cbz	r7, 8014302 <json_serialize_to_buffer_r+0x262>
    return sprintf(buf, "%s", string);
 80142fc:	4b40      	ldr	r3, [pc, #256]	; (8014400 <json_serialize_to_buffer_r+0x360>)
 80142fe:	881b      	ldrh	r3, [r3, #0]
 8014300:	803b      	strh	r3, [r7, #0]
            APPEND_STRING("]");
 8014302:	1c70      	adds	r0, r6, #1
            return written_total;
 8014304:	e6e3      	b.n	80140ce <json_serialize_to_buffer_r+0x2e>
}

const char * json_value_get_string(const JSON_Value *value) {
    return json_value_get_type(value) == JSONString ? value->value.string : NULL;
 8014306:	6898      	ldr	r0, [r3, #8]
            if (string == NULL) {
 8014308:	2800      	cmp	r0, #0
 801430a:	f43f aede 	beq.w	80140ca <json_serialize_to_buffer_r+0x2a>
            written = json_serialize_string(string, buf);
 801430e:	f7ff fcb9 	bl	8013c84 <json_serialize_string>
            if (written < 0) {
 8014312:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 8014316:	e6da      	b.n	80140ce <json_serialize_to_buffer_r+0x2e>
    return sprintf(buf, "%s", string);
 8014318:	4b37      	ldr	r3, [pc, #220]	; (80143f8 <json_serialize_to_buffer_r+0x358>)
 801431a:	881b      	ldrh	r3, [r3, #0]
 801431c:	f827 3b01 	strh.w	r3, [r7], #1
                    APPEND_STRING(",");
 8014320:	3601      	adds	r6, #1
                if (is_pretty) {
 8014322:	2d00      	cmp	r5, #0
 8014324:	d0e2      	beq.n	80142ec <json_serialize_to_buffer_r+0x24c>
    return sprintf(buf, "%s", string);
 8014326:	4b37      	ldr	r3, [pc, #220]	; (8014404 <json_serialize_to_buffer_r+0x364>)
 8014328:	881b      	ldrh	r3, [r3, #0]
 801432a:	f827 3b01 	strh.w	r3, [r7], #1
                    APPEND_STRING("\n");
 801432e:	e040      	b.n	80143b2 <json_serialize_to_buffer_r+0x312>
    return sprintf(buf, "%s", string);
 8014330:	4b34      	ldr	r3, [pc, #208]	; (8014404 <json_serialize_to_buffer_r+0x364>)
                APPEND_STRING("\n");
 8014332:	2602      	movs	r6, #2
    return sprintf(buf, "%s", string);
 8014334:	881b      	ldrh	r3, [r3, #0]
 8014336:	803b      	strh	r3, [r7, #0]
                APPEND_STRING("\n");
 8014338:	198f      	adds	r7, r1, r6
 801433a:	e7b4      	b.n	80142a6 <json_serialize_to_buffer_r+0x206>
    return sprintf(buf, "%s", string);
 801433c:	4b31      	ldr	r3, [pc, #196]	; (8014404 <json_serialize_to_buffer_r+0x364>)
 801433e:	881b      	ldrh	r3, [r3, #0]
 8014340:	f8a9 3000 	strh.w	r3, [r9]
                APPEND_STRING("\n");
 8014344:	68c3      	ldr	r3, [r0, #12]
 8014346:	f101 0902 	add.w	r9, r1, #2
 801434a:	f04f 0a02 	mov.w	sl, #2
 801434e:	e6fc      	b.n	801414a <json_serialize_to_buffer_r+0xaa>
    for (i = 0; i < level; i++) {
 8014350:	3301      	adds	r3, #1
 8014352:	4599      	cmp	r9, r3
        APPEND_STRING("    ");
 8014354:	f101 0104 	add.w	r1, r1, #4
    for (i = 0; i < level; i++) {
 8014358:	f6bf af1b 	bge.w	8014192 <json_serialize_to_buffer_r+0xf2>
 801435c:	448a      	add	sl, r1
 801435e:	e71e      	b.n	801419e <json_serialize_to_buffer_r+0xfe>
 8014360:	2c00      	cmp	r4, #0
 8014362:	f2c0 80b3 	blt.w	80144cc <json_serialize_to_buffer_r+0x42c>
 8014366:	2300      	movs	r3, #0
 8014368:	469e      	mov	lr, r3
 801436a:	4639      	mov	r1, r7
    if (buf == NULL) {
 801436c:	b1b1      	cbz	r1, 801439c <json_serialize_to_buffer_r+0x2fc>
    return sprintf(buf, "%s", string);
 801436e:	f8d9 0000 	ldr.w	r0, [r9]
 8014372:	f899 c004 	ldrb.w	ip, [r9, #4]
 8014376:	6008      	str	r0, [r1, #0]
 8014378:	f801 cf04 	strb.w	ip, [r1, #4]!
    for (i = 0; i < level; i++) {
 801437c:	3301      	adds	r3, #1
 801437e:	429c      	cmp	r4, r3
        APPEND_STRING("    ");
 8014380:	f10e 0e04 	add.w	lr, lr, #4
    for (i = 0; i < level; i++) {
 8014384:	daf2      	bge.n	801436c <json_serialize_to_buffer_r+0x2cc>
 8014386:	4671      	mov	r1, lr
 8014388:	4476      	add	r6, lr
                    APPEND_INDENT(level+1);
 801438a:	2f00      	cmp	r7, #0
 801438c:	d092      	beq.n	80142b4 <json_serialize_to_buffer_r+0x214>
    if (array == NULL || index >= json_array_get_count(array)) {
 801438e:	f8db 3008 	ldr.w	r3, [fp, #8]
 8014392:	4598      	cmp	r8, r3
                    APPEND_INDENT(level+1);
 8014394:	440f      	add	r7, r1
    if (array == NULL || index >= json_array_get_count(array)) {
 8014396:	d391      	bcc.n	80142bc <json_serialize_to_buffer_r+0x21c>
        return NULL;
 8014398:	2000      	movs	r0, #0
 801439a:	e793      	b.n	80142c4 <json_serialize_to_buffer_r+0x224>
    for (i = 0; i < level; i++) {
 801439c:	3301      	adds	r3, #1
 801439e:	429c      	cmp	r4, r3
        APPEND_STRING("    ");
 80143a0:	f10e 0e04 	add.w	lr, lr, #4
    for (i = 0; i < level; i++) {
 80143a4:	daea      	bge.n	801437c <json_serialize_to_buffer_r+0x2dc>
 80143a6:	e7ee      	b.n	8014386 <json_serialize_to_buffer_r+0x2e6>
                if (i < (count - 1)) {
 80143a8:	4598      	cmp	r8, r3
                written_total += written;
 80143aa:	4406      	add	r6, r0
                if (i < (count - 1)) {
 80143ac:	d32c      	bcc.n	8014408 <json_serialize_to_buffer_r+0x368>
                if (is_pretty) {
 80143ae:	2d00      	cmp	r5, #0
 80143b0:	d09c      	beq.n	80142ec <json_serialize_to_buffer_r+0x24c>
                    APPEND_STRING("\n");
 80143b2:	3601      	adds	r6, #1
 80143b4:	e79a      	b.n	80142ec <json_serialize_to_buffer_r+0x24c>
                written = json_serialize_string(key, buf);
 80143b6:	4639      	mov	r1, r7
 80143b8:	4620      	mov	r0, r4
 80143ba:	f7ff fc63 	bl	8013c84 <json_serialize_string>
                if (written < 0) {
 80143be:	2800      	cmp	r0, #0
 80143c0:	f6ff ae83 	blt.w	80140ca <json_serialize_to_buffer_r+0x2a>
                if (buf != NULL) {
 80143c4:	2f00      	cmp	r7, #0
 80143c6:	d03c      	beq.n	8014442 <json_serialize_to_buffer_r+0x3a2>
    return sprintf(buf, "%s", string);
 80143c8:	4b09      	ldr	r3, [pc, #36]	; (80143f0 <json_serialize_to_buffer_r+0x350>)
                written_total += written;
 80143ca:	4482      	add	sl, r0
    return sprintf(buf, "%s", string);
 80143cc:	881b      	ldrh	r3, [r3, #0]
 80143ce:	523b      	strh	r3, [r7, r0]
                    buf += written;
 80143d0:	4407      	add	r7, r0
                APPEND_STRING(":");
 80143d2:	f10a 0301 	add.w	r3, sl, #1
 80143d6:	9306      	str	r3, [sp, #24]
 80143d8:	3701      	adds	r7, #1
                if (is_pretty) {
 80143da:	e6f9      	b.n	80141d0 <json_serialize_to_buffer_r+0x130>
 80143dc:	0801ac34 	.word	0x0801ac34
 80143e0:	0801ac3c 	.word	0x0801ac3c
 80143e4:	0801ac24 	.word	0x0801ac24
 80143e8:	0801ac1c 	.word	0x0801ac1c
 80143ec:	0801ac0c 	.word	0x0801ac0c
 80143f0:	0801ac44 	.word	0x0801ac44
 80143f4:	0801ac48 	.word	0x0801ac48
 80143f8:	0801ac14 	.word	0x0801ac14
 80143fc:	0801ac04 	.word	0x0801ac04
 8014400:	0801ac18 	.word	0x0801ac18
 8014404:	0801ac08 	.word	0x0801ac08
                    APPEND_STRING(",");
 8014408:	3601      	adds	r6, #1
                if (is_pretty) {
 801440a:	2d00      	cmp	r5, #0
 801440c:	f43f af6e 	beq.w	80142ec <json_serialize_to_buffer_r+0x24c>
 8014410:	e7cf      	b.n	80143b2 <json_serialize_to_buffer_r+0x312>
                written_total += written;
 8014412:	9a06      	ldr	r2, [sp, #24]
 8014414:	4402      	add	r2, r0
 8014416:	4692      	mov	sl, r2
                if (i < (count - 1)) {
 8014418:	9a03      	ldr	r2, [sp, #12]
 801441a:	429a      	cmp	r2, r3
 801441c:	d328      	bcc.n	8014470 <json_serialize_to_buffer_r+0x3d0>
                if (is_pretty) {
 801441e:	9b04      	ldr	r3, [sp, #16]
 8014420:	2b00      	cmp	r3, #0
 8014422:	f43f af1f 	beq.w	8014264 <json_serialize_to_buffer_r+0x1c4>
                    APPEND_STRING("\n");
 8014426:	f10a 0a01 	add.w	sl, sl, #1
 801442a:	e71b      	b.n	8014264 <json_serialize_to_buffer_r+0x1c4>
            return object->values[i];
 801442c:	f8db 3008 	ldr.w	r3, [fp, #8]
 8014430:	9f07      	ldr	r7, [sp, #28]
 8014432:	f853 0008 	ldr.w	r0, [r3, r8]
 8014436:	e6f4      	b.n	8014222 <json_serialize_to_buffer_r+0x182>
    return sprintf(buf, "%s", string);
 8014438:	4b4d      	ldr	r3, [pc, #308]	; (8014570 <json_serialize_to_buffer_r+0x4d0>)
 801443a:	881b      	ldrh	r3, [r3, #0]
 801443c:	f827 3b01 	strh.w	r3, [r7], #1
                    APPEND_STRING("\n");
 8014440:	e7f1      	b.n	8014426 <json_serialize_to_buffer_r+0x386>
                written_total += written;
 8014442:	4450      	add	r0, sl
                APPEND_STRING(":");
 8014444:	1c43      	adds	r3, r0, #1
 8014446:	9306      	str	r3, [sp, #24]
                if (is_pretty) {
 8014448:	e6c2      	b.n	80141d0 <json_serialize_to_buffer_r+0x130>
    if (buf == NULL) {
 801444a:	b121      	cbz	r1, 8014456 <json_serialize_to_buffer_r+0x3b6>
    return sprintf(buf, "%s", string);
 801444c:	4b49      	ldr	r3, [pc, #292]	; (8014574 <json_serialize_to_buffer_r+0x4d4>)
 801444e:	6818      	ldr	r0, [r3, #0]
 8014450:	889b      	ldrh	r3, [r3, #4]
 8014452:	6008      	str	r0, [r1, #0]
 8014454:	808b      	strh	r3, [r1, #4]
                APPEND_STRING("false");
 8014456:	2005      	movs	r0, #5
 8014458:	e639      	b.n	80140ce <json_serialize_to_buffer_r+0x2e>
                written = json_serialize_string(key, buf);
 801445a:	4639      	mov	r1, r7
 801445c:	4620      	mov	r0, r4
 801445e:	f7ff fc11 	bl	8013c84 <json_serialize_string>
                if (written < 0) {
 8014462:	2800      	cmp	r0, #0
 8014464:	f6ff ae31 	blt.w	80140ca <json_serialize_to_buffer_r+0x2a>
                written_total += written;
 8014468:	4482      	add	sl, r0
                APPEND_STRING(":");
 801446a:	f10a 0a01 	add.w	sl, sl, #1
                if (is_pretty) {
 801446e:	e6ac      	b.n	80141ca <json_serialize_to_buffer_r+0x12a>
                if (is_pretty) {
 8014470:	9b04      	ldr	r3, [sp, #16]
                    APPEND_STRING(",");
 8014472:	f10a 0a01 	add.w	sl, sl, #1
                if (is_pretty) {
 8014476:	2b00      	cmp	r3, #0
 8014478:	f43f aef4 	beq.w	8014264 <json_serialize_to_buffer_r+0x1c4>
 801447c:	e7d3      	b.n	8014426 <json_serialize_to_buffer_r+0x386>
            if (count > 0 && is_pretty) {
 801447e:	b303      	cbz	r3, 80144c2 <json_serialize_to_buffer_r+0x422>
 8014480:	4689      	mov	r9, r1
 8014482:	f105 0a01 	add.w	sl, r5, #1
 8014486:	e660      	b.n	801414a <json_serialize_to_buffer_r+0xaa>
            if (count > 0 && is_pretty) {
 8014488:	f1ba 0f00 	cmp.w	sl, #0
 801448c:	d01c      	beq.n	80144c8 <json_serialize_to_buffer_r+0x428>
 801448e:	460f      	mov	r7, r1
 8014490:	1c6e      	adds	r6, r5, #1
 8014492:	e708      	b.n	80142a6 <json_serialize_to_buffer_r+0x206>
    if (buf == NULL) {
 8014494:	b1a9      	cbz	r1, 80144c2 <json_serialize_to_buffer_r+0x422>
    return sprintf(buf, "%s", string);
 8014496:	4b38      	ldr	r3, [pc, #224]	; (8014578 <json_serialize_to_buffer_r+0x4d8>)
 8014498:	4689      	mov	r9, r1
 801449a:	881b      	ldrh	r3, [r3, #0]
 801449c:	f829 3b01 	strh.w	r3, [r9], #1
    int written = -1, written_total = 0;
 80144a0:	f04f 0a01 	mov.w	sl, #1
    return sprintf(buf, "%s", string);
 80144a4:	4b35      	ldr	r3, [pc, #212]	; (801457c <json_serialize_to_buffer_r+0x4dc>)
 80144a6:	881b      	ldrh	r3, [r3, #0]
 80144a8:	f8a9 3000 	strh.w	r3, [r9]
            APPEND_STRING("}");
 80144ac:	f10a 0001 	add.w	r0, sl, #1
            return written_total;
 80144b0:	e60d      	b.n	80140ce <json_serialize_to_buffer_r+0x2e>
    if (buf == NULL) {
 80144b2:	b149      	cbz	r1, 80144c8 <json_serialize_to_buffer_r+0x428>
    return sprintf(buf, "%s", string);
 80144b4:	4b32      	ldr	r3, [pc, #200]	; (8014580 <json_serialize_to_buffer_r+0x4e0>)
 80144b6:	460f      	mov	r7, r1
 80144b8:	881b      	ldrh	r3, [r3, #0]
 80144ba:	f827 3b01 	strh.w	r3, [r7], #1
    int written = -1, written_total = 0;
 80144be:	2601      	movs	r6, #1
 80144c0:	e71c      	b.n	80142fc <json_serialize_to_buffer_r+0x25c>
            if (count > 0 && is_pretty) {
 80144c2:	f04f 0a01 	mov.w	sl, #1
 80144c6:	e7f1      	b.n	80144ac <json_serialize_to_buffer_r+0x40c>
        return (int)strlen(string);
 80144c8:	2601      	movs	r6, #1
 80144ca:	e71a      	b.n	8014302 <json_serialize_to_buffer_r+0x262>
    int written = -1, written_total = 0;
 80144cc:	2100      	movs	r1, #0
 80144ce:	e75c      	b.n	801438a <json_serialize_to_buffer_r+0x2ea>
    return NULL;
 80144d0:	4618      	mov	r0, r3
 80144d2:	e6a6      	b.n	8014222 <json_serialize_to_buffer_r+0x182>
    for (i = 0; i < level; i++) {
 80144d4:	2c00      	cmp	r4, #0
 80144d6:	dd46      	ble.n	8014566 <json_serialize_to_buffer_r+0x4c6>
 80144d8:	2300      	movs	r3, #0
    return sprintf(buf, "%s", string);
 80144da:	f8df c0a8 	ldr.w	ip, [pc, #168]	; 8014584 <json_serialize_to_buffer_r+0x4e4>
    int written = -1, written_total = 0;
 80144de:	461d      	mov	r5, r3
    for (i = 0; i < level; i++) {
 80144e0:	463a      	mov	r2, r7
    if (buf == NULL) {
 80144e2:	b17a      	cbz	r2, 8014504 <json_serialize_to_buffer_r+0x464>
    return sprintf(buf, "%s", string);
 80144e4:	f8dc 0000 	ldr.w	r0, [ip]
 80144e8:	f89c 1004 	ldrb.w	r1, [ip, #4]
 80144ec:	6010      	str	r0, [r2, #0]
 80144ee:	f802 1f04 	strb.w	r1, [r2, #4]!
    for (i = 0; i < level; i++) {
 80144f2:	3301      	adds	r3, #1
 80144f4:	429c      	cmp	r4, r3
        APPEND_STRING("    ");
 80144f6:	f105 0504 	add.w	r5, r5, #4
    for (i = 0; i < level; i++) {
 80144fa:	dcf2      	bgt.n	80144e2 <json_serialize_to_buffer_r+0x442>
                APPEND_INDENT(level);
 80144fc:	b197      	cbz	r7, 8014524 <json_serialize_to_buffer_r+0x484>
 80144fe:	442f      	add	r7, r5
 8014500:	442e      	add	r6, r5
    if (buf == NULL) {
 8014502:	e6fb      	b.n	80142fc <json_serialize_to_buffer_r+0x25c>
    for (i = 0; i < level; i++) {
 8014504:	3301      	adds	r3, #1
 8014506:	429c      	cmp	r4, r3
        APPEND_STRING("    ");
 8014508:	f105 0504 	add.w	r5, r5, #4
    for (i = 0; i < level; i++) {
 801450c:	dcf1      	bgt.n	80144f2 <json_serialize_to_buffer_r+0x452>
 801450e:	e7f5      	b.n	80144fc <json_serialize_to_buffer_r+0x45c>
    int written = -1, written_total = 0;
 8014510:	2100      	movs	r1, #0
 8014512:	e644      	b.n	801419e <json_serialize_to_buffer_r+0xfe>
            if (count > 0 && is_pretty) {
 8014514:	9d04      	ldr	r5, [sp, #16]
 8014516:	464c      	mov	r4, r9
 8014518:	46b9      	mov	r9, r7
 801451a:	b92d      	cbnz	r5, 8014528 <json_serialize_to_buffer_r+0x488>
    if (buf == NULL) {
 801451c:	f1b9 0f00 	cmp.w	r9, #0
 8014520:	d1c0      	bne.n	80144a4 <json_serialize_to_buffer_r+0x404>
 8014522:	e7c3      	b.n	80144ac <json_serialize_to_buffer_r+0x40c>
                APPEND_INDENT(level);
 8014524:	442e      	add	r6, r5
    if (buf == NULL) {
 8014526:	e6ec      	b.n	8014302 <json_serialize_to_buffer_r+0x262>
    for (i = 0; i < level; i++) {
 8014528:	2c00      	cmp	r4, #0
 801452a:	dd1e      	ble.n	801456a <json_serialize_to_buffer_r+0x4ca>
 801452c:	2200      	movs	r2, #0
    return sprintf(buf, "%s", string);
 801452e:	4e15      	ldr	r6, [pc, #84]	; (8014584 <json_serialize_to_buffer_r+0x4e4>)
    int written = -1, written_total = 0;
 8014530:	4615      	mov	r5, r2
    for (i = 0; i < level; i++) {
 8014532:	464b      	mov	r3, r9
    if (buf == NULL) {
 8014534:	b17b      	cbz	r3, 8014556 <json_serialize_to_buffer_r+0x4b6>
    return sprintf(buf, "%s", string);
 8014536:	6830      	ldr	r0, [r6, #0]
 8014538:	7931      	ldrb	r1, [r6, #4]
 801453a:	6018      	str	r0, [r3, #0]
 801453c:	f803 1f04 	strb.w	r1, [r3, #4]!
    for (i = 0; i < level; i++) {
 8014540:	3201      	adds	r2, #1
 8014542:	4294      	cmp	r4, r2
        APPEND_STRING("    ");
 8014544:	f105 0504 	add.w	r5, r5, #4
    for (i = 0; i < level; i++) {
 8014548:	dcf4      	bgt.n	8014534 <json_serialize_to_buffer_r+0x494>
                APPEND_INDENT(level);
 801454a:	f1b9 0f00 	cmp.w	r9, #0
 801454e:	d008      	beq.n	8014562 <json_serialize_to_buffer_r+0x4c2>
 8014550:	44a9      	add	r9, r5
 8014552:	44aa      	add	sl, r5
    if (buf == NULL) {
 8014554:	e7a6      	b.n	80144a4 <json_serialize_to_buffer_r+0x404>
    for (i = 0; i < level; i++) {
 8014556:	3201      	adds	r2, #1
 8014558:	4294      	cmp	r4, r2
        APPEND_STRING("    ");
 801455a:	f105 0504 	add.w	r5, r5, #4
    for (i = 0; i < level; i++) {
 801455e:	dcef      	bgt.n	8014540 <json_serialize_to_buffer_r+0x4a0>
 8014560:	e7f3      	b.n	801454a <json_serialize_to_buffer_r+0x4aa>
                APPEND_INDENT(level);
 8014562:	44aa      	add	sl, r5
    if (buf == NULL) {
 8014564:	e7a2      	b.n	80144ac <json_serialize_to_buffer_r+0x40c>
    int written = -1, written_total = 0;
 8014566:	2500      	movs	r5, #0
 8014568:	e7c8      	b.n	80144fc <json_serialize_to_buffer_r+0x45c>
 801456a:	2500      	movs	r5, #0
 801456c:	e7ed      	b.n	801454a <json_serialize_to_buffer_r+0x4aa>
 801456e:	bf00      	nop
 8014570:	0801ac08 	.word	0x0801ac08
 8014574:	0801ac2c 	.word	0x0801ac2c
 8014578:	0801ac1c 	.word	0x0801ac1c
 801457c:	0801ac20 	.word	0x0801ac20
 8014580:	0801ac04 	.word	0x0801ac04
 8014584:	0801ac0c 	.word	0x0801ac0c

08014588 <json_serialize_to_buffer_r.constprop.0>:
static int json_serialize_to_buffer_r(const JSON_Value *value, char *buf, int level, int is_pretty, char *num_buf)
 8014588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801458c:	b089      	sub	sp, #36	; 0x24
 801458e:	9303      	str	r3, [sp, #12]
    return value ? value->type : JSONError;
 8014590:	b168      	cbz	r0, 80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
 8014592:	4615      	mov	r5, r2
 8014594:	6842      	ldr	r2, [r0, #4]
 8014596:	3a01      	subs	r2, #1
 8014598:	4603      	mov	r3, r0
 801459a:	2a05      	cmp	r2, #5
 801459c:	d807      	bhi.n	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
 801459e:	e8df f012 	tbh	[pc, r2, lsl #1]
 80145a2:	0018      	.short	0x0018
 80145a4:	000b00e2 	.word	0x000b00e2
 80145a8:	00cc002e 	.word	0x00cc002e
 80145ac:	0022      	.short	0x0022
 80145ae:	f04f 30ff 	mov.w	r0, #4294967295
}
 80145b2:	b009      	add	sp, #36	; 0x24
 80145b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            written = sprintf(num_buf, FLOAT_FORMAT, num);
 80145b8:	9a03      	ldr	r2, [sp, #12]
 80145ba:	2900      	cmp	r1, #0
 80145bc:	bf18      	it	ne
 80145be:	460a      	movne	r2, r1
 80145c0:	4610      	mov	r0, r2
 80145c2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80145c6:	49bb      	ldr	r1, [pc, #748]	; (80148b4 <json_serialize_to_buffer_r.constprop.0+0x32c>)
}
 80145c8:	b009      	add	sp, #36	; 0x24
 80145ca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            written = sprintf(num_buf, FLOAT_FORMAT, num);
 80145ce:	f002 ba1b 	b.w	8016a08 <siprintf>
    if (buf == NULL) {
 80145d2:	b121      	cbz	r1, 80145de <json_serialize_to_buffer_r.constprop.0+0x56>
    return sprintf(buf, "%s", string);
 80145d4:	4bb8      	ldr	r3, [pc, #736]	; (80148b8 <json_serialize_to_buffer_r.constprop.0+0x330>)
 80145d6:	6818      	ldr	r0, [r3, #0]
 80145d8:	791b      	ldrb	r3, [r3, #4]
 80145da:	6008      	str	r0, [r1, #0]
 80145dc:	710b      	strb	r3, [r1, #4]
            return written_total;
 80145de:	2004      	movs	r0, #4
}
 80145e0:	b009      	add	sp, #36	; 0x24
 80145e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if (json_value_get_boolean(value)) {
 80145e6:	689b      	ldr	r3, [r3, #8]
 80145e8:	2b00      	cmp	r3, #0
 80145ea:	f000 814f 	beq.w	801488c <json_serialize_to_buffer_r.constprop.0+0x304>
    if (buf == NULL) {
 80145ee:	2900      	cmp	r1, #0
 80145f0:	d0f5      	beq.n	80145de <json_serialize_to_buffer_r.constprop.0+0x56>
    return sprintf(buf, "%s", string);
 80145f2:	4bb2      	ldr	r3, [pc, #712]	; (80148bc <json_serialize_to_buffer_r.constprop.0+0x334>)
 80145f4:	6818      	ldr	r0, [r3, #0]
 80145f6:	791b      	ldrb	r3, [r3, #4]
 80145f8:	6008      	str	r0, [r1, #0]
 80145fa:	710b      	strb	r3, [r1, #4]
                APPEND_STRING("true");
 80145fc:	e7ef      	b.n	80145de <json_serialize_to_buffer_r.constprop.0+0x56>
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 80145fe:	f8d3 9008 	ldr.w	r9, [r3, #8]
    return object ? object->count : 0;
 8014602:	f1b9 0f00 	cmp.w	r9, #0
 8014606:	f000 8171 	beq.w	80148ec <json_serialize_to_buffer_r.constprop.0+0x364>
 801460a:	f8d9 300c 	ldr.w	r3, [r9, #12]
 801460e:	9306      	str	r3, [sp, #24]
    if (buf == NULL) {
 8014610:	2900      	cmp	r1, #0
 8014612:	f000 814a 	beq.w	80148aa <json_serialize_to_buffer_r.constprop.0+0x322>
    return sprintf(buf, "%s", string);
 8014616:	4aaa      	ldr	r2, [pc, #680]	; (80148c0 <json_serialize_to_buffer_r.constprop.0+0x338>)
 8014618:	460c      	mov	r4, r1
 801461a:	8812      	ldrh	r2, [r2, #0]
 801461c:	f824 2b01 	strh.w	r2, [r4], #1
            if (count > 0 && is_pretty) {
 8014620:	2b00      	cmp	r3, #0
 8014622:	f000 8169 	beq.w	80148f8 <json_serialize_to_buffer_r.constprop.0+0x370>
 8014626:	2d00      	cmp	r5, #0
 8014628:	f040 8108 	bne.w	801483c <json_serialize_to_buffer_r.constprop.0+0x2b4>
 801462c:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8014630:	f04f 0b01 	mov.w	fp, #1
 8014634:	2200      	movs	r2, #0
 8014636:	4692      	mov	sl, r2
 8014638:	9504      	str	r5, [sp, #16]
    if (object == NULL || index >= json_object_get_count(object)) {
 801463a:	4553      	cmp	r3, sl
 801463c:	d9b7      	bls.n	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
    return object->names[index];
 801463e:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8014642:	f853 502a 	ldr.w	r5, [r3, sl, lsl #2]
                if (key == NULL) {
 8014646:	2d00      	cmp	r5, #0
 8014648:	d0b1      	beq.n	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
                if (is_pretty) {
 801464a:	9b04      	ldr	r3, [sp, #16]
 801464c:	b143      	cbz	r3, 8014660 <json_serialize_to_buffer_r.constprop.0+0xd8>
    if (buf == NULL) {
 801464e:	b12c      	cbz	r4, 801465c <json_serialize_to_buffer_r.constprop.0+0xd4>
    return sprintf(buf, "%s", string);
 8014650:	4b9c      	ldr	r3, [pc, #624]	; (80148c4 <json_serialize_to_buffer_r.constprop.0+0x33c>)
 8014652:	6818      	ldr	r0, [r3, #0]
 8014654:	791b      	ldrb	r3, [r3, #4]
 8014656:	6020      	str	r0, [r4, #0]
 8014658:	f804 3f04 	strb.w	r3, [r4, #4]!
                    APPEND_INDENT(level+1);
 801465c:	f10b 0b04 	add.w	fp, fp, #4
                written = json_serialize_string(key, buf);
 8014660:	4621      	mov	r1, r4
 8014662:	4628      	mov	r0, r5
 8014664:	f7ff fb0e 	bl	8013c84 <json_serialize_string>
                if (written < 0) {
 8014668:	2800      	cmp	r0, #0
 801466a:	dba0      	blt.n	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
                if (buf != NULL) {
 801466c:	2c00      	cmp	r4, #0
 801466e:	f000 80ee 	beq.w	801484e <json_serialize_to_buffer_r.constprop.0+0x2c6>
    return sprintf(buf, "%s", string);
 8014672:	4b95      	ldr	r3, [pc, #596]	; (80148c8 <json_serialize_to_buffer_r.constprop.0+0x340>)
                written_total += written;
 8014674:	4483      	add	fp, r0
    return sprintf(buf, "%s", string);
 8014676:	881b      	ldrh	r3, [r3, #0]
 8014678:	5223      	strh	r3, [r4, r0]
                APPEND_STRING(":");
 801467a:	f10b 0301 	add.w	r3, fp, #1
 801467e:	9305      	str	r3, [sp, #20]
                if (is_pretty) {
 8014680:	9b04      	ldr	r3, [sp, #16]
                    buf += written;
 8014682:	4420      	add	r0, r4
                APPEND_STRING(":");
 8014684:	1c44      	adds	r4, r0, #1
                if (is_pretty) {
 8014686:	b13b      	cbz	r3, 8014698 <json_serialize_to_buffer_r.constprop.0+0x110>
    return sprintf(buf, "%s", string);
 8014688:	4b90      	ldr	r3, [pc, #576]	; (80148cc <json_serialize_to_buffer_r.constprop.0+0x344>)
 801468a:	881b      	ldrh	r3, [r3, #0]
 801468c:	f8a0 3001 	strh.w	r3, [r0, #1]
                    APPEND_STRING(" ");
 8014690:	1c84      	adds	r4, r0, #2
 8014692:	9b05      	ldr	r3, [sp, #20]
 8014694:	3301      	adds	r3, #1
 8014696:	9305      	str	r3, [sp, #20]
    return json_object_getn_value(object, name, strlen(name));
 8014698:	4628      	mov	r0, r5
 801469a:	f7eb fdbb 	bl	8000214 <strlen>
    return object ? object->count : 0;
 801469e:	f8d9 300c 	ldr.w	r3, [r9, #12]
    return json_object_getn_value(object, name, strlen(name));
 80146a2:	4606      	mov	r6, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 80146a4:	2b00      	cmp	r3, #0
 80146a6:	f000 813c 	beq.w	8014922 <json_serialize_to_buffer_r.constprop.0+0x39a>
 80146aa:	f8d9 7004 	ldr.w	r7, [r9, #4]
 80146ae:	9407      	str	r4, [sp, #28]
 80146b0:	f04f 0800 	mov.w	r8, #0
 80146b4:	3f04      	subs	r7, #4
 80146b6:	4644      	mov	r4, r8
 80146b8:	469b      	mov	fp, r3
        name_length = strlen(object->names[i]);
 80146ba:	f857 8f04 	ldr.w	r8, [r7, #4]!
 80146be:	4640      	mov	r0, r8
 80146c0:	f7eb fda8 	bl	8000214 <strlen>
 80146c4:	4684      	mov	ip, r0
        if (name_length != name_len) {
 80146c6:	4566      	cmp	r6, ip
        if (strncmp(object->names[i], name, name_len) == 0) {
 80146c8:	4640      	mov	r0, r8
 80146ca:	4632      	mov	r2, r6
 80146cc:	ea4f 0884 	mov.w	r8, r4, lsl #2
 80146d0:	4629      	mov	r1, r5
    for (i = 0; i < json_object_get_count(object); i++) {
 80146d2:	f104 0401 	add.w	r4, r4, #1
        if (name_length != name_len) {
 80146d6:	d104      	bne.n	80146e2 <json_serialize_to_buffer_r.constprop.0+0x15a>
        if (strncmp(object->names[i], name, name_len) == 0) {
 80146d8:	f002 fa1e 	bl	8016b18 <strncmp>
 80146dc:	2800      	cmp	r0, #0
 80146de:	f000 80ca 	beq.w	8014876 <json_serialize_to_buffer_r.constprop.0+0x2ee>
    for (i = 0; i < json_object_get_count(object); i++) {
 80146e2:	455c      	cmp	r4, fp
 80146e4:	d1e9      	bne.n	80146ba <json_serialize_to_buffer_r.constprop.0+0x132>
 80146e6:	9c07      	ldr	r4, [sp, #28]
    return NULL;
 80146e8:	2000      	movs	r0, #0
                written = json_serialize_to_buffer_r(temp_value, buf, level+1, is_pretty, num_buf);
 80146ea:	9b03      	ldr	r3, [sp, #12]
 80146ec:	9300      	str	r3, [sp, #0]
 80146ee:	2201      	movs	r2, #1
 80146f0:	9b04      	ldr	r3, [sp, #16]
 80146f2:	4621      	mov	r1, r4
 80146f4:	f7ff fcd4 	bl	80140a0 <json_serialize_to_buffer_r>
                if (written < 0) {
 80146f8:	2800      	cmp	r0, #0
 80146fa:	f6ff af58 	blt.w	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
                if (i < (count - 1)) {
 80146fe:	9b06      	ldr	r3, [sp, #24]
 8014700:	3b01      	subs	r3, #1
                if (buf != NULL) {
 8014702:	2c00      	cmp	r4, #0
 8014704:	f000 80ab 	beq.w	801485e <json_serialize_to_buffer_r.constprop.0+0x2d6>
                written_total += written;
 8014708:	9a05      	ldr	r2, [sp, #20]
                if (i < (count - 1)) {
 801470a:	459a      	cmp	sl, r3
                written_total += written;
 801470c:	4402      	add	r2, r0
                    buf += written;
 801470e:	4404      	add	r4, r0
                written_total += written;
 8014710:	4693      	mov	fp, r2
                if (i < (count - 1)) {
 8014712:	d205      	bcs.n	8014720 <json_serialize_to_buffer_r.constprop.0+0x198>
    return sprintf(buf, "%s", string);
 8014714:	4b6e      	ldr	r3, [pc, #440]	; (80148d0 <json_serialize_to_buffer_r.constprop.0+0x348>)
 8014716:	881b      	ldrh	r3, [r3, #0]
 8014718:	f824 3b01 	strh.w	r3, [r4], #1
                    APPEND_STRING(",");
 801471c:	f102 0b01 	add.w	fp, r2, #1
                if (is_pretty) {
 8014720:	9b04      	ldr	r3, [sp, #16]
 8014722:	2b00      	cmp	r3, #0
 8014724:	f040 80ad 	bne.w	8014882 <json_serialize_to_buffer_r.constprop.0+0x2fa>
            for (i = 0; i < count; i++) {
 8014728:	9b06      	ldr	r3, [sp, #24]
 801472a:	f10a 0a01 	add.w	sl, sl, #1
 801472e:	4553      	cmp	r3, sl
 8014730:	f240 80f9 	bls.w	8014926 <json_serialize_to_buffer_r.constprop.0+0x39e>
 8014734:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8014738:	e77f      	b.n	801463a <json_serialize_to_buffer_r.constprop.0+0xb2>
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 801473a:	f8d3 8008 	ldr.w	r8, [r3, #8]
    return array ? array->count : 0;
 801473e:	f1b8 0f00 	cmp.w	r8, #0
 8014742:	f000 80e1 	beq.w	8014908 <json_serialize_to_buffer_r.constprop.0+0x380>
 8014746:	f8d8 7008 	ldr.w	r7, [r8, #8]
    if (buf == NULL) {
 801474a:	2900      	cmp	r1, #0
 801474c:	f000 80ca 	beq.w	80148e4 <json_serialize_to_buffer_r.constprop.0+0x35c>
    return sprintf(buf, "%s", string);
 8014750:	4b60      	ldr	r3, [pc, #384]	; (80148d4 <json_serialize_to_buffer_r.constprop.0+0x34c>)
 8014752:	468b      	mov	fp, r1
 8014754:	881b      	ldrh	r3, [r3, #0]
 8014756:	f82b 3b01 	strh.w	r3, [fp], #1
            if (count > 0 && is_pretty) {
 801475a:	2f00      	cmp	r7, #0
 801475c:	f000 80da 	beq.w	8014914 <json_serialize_to_buffer_r.constprop.0+0x38c>
 8014760:	b955      	cbnz	r5, 8014778 <json_serialize_to_buffer_r.constprop.0+0x1f0>
 8014762:	2401      	movs	r4, #1
 8014764:	e00f      	b.n	8014786 <json_serialize_to_buffer_r.constprop.0+0x1fe>
    return json_value_get_type(value) == JSONString ? value->value.string : NULL;
 8014766:	6898      	ldr	r0, [r3, #8]
            if (string == NULL) {
 8014768:	2800      	cmp	r0, #0
 801476a:	f43f af20 	beq.w	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
            written = json_serialize_string(string, buf);
 801476e:	f7ff fa89 	bl	8013c84 <json_serialize_string>
            if (written < 0) {
 8014772:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 8014776:	e71c      	b.n	80145b2 <json_serialize_to_buffer_r.constprop.0+0x2a>
    return sprintf(buf, "%s", string);
 8014778:	4b57      	ldr	r3, [pc, #348]	; (80148d8 <json_serialize_to_buffer_r.constprop.0+0x350>)
                APPEND_STRING("\n");
 801477a:	2402      	movs	r4, #2
    return sprintf(buf, "%s", string);
 801477c:	881b      	ldrh	r3, [r3, #0]
 801477e:	f8ab 3000 	strh.w	r3, [fp]
                APPEND_STRING("\n");
 8014782:	eb01 0b04 	add.w	fp, r1, r4
            for (i = 0; i < count; i++) {
 8014786:	462b      	mov	r3, r5
    return sprintf(buf, "%s", string);
 8014788:	f8df 9138 	ldr.w	r9, [pc, #312]	; 80148c4 <json_serialize_to_buffer_r.constprop.0+0x33c>
 801478c:	f8df a140 	ldr.w	sl, [pc, #320]	; 80148d0 <json_serialize_to_buffer_r.constprop.0+0x348>
 8014790:	465d      	mov	r5, fp
 8014792:	2600      	movs	r6, #0
 8014794:	469b      	mov	fp, r3
                if (is_pretty) {
 8014796:	f1bb 0f00 	cmp.w	fp, #0
 801479a:	d133      	bne.n	8014804 <json_serialize_to_buffer_r.constprop.0+0x27c>
    if (array == NULL || index >= json_array_get_count(array)) {
 801479c:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80147a0:	42b2      	cmp	r2, r6
 80147a2:	d93d      	bls.n	8014820 <json_serialize_to_buffer_r.constprop.0+0x298>
    return array->items[index];
 80147a4:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80147a8:	f852 0026 	ldr.w	r0, [r2, r6, lsl #2]
                written = json_serialize_to_buffer_r(temp_value, buf, level+1, is_pretty, num_buf);
 80147ac:	9b03      	ldr	r3, [sp, #12]
 80147ae:	9300      	str	r3, [sp, #0]
 80147b0:	2201      	movs	r2, #1
 80147b2:	465b      	mov	r3, fp
 80147b4:	4629      	mov	r1, r5
 80147b6:	f7ff fc73 	bl	80140a0 <json_serialize_to_buffer_r>
                if (written < 0) {
 80147ba:	2800      	cmp	r0, #0
 80147bc:	f6ff aef7 	blt.w	80145ae <json_serialize_to_buffer_r.constprop.0+0x26>
                if (i < (count - 1)) {
 80147c0:	1e7a      	subs	r2, r7, #1
                if (buf != NULL) {
 80147c2:	b37d      	cbz	r5, 8014824 <json_serialize_to_buffer_r.constprop.0+0x29c>
                if (i < (count - 1)) {
 80147c4:	4296      	cmp	r6, r2
                    buf += written;
 80147c6:	4405      	add	r5, r0
                written_total += written;
 80147c8:	4404      	add	r4, r0
                if (i < (count - 1)) {
 80147ca:	d30d      	bcc.n	80147e8 <json_serialize_to_buffer_r.constprop.0+0x260>
                if (is_pretty) {
 80147cc:	f1bb 0f00 	cmp.w	fp, #0
 80147d0:	d112      	bne.n	80147f8 <json_serialize_to_buffer_r.constprop.0+0x270>
            for (i = 0; i < count; i++) {
 80147d2:	3601      	adds	r6, #1
 80147d4:	42b7      	cmp	r7, r6
 80147d6:	d8de      	bhi.n	8014796 <json_serialize_to_buffer_r.constprop.0+0x20e>
    if (buf == NULL) {
 80147d8:	46ab      	mov	fp, r5
 80147da:	b11d      	cbz	r5, 80147e4 <json_serialize_to_buffer_r.constprop.0+0x25c>
    return sprintf(buf, "%s", string);
 80147dc:	4b3f      	ldr	r3, [pc, #252]	; (80148dc <json_serialize_to_buffer_r.constprop.0+0x354>)
 80147de:	881b      	ldrh	r3, [r3, #0]
 80147e0:	f8ab 3000 	strh.w	r3, [fp]
            APPEND_STRING("]");
 80147e4:	1c60      	adds	r0, r4, #1
            return written_total;
 80147e6:	e6e4      	b.n	80145b2 <json_serialize_to_buffer_r.constprop.0+0x2a>
    return sprintf(buf, "%s", string);
 80147e8:	f8ba 2000 	ldrh.w	r2, [sl]
 80147ec:	f825 2b01 	strh.w	r2, [r5], #1
                    APPEND_STRING(",");
 80147f0:	3401      	adds	r4, #1
                if (is_pretty) {
 80147f2:	f1bb 0f00 	cmp.w	fp, #0
 80147f6:	d0ec      	beq.n	80147d2 <json_serialize_to_buffer_r.constprop.0+0x24a>
    return sprintf(buf, "%s", string);
 80147f8:	4b37      	ldr	r3, [pc, #220]	; (80148d8 <json_serialize_to_buffer_r.constprop.0+0x350>)
 80147fa:	881a      	ldrh	r2, [r3, #0]
 80147fc:	f825 2b01 	strh.w	r2, [r5], #1
                    APPEND_STRING("\n");
 8014800:	3401      	adds	r4, #1
 8014802:	e7e6      	b.n	80147d2 <json_serialize_to_buffer_r.constprop.0+0x24a>
    if (buf == NULL) {
 8014804:	b135      	cbz	r5, 8014814 <json_serialize_to_buffer_r.constprop.0+0x28c>
    return sprintf(buf, "%s", string);
 8014806:	f8d9 0000 	ldr.w	r0, [r9]
 801480a:	f899 2004 	ldrb.w	r2, [r9, #4]
 801480e:	6028      	str	r0, [r5, #0]
 8014810:	f805 2f04 	strb.w	r2, [r5, #4]!
    if (array == NULL || index >= json_array_get_count(array)) {
 8014814:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8014818:	42b2      	cmp	r2, r6
                    APPEND_INDENT(level+1);
 801481a:	f104 0404 	add.w	r4, r4, #4
    if (array == NULL || index >= json_array_get_count(array)) {
 801481e:	d8c1      	bhi.n	80147a4 <json_serialize_to_buffer_r.constprop.0+0x21c>
        return NULL;
 8014820:	2000      	movs	r0, #0
 8014822:	e7c3      	b.n	80147ac <json_serialize_to_buffer_r.constprop.0+0x224>
                if (i < (count - 1)) {
 8014824:	4296      	cmp	r6, r2
                written_total += written;
 8014826:	4404      	add	r4, r0
                if (i < (count - 1)) {
 8014828:	d303      	bcc.n	8014832 <json_serialize_to_buffer_r.constprop.0+0x2aa>
                if (is_pretty) {
 801482a:	f1bb 0f00 	cmp.w	fp, #0
 801482e:	d0d0      	beq.n	80147d2 <json_serialize_to_buffer_r.constprop.0+0x24a>
 8014830:	e7e6      	b.n	8014800 <json_serialize_to_buffer_r.constprop.0+0x278>
                    APPEND_STRING(",");
 8014832:	3401      	adds	r4, #1
                if (is_pretty) {
 8014834:	f1bb 0f00 	cmp.w	fp, #0
 8014838:	d0cb      	beq.n	80147d2 <json_serialize_to_buffer_r.constprop.0+0x24a>
 801483a:	e7e1      	b.n	8014800 <json_serialize_to_buffer_r.constprop.0+0x278>
    return sprintf(buf, "%s", string);
 801483c:	4b26      	ldr	r3, [pc, #152]	; (80148d8 <json_serialize_to_buffer_r.constprop.0+0x350>)
 801483e:	881b      	ldrh	r3, [r3, #0]
 8014840:	8023      	strh	r3, [r4, #0]
                APPEND_STRING("\n");
 8014842:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8014846:	1c8c      	adds	r4, r1, #2
 8014848:	f04f 0b02 	mov.w	fp, #2
 801484c:	e6f2      	b.n	8014634 <json_serialize_to_buffer_r.constprop.0+0xac>
                written_total += written;
 801484e:	4458      	add	r0, fp
                APPEND_STRING(":");
 8014850:	1c43      	adds	r3, r0, #1
 8014852:	9305      	str	r3, [sp, #20]
                if (is_pretty) {
 8014854:	9b04      	ldr	r3, [sp, #16]
 8014856:	2b00      	cmp	r3, #0
 8014858:	f47f af1b 	bne.w	8014692 <json_serialize_to_buffer_r.constprop.0+0x10a>
 801485c:	e71c      	b.n	8014698 <json_serialize_to_buffer_r.constprop.0+0x110>
                written_total += written;
 801485e:	9a05      	ldr	r2, [sp, #20]
                if (i < (count - 1)) {
 8014860:	459a      	cmp	sl, r3
                written_total += written;
 8014862:	4402      	add	r2, r0
 8014864:	4693      	mov	fp, r2
                if (i < (count - 1)) {
 8014866:	d319      	bcc.n	801489c <json_serialize_to_buffer_r.constprop.0+0x314>
                if (is_pretty) {
 8014868:	9b04      	ldr	r3, [sp, #16]
 801486a:	2b00      	cmp	r3, #0
 801486c:	f43f af5c 	beq.w	8014728 <json_serialize_to_buffer_r.constprop.0+0x1a0>
                    APPEND_STRING("\n");
 8014870:	f10b 0b01 	add.w	fp, fp, #1
 8014874:	e758      	b.n	8014728 <json_serialize_to_buffer_r.constprop.0+0x1a0>
            return object->values[i];
 8014876:	f8d9 3008 	ldr.w	r3, [r9, #8]
 801487a:	9c07      	ldr	r4, [sp, #28]
 801487c:	f853 0008 	ldr.w	r0, [r3, r8]
 8014880:	e733      	b.n	80146ea <json_serialize_to_buffer_r.constprop.0+0x162>
    return sprintf(buf, "%s", string);
 8014882:	4b15      	ldr	r3, [pc, #84]	; (80148d8 <json_serialize_to_buffer_r.constprop.0+0x350>)
 8014884:	881b      	ldrh	r3, [r3, #0]
 8014886:	f824 3b01 	strh.w	r3, [r4], #1
                    APPEND_STRING("\n");
 801488a:	e7f1      	b.n	8014870 <json_serialize_to_buffer_r.constprop.0+0x2e8>
    if (buf == NULL) {
 801488c:	b121      	cbz	r1, 8014898 <json_serialize_to_buffer_r.constprop.0+0x310>
    return sprintf(buf, "%s", string);
 801488e:	4b14      	ldr	r3, [pc, #80]	; (80148e0 <json_serialize_to_buffer_r.constprop.0+0x358>)
 8014890:	6818      	ldr	r0, [r3, #0]
 8014892:	889b      	ldrh	r3, [r3, #4]
 8014894:	6008      	str	r0, [r1, #0]
 8014896:	808b      	strh	r3, [r1, #4]
                APPEND_STRING("false");
 8014898:	2005      	movs	r0, #5
 801489a:	e68a      	b.n	80145b2 <json_serialize_to_buffer_r.constprop.0+0x2a>
                if (is_pretty) {
 801489c:	9b04      	ldr	r3, [sp, #16]
                    APPEND_STRING(",");
 801489e:	f10b 0b01 	add.w	fp, fp, #1
                if (is_pretty) {
 80148a2:	2b00      	cmp	r3, #0
 80148a4:	f43f af40 	beq.w	8014728 <json_serialize_to_buffer_r.constprop.0+0x1a0>
 80148a8:	e7e2      	b.n	8014870 <json_serialize_to_buffer_r.constprop.0+0x2e8>
            if (count > 0 && is_pretty) {
 80148aa:	b3ab      	cbz	r3, 8014918 <json_serialize_to_buffer_r.constprop.0+0x390>
 80148ac:	460c      	mov	r4, r1
 80148ae:	f105 0b01 	add.w	fp, r5, #1
    if (object == NULL || index >= json_object_get_count(object)) {
 80148b2:	e6bf      	b.n	8014634 <json_serialize_to_buffer_r.constprop.0+0xac>
 80148b4:	0801ac34 	.word	0x0801ac34
 80148b8:	0801ac3c 	.word	0x0801ac3c
 80148bc:	0801ac24 	.word	0x0801ac24
 80148c0:	0801ac1c 	.word	0x0801ac1c
 80148c4:	0801ac0c 	.word	0x0801ac0c
 80148c8:	0801ac44 	.word	0x0801ac44
 80148cc:	0801ac48 	.word	0x0801ac48
 80148d0:	0801ac14 	.word	0x0801ac14
 80148d4:	0801ac04 	.word	0x0801ac04
 80148d8:	0801ac08 	.word	0x0801ac08
 80148dc:	0801ac18 	.word	0x0801ac18
 80148e0:	0801ac2c 	.word	0x0801ac2c
            if (count > 0 && is_pretty) {
 80148e4:	b1df      	cbz	r7, 801491e <json_serialize_to_buffer_r.constprop.0+0x396>
 80148e6:	468b      	mov	fp, r1
 80148e8:	1c6c      	adds	r4, r5, #1
 80148ea:	e74c      	b.n	8014786 <json_serialize_to_buffer_r.constprop.0+0x1fe>
    if (buf == NULL) {
 80148ec:	b1a1      	cbz	r1, 8014918 <json_serialize_to_buffer_r.constprop.0+0x390>
    return sprintf(buf, "%s", string);
 80148ee:	4b0f      	ldr	r3, [pc, #60]	; (801492c <json_serialize_to_buffer_r.constprop.0+0x3a4>)
 80148f0:	460c      	mov	r4, r1
 80148f2:	881b      	ldrh	r3, [r3, #0]
 80148f4:	f824 3b01 	strh.w	r3, [r4], #1
    return NULL;
 80148f8:	f04f 0b01 	mov.w	fp, #1
    return sprintf(buf, "%s", string);
 80148fc:	4b0c      	ldr	r3, [pc, #48]	; (8014930 <json_serialize_to_buffer_r.constprop.0+0x3a8>)
 80148fe:	881b      	ldrh	r3, [r3, #0]
 8014900:	8023      	strh	r3, [r4, #0]
            APPEND_STRING("}");
 8014902:	f10b 0001 	add.w	r0, fp, #1
            return written_total;
 8014906:	e654      	b.n	80145b2 <json_serialize_to_buffer_r.constprop.0+0x2a>
    if (buf == NULL) {
 8014908:	b149      	cbz	r1, 801491e <json_serialize_to_buffer_r.constprop.0+0x396>
    return sprintf(buf, "%s", string);
 801490a:	4b0a      	ldr	r3, [pc, #40]	; (8014934 <json_serialize_to_buffer_r.constprop.0+0x3ac>)
 801490c:	468b      	mov	fp, r1
 801490e:	881b      	ldrh	r3, [r3, #0]
 8014910:	f82b 3b01 	strh.w	r3, [fp], #1
        return NULL;
 8014914:	2401      	movs	r4, #1
 8014916:	e761      	b.n	80147dc <json_serialize_to_buffer_r.constprop.0+0x254>
            if (count > 0 && is_pretty) {
 8014918:	f04f 0b01 	mov.w	fp, #1
 801491c:	e7f1      	b.n	8014902 <json_serialize_to_buffer_r.constprop.0+0x37a>
        return (int)strlen(string);
 801491e:	2401      	movs	r4, #1
 8014920:	e760      	b.n	80147e4 <json_serialize_to_buffer_r.constprop.0+0x25c>
    return NULL;
 8014922:	4618      	mov	r0, r3
 8014924:	e6e1      	b.n	80146ea <json_serialize_to_buffer_r.constprop.0+0x162>
    if (buf == NULL) {
 8014926:	2c00      	cmp	r4, #0
 8014928:	d1e8      	bne.n	80148fc <json_serialize_to_buffer_r.constprop.0+0x374>
 801492a:	e7ea      	b.n	8014902 <json_serialize_to_buffer_r.constprop.0+0x37a>
 801492c:	0801ac1c 	.word	0x0801ac1c
 8014930:	0801ac20 	.word	0x0801ac20
 8014934:	0801ac04 	.word	0x0801ac04

08014938 <json_object_get_value>:
JSON_Value * json_object_get_value(const JSON_Object *object, const char *name) {
 8014938:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (object == NULL || name == NULL) {
 801493c:	4605      	mov	r5, r0
 801493e:	b310      	cbz	r0, 8014986 <json_object_get_value+0x4e>
 8014940:	460c      	mov	r4, r1
        return NULL;
 8014942:	4608      	mov	r0, r1
    if (object == NULL || name == NULL) {
 8014944:	b301      	cbz	r1, 8014988 <json_object_get_value+0x50>
    return json_object_getn_value(object, name, strlen(name));
 8014946:	f7eb fc65 	bl	8000214 <strlen>
    return object ? object->count : 0;
 801494a:	f8d5 800c 	ldr.w	r8, [r5, #12]
    return json_object_getn_value(object, name, strlen(name));
 801494e:	4681      	mov	r9, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 8014950:	f1b8 0f00 	cmp.w	r8, #0
 8014954:	d01e      	beq.n	8014994 <json_object_get_value+0x5c>
 8014956:	686b      	ldr	r3, [r5, #4]
 8014958:	2600      	movs	r6, #0
 801495a:	f1a3 0a04 	sub.w	sl, r3, #4
        name_length = strlen(object->names[i]);
 801495e:	f85a 7f04 	ldr.w	r7, [sl, #4]!
 8014962:	4638      	mov	r0, r7
 8014964:	f7eb fc56 	bl	8000214 <strlen>
 8014968:	4603      	mov	r3, r0
        if (name_length != name_len) {
 801496a:	4599      	cmp	r9, r3
        if (strncmp(object->names[i], name, name_len) == 0) {
 801496c:	4638      	mov	r0, r7
 801496e:	464a      	mov	r2, r9
 8014970:	ea4f 0786 	mov.w	r7, r6, lsl #2
 8014974:	4621      	mov	r1, r4
    for (i = 0; i < json_object_get_count(object); i++) {
 8014976:	f106 0601 	add.w	r6, r6, #1
        if (name_length != name_len) {
 801497a:	d102      	bne.n	8014982 <json_object_get_value+0x4a>
        if (strncmp(object->names[i], name, name_len) == 0) {
 801497c:	f002 f8cc 	bl	8016b18 <strncmp>
 8014980:	b120      	cbz	r0, 801498c <json_object_get_value+0x54>
    for (i = 0; i < json_object_get_count(object); i++) {
 8014982:	4546      	cmp	r6, r8
 8014984:	d1eb      	bne.n	801495e <json_object_get_value+0x26>
        return NULL;
 8014986:	2000      	movs	r0, #0
}
 8014988:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            return object->values[i];
 801498c:	68ab      	ldr	r3, [r5, #8]
 801498e:	59d8      	ldr	r0, [r3, r7]
}
 8014990:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return NULL;
 8014994:	4640      	mov	r0, r8
 8014996:	e7f7      	b.n	8014988 <json_object_get_value+0x50>

08014998 <json_object_dotget_value>:
JSON_Value * json_object_dotget_value(const JSON_Object *object, const char *name) {
 8014998:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801499c:	460f      	mov	r7, r1
 801499e:	4604      	mov	r4, r0
    const char *dot_position = strchr(name, '.');
 80149a0:	212e      	movs	r1, #46	; 0x2e
 80149a2:	4638      	mov	r0, r7
 80149a4:	f002 f8ab 	bl	8016afe <strchr>
    if (!dot_position) {
 80149a8:	4605      	mov	r5, r0
 80149aa:	b360      	cbz	r0, 8014a06 <json_object_dotget_value+0x6e>
    return object ? object->count : 0;
 80149ac:	b31c      	cbz	r4, 80149f6 <json_object_dotget_value+0x5e>
 80149ae:	f8d4 a00c 	ldr.w	sl, [r4, #12]
    object = json_value_get_object(json_object_getn_value(object, name, dot_position - name));
 80149b2:	eba0 0807 	sub.w	r8, r0, r7
    for (i = 0; i < json_object_get_count(object); i++) {
 80149b6:	2600      	movs	r6, #0
 80149b8:	e000      	b.n	80149bc <json_object_dotget_value+0x24>
 80149ba:	3601      	adds	r6, #1
 80149bc:	45b2      	cmp	sl, r6
 80149be:	ea4f 0986 	mov.w	r9, r6, lsl #2
 80149c2:	d04b      	beq.n	8014a5c <json_object_dotget_value+0xc4>
        name_length = strlen(object->names[i]);
 80149c4:	6863      	ldr	r3, [r4, #4]
 80149c6:	f853 b026 	ldr.w	fp, [r3, r6, lsl #2]
 80149ca:	4658      	mov	r0, fp
 80149cc:	f7eb fc22 	bl	8000214 <strlen>
 80149d0:	4603      	mov	r3, r0
        if (name_length != name_len) {
 80149d2:	4598      	cmp	r8, r3
        if (strncmp(object->names[i], name, name_len) == 0) {
 80149d4:	4642      	mov	r2, r8
 80149d6:	4639      	mov	r1, r7
 80149d8:	4658      	mov	r0, fp
        if (name_length != name_len) {
 80149da:	d1ee      	bne.n	80149ba <json_object_dotget_value+0x22>
        if (strncmp(object->names[i], name, name_len) == 0) {
 80149dc:	f002 f89c 	bl	8016b18 <strncmp>
 80149e0:	2800      	cmp	r0, #0
 80149e2:	d1ea      	bne.n	80149ba <json_object_dotget_value+0x22>
            return object->values[i];
 80149e4:	68a3      	ldr	r3, [r4, #8]
 80149e6:	f853 4009 	ldr.w	r4, [r3, r9]
    return value ? value->type : JSONError;
 80149ea:	b124      	cbz	r4, 80149f6 <json_object_dotget_value+0x5e>
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 80149ec:	6863      	ldr	r3, [r4, #4]
 80149ee:	2b04      	cmp	r3, #4
 80149f0:	bf0c      	ite	eq
 80149f2:	68a4      	ldreq	r4, [r4, #8]
 80149f4:	4604      	movne	r4, r0
    return json_object_dotget_value(object, dot_position + 1);
 80149f6:	1c6f      	adds	r7, r5, #1
    const char *dot_position = strchr(name, '.');
 80149f8:	212e      	movs	r1, #46	; 0x2e
 80149fa:	4638      	mov	r0, r7
 80149fc:	f002 f87f 	bl	8016afe <strchr>
    if (!dot_position) {
 8014a00:	4605      	mov	r5, r0
 8014a02:	2800      	cmp	r0, #0
 8014a04:	d1d2      	bne.n	80149ac <json_object_dotget_value+0x14>
    if (object == NULL || name == NULL) {
 8014a06:	b304      	cbz	r4, 8014a4a <json_object_dotget_value+0xb2>
    return json_object_getn_value(object, name, strlen(name));
 8014a08:	4638      	mov	r0, r7
 8014a0a:	f7eb fc03 	bl	8000214 <strlen>
    return object ? object->count : 0;
 8014a0e:	f8d4 b00c 	ldr.w	fp, [r4, #12]
    return json_object_getn_value(object, name, strlen(name));
 8014a12:	4681      	mov	r9, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 8014a14:	f1bb 0f00 	cmp.w	fp, #0
 8014a18:	d017      	beq.n	8014a4a <json_object_dotget_value+0xb2>
 8014a1a:	6863      	ldr	r3, [r4, #4]
 8014a1c:	462e      	mov	r6, r5
 8014a1e:	f1a3 0a04 	sub.w	sl, r3, #4
        name_length = strlen(object->names[i]);
 8014a22:	f85a 8f04 	ldr.w	r8, [sl, #4]!
 8014a26:	4640      	mov	r0, r8
 8014a28:	f7eb fbf4 	bl	8000214 <strlen>
 8014a2c:	4603      	mov	r3, r0
        if (name_length != name_len) {
 8014a2e:	4599      	cmp	r9, r3
        if (strncmp(object->names[i], name, name_len) == 0) {
 8014a30:	4640      	mov	r0, r8
 8014a32:	464a      	mov	r2, r9
 8014a34:	ea4f 0886 	mov.w	r8, r6, lsl #2
 8014a38:	4639      	mov	r1, r7
    for (i = 0; i < json_object_get_count(object); i++) {
 8014a3a:	f106 0601 	add.w	r6, r6, #1
        if (name_length != name_len) {
 8014a3e:	d102      	bne.n	8014a46 <json_object_dotget_value+0xae>
        if (strncmp(object->names[i], name, name_len) == 0) {
 8014a40:	f002 f86a 	bl	8016b18 <strncmp>
 8014a44:	b120      	cbz	r0, 8014a50 <json_object_dotget_value+0xb8>
    for (i = 0; i < json_object_get_count(object); i++) {
 8014a46:	455e      	cmp	r6, fp
 8014a48:	d1eb      	bne.n	8014a22 <json_object_dotget_value+0x8a>
}
 8014a4a:	4628      	mov	r0, r5
 8014a4c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return object->values[i];
 8014a50:	68a3      	ldr	r3, [r4, #8]
 8014a52:	f853 5008 	ldr.w	r5, [r3, r8]
}
 8014a56:	4628      	mov	r0, r5
 8014a58:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8014a5c:	2400      	movs	r4, #0
 8014a5e:	e7ca      	b.n	80149f6 <json_object_dotget_value+0x5e>

08014a60 <json_object_dotget_number>:
double json_object_dotget_number(const JSON_Object *object, const char *name) {
 8014a60:	b508      	push	{r3, lr}
    return json_value_get_number(json_object_dotget_value(object, name));
 8014a62:	f7ff ff99 	bl	8014998 <json_object_dotget_value>
    return value ? value->type : JSONError;
 8014a66:	b110      	cbz	r0, 8014a6e <json_object_dotget_number+0xe>
}

double json_value_get_number(const JSON_Value *value) {
    return json_value_get_type(value) == JSONNumber ? value->value.number : 0;
 8014a68:	6843      	ldr	r3, [r0, #4]
 8014a6a:	2b03      	cmp	r3, #3
 8014a6c:	d002      	beq.n	8014a74 <json_object_dotget_number+0x14>
 8014a6e:	ed9f 0b04 	vldr	d0, [pc, #16]	; 8014a80 <json_object_dotget_number+0x20>
}
 8014a72:	bd08      	pop	{r3, pc}
    return json_value_get_type(value) == JSONNumber ? value->value.number : 0;
 8014a74:	ed90 0b02 	vldr	d0, [r0, #8]
}
 8014a78:	bd08      	pop	{r3, pc}
 8014a7a:	bf00      	nop
 8014a7c:	f3af 8000 	nop.w
	...

08014a88 <json_object_dotget_array>:
JSON_Array * json_object_dotget_array(const JSON_Object *object, const char *name) {
 8014a88:	b508      	push	{r3, lr}
    return json_value_get_array(json_object_dotget_value(object, name));
 8014a8a:	f7ff ff85 	bl	8014998 <json_object_dotget_value>
    return value ? value->type : JSONError;
 8014a8e:	b120      	cbz	r0, 8014a9a <json_object_dotget_array+0x12>
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 8014a90:	6843      	ldr	r3, [r0, #4]
 8014a92:	2b05      	cmp	r3, #5
 8014a94:	bf0c      	ite	eq
 8014a96:	6880      	ldreq	r0, [r0, #8]
 8014a98:	2000      	movne	r0, #0
}
 8014a9a:	bd08      	pop	{r3, pc}

08014a9c <json_object_dotget_boolean>:
int json_object_dotget_boolean(const JSON_Object *object, const char *name) {
 8014a9c:	b508      	push	{r3, lr}
    return json_value_get_boolean(json_object_dotget_value(object, name));
 8014a9e:	f7ff ff7b 	bl	8014998 <json_object_dotget_value>
    return value ? value->type : JSONError;
 8014aa2:	b120      	cbz	r0, 8014aae <json_object_dotget_boolean+0x12>
}

int json_value_get_boolean(const JSON_Value *value) {
    return json_value_get_type(value) == JSONBoolean ? value->value.boolean : -1;
 8014aa4:	6843      	ldr	r3, [r0, #4]
 8014aa6:	2b06      	cmp	r3, #6
 8014aa8:	d101      	bne.n	8014aae <json_object_dotget_boolean+0x12>
 8014aaa:	6880      	ldr	r0, [r0, #8]
}
 8014aac:	bd08      	pop	{r3, pc}
    return json_value_get_type(value) == JSONBoolean ? value->value.boolean : -1;
 8014aae:	f04f 30ff 	mov.w	r0, #4294967295
}
 8014ab2:	bd08      	pop	{r3, pc}

08014ab4 <json_object_dothas_value>:
int json_object_dothas_value (const JSON_Object *object, const char *name) {
 8014ab4:	b508      	push	{r3, lr}
    return json_object_dotget_value(object, name) != NULL;
 8014ab6:	f7ff ff6f 	bl	8014998 <json_object_dotget_value>
}
 8014aba:	3800      	subs	r0, #0
 8014abc:	bf18      	it	ne
 8014abe:	2001      	movne	r0, #1
 8014ac0:	bd08      	pop	{r3, pc}
 8014ac2:	bf00      	nop

08014ac4 <json_array_get_object>:
    if (array == NULL || index >= json_array_get_count(array)) {
 8014ac4:	b160      	cbz	r0, 8014ae0 <json_array_get_object+0x1c>
 8014ac6:	6883      	ldr	r3, [r0, #8]
 8014ac8:	4299      	cmp	r1, r3
 8014aca:	d208      	bcs.n	8014ade <json_array_get_object+0x1a>
    return array->items[index];
 8014acc:	6843      	ldr	r3, [r0, #4]
 8014ace:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
    return value ? value->type : JSONError;
 8014ad2:	b128      	cbz	r0, 8014ae0 <json_array_get_object+0x1c>
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8014ad4:	6843      	ldr	r3, [r0, #4]
 8014ad6:	2b04      	cmp	r3, #4
 8014ad8:	d101      	bne.n	8014ade <json_array_get_object+0x1a>
 8014ada:	6880      	ldr	r0, [r0, #8]
 8014adc:	4770      	bx	lr
 8014ade:	2000      	movs	r0, #0
}
 8014ae0:	4770      	bx	lr
 8014ae2:	bf00      	nop

08014ae4 <json_array_get_count>:
    return array ? array->count : 0;
 8014ae4:	b100      	cbz	r0, 8014ae8 <json_array_get_count+0x4>
 8014ae6:	6880      	ldr	r0, [r0, #8]
}
 8014ae8:	4770      	bx	lr
 8014aea:	bf00      	nop

08014aec <json_value_get_object>:
    return value ? value->type : JSONError;
 8014aec:	b128      	cbz	r0, 8014afa <json_value_get_object+0xe>
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8014aee:	6843      	ldr	r3, [r0, #4]
 8014af0:	2b04      	cmp	r3, #4
 8014af2:	d101      	bne.n	8014af8 <json_value_get_object+0xc>
 8014af4:	6880      	ldr	r0, [r0, #8]
 8014af6:	4770      	bx	lr
 8014af8:	2000      	movs	r0, #0
}
 8014afa:	4770      	bx	lr

08014afc <json_value_get_array>:
    return value ? value->type : JSONError;
 8014afc:	b128      	cbz	r0, 8014b0a <json_value_get_array+0xe>
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 8014afe:	6843      	ldr	r3, [r0, #4]
 8014b00:	2b05      	cmp	r3, #5
 8014b02:	d101      	bne.n	8014b08 <json_value_get_array+0xc>
 8014b04:	6880      	ldr	r0, [r0, #8]
 8014b06:	4770      	bx	lr
 8014b08:	2000      	movs	r0, #0
}
 8014b0a:	4770      	bx	lr

08014b0c <json_value_free>:

JSON_Value * json_value_get_parent (const JSON_Value *value) {
    return value ? value->parent : NULL;
}

void json_value_free(JSON_Value *value) {
 8014b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return value ? value->type : JSONError;
 8014b10:	4604      	mov	r4, r0
 8014b12:	2800      	cmp	r0, #0
 8014b14:	d04e      	beq.n	8014bb4 <json_value_free+0xa8>
 8014b16:	6843      	ldr	r3, [r0, #4]
    switch (json_value_get_type(value)) {
 8014b18:	2b04      	cmp	r3, #4
 8014b1a:	d009      	beq.n	8014b30 <json_value_free+0x24>
 8014b1c:	2b05      	cmp	r3, #5
 8014b1e:	d030      	beq.n	8014b82 <json_value_free+0x76>
 8014b20:	2b02      	cmp	r3, #2
 8014b22:	4e25      	ldr	r6, [pc, #148]	; (8014bb8 <json_value_free+0xac>)
 8014b24:	d025      	beq.n	8014b72 <json_value_free+0x66>
            json_array_free(value->value.array);
            break;
        default:
            break;
    }
    parson_free(value);
 8014b26:	6873      	ldr	r3, [r6, #4]
 8014b28:	4620      	mov	r0, r4
}
 8014b2a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    parson_free(value);
 8014b2e:	4718      	bx	r3
            json_object_free(value->value.object);
 8014b30:	6887      	ldr	r7, [r0, #8]
    for (i = 0; i < object->count; i++) {
 8014b32:	4e21      	ldr	r6, [pc, #132]	; (8014bb8 <json_value_free+0xac>)
 8014b34:	68fb      	ldr	r3, [r7, #12]
 8014b36:	2500      	movs	r5, #0
 8014b38:	b16b      	cbz	r3, 8014b56 <json_value_free+0x4a>
        parson_free(object->names[i]);
 8014b3a:	687a      	ldr	r2, [r7, #4]
 8014b3c:	6873      	ldr	r3, [r6, #4]
 8014b3e:	f852 0025 	ldr.w	r0, [r2, r5, lsl #2]
 8014b42:	4798      	blx	r3
        json_value_free(object->values[i]);
 8014b44:	68bb      	ldr	r3, [r7, #8]
 8014b46:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8014b4a:	f7ff ffdf 	bl	8014b0c <json_value_free>
    for (i = 0; i < object->count; i++) {
 8014b4e:	68fb      	ldr	r3, [r7, #12]
 8014b50:	3501      	adds	r5, #1
 8014b52:	429d      	cmp	r5, r3
 8014b54:	d3f1      	bcc.n	8014b3a <json_value_free+0x2e>
    parson_free(object->names);
 8014b56:	6873      	ldr	r3, [r6, #4]
 8014b58:	6878      	ldr	r0, [r7, #4]
 8014b5a:	4798      	blx	r3
    parson_free(object->values);
 8014b5c:	6873      	ldr	r3, [r6, #4]
 8014b5e:	68b8      	ldr	r0, [r7, #8]
 8014b60:	4798      	blx	r3
    parson_free(object);
 8014b62:	6873      	ldr	r3, [r6, #4]
 8014b64:	4638      	mov	r0, r7
 8014b66:	4798      	blx	r3
    parson_free(value);
 8014b68:	6873      	ldr	r3, [r6, #4]
 8014b6a:	4620      	mov	r0, r4
}
 8014b6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    parson_free(value);
 8014b70:	4718      	bx	r3
            parson_free(value->value.string);
 8014b72:	6873      	ldr	r3, [r6, #4]
 8014b74:	6880      	ldr	r0, [r0, #8]
 8014b76:	4798      	blx	r3
    parson_free(value);
 8014b78:	6873      	ldr	r3, [r6, #4]
 8014b7a:	4620      	mov	r0, r4
}
 8014b7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    parson_free(value);
 8014b80:	4718      	bx	r3
            json_array_free(value->value.array);
 8014b82:	6887      	ldr	r7, [r0, #8]
    for (i = 0; i < array->count; i++) {
 8014b84:	68bb      	ldr	r3, [r7, #8]
 8014b86:	b14b      	cbz	r3, 8014b9c <json_value_free+0x90>
 8014b88:	2500      	movs	r5, #0
        json_value_free(array->items[i]);
 8014b8a:	687b      	ldr	r3, [r7, #4]
 8014b8c:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8014b90:	f7ff ffbc 	bl	8014b0c <json_value_free>
    for (i = 0; i < array->count; i++) {
 8014b94:	68bb      	ldr	r3, [r7, #8]
 8014b96:	3501      	adds	r5, #1
 8014b98:	429d      	cmp	r5, r3
 8014b9a:	d3f6      	bcc.n	8014b8a <json_value_free+0x7e>
    parson_free(array->items);
 8014b9c:	4e06      	ldr	r6, [pc, #24]	; (8014bb8 <json_value_free+0xac>)
 8014b9e:	6878      	ldr	r0, [r7, #4]
 8014ba0:	6873      	ldr	r3, [r6, #4]
 8014ba2:	4798      	blx	r3
    parson_free(array);
 8014ba4:	6873      	ldr	r3, [r6, #4]
 8014ba6:	4638      	mov	r0, r7
 8014ba8:	4798      	blx	r3
    parson_free(value);
 8014baa:	6873      	ldr	r3, [r6, #4]
 8014bac:	4620      	mov	r0, r4
}
 8014bae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    parson_free(value);
 8014bb2:	4718      	bx	r3
 8014bb4:	4e00      	ldr	r6, [pc, #0]	; (8014bb8 <json_value_free+0xac>)
 8014bb6:	e7b6      	b.n	8014b26 <json_value_free+0x1a>
 8014bb8:	20000138 	.word	0x20000138

08014bbc <json_object_remove_internal>:
static JSON_Status json_object_remove_internal(JSON_Object *object, const char *name, int free_value) {
 8014bbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014bc0:	b083      	sub	sp, #12
 8014bc2:	9200      	str	r2, [sp, #0]
    if (object == NULL || json_object_get_value(object, name) == NULL) {
 8014bc4:	b318      	cbz	r0, 8014c0e <json_object_remove_internal+0x52>
    if (object == NULL || name == NULL) {
 8014bc6:	460e      	mov	r6, r1
 8014bc8:	b309      	cbz	r1, 8014c0e <json_object_remove_internal+0x52>
    return json_object_getn_value(object, name, strlen(name));
 8014bca:	4681      	mov	r9, r0
 8014bcc:	4608      	mov	r0, r1
 8014bce:	f7eb fb21 	bl	8000214 <strlen>
    return object ? object->count : 0;
 8014bd2:	f8d9 700c 	ldr.w	r7, [r9, #12]
    return json_object_getn_value(object, name, strlen(name));
 8014bd6:	4683      	mov	fp, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 8014bd8:	b1cf      	cbz	r7, 8014c0e <json_object_remove_internal+0x52>
 8014bda:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8014bde:	f1a3 0804 	sub.w	r8, r3, #4
        name_length = strlen(object->names[i]);
 8014be2:	4644      	mov	r4, r8
    for (i = 0; i < json_object_get_count(object); i++) {
 8014be4:	2500      	movs	r5, #0
        name_length = strlen(object->names[i]);
 8014be6:	f854 af04 	ldr.w	sl, [r4, #4]!
 8014bea:	4650      	mov	r0, sl
 8014bec:	f7eb fb12 	bl	8000214 <strlen>
 8014bf0:	4684      	mov	ip, r0
        if (name_length != name_len) {
 8014bf2:	45e3      	cmp	fp, ip
        if (strncmp(object->names[i], name, name_len) == 0) {
 8014bf4:	4650      	mov	r0, sl
 8014bf6:	465a      	mov	r2, fp
 8014bf8:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 8014bfc:	4631      	mov	r1, r6
    for (i = 0; i < json_object_get_count(object); i++) {
 8014bfe:	f105 0501 	add.w	r5, r5, #1
        if (name_length != name_len) {
 8014c02:	d102      	bne.n	8014c0a <json_object_remove_internal+0x4e>
        if (strncmp(object->names[i], name, name_len) == 0) {
 8014c04:	f001 ff88 	bl	8016b18 <strncmp>
 8014c08:	b138      	cbz	r0, 8014c1a <json_object_remove_internal+0x5e>
    for (i = 0; i < json_object_get_count(object); i++) {
 8014c0a:	42af      	cmp	r7, r5
 8014c0c:	d1eb      	bne.n	8014be6 <json_object_remove_internal+0x2a>
        return JSONFailure;
 8014c0e:	f04f 35ff 	mov.w	r5, #4294967295
}
 8014c12:	4628      	mov	r0, r5
 8014c14:	b003      	add	sp, #12
 8014c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return object->values[i];
 8014c1a:	f8d9 2008 	ldr.w	r2, [r9, #8]
    if (object == NULL || json_object_get_value(object, name) == NULL) {
 8014c1e:	f852 300a 	ldr.w	r3, [r2, sl]
 8014c22:	2b00      	cmp	r3, #0
 8014c24:	d0f3      	beq.n	8014c0e <json_object_remove_internal+0x52>
    for (i = 0; i < json_object_get_count(object); i++) {
 8014c26:	4604      	mov	r4, r0
 8014c28:	e002      	b.n	8014c30 <json_object_remove_internal+0x74>
 8014c2a:	3401      	adds	r4, #1
 8014c2c:	42a7      	cmp	r7, r4
 8014c2e:	d0ee      	beq.n	8014c0e <json_object_remove_internal+0x52>
        if (strcmp(object->names[i], name) == 0) {
 8014c30:	f858 bf04 	ldr.w	fp, [r8, #4]!
 8014c34:	4631      	mov	r1, r6
 8014c36:	4658      	mov	r0, fp
 8014c38:	f7eb fae2 	bl	8000200 <strcmp>
    for (i = 0; i < json_object_get_count(object); i++) {
 8014c3c:	00a3      	lsls	r3, r4, #2
        if (strcmp(object->names[i], name) == 0) {
 8014c3e:	4605      	mov	r5, r0
 8014c40:	2800      	cmp	r0, #0
 8014c42:	d1f2      	bne.n	8014c2a <json_object_remove_internal+0x6e>
            parson_free(object->names[i]);
 8014c44:	4a11      	ldr	r2, [pc, #68]	; (8014c8c <json_object_remove_internal+0xd0>)
 8014c46:	9301      	str	r3, [sp, #4]
 8014c48:	6852      	ldr	r2, [r2, #4]
 8014c4a:	4658      	mov	r0, fp
 8014c4c:	4790      	blx	r2
            if (free_value) {
 8014c4e:	e9dd 2300 	ldrd	r2, r3, [sp]
 8014c52:	b99a      	cbnz	r2, 8014c7c <json_object_remove_internal+0xc0>
    last_item_index = json_object_get_count(object) - 1;
 8014c54:	3f01      	subs	r7, #1
            if (i != last_item_index) { /* Replace key value pair with one from the end */
 8014c56:	42a7      	cmp	r7, r4
 8014c58:	d007      	beq.n	8014c6a <json_object_remove_internal+0xae>
                object->values[i] = object->values[last_item_index];
 8014c5a:	e9d9 1201 	ldrd	r1, r2, [r9, #4]
                object->names[i] = object->names[last_item_index];
 8014c5e:	f851 4027 	ldr.w	r4, [r1, r7, lsl #2]
                object->values[i] = object->values[last_item_index];
 8014c62:	f852 0027 	ldr.w	r0, [r2, r7, lsl #2]
                object->names[i] = object->names[last_item_index];
 8014c66:	50cc      	str	r4, [r1, r3]
                object->values[i] = object->values[last_item_index];
 8014c68:	50d0      	str	r0, [r2, r3]
            object->count -= 1;
 8014c6a:	f8d9 300c 	ldr.w	r3, [r9, #12]
}
 8014c6e:	4628      	mov	r0, r5
            object->count -= 1;
 8014c70:	3b01      	subs	r3, #1
 8014c72:	f8c9 300c 	str.w	r3, [r9, #12]
}
 8014c76:	b003      	add	sp, #12
 8014c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                json_value_free(object->values[i]);
 8014c7c:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8014c80:	9300      	str	r3, [sp, #0]
 8014c82:	58d0      	ldr	r0, [r2, r3]
 8014c84:	f7ff ff42 	bl	8014b0c <json_value_free>
 8014c88:	9b00      	ldr	r3, [sp, #0]
 8014c8a:	e7e3      	b.n	8014c54 <json_object_remove_internal+0x98>
 8014c8c:	20000138 	.word	0x20000138

08014c90 <parse_value.part.0>:
static JSON_Value * parse_value(const char **string, size_t nesting) {
 8014c90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    SKIP_WHITESPACES(string);
 8014c94:	6806      	ldr	r6, [r0, #0]
 8014c96:	4da2      	ldr	r5, [pc, #648]	; (8014f20 <parse_value.part.0+0x290>)
 8014c98:	7833      	ldrb	r3, [r6, #0]
 8014c9a:	5cea      	ldrb	r2, [r5, r3]
 8014c9c:	0712      	lsls	r2, r2, #28
static JSON_Value * parse_value(const char **string, size_t nesting) {
 8014c9e:	b083      	sub	sp, #12
 8014ca0:	4604      	mov	r4, r0
 8014ca2:	460f      	mov	r7, r1
    SKIP_WHITESPACES(string);
 8014ca4:	d505      	bpl.n	8014cb2 <parse_value.part.0+0x22>
 8014ca6:	3601      	adds	r6, #1
 8014ca8:	6026      	str	r6, [r4, #0]
 8014caa:	7833      	ldrb	r3, [r6, #0]
 8014cac:	5cea      	ldrb	r2, [r5, r3]
 8014cae:	0710      	lsls	r0, r2, #28
 8014cb0:	d4f9      	bmi.n	8014ca6 <parse_value.part.0+0x16>
    switch (**string) {
 8014cb2:	2b7b      	cmp	r3, #123	; 0x7b
 8014cb4:	d82d      	bhi.n	8014d12 <parse_value.part.0+0x82>
 8014cb6:	2b5a      	cmp	r3, #90	; 0x5a
 8014cb8:	d930      	bls.n	8014d1c <parse_value.part.0+0x8c>
 8014cba:	3b5b      	subs	r3, #91	; 0x5b
 8014cbc:	2b20      	cmp	r3, #32
 8014cbe:	d828      	bhi.n	8014d12 <parse_value.part.0+0x82>
 8014cc0:	e8df f013 	tbh	[pc, r3, lsl #1]
 8014cc4:	00270136 	.word	0x00270136
 8014cc8:	00270027 	.word	0x00270027
 8014ccc:	00270027 	.word	0x00270027
 8014cd0:	00270027 	.word	0x00270027
 8014cd4:	00270027 	.word	0x00270027
 8014cd8:	01a00027 	.word	0x01a00027
 8014cdc:	00270027 	.word	0x00270027
 8014ce0:	00270027 	.word	0x00270027
 8014ce4:	00270027 	.word	0x00270027
 8014ce8:	01c00027 	.word	0x01c00027
 8014cec:	00270027 	.word	0x00270027
 8014cf0:	00270027 	.word	0x00270027
 8014cf4:	01a00027 	.word	0x01a00027
 8014cf8:	00270027 	.word	0x00270027
 8014cfc:	00270027 	.word	0x00270027
 8014d00:	00270027 	.word	0x00270027
 8014d04:	00a1      	.short	0x00a1
            json_value_free(new_array_value);
 8014d06:	4638      	mov	r0, r7
 8014d08:	f7ff ff00 	bl	8014b0c <json_value_free>
            json_value_free(output_value);
 8014d0c:	4630      	mov	r0, r6
 8014d0e:	f7ff fefd 	bl	8014b0c <json_value_free>
            return NULL;
 8014d12:	2600      	movs	r6, #0
}
 8014d14:	4630      	mov	r0, r6
 8014d16:	b003      	add	sp, #12
 8014d18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (**string) {
 8014d1c:	2b2d      	cmp	r3, #45	; 0x2d
 8014d1e:	d003      	beq.n	8014d28 <parse_value.part.0+0x98>
 8014d20:	d959      	bls.n	8014dd6 <parse_value.part.0+0x146>
 8014d22:	3b30      	subs	r3, #48	; 0x30
 8014d24:	2b09      	cmp	r3, #9
 8014d26:	d8f4      	bhi.n	8014d12 <parse_value.part.0+0x82>
    errno = 0;
 8014d28:	f000 fe96 	bl	8015a58 <__errno>
 8014d2c:	2300      	movs	r3, #0
 8014d2e:	6003      	str	r3, [r0, #0]
    number = strtod(*string, &end);
 8014d30:	a901      	add	r1, sp, #4
 8014d32:	6820      	ldr	r0, [r4, #0]
 8014d34:	f002 fd3e 	bl	80177b4 <strtod>
 8014d38:	ec59 8b10 	vmov	r8, r9, d0
    if (errno || !is_decimal(*string, end - *string)) {
 8014d3c:	f000 fe8c 	bl	8015a58 <__errno>
 8014d40:	6803      	ldr	r3, [r0, #0]
 8014d42:	2b00      	cmp	r3, #0
 8014d44:	d1e5      	bne.n	8014d12 <parse_value.part.0+0x82>
 8014d46:	6826      	ldr	r6, [r4, #0]
 8014d48:	f8dd a004 	ldr.w	sl, [sp, #4]
 8014d4c:	ebaa 0306 	sub.w	r3, sl, r6
    if (length > 1 && string[0] == '0' && string[1] != '.') {
 8014d50:	2b01      	cmp	r3, #1
 8014d52:	d909      	bls.n	8014d68 <parse_value.part.0+0xd8>
 8014d54:	7832      	ldrb	r2, [r6, #0]
 8014d56:	2a30      	cmp	r2, #48	; 0x30
 8014d58:	f000 81b4 	beq.w	80150c4 <parse_value.part.0+0x434>
    if (length > 2 && !strncmp(string, "-0", 2) && string[2] != '.') {
 8014d5c:	2b02      	cmp	r3, #2
 8014d5e:	d003      	beq.n	8014d68 <parse_value.part.0+0xd8>
 8014d60:	7833      	ldrb	r3, [r6, #0]
 8014d62:	2b2d      	cmp	r3, #45	; 0x2d
 8014d64:	f000 81a5 	beq.w	80150b2 <parse_value.part.0+0x422>
        if (strchr("xX", string[length])) {
 8014d68:	4f6e      	ldr	r7, [pc, #440]	; (8014f24 <parse_value.part.0+0x294>)
 8014d6a:	4655      	mov	r5, sl
 8014d6c:	e005      	b.n	8014d7a <parse_value.part.0+0xea>
 8014d6e:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
 8014d72:	f001 fec4 	bl	8016afe <strchr>
 8014d76:	2800      	cmp	r0, #0
 8014d78:	d1cb      	bne.n	8014d12 <parse_value.part.0+0x82>
    while (length--) {
 8014d7a:	42ae      	cmp	r6, r5
        if (strchr("xX", string[length])) {
 8014d7c:	4638      	mov	r0, r7
    while (length--) {
 8014d7e:	d1f6      	bne.n	8014d6e <parse_value.part.0+0xde>
    *string = end;
 8014d80:	f8c4 a000 	str.w	sl, [r4]
    return value;
}

JSON_Value * json_value_init_number(double number) {
    JSON_Value *new_value = NULL;
    if (IS_NUMBER_INVALID(number)) {
 8014d84:	4642      	mov	r2, r8
 8014d86:	464b      	mov	r3, r9
 8014d88:	4640      	mov	r0, r8
 8014d8a:	4649      	mov	r1, r9
 8014d8c:	f7eb fef6 	bl	8000b7c <__aeabi_dcmpun>
 8014d90:	2800      	cmp	r0, #0
 8014d92:	d1be      	bne.n	8014d12 <parse_value.part.0+0x82>
 8014d94:	f029 4500 	bic.w	r5, r9, #2147483648	; 0x80000000
 8014d98:	4b63      	ldr	r3, [pc, #396]	; (8014f28 <parse_value.part.0+0x298>)
 8014d9a:	4640      	mov	r0, r8
 8014d9c:	4629      	mov	r1, r5
 8014d9e:	f04f 32ff 	mov.w	r2, #4294967295
 8014da2:	f7eb feeb 	bl	8000b7c <__aeabi_dcmpun>
 8014da6:	b940      	cbnz	r0, 8014dba <parse_value.part.0+0x12a>
 8014da8:	4b5f      	ldr	r3, [pc, #380]	; (8014f28 <parse_value.part.0+0x298>)
 8014daa:	4640      	mov	r0, r8
 8014dac:	4629      	mov	r1, r5
 8014dae:	f04f 32ff 	mov.w	r2, #4294967295
 8014db2:	f7eb fec5 	bl	8000b40 <__aeabi_dcmple>
 8014db6:	2800      	cmp	r0, #0
 8014db8:	d0ab      	beq.n	8014d12 <parse_value.part.0+0x82>
        return NULL;
    }
    new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8014dba:	4b5c      	ldr	r3, [pc, #368]	; (8014f2c <parse_value.part.0+0x29c>)
 8014dbc:	2010      	movs	r0, #16
 8014dbe:	681b      	ldr	r3, [r3, #0]
 8014dc0:	4798      	blx	r3
    if (new_value == NULL) {
 8014dc2:	4606      	mov	r6, r0
 8014dc4:	2800      	cmp	r0, #0
 8014dc6:	d0a5      	beq.n	8014d14 <parse_value.part.0+0x84>
        return NULL;
    }
    new_value->parent = NULL;
 8014dc8:	2200      	movs	r2, #0
    new_value->type = JSONNumber;
 8014dca:	2303      	movs	r3, #3
    new_value->value.number = number;
 8014dcc:	e9c0 8902 	strd	r8, r9, [r0, #8]
    new_value->type = JSONNumber;
 8014dd0:	e9c0 2300 	strd	r2, r3, [r0]
            return parse_number_value(string);
 8014dd4:	e79e      	b.n	8014d14 <parse_value.part.0+0x84>
    switch (**string) {
 8014dd6:	2b22      	cmp	r3, #34	; 0x22
 8014dd8:	d19b      	bne.n	8014d12 <parse_value.part.0+0x82>
    char *new_string = get_quoted_string(string);
 8014dda:	4620      	mov	r0, r4
 8014ddc:	f7fe fe42 	bl	8013a64 <get_quoted_string>
    if (new_string == NULL) {
 8014de0:	4604      	mov	r4, r0
 8014de2:	2800      	cmp	r0, #0
 8014de4:	d095      	beq.n	8014d12 <parse_value.part.0+0x82>
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8014de6:	4d51      	ldr	r5, [pc, #324]	; (8014f2c <parse_value.part.0+0x29c>)
 8014de8:	2010      	movs	r0, #16
 8014dea:	682b      	ldr	r3, [r5, #0]
 8014dec:	4798      	blx	r3
    if (!new_value) {
 8014dee:	4606      	mov	r6, r0
 8014df0:	2800      	cmp	r0, #0
 8014df2:	f000 8184 	beq.w	80150fe <parse_value.part.0+0x46e>
    new_value->parent = NULL;
 8014df6:	2200      	movs	r2, #0
    new_value->type = JSONString;
 8014df8:	2302      	movs	r3, #2
 8014dfa:	e880 001c 	stmia.w	r0, {r2, r3, r4}
}
 8014dfe:	4630      	mov	r0, r6
 8014e00:	b003      	add	sp, #12
 8014e02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8014e06:	f8df b124 	ldr.w	fp, [pc, #292]	; 8014f2c <parse_value.part.0+0x29c>
 8014e0a:	2010      	movs	r0, #16
 8014e0c:	f8db 3000 	ldr.w	r3, [fp]
 8014e10:	4798      	blx	r3
    if (!new_value) {
 8014e12:	4606      	mov	r6, r0
 8014e14:	2800      	cmp	r0, #0
 8014e16:	f43f af7c 	beq.w	8014d12 <parse_value.part.0+0x82>
    new_value->type = JSONObject;
 8014e1a:	2304      	movs	r3, #4
 8014e1c:	f04f 0800 	mov.w	r8, #0
 8014e20:	e9c0 8300 	strd	r8, r3, [r0]
    JSON_Object *new_obj = (JSON_Object*)parson_malloc(sizeof(JSON_Object));
 8014e24:	f8db 3000 	ldr.w	r3, [fp]
 8014e28:	2014      	movs	r0, #20
 8014e2a:	4798      	blx	r3
    if (new_obj == NULL) {
 8014e2c:	4681      	mov	r9, r0
 8014e2e:	2800      	cmp	r0, #0
 8014e30:	f000 815d 	beq.w	80150ee <parse_value.part.0+0x45e>
    new_obj->names = (char**)NULL;
 8014e34:	e9c0 6800 	strd	r6, r8, [r0]
    new_obj->count = 0;
 8014e38:	e9c0 8803 	strd	r8, r8, [r0, #12]
    new_obj->values = (JSON_Value**)NULL;
 8014e3c:	f8c0 8008 	str.w	r8, [r0, #8]
    new_value->value.object = json_object_init(new_value);
 8014e40:	60b0      	str	r0, [r6, #8]
    if (**string != '{') {
 8014e42:	6822      	ldr	r2, [r4, #0]
 8014e44:	7813      	ldrb	r3, [r2, #0]
 8014e46:	2b7b      	cmp	r3, #123	; 0x7b
 8014e48:	f040 812e 	bne.w	80150a8 <parse_value.part.0+0x418>
    SKIP_CHAR(string);
 8014e4c:	1c53      	adds	r3, r2, #1
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8014e4e:	6870      	ldr	r0, [r6, #4]
    SKIP_CHAR(string);
 8014e50:	6023      	str	r3, [r4, #0]
    SKIP_WHITESPACES(string);
 8014e52:	7852      	ldrb	r2, [r2, #1]
 8014e54:	5ca9      	ldrb	r1, [r5, r2]
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8014e56:	2804      	cmp	r0, #4
 8014e58:	bf18      	it	ne
 8014e5a:	f04f 0900 	movne.w	r9, #0
    SKIP_WHITESPACES(string);
 8014e5e:	0709      	lsls	r1, r1, #28
 8014e60:	d505      	bpl.n	8014e6e <parse_value.part.0+0x1de>
 8014e62:	3301      	adds	r3, #1
 8014e64:	6023      	str	r3, [r4, #0]
 8014e66:	781a      	ldrb	r2, [r3, #0]
 8014e68:	5ca9      	ldrb	r1, [r5, r2]
 8014e6a:	0708      	lsls	r0, r1, #28
 8014e6c:	d4f9      	bmi.n	8014e62 <parse_value.part.0+0x1d2>
    if (**string == '}') { /* empty object */
 8014e6e:	2a7d      	cmp	r2, #125	; 0x7d
 8014e70:	f000 8117 	beq.w	80150a2 <parse_value.part.0+0x412>
            return parse_object_value(string, nesting + 1);
 8014e74:	3701      	adds	r7, #1
    while (**string != '\0') {
 8014e76:	2a00      	cmp	r2, #0
 8014e78:	f43f af48 	beq.w	8014d0c <parse_value.part.0+0x7c>
        new_key = get_quoted_string(string);
 8014e7c:	4620      	mov	r0, r4
 8014e7e:	f7fe fdf1 	bl	8013a64 <get_quoted_string>
        if (new_key == NULL) {
 8014e82:	4680      	mov	r8, r0
 8014e84:	2800      	cmp	r0, #0
 8014e86:	f000 810f 	beq.w	80150a8 <parse_value.part.0+0x418>
        SKIP_WHITESPACES(string);
 8014e8a:	6823      	ldr	r3, [r4, #0]
 8014e8c:	781a      	ldrb	r2, [r3, #0]
 8014e8e:	5ca9      	ldrb	r1, [r5, r2]
 8014e90:	0709      	lsls	r1, r1, #28
 8014e92:	d505      	bpl.n	8014ea0 <parse_value.part.0+0x210>
 8014e94:	3301      	adds	r3, #1
 8014e96:	6023      	str	r3, [r4, #0]
 8014e98:	781a      	ldrb	r2, [r3, #0]
 8014e9a:	5ca9      	ldrb	r1, [r5, r2]
 8014e9c:	0708      	lsls	r0, r1, #28
 8014e9e:	d4f9      	bmi.n	8014e94 <parse_value.part.0+0x204>
        if (**string != ':') {
 8014ea0:	2a3a      	cmp	r2, #58	; 0x3a
 8014ea2:	f040 80e6 	bne.w	8015072 <parse_value.part.0+0x3e2>
        SKIP_CHAR(string);
 8014ea6:	3301      	adds	r3, #1
 8014ea8:	6023      	str	r3, [r4, #0]
    if (nesting > MAX_NESTING) {
 8014eaa:	f640 0301 	movw	r3, #2049	; 0x801
 8014eae:	429f      	cmp	r7, r3
 8014eb0:	f000 80df 	beq.w	8015072 <parse_value.part.0+0x3e2>
 8014eb4:	4639      	mov	r1, r7
 8014eb6:	4620      	mov	r0, r4
 8014eb8:	f7ff feea 	bl	8014c90 <parse_value.part.0>
        if (new_value == NULL) {
 8014ebc:	4682      	mov	sl, r0
 8014ebe:	2800      	cmp	r0, #0
 8014ec0:	f000 80d7 	beq.w	8015072 <parse_value.part.0+0x3e2>
    return json_object_addn(object, name, strlen(name), value);
 8014ec4:	4640      	mov	r0, r8
 8014ec6:	f7eb f9a5 	bl	8000214 <strlen>
 8014eca:	4653      	mov	r3, sl
 8014ecc:	4602      	mov	r2, r0
 8014ece:	4641      	mov	r1, r8
 8014ed0:	4648      	mov	r0, r9
 8014ed2:	f7fe fcbf 	bl	8013854 <json_object_addn>
        if (json_object_add(output_object, new_key, new_value) == JSONFailure) {
 8014ed6:	3001      	adds	r0, #1
 8014ed8:	f000 813b 	beq.w	8015152 <parse_value.part.0+0x4c2>
        parson_free(new_key);
 8014edc:	f8db 3004 	ldr.w	r3, [fp, #4]
 8014ee0:	4640      	mov	r0, r8
 8014ee2:	4798      	blx	r3
        SKIP_WHITESPACES(string);
 8014ee4:	6823      	ldr	r3, [r4, #0]
 8014ee6:	781a      	ldrb	r2, [r3, #0]
 8014ee8:	5ca9      	ldrb	r1, [r5, r2]
 8014eea:	0709      	lsls	r1, r1, #28
 8014eec:	d505      	bpl.n	8014efa <parse_value.part.0+0x26a>
 8014eee:	3301      	adds	r3, #1
 8014ef0:	6023      	str	r3, [r4, #0]
 8014ef2:	781a      	ldrb	r2, [r3, #0]
 8014ef4:	5ca9      	ldrb	r1, [r5, r2]
 8014ef6:	0708      	lsls	r0, r1, #28
 8014ef8:	d4f9      	bmi.n	8014eee <parse_value.part.0+0x25e>
        if (**string != ',') {
 8014efa:	2a2c      	cmp	r2, #44	; 0x2c
 8014efc:	f040 80c2 	bne.w	8015084 <parse_value.part.0+0x3f4>
        SKIP_CHAR(string);
 8014f00:	1c5a      	adds	r2, r3, #1
 8014f02:	6022      	str	r2, [r4, #0]
        SKIP_WHITESPACES(string);
 8014f04:	785b      	ldrb	r3, [r3, #1]
 8014f06:	5ce9      	ldrb	r1, [r5, r3]
 8014f08:	0709      	lsls	r1, r1, #28
 8014f0a:	d505      	bpl.n	8014f18 <parse_value.part.0+0x288>
 8014f0c:	3201      	adds	r2, #1
 8014f0e:	6022      	str	r2, [r4, #0]
 8014f10:	7813      	ldrb	r3, [r2, #0]
 8014f12:	5ce9      	ldrb	r1, [r5, r3]
 8014f14:	0708      	lsls	r0, r1, #28
 8014f16:	d4f9      	bmi.n	8014f0c <parse_value.part.0+0x27c>
    while (**string != '\0') {
 8014f18:	2b00      	cmp	r3, #0
 8014f1a:	d1af      	bne.n	8014e7c <parse_value.part.0+0x1ec>
 8014f1c:	e6f6      	b.n	8014d0c <parse_value.part.0+0x7c>
 8014f1e:	bf00      	nop
 8014f20:	0801ac5f 	.word	0x0801ac5f
 8014f24:	0801ac4c 	.word	0x0801ac4c
 8014f28:	7fefffff 	.word	0x7fefffff
 8014f2c:	20000138 	.word	0x20000138
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8014f30:	f8df b250 	ldr.w	fp, [pc, #592]	; 8015184 <parse_value.part.0+0x4f4>
 8014f34:	2010      	movs	r0, #16
 8014f36:	f8db 3000 	ldr.w	r3, [fp]
 8014f3a:	4798      	blx	r3
    if (!new_value) {
 8014f3c:	4606      	mov	r6, r0
 8014f3e:	2800      	cmp	r0, #0
 8014f40:	f43f aee7 	beq.w	8014d12 <parse_value.part.0+0x82>
    new_value->type = JSONArray;
 8014f44:	2305      	movs	r3, #5
 8014f46:	f04f 0800 	mov.w	r8, #0
 8014f4a:	e9c0 8300 	strd	r8, r3, [r0]
    JSON_Array *new_array = (JSON_Array*)parson_malloc(sizeof(JSON_Array));
 8014f4e:	f8db 3000 	ldr.w	r3, [fp]
 8014f52:	2010      	movs	r0, #16
 8014f54:	4798      	blx	r3
    if (new_array == NULL) {
 8014f56:	4681      	mov	r9, r0
 8014f58:	2800      	cmp	r0, #0
 8014f5a:	f000 80c8 	beq.w	80150ee <parse_value.part.0+0x45e>
    new_array->items = (JSON_Value**)NULL;
 8014f5e:	e9c0 6800 	strd	r6, r8, [r0]
    new_array->count = 0;
 8014f62:	e9c0 8802 	strd	r8, r8, [r0, #8]
    new_value->value.array = json_array_init(new_value);
 8014f66:	60b0      	str	r0, [r6, #8]
    if (**string != '[') {
 8014f68:	6822      	ldr	r2, [r4, #0]
 8014f6a:	7813      	ldrb	r3, [r2, #0]
 8014f6c:	2b5b      	cmp	r3, #91	; 0x5b
 8014f6e:	f040 809b 	bne.w	80150a8 <parse_value.part.0+0x418>
    SKIP_CHAR(string);
 8014f72:	1c53      	adds	r3, r2, #1
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 8014f74:	6870      	ldr	r0, [r6, #4]
    SKIP_CHAR(string);
 8014f76:	6023      	str	r3, [r4, #0]
    SKIP_WHITESPACES(string);
 8014f78:	7852      	ldrb	r2, [r2, #1]
 8014f7a:	5ca9      	ldrb	r1, [r5, r2]
    return json_value_get_type(value) == JSONArray ? value->value.array : NULL;
 8014f7c:	2805      	cmp	r0, #5
 8014f7e:	bf18      	it	ne
 8014f80:	f04f 0900 	movne.w	r9, #0
    SKIP_WHITESPACES(string);
 8014f84:	0709      	lsls	r1, r1, #28
 8014f86:	d505      	bpl.n	8014f94 <parse_value.part.0+0x304>
 8014f88:	3301      	adds	r3, #1
 8014f8a:	6023      	str	r3, [r4, #0]
 8014f8c:	781a      	ldrb	r2, [r3, #0]
 8014f8e:	5ca9      	ldrb	r1, [r5, r2]
 8014f90:	0708      	lsls	r0, r1, #28
 8014f92:	d4f9      	bmi.n	8014f88 <parse_value.part.0+0x2f8>
    if (**string == ']') { /* empty array */
 8014f94:	2a5d      	cmp	r2, #93	; 0x5d
 8014f96:	f000 8084 	beq.w	80150a2 <parse_value.part.0+0x412>
    while (**string != '\0') {
 8014f9a:	2a00      	cmp	r2, #0
 8014f9c:	f43f aeb6 	beq.w	8014d0c <parse_value.part.0+0x7c>
    if (nesting > MAX_NESTING) {
 8014fa0:	f5b7 6f00 	cmp.w	r7, #2048	; 0x800
 8014fa4:	f107 0801 	add.w	r8, r7, #1
 8014fa8:	f43f aeb0 	beq.w	8014d0c <parse_value.part.0+0x7c>
 8014fac:	4641      	mov	r1, r8
 8014fae:	4620      	mov	r0, r4
 8014fb0:	f7ff fe6e 	bl	8014c90 <parse_value.part.0>
        if (new_array_value == NULL) {
 8014fb4:	4607      	mov	r7, r0
 8014fb6:	2800      	cmp	r0, #0
 8014fb8:	f43f aea8 	beq.w	8014d0c <parse_value.part.0+0x7c>
        if (json_array_add(output_array, new_array_value) == JSONFailure) {
 8014fbc:	4601      	mov	r1, r0
 8014fbe:	4648      	mov	r0, r9
 8014fc0:	f7fe fcac 	bl	801391c <json_array_add>
 8014fc4:	3001      	adds	r0, #1
 8014fc6:	f43f ae9e 	beq.w	8014d06 <parse_value.part.0+0x76>
        SKIP_WHITESPACES(string);
 8014fca:	6823      	ldr	r3, [r4, #0]
 8014fcc:	781a      	ldrb	r2, [r3, #0]
 8014fce:	5ca9      	ldrb	r1, [r5, r2]
 8014fd0:	0709      	lsls	r1, r1, #28
 8014fd2:	d505      	bpl.n	8014fe0 <parse_value.part.0+0x350>
 8014fd4:	3301      	adds	r3, #1
 8014fd6:	6023      	str	r3, [r4, #0]
 8014fd8:	781a      	ldrb	r2, [r3, #0]
 8014fda:	5ca9      	ldrb	r1, [r5, r2]
 8014fdc:	070f      	lsls	r7, r1, #28
 8014fde:	d4f9      	bmi.n	8014fd4 <parse_value.part.0+0x344>
        if (**string != ',') {
 8014fe0:	2a2c      	cmp	r2, #44	; 0x2c
 8014fe2:	f040 8090 	bne.w	8015106 <parse_value.part.0+0x476>
        SKIP_CHAR(string);
 8014fe6:	1c5a      	adds	r2, r3, #1
 8014fe8:	6022      	str	r2, [r4, #0]
        SKIP_WHITESPACES(string);
 8014fea:	785b      	ldrb	r3, [r3, #1]
 8014fec:	5ce9      	ldrb	r1, [r5, r3]
 8014fee:	0708      	lsls	r0, r1, #28
 8014ff0:	d505      	bpl.n	8014ffe <parse_value.part.0+0x36e>
 8014ff2:	3201      	adds	r2, #1
 8014ff4:	6022      	str	r2, [r4, #0]
 8014ff6:	7813      	ldrb	r3, [r2, #0]
 8014ff8:	5ce9      	ldrb	r1, [r5, r3]
 8014ffa:	0709      	lsls	r1, r1, #28
 8014ffc:	d4f9      	bmi.n	8014ff2 <parse_value.part.0+0x362>
    while (**string != '\0') {
 8014ffe:	2b00      	cmp	r3, #0
 8015000:	d1d4      	bne.n	8014fac <parse_value.part.0+0x31c>
 8015002:	e683      	b.n	8014d0c <parse_value.part.0+0x7c>
    if (strncmp("true", *string, true_token_size) == 0) {
 8015004:	485d      	ldr	r0, [pc, #372]	; (801517c <parse_value.part.0+0x4ec>)
 8015006:	2204      	movs	r2, #4
 8015008:	4631      	mov	r1, r6
 801500a:	f001 fd85 	bl	8016b18 <strncmp>
 801500e:	4605      	mov	r5, r0
 8015010:	2800      	cmp	r0, #0
 8015012:	d05c      	beq.n	80150ce <parse_value.part.0+0x43e>
    } else if (strncmp("false", *string, false_token_size) == 0) {
 8015014:	485a      	ldr	r0, [pc, #360]	; (8015180 <parse_value.part.0+0x4f0>)
 8015016:	2205      	movs	r2, #5
 8015018:	4631      	mov	r1, r6
 801501a:	f001 fd7d 	bl	8016b18 <strncmp>
 801501e:	4605      	mov	r5, r0
 8015020:	2800      	cmp	r0, #0
 8015022:	f47f ae76 	bne.w	8014d12 <parse_value.part.0+0x82>
    return new_value;
}

JSON_Value * json_value_init_boolean(int boolean) {
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8015026:	4b57      	ldr	r3, [pc, #348]	; (8015184 <parse_value.part.0+0x4f4>)
        *string += false_token_size;
 8015028:	3605      	adds	r6, #5
 801502a:	6026      	str	r6, [r4, #0]
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 801502c:	681b      	ldr	r3, [r3, #0]
 801502e:	2010      	movs	r0, #16
 8015030:	4798      	blx	r3
    if (!new_value) {
 8015032:	4606      	mov	r6, r0
 8015034:	2800      	cmp	r0, #0
 8015036:	f43f ae6d 	beq.w	8014d14 <parse_value.part.0+0x84>
        return NULL;
    }
    new_value->parent = NULL;
    new_value->type = JSONBoolean;
 801503a:	2306      	movs	r3, #6
 801503c:	e9c0 3501 	strd	r3, r5, [r0, #4]
    new_value->parent = NULL;
 8015040:	6005      	str	r5, [r0, #0]
    new_value->value.boolean = boolean ? 1 : 0;
    return new_value;
 8015042:	e667      	b.n	8014d14 <parse_value.part.0+0x84>
    if (strncmp("null", *string, token_size) == 0) {
 8015044:	4850      	ldr	r0, [pc, #320]	; (8015188 <parse_value.part.0+0x4f8>)
 8015046:	2204      	movs	r2, #4
 8015048:	4631      	mov	r1, r6
 801504a:	f001 fd65 	bl	8016b18 <strncmp>
 801504e:	4605      	mov	r5, r0
 8015050:	2800      	cmp	r0, #0
 8015052:	f47f ae5e 	bne.w	8014d12 <parse_value.part.0+0x82>
}

JSON_Value * json_value_init_null(void) {
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8015056:	4b4b      	ldr	r3, [pc, #300]	; (8015184 <parse_value.part.0+0x4f4>)
        *string += token_size;
 8015058:	3604      	adds	r6, #4
 801505a:	6026      	str	r6, [r4, #0]
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 801505c:	681b      	ldr	r3, [r3, #0]
 801505e:	2010      	movs	r0, #16
 8015060:	4798      	blx	r3
    if (!new_value) {
 8015062:	4606      	mov	r6, r0
 8015064:	2800      	cmp	r0, #0
 8015066:	f43f ae55 	beq.w	8014d14 <parse_value.part.0+0x84>
        return NULL;
    }
    new_value->parent = NULL;
    new_value->type = JSONNull;
 801506a:	2301      	movs	r3, #1
 801506c:	e9c0 5300 	strd	r5, r3, [r0]
    return new_value;
 8015070:	e650      	b.n	8014d14 <parse_value.part.0+0x84>
            parson_free(new_key);
 8015072:	f8db 3004 	ldr.w	r3, [fp, #4]
 8015076:	4640      	mov	r0, r8
 8015078:	4798      	blx	r3
            json_value_free(output_value);
 801507a:	4630      	mov	r0, r6
 801507c:	f7ff fd46 	bl	8014b0c <json_value_free>
            return NULL;
 8015080:	2600      	movs	r6, #0
 8015082:	e647      	b.n	8014d14 <parse_value.part.0+0x84>
    if (**string != '}' || /* Trim object after parsing is over */
 8015084:	2a7d      	cmp	r2, #125	; 0x7d
 8015086:	f47f ae41 	bne.w	8014d0c <parse_value.part.0+0x7c>
    return object ? object->count : 0;
 801508a:	f1b9 0f00 	cmp.w	r9, #0
 801508e:	d072      	beq.n	8015176 <parse_value.part.0+0x4e6>
 8015090:	f8d9 100c 	ldr.w	r1, [r9, #12]
        json_object_resize(output_object, json_object_get_count(output_object)) == JSONFailure) {
 8015094:	4648      	mov	r0, r9
 8015096:	f7fe fb97 	bl	80137c8 <json_object_resize>
    if (**string != '}' || /* Trim object after parsing is over */
 801509a:	3001      	adds	r0, #1
 801509c:	f43f ae36 	beq.w	8014d0c <parse_value.part.0+0x7c>
    SKIP_CHAR(string);
 80150a0:	6823      	ldr	r3, [r4, #0]
 80150a2:	3301      	adds	r3, #1
 80150a4:	6023      	str	r3, [r4, #0]
    return output_value;
 80150a6:	e635      	b.n	8014d14 <parse_value.part.0+0x84>
        json_value_free(output_value);
 80150a8:	4630      	mov	r0, r6
 80150aa:	f7ff fd2f 	bl	8014b0c <json_value_free>
        return NULL;
 80150ae:	4646      	mov	r6, r8
 80150b0:	e630      	b.n	8014d14 <parse_value.part.0+0x84>
    if (length > 2 && !strncmp(string, "-0", 2) && string[2] != '.') {
 80150b2:	7873      	ldrb	r3, [r6, #1]
 80150b4:	2b30      	cmp	r3, #48	; 0x30
 80150b6:	f47f ae57 	bne.w	8014d68 <parse_value.part.0+0xd8>
 80150ba:	78b3      	ldrb	r3, [r6, #2]
 80150bc:	2b2e      	cmp	r3, #46	; 0x2e
 80150be:	f47f ae28 	bne.w	8014d12 <parse_value.part.0+0x82>
 80150c2:	e651      	b.n	8014d68 <parse_value.part.0+0xd8>
    if (length > 1 && string[0] == '0' && string[1] != '.') {
 80150c4:	7872      	ldrb	r2, [r6, #1]
 80150c6:	2a2e      	cmp	r2, #46	; 0x2e
 80150c8:	f47f ae23 	bne.w	8014d12 <parse_value.part.0+0x82>
 80150cc:	e646      	b.n	8014d5c <parse_value.part.0+0xcc>
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80150ce:	4b2d      	ldr	r3, [pc, #180]	; (8015184 <parse_value.part.0+0x4f4>)
        *string += true_token_size;
 80150d0:	3604      	adds	r6, #4
 80150d2:	6026      	str	r6, [r4, #0]
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80150d4:	681b      	ldr	r3, [r3, #0]
 80150d6:	2010      	movs	r0, #16
 80150d8:	4798      	blx	r3
    if (!new_value) {
 80150da:	4606      	mov	r6, r0
 80150dc:	2800      	cmp	r0, #0
 80150de:	f43f ae19 	beq.w	8014d14 <parse_value.part.0+0x84>
    new_value->type = JSONBoolean;
 80150e2:	2206      	movs	r2, #6
    new_value->value.boolean = boolean ? 1 : 0;
 80150e4:	2301      	movs	r3, #1
    new_value->type = JSONBoolean;
 80150e6:	e9c0 5200 	strd	r5, r2, [r0]
    new_value->value.boolean = boolean ? 1 : 0;
 80150ea:	6083      	str	r3, [r0, #8]
    return new_value;
 80150ec:	e612      	b.n	8014d14 <parse_value.part.0+0x84>
    new_value->value.array = json_array_init(new_value);
 80150ee:	f8c6 9008 	str.w	r9, [r6, #8]
        parson_free(new_value);
 80150f2:	4630      	mov	r0, r6
 80150f4:	f8db 3004 	ldr.w	r3, [fp, #4]
 80150f8:	4798      	blx	r3
        return NULL;
 80150fa:	464e      	mov	r6, r9
 80150fc:	e60a      	b.n	8014d14 <parse_value.part.0+0x84>
        parson_free(new_string);
 80150fe:	686b      	ldr	r3, [r5, #4]
 8015100:	4620      	mov	r0, r4
 8015102:	4798      	blx	r3
        return NULL;
 8015104:	e606      	b.n	8014d14 <parse_value.part.0+0x84>
    if (**string != ']' || /* Trim array after parsing is over */
 8015106:	2a5d      	cmp	r2, #93	; 0x5d
 8015108:	f47f ae00 	bne.w	8014d0c <parse_value.part.0+0x7c>
    return array ? array->count : 0;
 801510c:	f1b9 0f00 	cmp.w	r9, #0
 8015110:	f43f adfc 	beq.w	8014d0c <parse_value.part.0+0x7c>
 8015114:	f8d9 7008 	ldr.w	r7, [r9, #8]
    if (new_capacity == 0) {
 8015118:	2f00      	cmp	r7, #0
 801511a:	f43f adf7 	beq.w	8014d0c <parse_value.part.0+0x7c>
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 801511e:	f8db 3000 	ldr.w	r3, [fp]
 8015122:	00b8      	lsls	r0, r7, #2
 8015124:	4798      	blx	r3
    if (new_items == NULL) {
 8015126:	4605      	mov	r5, r0
 8015128:	2800      	cmp	r0, #0
 801512a:	f43f adef 	beq.w	8014d0c <parse_value.part.0+0x7c>
    if (array->items != NULL && array->count > 0) {
 801512e:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8015132:	b111      	cbz	r1, 801513a <parse_value.part.0+0x4aa>
 8015134:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8015138:	b9ba      	cbnz	r2, 801516a <parse_value.part.0+0x4da>
    parson_free(array->items);
 801513a:	f8db 3004 	ldr.w	r3, [fp, #4]
 801513e:	4608      	mov	r0, r1
 8015140:	4798      	blx	r3
    SKIP_CHAR(string);
 8015142:	6823      	ldr	r3, [r4, #0]
    array->items = new_items;
 8015144:	f8c9 5004 	str.w	r5, [r9, #4]
    SKIP_CHAR(string);
 8015148:	3301      	adds	r3, #1
    array->capacity = new_capacity;
 801514a:	f8c9 700c 	str.w	r7, [r9, #12]
    SKIP_CHAR(string);
 801514e:	6023      	str	r3, [r4, #0]
    return output_value;
 8015150:	e5e0      	b.n	8014d14 <parse_value.part.0+0x84>
            parson_free(new_key);
 8015152:	f8db 3004 	ldr.w	r3, [fp, #4]
 8015156:	4640      	mov	r0, r8
 8015158:	4798      	blx	r3
            json_value_free(new_value);
 801515a:	4650      	mov	r0, sl
 801515c:	f7ff fcd6 	bl	8014b0c <json_value_free>
            json_value_free(output_value);
 8015160:	4630      	mov	r0, r6
 8015162:	f7ff fcd3 	bl	8014b0c <json_value_free>
            return NULL;
 8015166:	2600      	movs	r6, #0
 8015168:	e5d4      	b.n	8014d14 <parse_value.part.0+0x84>
        memcpy(new_items, array->items, array->count * sizeof(JSON_Value*));
 801516a:	0092      	lsls	r2, r2, #2
 801516c:	f000 fee8 	bl	8015f40 <memcpy>
 8015170:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8015174:	e7e1      	b.n	801513a <parse_value.part.0+0x4aa>
    return object ? object->count : 0;
 8015176:	4649      	mov	r1, r9
 8015178:	e78c      	b.n	8015094 <parse_value.part.0+0x404>
 801517a:	bf00      	nop
 801517c:	0801ac24 	.word	0x0801ac24
 8015180:	0801ac2c 	.word	0x0801ac2c
 8015184:	20000138 	.word	0x20000138
 8015188:	0801ac3c 	.word	0x0801ac3c

0801518c <json_parse_string>:
JSON_Value * json_parse_string(const char *string) {
 801518c:	b500      	push	{lr}
 801518e:	b083      	sub	sp, #12
 8015190:	9001      	str	r0, [sp, #4]
    if (string == NULL) {
 8015192:	b130      	cbz	r0, 80151a2 <json_parse_string+0x16>
    if (string[0] == '\xEF' && string[1] == '\xBB' && string[2] == '\xBF') {
 8015194:	7803      	ldrb	r3, [r0, #0]
 8015196:	2bef      	cmp	r3, #239	; 0xef
 8015198:	d006      	beq.n	80151a8 <json_parse_string+0x1c>
    if (nesting > MAX_NESTING) {
 801519a:	2100      	movs	r1, #0
 801519c:	a801      	add	r0, sp, #4
 801519e:	f7ff fd77 	bl	8014c90 <parse_value.part.0>
}
 80151a2:	b003      	add	sp, #12
 80151a4:	f85d fb04 	ldr.w	pc, [sp], #4
    if (string[0] == '\xEF' && string[1] == '\xBB' && string[2] == '\xBF') {
 80151a8:	7843      	ldrb	r3, [r0, #1]
 80151aa:	2bbb      	cmp	r3, #187	; 0xbb
 80151ac:	d1f5      	bne.n	801519a <json_parse_string+0xe>
 80151ae:	7883      	ldrb	r3, [r0, #2]
 80151b0:	2bbf      	cmp	r3, #191	; 0xbf
        string = string + 3; /* Support for UTF-8 BOM */
 80151b2:	bf04      	itt	eq
 80151b4:	3003      	addeq	r0, #3
 80151b6:	9001      	streq	r0, [sp, #4]
 80151b8:	e7ef      	b.n	801519a <json_parse_string+0xe>
 80151ba:	bf00      	nop

080151bc <json_value_init_object>:
JSON_Value * json_value_init_object(void) {
 80151bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80151be:	4f0e      	ldr	r7, [pc, #56]	; (80151f8 <json_value_init_object+0x3c>)
 80151c0:	2010      	movs	r0, #16
 80151c2:	683b      	ldr	r3, [r7, #0]
 80151c4:	4798      	blx	r3
    if (!new_value) {
 80151c6:	4605      	mov	r5, r0
 80151c8:	b170      	cbz	r0, 80151e8 <json_value_init_object+0x2c>
    new_value->type = JSONObject;
 80151ca:	2304      	movs	r3, #4
 80151cc:	2600      	movs	r6, #0
 80151ce:	e9c0 6300 	strd	r6, r3, [r0]
    JSON_Object *new_obj = (JSON_Object*)parson_malloc(sizeof(JSON_Object));
 80151d2:	683b      	ldr	r3, [r7, #0]
 80151d4:	2014      	movs	r0, #20
 80151d6:	4798      	blx	r3
    if (new_obj == NULL) {
 80151d8:	4604      	mov	r4, r0
 80151da:	b138      	cbz	r0, 80151ec <json_value_init_object+0x30>
    new_obj->names = (char**)NULL;
 80151dc:	e9c0 5600 	strd	r5, r6, [r0]
    new_obj->count = 0;
 80151e0:	e9c0 6603 	strd	r6, r6, [r0, #12]
    new_obj->values = (JSON_Value**)NULL;
 80151e4:	6086      	str	r6, [r0, #8]
    new_value->value.object = json_object_init(new_value);
 80151e6:	60a8      	str	r0, [r5, #8]
}
 80151e8:	4628      	mov	r0, r5
 80151ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    new_value->value.object = json_object_init(new_value);
 80151ec:	60a8      	str	r0, [r5, #8]
        parson_free(new_value);
 80151ee:	687b      	ldr	r3, [r7, #4]
 80151f0:	4628      	mov	r0, r5
 80151f2:	4798      	blx	r3
        return NULL;
 80151f4:	4625      	mov	r5, r4
 80151f6:	e7f7      	b.n	80151e8 <json_value_init_object+0x2c>
 80151f8:	20000138 	.word	0x20000138

080151fc <json_value_init_array>:
JSON_Value * json_value_init_array(void) {
 80151fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80151fe:	4f0e      	ldr	r7, [pc, #56]	; (8015238 <json_value_init_array+0x3c>)
 8015200:	2010      	movs	r0, #16
 8015202:	683b      	ldr	r3, [r7, #0]
 8015204:	4798      	blx	r3
    if (!new_value) {
 8015206:	4604      	mov	r4, r0
 8015208:	b168      	cbz	r0, 8015226 <json_value_init_array+0x2a>
    new_value->type = JSONArray;
 801520a:	2305      	movs	r3, #5
 801520c:	2600      	movs	r6, #0
 801520e:	e9c0 6300 	strd	r6, r3, [r0]
    JSON_Array *new_array = (JSON_Array*)parson_malloc(sizeof(JSON_Array));
 8015212:	683b      	ldr	r3, [r7, #0]
 8015214:	2010      	movs	r0, #16
 8015216:	4798      	blx	r3
    if (new_array == NULL) {
 8015218:	4605      	mov	r5, r0
 801521a:	b130      	cbz	r0, 801522a <json_value_init_array+0x2e>
    new_array->items = (JSON_Value**)NULL;
 801521c:	e9c0 4600 	strd	r4, r6, [r0]
    new_array->count = 0;
 8015220:	e9c0 6602 	strd	r6, r6, [r0, #8]
    new_value->value.array = json_array_init(new_value);
 8015224:	60a0      	str	r0, [r4, #8]
}
 8015226:	4620      	mov	r0, r4
 8015228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    new_value->value.array = json_array_init(new_value);
 801522a:	60a0      	str	r0, [r4, #8]
        parson_free(new_value);
 801522c:	687b      	ldr	r3, [r7, #4]
 801522e:	4620      	mov	r0, r4
 8015230:	4798      	blx	r3
        return NULL;
 8015232:	462c      	mov	r4, r5
 8015234:	e7f7      	b.n	8015226 <json_value_init_array+0x2a>
 8015236:	bf00      	nop
 8015238:	20000138 	.word	0x20000138

0801523c <json_value_init_string>:
JSON_Value * json_value_init_string(const char *string) {
 801523c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (string == NULL) {
 8015240:	b310      	cbz	r0, 8015288 <json_value_init_string+0x4c>
 8015242:	4605      	mov	r5, r0
    string_len = strlen(string);
 8015244:	f7ea ffe6 	bl	8000214 <strlen>
 8015248:	4606      	mov	r6, r0
    const char *string_end =  string + string_len;
 801524a:	1828      	adds	r0, r5, r0
    while (string < string_end) {
 801524c:	4285      	cmp	r5, r0
 801524e:	d246      	bcs.n	80152de <json_value_init_string+0xa2>
 8015250:	462c      	mov	r4, r5
    *len = num_bytes_in_utf8_sequence(string[0]);
 8015252:	7823      	ldrb	r3, [r4, #0]
    if (c == 0xC0 || c == 0xC1 || c > 0xF4 || IS_CONT(c)) {
 8015254:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8015258:	b2d2      	uxtb	r2, r2
 801525a:	2a01      	cmp	r2, #1
 801525c:	d914      	bls.n	8015288 <json_value_init_string+0x4c>
 801525e:	2bf4      	cmp	r3, #244	; 0xf4
 8015260:	d812      	bhi.n	8015288 <json_value_init_string+0x4c>
 8015262:	f003 02c0 	and.w	r2, r3, #192	; 0xc0
 8015266:	2a80      	cmp	r2, #128	; 0x80
 8015268:	d00e      	beq.n	8015288 <json_value_init_string+0x4c>
    } else if ((c & 0x80) == 0) {    /* 0xxxxxxx */
 801526a:	061a      	lsls	r2, r3, #24
 801526c:	f140 8083 	bpl.w	8015376 <json_value_init_string+0x13a>
    } else if ((c & 0xE0) == 0xC0) { /* 110xxxxx */
 8015270:	f003 02e0 	and.w	r2, r3, #224	; 0xe0
 8015274:	2ac0      	cmp	r2, #192	; 0xc0
 8015276:	d06f      	beq.n	8015358 <json_value_init_string+0x11c>
    } else if ((c & 0xF0) == 0xE0) { /* 1110xxxx */
 8015278:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 801527c:	2ae0      	cmp	r2, #224	; 0xe0
 801527e:	d04d      	beq.n	801531c <json_value_init_string+0xe0>
    } else if ((c & 0xF8) == 0xF0) { /* 11110xxx */
 8015280:	f003 02f8 	and.w	r2, r3, #248	; 0xf8
 8015284:	2af0      	cmp	r2, #240	; 0xf0
 8015286:	d003      	beq.n	8015290 <json_value_init_string+0x54>
        return NULL;
 8015288:	2400      	movs	r4, #0
}
 801528a:	4620      	mov	r0, r4
 801528c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    } else if (*len == 4 && IS_CONT(string[1]) && IS_CONT(string[2]) && IS_CONT(string[3])) {
 8015290:	7861      	ldrb	r1, [r4, #1]
 8015292:	f001 02c0 	and.w	r2, r1, #192	; 0xc0
 8015296:	2a80      	cmp	r2, #128	; 0x80
 8015298:	d1f6      	bne.n	8015288 <json_value_init_string+0x4c>
 801529a:	78a2      	ldrb	r2, [r4, #2]
 801529c:	f002 07c0 	and.w	r7, r2, #192	; 0xc0
 80152a0:	2f80      	cmp	r7, #128	; 0x80
 80152a2:	d1f1      	bne.n	8015288 <json_value_init_string+0x4c>
 80152a4:	78e7      	ldrb	r7, [r4, #3]
 80152a6:	f007 0cc0 	and.w	ip, r7, #192	; 0xc0
 80152aa:	f1bc 0f80 	cmp.w	ip, #128	; 0x80
 80152ae:	d1eb      	bne.n	8015288 <json_value_init_string+0x4c>
        cp = string[0] & 0x7;
 80152b0:	f003 0307 	and.w	r3, r3, #7
        cp = (cp << 6) | (string[1] & 0x3F);
 80152b4:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 80152b8:	ea41 1383 	orr.w	r3, r1, r3, lsl #6
        cp = (cp << 6) | (string[2] & 0x3F);
 80152bc:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80152c0:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
        cp = (cp << 6) | (string[3] & 0x3F);
 80152c4:	f007 073f 	and.w	r7, r7, #63	; 0x3f
 80152c8:	ea47 1282 	orr.w	r2, r7, r2, lsl #6
    if ((cp < 0x80    && *len > 1) ||
 80152cc:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
 80152d0:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 80152d4:	d2d8      	bcs.n	8015288 <json_value_init_string+0x4c>
 80152d6:	2304      	movs	r3, #4
        string += len;
 80152d8:	441c      	add	r4, r3
    while (string < string_end) {
 80152da:	42a0      	cmp	r0, r4
 80152dc:	d8b9      	bhi.n	8015252 <json_value_init_string+0x16>
    char *output_string = (char*)parson_malloc(n + 1);
 80152de:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 801538c <json_value_init_string+0x150>
 80152e2:	1c70      	adds	r0, r6, #1
 80152e4:	f8d9 3000 	ldr.w	r3, [r9]
 80152e8:	4798      	blx	r3
    if (!output_string) {
 80152ea:	4607      	mov	r7, r0
 80152ec:	2800      	cmp	r0, #0
 80152ee:	d0cb      	beq.n	8015288 <json_value_init_string+0x4c>
    output_string[n] = '\0';
 80152f0:	f04f 0800 	mov.w	r8, #0
    strncpy(output_string, string, n);
 80152f4:	4629      	mov	r1, r5
 80152f6:	4632      	mov	r2, r6
    output_string[n] = '\0';
 80152f8:	f807 8006 	strb.w	r8, [r7, r6]
    strncpy(output_string, string, n);
 80152fc:	f001 fc1e 	bl	8016b3c <strncpy>
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8015300:	f8d9 3000 	ldr.w	r3, [r9]
 8015304:	2010      	movs	r0, #16
 8015306:	4798      	blx	r3
    if (!new_value) {
 8015308:	4604      	mov	r4, r0
 801530a:	b3d0      	cbz	r0, 8015382 <json_value_init_string+0x146>
    new_value->type = JSONString;
 801530c:	2302      	movs	r3, #2
 801530e:	e9c0 3701 	strd	r3, r7, [r0, #4]
    new_value->parent = NULL;
 8015312:	f8c0 8000 	str.w	r8, [r0]
}
 8015316:	4620      	mov	r0, r4
 8015318:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    } else if (*len == 3 && IS_CONT(string[1]) && IS_CONT(string[2])) {
 801531c:	7861      	ldrb	r1, [r4, #1]
 801531e:	f001 02c0 	and.w	r2, r1, #192	; 0xc0
 8015322:	2a80      	cmp	r2, #128	; 0x80
 8015324:	d1b0      	bne.n	8015288 <json_value_init_string+0x4c>
 8015326:	78a2      	ldrb	r2, [r4, #2]
 8015328:	f002 07c0 	and.w	r7, r2, #192	; 0xc0
 801532c:	2f80      	cmp	r7, #128	; 0x80
 801532e:	d1ab      	bne.n	8015288 <json_value_init_string+0x4c>
        cp = ((unsigned char)string[0]) & 0xF;
 8015330:	f003 030f 	and.w	r3, r3, #15
        cp = (cp << 6) | (string[1] & 0x3F);
 8015334:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 8015338:	ea41 1383 	orr.w	r3, r1, r3, lsl #6
        cp = (cp << 6) | (string[2] & 0x3F);
 801533c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8015340:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
    if ((cp < 0x80    && *len > 1) ||
 8015344:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8015348:	d39e      	bcc.n	8015288 <json_value_init_string+0x4c>
    if (cp >= 0xD800 && cp <= 0xDFFF) {
 801534a:	f5a2 4258 	sub.w	r2, r2, #55296	; 0xd800
 801534e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8015352:	d399      	bcc.n	8015288 <json_value_init_string+0x4c>
 8015354:	2303      	movs	r3, #3
 8015356:	e00f      	b.n	8015378 <json_value_init_string+0x13c>
    } else if (*len == 2 && IS_CONT(string[1])) {
 8015358:	7862      	ldrb	r2, [r4, #1]
 801535a:	f002 01c0 	and.w	r1, r2, #192	; 0xc0
 801535e:	2980      	cmp	r1, #128	; 0x80
 8015360:	d192      	bne.n	8015288 <json_value_init_string+0x4c>
        cp = string[0] & 0x1F;
 8015362:	f003 031f 	and.w	r3, r3, #31
        cp = (cp << 6) | (string[1] & 0x3F);
 8015366:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 801536a:	ea42 1383 	orr.w	r3, r2, r3, lsl #6
    if ((cp < 0x80    && *len > 1) ||
 801536e:	2b7f      	cmp	r3, #127	; 0x7f
 8015370:	d98a      	bls.n	8015288 <json_value_init_string+0x4c>
 8015372:	2302      	movs	r3, #2
 8015374:	e000      	b.n	8015378 <json_value_init_string+0x13c>
 8015376:	2301      	movs	r3, #1
        string += len;
 8015378:	441c      	add	r4, r3
    while (string < string_end) {
 801537a:	42a0      	cmp	r0, r4
 801537c:	f63f af69 	bhi.w	8015252 <json_value_init_string+0x16>
 8015380:	e7ad      	b.n	80152de <json_value_init_string+0xa2>
        parson_free(copy);
 8015382:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8015386:	4638      	mov	r0, r7
 8015388:	4798      	blx	r3
 801538a:	e77e      	b.n	801528a <json_value_init_string+0x4e>
 801538c:	20000138 	.word	0x20000138

08015390 <json_serialization_size>:
        default:
            return NULL;
    }
}

size_t json_serialization_size(const JSON_Value *value) {
 8015390:	b500      	push	{lr}
    char num_buf[NUM_BUF_SIZE]; /* recursively allocating buffer on stack is a bad idea, so let's do it only once */
    int res = json_serialize_to_buffer_r(value, NULL, 0, 0, num_buf);
 8015392:	2200      	movs	r2, #0
size_t json_serialization_size(const JSON_Value *value) {
 8015394:	b091      	sub	sp, #68	; 0x44
    int res = json_serialize_to_buffer_r(value, NULL, 0, 0, num_buf);
 8015396:	4611      	mov	r1, r2
 8015398:	466b      	mov	r3, sp
 801539a:	f7ff f8f5 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    return res < 0 ? 0 : (size_t)(res + 1);
 801539e:	2800      	cmp	r0, #0
 80153a0:	bfac      	ite	ge
 80153a2:	3001      	addge	r0, #1
 80153a4:	2000      	movlt	r0, #0
}
 80153a6:	b011      	add	sp, #68	; 0x44
 80153a8:	f85d fb04 	ldr.w	pc, [sp], #4

080153ac <json_serialize_to_string>:
    }
    json_free_serialized_string(serialized_string);
    return return_code;
}

char * json_serialize_to_string(const JSON_Value *value) {
 80153ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    int res = json_serialize_to_buffer_r(value, NULL, 0, 0, num_buf);
 80153ae:	2200      	movs	r2, #0
char * json_serialize_to_string(const JSON_Value *value) {
 80153b0:	b091      	sub	sp, #68	; 0x44
    int res = json_serialize_to_buffer_r(value, NULL, 0, 0, num_buf);
 80153b2:	466b      	mov	r3, sp
 80153b4:	4611      	mov	r1, r2
char * json_serialize_to_string(const JSON_Value *value) {
 80153b6:	4606      	mov	r6, r0
    int res = json_serialize_to_buffer_r(value, NULL, 0, 0, num_buf);
 80153b8:	f7ff f8e6 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    return res < 0 ? 0 : (size_t)(res + 1);
 80153bc:	1e03      	subs	r3, r0, #0
 80153be:	db1f      	blt.n	8015400 <json_serialize_to_string+0x54>
    size_t buf_size_bytes = json_serialization_size(value);
    char *buf = NULL;
    if (buf_size_bytes == 0) {
        return NULL;
    }
    buf = (char*)parson_malloc(buf_size_bytes);
 80153c0:	4f11      	ldr	r7, [pc, #68]	; (8015408 <json_serialize_to_string+0x5c>)
    return res < 0 ? 0 : (size_t)(res + 1);
 80153c2:	1c5c      	adds	r4, r3, #1
    buf = (char*)parson_malloc(buf_size_bytes);
 80153c4:	4620      	mov	r0, r4
 80153c6:	683b      	ldr	r3, [r7, #0]
 80153c8:	4798      	blx	r3
    if (buf == NULL) {
 80153ca:	4605      	mov	r5, r0
 80153cc:	b190      	cbz	r0, 80153f4 <json_serialize_to_string+0x48>
    int res = json_serialize_to_buffer_r(value, NULL, 0, 0, num_buf);
 80153ce:	2200      	movs	r2, #0
 80153d0:	466b      	mov	r3, sp
 80153d2:	4611      	mov	r1, r2
 80153d4:	4630      	mov	r0, r6
 80153d6:	f7ff f8d7 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    return res < 0 ? 0 : (size_t)(res + 1);
 80153da:	1e03      	subs	r3, r0, #0
 80153dc:	db0d      	blt.n	80153fa <json_serialize_to_string+0x4e>
 80153de:	3301      	adds	r3, #1
    if (needed_size_in_bytes == 0 || buf_size_in_bytes < needed_size_in_bytes) {
 80153e0:	429c      	cmp	r4, r3
 80153e2:	d30a      	bcc.n	80153fa <json_serialize_to_string+0x4e>
    written = json_serialize_to_buffer_r(value, buf, 0, 0, NULL);
 80153e4:	2300      	movs	r3, #0
 80153e6:	4630      	mov	r0, r6
 80153e8:	461a      	mov	r2, r3
 80153ea:	4629      	mov	r1, r5
 80153ec:	f7ff f8cc 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    if (written < 0) {
 80153f0:	2800      	cmp	r0, #0
 80153f2:	db02      	blt.n	80153fa <json_serialize_to_string+0x4e>
    if (serialization_result == JSONFailure) {
        json_free_serialized_string(buf);
        return NULL;
    }
    return buf;
}
 80153f4:	4628      	mov	r0, r5
 80153f6:	b011      	add	sp, #68	; 0x44
 80153f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }
    return buf;
}

void json_free_serialized_string(char *string) {
    parson_free(string);
 80153fa:	687b      	ldr	r3, [r7, #4]
 80153fc:	4628      	mov	r0, r5
 80153fe:	4798      	blx	r3
        return NULL;
 8015400:	2500      	movs	r5, #0
}
 8015402:	4628      	mov	r0, r5
 8015404:	b011      	add	sp, #68	; 0x44
 8015406:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015408:	20000138 	.word	0x20000138

0801540c <json_serialization_size_pretty>:
size_t json_serialization_size_pretty(const JSON_Value *value) {
 801540c:	b500      	push	{lr}
 801540e:	b091      	sub	sp, #68	; 0x44
    int res = json_serialize_to_buffer_r(value, NULL, 0, 1, num_buf);
 8015410:	466b      	mov	r3, sp
 8015412:	2201      	movs	r2, #1
 8015414:	2100      	movs	r1, #0
 8015416:	f7ff f8b7 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    return res < 0 ? 0 : (size_t)(res + 1);
 801541a:	2800      	cmp	r0, #0
 801541c:	bfac      	ite	ge
 801541e:	3001      	addge	r0, #1
 8015420:	2000      	movlt	r0, #0
}
 8015422:	b011      	add	sp, #68	; 0x44
 8015424:	f85d fb04 	ldr.w	pc, [sp], #4

08015428 <json_serialize_to_string_pretty>:
char * json_serialize_to_string_pretty(const JSON_Value *value) {
 8015428:	b5f0      	push	{r4, r5, r6, r7, lr}
 801542a:	b091      	sub	sp, #68	; 0x44
    int res = json_serialize_to_buffer_r(value, NULL, 0, 1, num_buf);
 801542c:	466b      	mov	r3, sp
 801542e:	2201      	movs	r2, #1
 8015430:	2100      	movs	r1, #0
char * json_serialize_to_string_pretty(const JSON_Value *value) {
 8015432:	4606      	mov	r6, r0
    int res = json_serialize_to_buffer_r(value, NULL, 0, 1, num_buf);
 8015434:	f7ff f8a8 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    return res < 0 ? 0 : (size_t)(res + 1);
 8015438:	1e03      	subs	r3, r0, #0
 801543a:	db1f      	blt.n	801547c <json_serialize_to_string_pretty+0x54>
    buf = (char*)parson_malloc(buf_size_bytes);
 801543c:	4f11      	ldr	r7, [pc, #68]	; (8015484 <json_serialize_to_string_pretty+0x5c>)
    return res < 0 ? 0 : (size_t)(res + 1);
 801543e:	1c5c      	adds	r4, r3, #1
    buf = (char*)parson_malloc(buf_size_bytes);
 8015440:	4620      	mov	r0, r4
 8015442:	683b      	ldr	r3, [r7, #0]
 8015444:	4798      	blx	r3
    if (buf == NULL) {
 8015446:	4605      	mov	r5, r0
 8015448:	b190      	cbz	r0, 8015470 <json_serialize_to_string_pretty+0x48>
    int res = json_serialize_to_buffer_r(value, NULL, 0, 1, num_buf);
 801544a:	466b      	mov	r3, sp
 801544c:	2201      	movs	r2, #1
 801544e:	2100      	movs	r1, #0
 8015450:	4630      	mov	r0, r6
 8015452:	f7ff f899 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    return res < 0 ? 0 : (size_t)(res + 1);
 8015456:	1e03      	subs	r3, r0, #0
 8015458:	db0d      	blt.n	8015476 <json_serialize_to_string_pretty+0x4e>
 801545a:	3301      	adds	r3, #1
    if (needed_size_in_bytes == 0 || buf_size_in_bytes < needed_size_in_bytes) {
 801545c:	429c      	cmp	r4, r3
 801545e:	d30a      	bcc.n	8015476 <json_serialize_to_string_pretty+0x4e>
    written = json_serialize_to_buffer_r(value, buf, 0, 1, NULL);
 8015460:	4630      	mov	r0, r6
 8015462:	2300      	movs	r3, #0
 8015464:	2201      	movs	r2, #1
 8015466:	4629      	mov	r1, r5
 8015468:	f7ff f88e 	bl	8014588 <json_serialize_to_buffer_r.constprop.0>
    if (written < 0) {
 801546c:	2800      	cmp	r0, #0
 801546e:	db02      	blt.n	8015476 <json_serialize_to_string_pretty+0x4e>
}
 8015470:	4628      	mov	r0, r5
 8015472:	b011      	add	sp, #68	; 0x44
 8015474:	bdf0      	pop	{r4, r5, r6, r7, pc}
    parson_free(string);
 8015476:	687b      	ldr	r3, [r7, #4]
 8015478:	4628      	mov	r0, r5
 801547a:	4798      	blx	r3
        return NULL;
 801547c:	2500      	movs	r5, #0
}
 801547e:	4628      	mov	r0, r5
 8015480:	b011      	add	sp, #68	; 0x44
 8015482:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8015484:	20000138 	.word	0x20000138

08015488 <json_array_append_value>:
    array->count = 0;
    return JSONSuccess;
}

JSON_Status json_array_append_value(JSON_Array *array, JSON_Value *value) {
    if (array == NULL || value == NULL || value->parent != NULL) {
 8015488:	2800      	cmp	r0, #0
 801548a:	d034      	beq.n	80154f6 <json_array_append_value+0x6e>
JSON_Status json_array_append_value(JSON_Array *array, JSON_Value *value) {
 801548c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015490:	460f      	mov	r7, r1
    if (array == NULL || value == NULL || value->parent != NULL) {
 8015492:	b369      	cbz	r1, 80154f0 <json_array_append_value+0x68>
 8015494:	680b      	ldr	r3, [r1, #0]
 8015496:	bb5b      	cbnz	r3, 80154f0 <json_array_append_value+0x68>
    if (array->count >= array->capacity) {
 8015498:	e9d0 3602 	ldrd	r3, r6, [r0, #8]
 801549c:	42b3      	cmp	r3, r6
 801549e:	4604      	mov	r4, r0
 80154a0:	d209      	bcs.n	80154b6 <json_array_append_value+0x2e>
 80154a2:	6845      	ldr	r5, [r0, #4]
    value->parent = json_array_get_wrapping_value(array);
 80154a4:	6822      	ldr	r2, [r4, #0]
 80154a6:	603a      	str	r2, [r7, #0]
    array->count++;
 80154a8:	1c5a      	adds	r2, r3, #1
    array->items[array->count] = value;
 80154aa:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
    return JSONSuccess;
 80154ae:	2000      	movs	r0, #0
    array->count++;
 80154b0:	60a2      	str	r2, [r4, #8]
        return JSONFailure;
    }
    return json_array_add(array, value);
}
 80154b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        size_t new_capacity = MAX(array->capacity * 2, STARTING_CAPACITY);
 80154b6:	0076      	lsls	r6, r6, #1
 80154b8:	2e10      	cmp	r6, #16
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 80154ba:	f8df 8040 	ldr.w	r8, [pc, #64]	; 80154fc <json_array_append_value+0x74>
        size_t new_capacity = MAX(array->capacity * 2, STARTING_CAPACITY);
 80154be:	bf38      	it	cc
 80154c0:	2610      	movcc	r6, #16
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 80154c2:	f8d8 3000 	ldr.w	r3, [r8]
 80154c6:	00b0      	lsls	r0, r6, #2
 80154c8:	4798      	blx	r3
    if (new_items == NULL) {
 80154ca:	4605      	mov	r5, r0
 80154cc:	b180      	cbz	r0, 80154f0 <json_array_append_value+0x68>
    if (array->items != NULL && array->count > 0) {
 80154ce:	6861      	ldr	r1, [r4, #4]
 80154d0:	b109      	cbz	r1, 80154d6 <json_array_append_value+0x4e>
 80154d2:	68a2      	ldr	r2, [r4, #8]
 80154d4:	b93a      	cbnz	r2, 80154e6 <json_array_append_value+0x5e>
    parson_free(array->items);
 80154d6:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80154da:	4608      	mov	r0, r1
 80154dc:	4798      	blx	r3
    array->items = new_items;
 80154de:	68a3      	ldr	r3, [r4, #8]
 80154e0:	6065      	str	r5, [r4, #4]
    array->capacity = new_capacity;
 80154e2:	60e6      	str	r6, [r4, #12]
    return JSONSuccess;
 80154e4:	e7de      	b.n	80154a4 <json_array_append_value+0x1c>
        memcpy(new_items, array->items, array->count * sizeof(JSON_Value*));
 80154e6:	0092      	lsls	r2, r2, #2
 80154e8:	f000 fd2a 	bl	8015f40 <memcpy>
 80154ec:	6861      	ldr	r1, [r4, #4]
 80154ee:	e7f2      	b.n	80154d6 <json_array_append_value+0x4e>
        return JSONFailure;
 80154f0:	f04f 30ff 	mov.w	r0, #4294967295
 80154f4:	e7dd      	b.n	80154b2 <json_array_append_value+0x2a>
 80154f6:	f04f 30ff 	mov.w	r0, #4294967295
}
 80154fa:	4770      	bx	lr
 80154fc:	20000138 	.word	0x20000138

08015500 <json_array_append_number>:
        return JSONFailure;
    }
    return JSONSuccess;
}

JSON_Status json_array_append_number(JSON_Array *array, double number) {
 8015500:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015504:	ec57 6b10 	vmov	r6, r7, d0
 8015508:	4604      	mov	r4, r0
    if (IS_NUMBER_INVALID(number)) {
 801550a:	ee10 2a10 	vmov	r2, s0
 801550e:	ee10 0a10 	vmov	r0, s0
 8015512:	463b      	mov	r3, r7
 8015514:	4639      	mov	r1, r7
 8015516:	f7eb fb31 	bl	8000b7c <__aeabi_dcmpun>
 801551a:	2800      	cmp	r0, #0
 801551c:	d14d      	bne.n	80155ba <json_array_append_number+0xba>
 801551e:	f027 4900 	bic.w	r9, r7, #2147483648	; 0x80000000
 8015522:	4b28      	ldr	r3, [pc, #160]	; (80155c4 <json_array_append_number+0xc4>)
 8015524:	4630      	mov	r0, r6
 8015526:	4649      	mov	r1, r9
 8015528:	f04f 32ff 	mov.w	r2, #4294967295
 801552c:	f7eb fb26 	bl	8000b7c <__aeabi_dcmpun>
 8015530:	b940      	cbnz	r0, 8015544 <json_array_append_number+0x44>
 8015532:	4b24      	ldr	r3, [pc, #144]	; (80155c4 <json_array_append_number+0xc4>)
 8015534:	4630      	mov	r0, r6
 8015536:	4649      	mov	r1, r9
 8015538:	f04f 32ff 	mov.w	r2, #4294967295
 801553c:	f7eb fb00 	bl	8000b40 <__aeabi_dcmple>
 8015540:	2800      	cmp	r0, #0
 8015542:	d03a      	beq.n	80155ba <json_array_append_number+0xba>
    new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8015544:	f8df 8080 	ldr.w	r8, [pc, #128]	; 80155c8 <json_array_append_number+0xc8>
 8015548:	2010      	movs	r0, #16
 801554a:	f8d8 3000 	ldr.w	r3, [r8]
 801554e:	4798      	blx	r3
    if (new_value == NULL) {
 8015550:	4605      	mov	r5, r0
 8015552:	2800      	cmp	r0, #0
 8015554:	d031      	beq.n	80155ba <json_array_append_number+0xba>
    new_value->parent = NULL;
 8015556:	2200      	movs	r2, #0
    new_value->type = JSONNumber;
 8015558:	2303      	movs	r3, #3
    new_value->value.number = number;
 801555a:	e9c0 6702 	strd	r6, r7, [r0, #8]
    new_value->type = JSONNumber;
 801555e:	e9c0 2300 	strd	r2, r3, [r0]
    if (array == NULL || value == NULL || value->parent != NULL) {
 8015562:	b33c      	cbz	r4, 80155b4 <json_array_append_number+0xb4>
    if (array->count >= array->capacity) {
 8015564:	e9d4 3702 	ldrd	r3, r7, [r4, #8]
 8015568:	42bb      	cmp	r3, r7
 801556a:	d209      	bcs.n	8015580 <json_array_append_number+0x80>
 801556c:	6866      	ldr	r6, [r4, #4]
    value->parent = json_array_get_wrapping_value(array);
 801556e:	6822      	ldr	r2, [r4, #0]
 8015570:	602a      	str	r2, [r5, #0]
    array->count++;
 8015572:	1c5a      	adds	r2, r3, #1
    array->items[array->count] = value;
 8015574:	f846 5023 	str.w	r5, [r6, r3, lsl #2]
    }
    if (json_array_append_value(array, value) == JSONFailure) {
        json_value_free(value);
        return JSONFailure;
    }
    return JSONSuccess;
 8015578:	2000      	movs	r0, #0
    array->count++;
 801557a:	60a2      	str	r2, [r4, #8]
}
 801557c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        size_t new_capacity = MAX(array->capacity * 2, STARTING_CAPACITY);
 8015580:	007f      	lsls	r7, r7, #1
 8015582:	2f10      	cmp	r7, #16
 8015584:	bf38      	it	cc
 8015586:	2710      	movcc	r7, #16
    new_items = (JSON_Value**)parson_malloc(new_capacity * sizeof(JSON_Value*));
 8015588:	f8d8 3000 	ldr.w	r3, [r8]
 801558c:	00b8      	lsls	r0, r7, #2
 801558e:	4798      	blx	r3
    if (new_items == NULL) {
 8015590:	4606      	mov	r6, r0
 8015592:	b178      	cbz	r0, 80155b4 <json_array_append_number+0xb4>
    if (array->items != NULL && array->count > 0) {
 8015594:	6861      	ldr	r1, [r4, #4]
 8015596:	b129      	cbz	r1, 80155a4 <json_array_append_number+0xa4>
 8015598:	68a2      	ldr	r2, [r4, #8]
 801559a:	b11a      	cbz	r2, 80155a4 <json_array_append_number+0xa4>
        memcpy(new_items, array->items, array->count * sizeof(JSON_Value*));
 801559c:	0092      	lsls	r2, r2, #2
 801559e:	f000 fccf 	bl	8015f40 <memcpy>
 80155a2:	6861      	ldr	r1, [r4, #4]
    parson_free(array->items);
 80155a4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80155a8:	4608      	mov	r0, r1
 80155aa:	4798      	blx	r3
    array->items = new_items;
 80155ac:	68a3      	ldr	r3, [r4, #8]
 80155ae:	6066      	str	r6, [r4, #4]
    array->capacity = new_capacity;
 80155b0:	60e7      	str	r7, [r4, #12]
    return JSONSuccess;
 80155b2:	e7dc      	b.n	801556e <json_array_append_number+0x6e>
        json_value_free(value);
 80155b4:	4628      	mov	r0, r5
 80155b6:	f7ff faa9 	bl	8014b0c <json_value_free>
        return JSONFailure;
 80155ba:	f04f 30ff 	mov.w	r0, #4294967295
}
 80155be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80155c2:	bf00      	nop
 80155c4:	7fefffff 	.word	0x7fefffff
 80155c8:	20000138 	.word	0x20000138

080155cc <json_object_set_value>:
        return JSONFailure;
    }
    return JSONSuccess;
}

JSON_Status json_object_set_value(JSON_Object *object, const char *name, JSON_Value *value) {
 80155cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80155d0:	b083      	sub	sp, #12
 80155d2:	9201      	str	r2, [sp, #4]
    size_t i = 0;
    JSON_Value *old_value;
    if (object == NULL || name == NULL || value == NULL || value->parent != NULL) {
 80155d4:	2800      	cmp	r0, #0
 80155d6:	d05c      	beq.n	8015692 <json_object_set_value+0xc6>
 80155d8:	460d      	mov	r5, r1
 80155da:	2900      	cmp	r1, #0
 80155dc:	d059      	beq.n	8015692 <json_object_set_value+0xc6>
 80155de:	2a00      	cmp	r2, #0
 80155e0:	d057      	beq.n	8015692 <json_object_set_value+0xc6>
 80155e2:	6814      	ldr	r4, [r2, #0]
 80155e4:	2c00      	cmp	r4, #0
 80155e6:	d154      	bne.n	8015692 <json_object_set_value+0xc6>
        return JSONFailure;
    }
    old_value = json_object_get_value(object, name);
 80155e8:	4680      	mov	r8, r0
    return json_object_getn_value(object, name, strlen(name));
 80155ea:	4608      	mov	r0, r1
 80155ec:	f7ea fe12 	bl	8000214 <strlen>
    return object ? object->count : 0;
 80155f0:	f8d8 900c 	ldr.w	r9, [r8, #12]
    return json_object_getn_value(object, name, strlen(name));
 80155f4:	4606      	mov	r6, r0
    for (i = 0; i < json_object_get_count(object); i++) {
 80155f6:	f1b9 0f00 	cmp.w	r9, #0
 80155fa:	d018      	beq.n	801562e <json_object_set_value+0x62>
 80155fc:	f8d8 7004 	ldr.w	r7, [r8, #4]
 8015600:	46a2      	mov	sl, r4
 8015602:	3f04      	subs	r7, #4
        name_length = strlen(object->names[i]);
 8015604:	f857 4f04 	ldr.w	r4, [r7, #4]!
 8015608:	4620      	mov	r0, r4
 801560a:	f7ea fe03 	bl	8000214 <strlen>
 801560e:	4684      	mov	ip, r0
        if (name_length != name_len) {
 8015610:	4566      	cmp	r6, ip
 8015612:	ea4f 0b8a 	mov.w	fp, sl, lsl #2
        if (strncmp(object->names[i], name, name_len) == 0) {
 8015616:	4632      	mov	r2, r6
 8015618:	4629      	mov	r1, r5
 801561a:	4620      	mov	r0, r4
    for (i = 0; i < json_object_get_count(object); i++) {
 801561c:	f10a 0a01 	add.w	sl, sl, #1
        if (name_length != name_len) {
 8015620:	d103      	bne.n	801562a <json_object_set_value+0x5e>
        if (strncmp(object->names[i], name, name_len) == 0) {
 8015622:	f001 fa79 	bl	8016b18 <strncmp>
 8015626:	4604      	mov	r4, r0
 8015628:	b150      	cbz	r0, 8015640 <json_object_set_value+0x74>
    for (i = 0; i < json_object_get_count(object); i++) {
 801562a:	45ca      	cmp	sl, r9
 801562c:	d1ea      	bne.n	8015604 <json_object_set_value+0x38>
    return json_object_addn(object, name, strlen(name), value);
 801562e:	9b01      	ldr	r3, [sp, #4]
 8015630:	4632      	mov	r2, r6
 8015632:	4629      	mov	r1, r5
 8015634:	4640      	mov	r0, r8
            }
        }
    }
    /* add new key value pair */
    return json_object_add(object, name, value);
}
 8015636:	b003      	add	sp, #12
 8015638:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return json_object_addn(object, name, strlen(name), value);
 801563c:	f7fe b90a 	b.w	8013854 <json_object_addn>
            return object->values[i];
 8015640:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8015644:	f853 000b 	ldr.w	r0, [r3, fp]
    if (old_value != NULL) { /* free and overwrite old value */
 8015648:	2800      	cmp	r0, #0
 801564a:	d0f0      	beq.n	801562e <json_object_set_value+0x62>
        json_value_free(old_value);
 801564c:	f7ff fa5e 	bl	8014b0c <json_value_free>
    return object ? object->count : 0;
 8015650:	f8d8 600c 	ldr.w	r6, [r8, #12]
        for (i = 0; i < json_object_get_count(object); i++) {
 8015654:	b1c6      	cbz	r6, 8015688 <json_object_set_value+0xbc>
 8015656:	f8d8 7004 	ldr.w	r7, [r8, #4]
 801565a:	3f04      	subs	r7, #4
 801565c:	e001      	b.n	8015662 <json_object_set_value+0x96>
 801565e:	42b4      	cmp	r4, r6
 8015660:	d012      	beq.n	8015688 <json_object_set_value+0xbc>
            if (strcmp(object->names[i], name) == 0) {
 8015662:	f857 0f04 	ldr.w	r0, [r7, #4]!
 8015666:	4629      	mov	r1, r5
 8015668:	f7ea fdca 	bl	8000200 <strcmp>
        for (i = 0; i < json_object_get_count(object); i++) {
 801566c:	00a3      	lsls	r3, r4, #2
 801566e:	3401      	adds	r4, #1
            if (strcmp(object->names[i], name) == 0) {
 8015670:	2800      	cmp	r0, #0
 8015672:	d1f4      	bne.n	801565e <json_object_set_value+0x92>
                object->values[i] = value;
 8015674:	f8d8 2008 	ldr.w	r2, [r8, #8]
                value->parent = json_object_get_wrapping_value(object);
 8015678:	9c01      	ldr	r4, [sp, #4]
 801567a:	f8d8 1000 	ldr.w	r1, [r8]
 801567e:	6021      	str	r1, [r4, #0]
                object->values[i] = value;
 8015680:	50d4      	str	r4, [r2, r3]
}
 8015682:	b003      	add	sp, #12
 8015684:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015688:	4628      	mov	r0, r5
 801568a:	f7ea fdc3 	bl	8000214 <strlen>
 801568e:	4606      	mov	r6, r0
 8015690:	e7cd      	b.n	801562e <json_object_set_value+0x62>
        return JSONFailure;
 8015692:	f04f 30ff 	mov.w	r0, #4294967295
 8015696:	e7f4      	b.n	8015682 <json_object_set_value+0xb6>

08015698 <json_object_dotset_value>:

JSON_Status json_object_set_null(JSON_Object *object, const char *name) {
    return json_object_set_value(object, name, json_value_init_null());
}

JSON_Status json_object_dotset_value(JSON_Object *object, const char *name, JSON_Value *value) {
 8015698:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801569c:	b083      	sub	sp, #12
 801569e:	9201      	str	r2, [sp, #4]
    const char *dot_pos = NULL;
    JSON_Value *temp_value = NULL, *new_value = NULL;
    JSON_Object *temp_object = NULL, *new_object = NULL;
    JSON_Status status = JSONFailure;
    size_t name_len = 0;
    if (object == NULL || name == NULL || value == NULL) {
 80156a0:	2800      	cmp	r0, #0
 80156a2:	f000 809f 	beq.w	80157e4 <json_object_dotset_value+0x14c>
 80156a6:	460f      	mov	r7, r1
 80156a8:	2900      	cmp	r1, #0
 80156aa:	f000 809b 	beq.w	80157e4 <json_object_dotset_value+0x14c>
 80156ae:	4605      	mov	r5, r0
 80156b0:	2a00      	cmp	r2, #0
 80156b2:	f000 8097 	beq.w	80157e4 <json_object_dotset_value+0x14c>
        return JSONFailure;
    }
    dot_pos = strchr(name, '.');
 80156b6:	212e      	movs	r1, #46	; 0x2e
 80156b8:	4638      	mov	r0, r7
 80156ba:	f001 fa20 	bl	8016afe <strchr>
    if (dot_pos == NULL) {
 80156be:	4604      	mov	r4, r0
 80156c0:	2800      	cmp	r0, #0
 80156c2:	f000 8094 	beq.w	80157ee <json_object_dotset_value+0x156>
    return object ? object->count : 0;
 80156c6:	f8d5 900c 	ldr.w	r9, [r5, #12]
        return json_object_set_value(object, name, value);
    }
    name_len = dot_pos - name;
 80156ca:	eba0 0807 	sub.w	r8, r0, r7
    for (i = 0; i < json_object_get_count(object); i++) {
 80156ce:	f1b9 0f00 	cmp.w	r9, #0
 80156d2:	d018      	beq.n	8015706 <json_object_dotset_value+0x6e>
 80156d4:	686e      	ldr	r6, [r5, #4]
 80156d6:	f04f 0b00 	mov.w	fp, #0
 80156da:	3e04      	subs	r6, #4
        name_length = strlen(object->names[i]);
 80156dc:	f856 af04 	ldr.w	sl, [r6, #4]!
 80156e0:	4650      	mov	r0, sl
 80156e2:	f7ea fd97 	bl	8000214 <strlen>
 80156e6:	4684      	mov	ip, r0
        if (name_length != name_len) {
 80156e8:	45e0      	cmp	r8, ip
        if (strncmp(object->names[i], name, name_len) == 0) {
 80156ea:	4650      	mov	r0, sl
 80156ec:	4642      	mov	r2, r8
 80156ee:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 80156f2:	4639      	mov	r1, r7
    for (i = 0; i < json_object_get_count(object); i++) {
 80156f4:	f10b 0b01 	add.w	fp, fp, #1
        if (name_length != name_len) {
 80156f8:	d103      	bne.n	8015702 <json_object_dotset_value+0x6a>
        if (strncmp(object->names[i], name, name_len) == 0) {
 80156fa:	f001 fa0d 	bl	8016b18 <strncmp>
 80156fe:	2800      	cmp	r0, #0
 8015700:	d063      	beq.n	80157ca <json_object_dotset_value+0x132>
    for (i = 0; i < json_object_get_count(object); i++) {
 8015702:	45cb      	cmp	fp, r9
 8015704:	d1ea      	bne.n	80156dc <json_object_dotset_value+0x44>
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 8015706:	f8df 9118 	ldr.w	r9, [pc, #280]	; 8015820 <json_object_dotset_value+0x188>
 801570a:	2010      	movs	r0, #16
 801570c:	f8d9 3000 	ldr.w	r3, [r9]
 8015710:	4798      	blx	r3
    if (!new_value) {
 8015712:	4606      	mov	r6, r0
 8015714:	2800      	cmp	r0, #0
 8015716:	d065      	beq.n	80157e4 <json_object_dotset_value+0x14c>
    new_value->type = JSONObject;
 8015718:	2200      	movs	r2, #0
 801571a:	2304      	movs	r3, #4
 801571c:	e9c0 2300 	strd	r2, r3, [r0]
    JSON_Object *new_obj = (JSON_Object*)parson_malloc(sizeof(JSON_Object));
 8015720:	f8d9 3000 	ldr.w	r3, [r9]
 8015724:	2014      	movs	r0, #20
 8015726:	4798      	blx	r3
    if (new_obj == NULL) {
 8015728:	2200      	movs	r2, #0
 801572a:	4682      	mov	sl, r0
 801572c:	2800      	cmp	r0, #0
 801572e:	d066      	beq.n	80157fe <json_object_dotset_value+0x166>
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8015730:	6873      	ldr	r3, [r6, #4]
    new_obj->wrapping_value = wrapping_value;
 8015732:	6006      	str	r6, [r0, #0]
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 8015734:	2b04      	cmp	r3, #4
 8015736:	bf18      	it	ne
 8015738:	f04f 0a00 	movne.w	sl, #0
    new_value = json_value_init_object();
    if (new_value == NULL) {
        return JSONFailure;
    }
    new_object = json_value_get_object(new_value);
    status = json_object_dotset_value(new_object, dot_pos + 1, value);
 801573c:	3401      	adds	r4, #1
    new_obj->values = (JSON_Value**)NULL;
 801573e:	e9c0 2201 	strd	r2, r2, [r0, #4]
    new_obj->count = 0;
 8015742:	e9c0 2203 	strd	r2, r2, [r0, #12]
    status = json_object_dotset_value(new_object, dot_pos + 1, value);
 8015746:	4621      	mov	r1, r4
    new_value->value.object = json_object_init(new_value);
 8015748:	60b0      	str	r0, [r6, #8]
    status = json_object_dotset_value(new_object, dot_pos + 1, value);
 801574a:	9a01      	ldr	r2, [sp, #4]
 801574c:	4650      	mov	r0, sl
 801574e:	f7ff ffa3 	bl	8015698 <json_object_dotset_value>
    if (status != JSONSuccess) {
 8015752:	2800      	cmp	r0, #0
 8015754:	d160      	bne.n	8015818 <json_object_dotset_value+0x180>
        json_value_free(new_value);
        return JSONFailure;
    }
    status = json_object_addn(object, name, name_len, new_value);
 8015756:	4642      	mov	r2, r8
 8015758:	4639      	mov	r1, r7
 801575a:	4628      	mov	r0, r5
 801575c:	4633      	mov	r3, r6
 801575e:	f7fe f879 	bl	8013854 <json_object_addn>
    if (status != JSONSuccess) {
 8015762:	2800      	cmp	r0, #0
 8015764:	d040      	beq.n	80157e8 <json_object_dotset_value+0x150>
    const char *dot_pos = strchr(name, '.');
 8015766:	212e      	movs	r1, #46	; 0x2e
 8015768:	4620      	mov	r0, r4
 801576a:	f001 f9c8 	bl	8016afe <strchr>
    if (dot_pos == NULL) {
 801576e:	9001      	str	r0, [sp, #4]
 8015770:	2800      	cmp	r0, #0
 8015772:	d04c      	beq.n	801580e <json_object_dotset_value+0x176>
    return object ? object->count : 0;
 8015774:	f1ba 0f00 	cmp.w	sl, #0
 8015778:	d04e      	beq.n	8015818 <json_object_dotset_value+0x180>
 801577a:	f8da 900c 	ldr.w	r9, [sl, #12]
    temp_value = json_object_getn_value(object, name, dot_pos - name);
 801577e:	1b07      	subs	r7, r0, r4
    for (i = 0; i < json_object_get_count(object); i++) {
 8015780:	2500      	movs	r5, #0
 8015782:	e000      	b.n	8015786 <json_object_dotset_value+0xee>
 8015784:	3501      	adds	r5, #1
 8015786:	45a9      	cmp	r9, r5
 8015788:	ea4f 0885 	mov.w	r8, r5, lsl #2
 801578c:	d044      	beq.n	8015818 <json_object_dotset_value+0x180>
        name_length = strlen(object->names[i]);
 801578e:	f8da 3004 	ldr.w	r3, [sl, #4]
 8015792:	f853 b025 	ldr.w	fp, [r3, r5, lsl #2]
 8015796:	4658      	mov	r0, fp
 8015798:	f7ea fd3c 	bl	8000214 <strlen>
 801579c:	4684      	mov	ip, r0
        if (name_length != name_len) {
 801579e:	4567      	cmp	r7, ip
        if (strncmp(object->names[i], name, name_len) == 0) {
 80157a0:	463a      	mov	r2, r7
 80157a2:	4621      	mov	r1, r4
 80157a4:	4658      	mov	r0, fp
        if (name_length != name_len) {
 80157a6:	d1ed      	bne.n	8015784 <json_object_dotset_value+0xec>
        if (strncmp(object->names[i], name, name_len) == 0) {
 80157a8:	f001 f9b6 	bl	8016b18 <strncmp>
 80157ac:	2800      	cmp	r0, #0
 80157ae:	d1e9      	bne.n	8015784 <json_object_dotset_value+0xec>
            return object->values[i];
 80157b0:	f8da 3008 	ldr.w	r3, [sl, #8]
 80157b4:	f853 3008 	ldr.w	r3, [r3, r8]
    return value ? value->type : JSONError;
 80157b8:	b373      	cbz	r3, 8015818 <json_object_dotset_value+0x180>
    if (json_value_get_type(temp_value) != JSONObject) {
 80157ba:	685a      	ldr	r2, [r3, #4]
 80157bc:	2a04      	cmp	r2, #4
 80157be:	d12b      	bne.n	8015818 <json_object_dotset_value+0x180>
    return json_object_dotremove_internal(temp_object, dot_pos + 1, free_value);
 80157c0:	9c01      	ldr	r4, [sp, #4]
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 80157c2:	f8d3 a008 	ldr.w	sl, [r3, #8]
    return json_object_dotremove_internal(temp_object, dot_pos + 1, free_value);
 80157c6:	3401      	adds	r4, #1
 80157c8:	e7cd      	b.n	8015766 <json_object_dotset_value+0xce>
            return object->values[i];
 80157ca:	68ab      	ldr	r3, [r5, #8]
 80157cc:	f853 300a 	ldr.w	r3, [r3, sl]
    if (temp_value) {
 80157d0:	2b00      	cmp	r3, #0
 80157d2:	d098      	beq.n	8015706 <json_object_dotset_value+0x6e>
        if (json_value_get_type(temp_value) != JSONObject) {
 80157d4:	685a      	ldr	r2, [r3, #4]
 80157d6:	2a04      	cmp	r2, #4
 80157d8:	d104      	bne.n	80157e4 <json_object_dotset_value+0x14c>
    return json_value_get_type(value) == JSONObject ? value->value.object : NULL;
 80157da:	689d      	ldr	r5, [r3, #8]
        return json_object_dotset_value(temp_object, dot_pos + 1, value);
 80157dc:	1c67      	adds	r7, r4, #1
    if (object == NULL || name == NULL || value == NULL) {
 80157de:	2d00      	cmp	r5, #0
 80157e0:	f47f af69 	bne.w	80156b6 <json_object_dotset_value+0x1e>
        json_object_dotremove_internal(new_object, dot_pos + 1, 0);
        json_value_free(new_value);
        return JSONFailure;
 80157e4:	f04f 30ff 	mov.w	r0, #4294967295
    }
    return JSONSuccess;
}
 80157e8:	b003      	add	sp, #12
 80157ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return json_object_set_value(object, name, value);
 80157ee:	9a01      	ldr	r2, [sp, #4]
 80157f0:	4639      	mov	r1, r7
 80157f2:	4628      	mov	r0, r5
}
 80157f4:	b003      	add	sp, #12
 80157f6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return json_object_set_value(object, name, value);
 80157fa:	f7ff bee7 	b.w	80155cc <json_object_set_value>
    new_value->value.object = json_object_init(new_value);
 80157fe:	60b0      	str	r0, [r6, #8]
        parson_free(new_value);
 8015800:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8015804:	4630      	mov	r0, r6
 8015806:	4798      	blx	r3
        return JSONFailure;
 8015808:	f04f 30ff 	mov.w	r0, #4294967295
 801580c:	e7ec      	b.n	80157e8 <json_object_dotset_value+0x150>
        return json_object_remove_internal(object, name, free_value);
 801580e:	4602      	mov	r2, r0
 8015810:	4621      	mov	r1, r4
 8015812:	4650      	mov	r0, sl
 8015814:	f7ff f9d2 	bl	8014bbc <json_object_remove_internal>
        json_value_free(new_value);
 8015818:	4630      	mov	r0, r6
 801581a:	f7ff f977 	bl	8014b0c <json_value_free>
 801581e:	e7e1      	b.n	80157e4 <json_object_dotset_value+0x14c>
 8015820:	20000138 	.word	0x20000138

08015824 <json_object_dotset_string>:

JSON_Status json_object_dotset_string(JSON_Object *object, const char *name, const char *string) {
 8015824:	b570      	push	{r4, r5, r6, lr}
 8015826:	4604      	mov	r4, r0
    JSON_Value *value = json_value_init_string(string);
 8015828:	4610      	mov	r0, r2
JSON_Status json_object_dotset_string(JSON_Object *object, const char *name, const char *string) {
 801582a:	460e      	mov	r6, r1
    JSON_Value *value = json_value_init_string(string);
 801582c:	f7ff fd06 	bl	801523c <json_value_init_string>
    if (value == NULL) {
 8015830:	b160      	cbz	r0, 801584c <json_object_dotset_string+0x28>
 8015832:	4605      	mov	r5, r0
        return JSONFailure;
    }
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 8015834:	4631      	mov	r1, r6
 8015836:	4620      	mov	r0, r4
 8015838:	462a      	mov	r2, r5
 801583a:	f7ff ff2d 	bl	8015698 <json_object_dotset_value>
 801583e:	1c43      	adds	r3, r0, #1
 8015840:	4604      	mov	r4, r0
        json_value_free(value);
        return JSONFailure;
    }
    return JSONSuccess;
 8015842:	bf18      	it	ne
 8015844:	2400      	movne	r4, #0
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 8015846:	d004      	beq.n	8015852 <json_object_dotset_string+0x2e>
}
 8015848:	4620      	mov	r0, r4
 801584a:	bd70      	pop	{r4, r5, r6, pc}
        return JSONFailure;
 801584c:	f04f 34ff 	mov.w	r4, #4294967295
 8015850:	e7fa      	b.n	8015848 <json_object_dotset_string+0x24>
        json_value_free(value);
 8015852:	4628      	mov	r0, r5
 8015854:	f7ff f95a 	bl	8014b0c <json_value_free>
        return JSONFailure;
 8015858:	e7f6      	b.n	8015848 <json_object_dotset_string+0x24>
 801585a:	bf00      	nop

0801585c <json_object_dotset_number>:

JSON_Status json_object_dotset_number(JSON_Object *object, const char *name, double number) {
 801585c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015860:	ec55 4b10 	vmov	r4, r5, d0
 8015864:	4680      	mov	r8, r0
 8015866:	4689      	mov	r9, r1
    if (IS_NUMBER_INVALID(number)) {
 8015868:	ee10 2a10 	vmov	r2, s0
 801586c:	ee10 0a10 	vmov	r0, s0
 8015870:	462b      	mov	r3, r5
 8015872:	4629      	mov	r1, r5
 8015874:	f7eb f982 	bl	8000b7c <__aeabi_dcmpun>
 8015878:	bb50      	cbnz	r0, 80158d0 <json_object_dotset_number+0x74>
 801587a:	f025 4700 	bic.w	r7, r5, #2147483648	; 0x80000000
 801587e:	4b19      	ldr	r3, [pc, #100]	; (80158e4 <json_object_dotset_number+0x88>)
 8015880:	4620      	mov	r0, r4
 8015882:	4639      	mov	r1, r7
 8015884:	f04f 32ff 	mov.w	r2, #4294967295
 8015888:	f7eb f978 	bl	8000b7c <__aeabi_dcmpun>
 801588c:	b938      	cbnz	r0, 801589e <json_object_dotset_number+0x42>
 801588e:	4b15      	ldr	r3, [pc, #84]	; (80158e4 <json_object_dotset_number+0x88>)
 8015890:	4620      	mov	r0, r4
 8015892:	4639      	mov	r1, r7
 8015894:	f04f 32ff 	mov.w	r2, #4294967295
 8015898:	f7eb f952 	bl	8000b40 <__aeabi_dcmple>
 801589c:	b1c0      	cbz	r0, 80158d0 <json_object_dotset_number+0x74>
    new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 801589e:	4b12      	ldr	r3, [pc, #72]	; (80158e8 <json_object_dotset_number+0x8c>)
 80158a0:	2010      	movs	r0, #16
 80158a2:	681b      	ldr	r3, [r3, #0]
 80158a4:	4798      	blx	r3
    if (new_value == NULL) {
 80158a6:	4606      	mov	r6, r0
 80158a8:	b190      	cbz	r0, 80158d0 <json_object_dotset_number+0x74>
    new_value->type = JSONNumber;
 80158aa:	2303      	movs	r3, #3
    new_value->parent = NULL;
 80158ac:	2700      	movs	r7, #0
    new_value->value.number = number;
 80158ae:	e9c0 4502 	strd	r4, r5, [r0, #8]
    JSON_Value *value = json_value_init_number(number);
    if (value == NULL) {
        return JSONFailure;
    }
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 80158b2:	4649      	mov	r1, r9
    new_value->type = JSONNumber;
 80158b4:	e9c6 7300 	strd	r7, r3, [r6]
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 80158b8:	4640      	mov	r0, r8
 80158ba:	4632      	mov	r2, r6
 80158bc:	f7ff feec 	bl	8015698 <json_object_dotset_value>
 80158c0:	1c43      	adds	r3, r0, #1
 80158c2:	4604      	mov	r4, r0
        json_value_free(value);
        return JSONFailure;
    }
    return JSONSuccess;
 80158c4:	bf18      	it	ne
 80158c6:	463c      	movne	r4, r7
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 80158c8:	d007      	beq.n	80158da <json_object_dotset_number+0x7e>
}
 80158ca:	4620      	mov	r0, r4
 80158cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return JSONFailure;
 80158d0:	f04f 34ff 	mov.w	r4, #4294967295
}
 80158d4:	4620      	mov	r0, r4
 80158d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        json_value_free(value);
 80158da:	4630      	mov	r0, r6
 80158dc:	f7ff f916 	bl	8014b0c <json_value_free>
        return JSONFailure;
 80158e0:	e7f3      	b.n	80158ca <json_object_dotset_number+0x6e>
 80158e2:	bf00      	nop
 80158e4:	7fefffff 	.word	0x7fefffff
 80158e8:	20000138 	.word	0x20000138

080158ec <json_object_dotset_boolean>:
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80158ec:	4b13      	ldr	r3, [pc, #76]	; (801593c <json_object_dotset_boolean+0x50>)

JSON_Status json_object_dotset_boolean(JSON_Object *object, const char *name, int boolean) {
 80158ee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80158f2:	681b      	ldr	r3, [r3, #0]
JSON_Status json_object_dotset_boolean(JSON_Object *object, const char *name, int boolean) {
 80158f4:	4680      	mov	r8, r0
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80158f6:	2010      	movs	r0, #16
JSON_Status json_object_dotset_boolean(JSON_Object *object, const char *name, int boolean) {
 80158f8:	460e      	mov	r6, r1
 80158fa:	4615      	mov	r5, r2
    JSON_Value *new_value = (JSON_Value*)parson_malloc(sizeof(JSON_Value));
 80158fc:	4798      	blx	r3
    if (!new_value) {
 80158fe:	b1a8      	cbz	r0, 801592c <json_object_dotset_boolean+0x40>
    new_value->value.boolean = boolean ? 1 : 0;
 8015900:	3d00      	subs	r5, #0
 8015902:	bf18      	it	ne
 8015904:	2501      	movne	r5, #1
 8015906:	4604      	mov	r4, r0
    new_value->type = JSONBoolean;
 8015908:	2306      	movs	r3, #6
    new_value->parent = NULL;
 801590a:	2700      	movs	r7, #0
    new_value->value.boolean = boolean ? 1 : 0;
 801590c:	6085      	str	r5, [r0, #8]
    JSON_Value *value = json_value_init_boolean(boolean);
    if (value == NULL) {
        return JSONFailure;
    }
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 801590e:	4631      	mov	r1, r6
    new_value->type = JSONBoolean;
 8015910:	e9c4 7300 	strd	r7, r3, [r4]
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 8015914:	4640      	mov	r0, r8
 8015916:	4622      	mov	r2, r4
 8015918:	f7ff febe 	bl	8015698 <json_object_dotset_value>
 801591c:	1c43      	adds	r3, r0, #1
 801591e:	4605      	mov	r5, r0
        json_value_free(value);
        return JSONFailure;
    }
    return JSONSuccess;
 8015920:	bf18      	it	ne
 8015922:	463d      	movne	r5, r7
    if (json_object_dotset_value(object, name, value) == JSONFailure) {
 8015924:	d005      	beq.n	8015932 <json_object_dotset_boolean+0x46>
}
 8015926:	4628      	mov	r0, r5
 8015928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return JSONFailure;
 801592c:	f04f 35ff 	mov.w	r5, #4294967295
 8015930:	e7f9      	b.n	8015926 <json_object_dotset_boolean+0x3a>
        json_value_free(value);
 8015932:	4620      	mov	r0, r4
 8015934:	f7ff f8ea 	bl	8014b0c <json_value_free>
        return JSONFailure;
 8015938:	e7f5      	b.n	8015926 <json_object_dotset_boolean+0x3a>
 801593a:	bf00      	nop
 801593c:	20000138 	.word	0x20000138

08015940 <json_set_allocation_functions>:
int json_boolean(const JSON_Value *value) {
    return json_value_get_boolean(value);
}

void json_set_allocation_functions(JSON_Malloc_Function malloc_fun, JSON_Free_Function free_fun) {
    parson_malloc = malloc_fun;
 8015940:	4b01      	ldr	r3, [pc, #4]	; (8015948 <json_set_allocation_functions+0x8>)
    parson_free = free_fun;
 8015942:	e9c3 0100 	strd	r0, r1, [r3]
}
 8015946:	4770      	bx	lr
 8015948:	20000138 	.word	0x20000138

0801594c <Reset_Handler>:
 801594c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8015984 <LoopForever+0x2>
 8015950:	2100      	movs	r1, #0
 8015952:	e003      	b.n	801595c <LoopCopyDataInit>

08015954 <CopyDataInit>:
 8015954:	4b0c      	ldr	r3, [pc, #48]	; (8015988 <LoopForever+0x6>)
 8015956:	585b      	ldr	r3, [r3, r1]
 8015958:	5043      	str	r3, [r0, r1]
 801595a:	3104      	adds	r1, #4

0801595c <LoopCopyDataInit>:
 801595c:	480b      	ldr	r0, [pc, #44]	; (801598c <LoopForever+0xa>)
 801595e:	4b0c      	ldr	r3, [pc, #48]	; (8015990 <LoopForever+0xe>)
 8015960:	1842      	adds	r2, r0, r1
 8015962:	429a      	cmp	r2, r3
 8015964:	d3f6      	bcc.n	8015954 <CopyDataInit>
 8015966:	4a0b      	ldr	r2, [pc, #44]	; (8015994 <LoopForever+0x12>)
 8015968:	e002      	b.n	8015970 <LoopFillZerobss>

0801596a <FillZerobss>:
 801596a:	2300      	movs	r3, #0
 801596c:	f842 3b04 	str.w	r3, [r2], #4

08015970 <LoopFillZerobss>:
 8015970:	4b09      	ldr	r3, [pc, #36]	; (8015998 <LoopForever+0x16>)
 8015972:	429a      	cmp	r2, r3
 8015974:	d3f9      	bcc.n	801596a <FillZerobss>
 8015976:	f7ef f8c9 	bl	8004b0c <SystemInit>
 801597a:	f000 fa2b 	bl	8015dd4 <__libc_init_array>
 801597e:	f7ec fe19 	bl	80025b4 <main>

08015982 <LoopForever>:
 8015982:	e7fe      	b.n	8015982 <LoopForever>
 8015984:	200a0000 	.word	0x200a0000
 8015988:	0801b148 	.word	0x0801b148
 801598c:	20000000 	.word	0x20000000
 8015990:	20000318 	.word	0x20000318
 8015994:	20000318 	.word	0x20000318
 8015998:	2001a17c 	.word	0x2001a17c

0801599c <ADC1_IRQHandler>:
 801599c:	e7fe      	b.n	801599c <ADC1_IRQHandler>
	...

080159a0 <_sbrk>:
	char *prev_heap_end;
#ifdef FreeRTOS
	char *min_stack_ptr;
#endif

	if (heap_end == 0)
 80159a0:	490c      	ldr	r1, [pc, #48]	; (80159d4 <_sbrk+0x34>)
{
 80159a2:	b508      	push	{r3, lr}
	if (heap_end == 0)
 80159a4:	680b      	ldr	r3, [r1, #0]
 80159a6:	b153      	cbz	r3, 80159be <_sbrk+0x1e>

	prev_heap_end = heap_end;

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
 80159a8:	4a0b      	ldr	r2, [pc, #44]	; (80159d8 <_sbrk+0x38>)
 80159aa:	6812      	ldr	r2, [r2, #0]
 80159ac:	6812      	ldr	r2, [r2, #0]
	/* Locate the STACK bottom address */
	min_stack_ptr -= MAX_STACK_SIZE;

	if (heap_end + incr > min_stack_ptr)
 80159ae:	4418      	add	r0, r3
	min_stack_ptr -= MAX_STACK_SIZE;
 80159b0:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
	if (heap_end + incr > min_stack_ptr)
 80159b4:	4290      	cmp	r0, r2
 80159b6:	d805      	bhi.n	80159c4 <_sbrk+0x24>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 80159b8:	6008      	str	r0, [r1, #0]

	return (caddr_t) prev_heap_end;
}
 80159ba:	4618      	mov	r0, r3
 80159bc:	bd08      	pop	{r3, pc}
		heap_end = &end;
 80159be:	4b07      	ldr	r3, [pc, #28]	; (80159dc <_sbrk+0x3c>)
 80159c0:	600b      	str	r3, [r1, #0]
 80159c2:	e7f1      	b.n	80159a8 <_sbrk+0x8>
		errno = ENOMEM;
 80159c4:	f000 f848 	bl	8015a58 <__errno>
 80159c8:	230c      	movs	r3, #12
 80159ca:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 80159cc:	f04f 33ff 	mov.w	r3, #4294967295
}
 80159d0:	4618      	mov	r0, r3
 80159d2:	bd08      	pop	{r3, pc}
 80159d4:	20010da4 	.word	0x20010da4
 80159d8:	e000ed08 	.word	0xe000ed08
 80159dc:	2001a180 	.word	0x2001a180

080159e0 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 80159e0:	2001      	movs	r0, #1
 80159e2:	4770      	bx	lr

080159e4 <_kill>:

int _kill(int pid, int sig)
{
 80159e4:	b508      	push	{r3, lr}
	errno = EINVAL;
 80159e6:	f000 f837 	bl	8015a58 <__errno>
 80159ea:	2316      	movs	r3, #22
 80159ec:	6003      	str	r3, [r0, #0]
	return -1;
}
 80159ee:	f04f 30ff 	mov.w	r0, #4294967295
 80159f2:	bd08      	pop	{r3, pc}

080159f4 <_exit>:

void _exit (int status)
{
 80159f4:	b508      	push	{r3, lr}
	errno = EINVAL;
 80159f6:	f000 f82f 	bl	8015a58 <__errno>
 80159fa:	2316      	movs	r3, #22
 80159fc:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}
 80159fe:	e7fe      	b.n	80159fe <_exit+0xa>

08015a00 <_write>:
}

int _write(int file, char *ptr, int len)
{
 8015a00:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

		for (DataIdx = 0; DataIdx < len; DataIdx++)
 8015a02:	1e16      	subs	r6, r2, #0
 8015a04:	dd07      	ble.n	8015a16 <_write+0x16>
 8015a06:	460c      	mov	r4, r1
 8015a08:	198d      	adds	r5, r1, r6
		{
		   __io_putchar( *ptr++ );
 8015a0a:	f814 0b01 	ldrb.w	r0, [r4], #1
 8015a0e:	f3af 8000 	nop.w
		for (DataIdx = 0; DataIdx < len; DataIdx++)
 8015a12:	42ac      	cmp	r4, r5
 8015a14:	d1f9      	bne.n	8015a0a <_write+0xa>
		}
	return len;
}
 8015a16:	4630      	mov	r0, r6
 8015a18:	bd70      	pop	{r4, r5, r6, pc}
 8015a1a:	bf00      	nop

08015a1c <_close>:

int _close(int file)
{
	return -1;
}
 8015a1c:	f04f 30ff 	mov.w	r0, #4294967295
 8015a20:	4770      	bx	lr
 8015a22:	bf00      	nop

08015a24 <_fstat>:

int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8015a24:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8015a28:	604b      	str	r3, [r1, #4]
	return 0;
}
 8015a2a:	2000      	movs	r0, #0
 8015a2c:	4770      	bx	lr
 8015a2e:	bf00      	nop

08015a30 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8015a30:	2001      	movs	r0, #1
 8015a32:	4770      	bx	lr

08015a34 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8015a34:	2000      	movs	r0, #0
 8015a36:	4770      	bx	lr

08015a38 <_read>:

int _read(int file, char *ptr, int len)
{
 8015a38:	b510      	push	{r4, lr}
 8015a3a:	460c      	mov	r4, r1
	/* scanf calls _read() with len=1024, so eat one character at time */
	*ptr = __io_getchar();
 8015a3c:	f3af 8000 	nop.w
 8015a40:	7020      	strb	r0, [r4, #0]
	return 1;
}
 8015a42:	2001      	movs	r0, #1
 8015a44:	bd10      	pop	{r4, pc}
 8015a46:	bf00      	nop

08015a48 <calloc>:
 8015a48:	4b02      	ldr	r3, [pc, #8]	; (8015a54 <calloc+0xc>)
 8015a4a:	460a      	mov	r2, r1
 8015a4c:	4601      	mov	r1, r0
 8015a4e:	6818      	ldr	r0, [r3, #0]
 8015a50:	f000 baa6 	b.w	8015fa0 <_calloc_r>
 8015a54:	20000140 	.word	0x20000140

08015a58 <__errno>:
 8015a58:	4b01      	ldr	r3, [pc, #4]	; (8015a60 <__errno+0x8>)
 8015a5a:	6818      	ldr	r0, [r3, #0]
 8015a5c:	4770      	bx	lr
 8015a5e:	bf00      	nop
 8015a60:	20000140 	.word	0x20000140

08015a64 <__sflush_r>:
 8015a64:	898a      	ldrh	r2, [r1, #12]
 8015a66:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015a6a:	4605      	mov	r5, r0
 8015a6c:	0710      	lsls	r0, r2, #28
 8015a6e:	460c      	mov	r4, r1
 8015a70:	d458      	bmi.n	8015b24 <__sflush_r+0xc0>
 8015a72:	684b      	ldr	r3, [r1, #4]
 8015a74:	2b00      	cmp	r3, #0
 8015a76:	dc05      	bgt.n	8015a84 <__sflush_r+0x20>
 8015a78:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8015a7a:	2b00      	cmp	r3, #0
 8015a7c:	dc02      	bgt.n	8015a84 <__sflush_r+0x20>
 8015a7e:	2000      	movs	r0, #0
 8015a80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015a84:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8015a86:	2e00      	cmp	r6, #0
 8015a88:	d0f9      	beq.n	8015a7e <__sflush_r+0x1a>
 8015a8a:	2300      	movs	r3, #0
 8015a8c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8015a90:	682f      	ldr	r7, [r5, #0]
 8015a92:	602b      	str	r3, [r5, #0]
 8015a94:	d032      	beq.n	8015afc <__sflush_r+0x98>
 8015a96:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8015a98:	89a3      	ldrh	r3, [r4, #12]
 8015a9a:	075a      	lsls	r2, r3, #29
 8015a9c:	d505      	bpl.n	8015aaa <__sflush_r+0x46>
 8015a9e:	6863      	ldr	r3, [r4, #4]
 8015aa0:	1ac0      	subs	r0, r0, r3
 8015aa2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8015aa4:	b10b      	cbz	r3, 8015aaa <__sflush_r+0x46>
 8015aa6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8015aa8:	1ac0      	subs	r0, r0, r3
 8015aaa:	2300      	movs	r3, #0
 8015aac:	4602      	mov	r2, r0
 8015aae:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8015ab0:	6a21      	ldr	r1, [r4, #32]
 8015ab2:	4628      	mov	r0, r5
 8015ab4:	47b0      	blx	r6
 8015ab6:	1c43      	adds	r3, r0, #1
 8015ab8:	89a3      	ldrh	r3, [r4, #12]
 8015aba:	d106      	bne.n	8015aca <__sflush_r+0x66>
 8015abc:	6829      	ldr	r1, [r5, #0]
 8015abe:	291d      	cmp	r1, #29
 8015ac0:	d82c      	bhi.n	8015b1c <__sflush_r+0xb8>
 8015ac2:	4a2a      	ldr	r2, [pc, #168]	; (8015b6c <__sflush_r+0x108>)
 8015ac4:	40ca      	lsrs	r2, r1
 8015ac6:	07d6      	lsls	r6, r2, #31
 8015ac8:	d528      	bpl.n	8015b1c <__sflush_r+0xb8>
 8015aca:	2200      	movs	r2, #0
 8015acc:	6062      	str	r2, [r4, #4]
 8015ace:	04d9      	lsls	r1, r3, #19
 8015ad0:	6922      	ldr	r2, [r4, #16]
 8015ad2:	6022      	str	r2, [r4, #0]
 8015ad4:	d504      	bpl.n	8015ae0 <__sflush_r+0x7c>
 8015ad6:	1c42      	adds	r2, r0, #1
 8015ad8:	d101      	bne.n	8015ade <__sflush_r+0x7a>
 8015ada:	682b      	ldr	r3, [r5, #0]
 8015adc:	b903      	cbnz	r3, 8015ae0 <__sflush_r+0x7c>
 8015ade:	6560      	str	r0, [r4, #84]	; 0x54
 8015ae0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8015ae2:	602f      	str	r7, [r5, #0]
 8015ae4:	2900      	cmp	r1, #0
 8015ae6:	d0ca      	beq.n	8015a7e <__sflush_r+0x1a>
 8015ae8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8015aec:	4299      	cmp	r1, r3
 8015aee:	d002      	beq.n	8015af6 <__sflush_r+0x92>
 8015af0:	4628      	mov	r0, r5
 8015af2:	f000 fa65 	bl	8015fc0 <_free_r>
 8015af6:	2000      	movs	r0, #0
 8015af8:	6360      	str	r0, [r4, #52]	; 0x34
 8015afa:	e7c1      	b.n	8015a80 <__sflush_r+0x1c>
 8015afc:	6a21      	ldr	r1, [r4, #32]
 8015afe:	2301      	movs	r3, #1
 8015b00:	4628      	mov	r0, r5
 8015b02:	47b0      	blx	r6
 8015b04:	1c41      	adds	r1, r0, #1
 8015b06:	d1c7      	bne.n	8015a98 <__sflush_r+0x34>
 8015b08:	682b      	ldr	r3, [r5, #0]
 8015b0a:	2b00      	cmp	r3, #0
 8015b0c:	d0c4      	beq.n	8015a98 <__sflush_r+0x34>
 8015b0e:	2b1d      	cmp	r3, #29
 8015b10:	d001      	beq.n	8015b16 <__sflush_r+0xb2>
 8015b12:	2b16      	cmp	r3, #22
 8015b14:	d101      	bne.n	8015b1a <__sflush_r+0xb6>
 8015b16:	602f      	str	r7, [r5, #0]
 8015b18:	e7b1      	b.n	8015a7e <__sflush_r+0x1a>
 8015b1a:	89a3      	ldrh	r3, [r4, #12]
 8015b1c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015b20:	81a3      	strh	r3, [r4, #12]
 8015b22:	e7ad      	b.n	8015a80 <__sflush_r+0x1c>
 8015b24:	690f      	ldr	r7, [r1, #16]
 8015b26:	2f00      	cmp	r7, #0
 8015b28:	d0a9      	beq.n	8015a7e <__sflush_r+0x1a>
 8015b2a:	0793      	lsls	r3, r2, #30
 8015b2c:	680e      	ldr	r6, [r1, #0]
 8015b2e:	bf08      	it	eq
 8015b30:	694b      	ldreq	r3, [r1, #20]
 8015b32:	600f      	str	r7, [r1, #0]
 8015b34:	bf18      	it	ne
 8015b36:	2300      	movne	r3, #0
 8015b38:	eba6 0807 	sub.w	r8, r6, r7
 8015b3c:	608b      	str	r3, [r1, #8]
 8015b3e:	f1b8 0f00 	cmp.w	r8, #0
 8015b42:	dd9c      	ble.n	8015a7e <__sflush_r+0x1a>
 8015b44:	6a21      	ldr	r1, [r4, #32]
 8015b46:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8015b48:	4643      	mov	r3, r8
 8015b4a:	463a      	mov	r2, r7
 8015b4c:	4628      	mov	r0, r5
 8015b4e:	47b0      	blx	r6
 8015b50:	2800      	cmp	r0, #0
 8015b52:	dc06      	bgt.n	8015b62 <__sflush_r+0xfe>
 8015b54:	89a3      	ldrh	r3, [r4, #12]
 8015b56:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015b5a:	81a3      	strh	r3, [r4, #12]
 8015b5c:	f04f 30ff 	mov.w	r0, #4294967295
 8015b60:	e78e      	b.n	8015a80 <__sflush_r+0x1c>
 8015b62:	4407      	add	r7, r0
 8015b64:	eba8 0800 	sub.w	r8, r8, r0
 8015b68:	e7e9      	b.n	8015b3e <__sflush_r+0xda>
 8015b6a:	bf00      	nop
 8015b6c:	20400001 	.word	0x20400001

08015b70 <_fflush_r>:
 8015b70:	b538      	push	{r3, r4, r5, lr}
 8015b72:	690b      	ldr	r3, [r1, #16]
 8015b74:	4605      	mov	r5, r0
 8015b76:	460c      	mov	r4, r1
 8015b78:	b913      	cbnz	r3, 8015b80 <_fflush_r+0x10>
 8015b7a:	2500      	movs	r5, #0
 8015b7c:	4628      	mov	r0, r5
 8015b7e:	bd38      	pop	{r3, r4, r5, pc}
 8015b80:	b118      	cbz	r0, 8015b8a <_fflush_r+0x1a>
 8015b82:	6983      	ldr	r3, [r0, #24]
 8015b84:	b90b      	cbnz	r3, 8015b8a <_fflush_r+0x1a>
 8015b86:	f000 f887 	bl	8015c98 <__sinit>
 8015b8a:	4b14      	ldr	r3, [pc, #80]	; (8015bdc <_fflush_r+0x6c>)
 8015b8c:	429c      	cmp	r4, r3
 8015b8e:	d11b      	bne.n	8015bc8 <_fflush_r+0x58>
 8015b90:	686c      	ldr	r4, [r5, #4]
 8015b92:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8015b96:	2b00      	cmp	r3, #0
 8015b98:	d0ef      	beq.n	8015b7a <_fflush_r+0xa>
 8015b9a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8015b9c:	07d0      	lsls	r0, r2, #31
 8015b9e:	d404      	bmi.n	8015baa <_fflush_r+0x3a>
 8015ba0:	0599      	lsls	r1, r3, #22
 8015ba2:	d402      	bmi.n	8015baa <_fflush_r+0x3a>
 8015ba4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8015ba6:	f000 f954 	bl	8015e52 <__retarget_lock_acquire_recursive>
 8015baa:	4628      	mov	r0, r5
 8015bac:	4621      	mov	r1, r4
 8015bae:	f7ff ff59 	bl	8015a64 <__sflush_r>
 8015bb2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8015bb4:	07da      	lsls	r2, r3, #31
 8015bb6:	4605      	mov	r5, r0
 8015bb8:	d4e0      	bmi.n	8015b7c <_fflush_r+0xc>
 8015bba:	89a3      	ldrh	r3, [r4, #12]
 8015bbc:	059b      	lsls	r3, r3, #22
 8015bbe:	d4dd      	bmi.n	8015b7c <_fflush_r+0xc>
 8015bc0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8015bc2:	f000 f947 	bl	8015e54 <__retarget_lock_release_recursive>
 8015bc6:	e7d9      	b.n	8015b7c <_fflush_r+0xc>
 8015bc8:	4b05      	ldr	r3, [pc, #20]	; (8015be0 <_fflush_r+0x70>)
 8015bca:	429c      	cmp	r4, r3
 8015bcc:	d101      	bne.n	8015bd2 <_fflush_r+0x62>
 8015bce:	68ac      	ldr	r4, [r5, #8]
 8015bd0:	e7df      	b.n	8015b92 <_fflush_r+0x22>
 8015bd2:	4b04      	ldr	r3, [pc, #16]	; (8015be4 <_fflush_r+0x74>)
 8015bd4:	429c      	cmp	r4, r3
 8015bd6:	bf08      	it	eq
 8015bd8:	68ec      	ldreq	r4, [r5, #12]
 8015bda:	e7da      	b.n	8015b92 <_fflush_r+0x22>
 8015bdc:	0801ad80 	.word	0x0801ad80
 8015be0:	0801ada0 	.word	0x0801ada0
 8015be4:	0801ad60 	.word	0x0801ad60

08015be8 <std>:
 8015be8:	2300      	movs	r3, #0
 8015bea:	b510      	push	{r4, lr}
 8015bec:	4604      	mov	r4, r0
 8015bee:	e9c0 3300 	strd	r3, r3, [r0]
 8015bf2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8015bf6:	6083      	str	r3, [r0, #8]
 8015bf8:	8181      	strh	r1, [r0, #12]
 8015bfa:	6643      	str	r3, [r0, #100]	; 0x64
 8015bfc:	81c2      	strh	r2, [r0, #14]
 8015bfe:	6183      	str	r3, [r0, #24]
 8015c00:	4619      	mov	r1, r3
 8015c02:	2208      	movs	r2, #8
 8015c04:	305c      	adds	r0, #92	; 0x5c
 8015c06:	f000 f9c3 	bl	8015f90 <memset>
 8015c0a:	4b05      	ldr	r3, [pc, #20]	; (8015c20 <std+0x38>)
 8015c0c:	6263      	str	r3, [r4, #36]	; 0x24
 8015c0e:	4b05      	ldr	r3, [pc, #20]	; (8015c24 <std+0x3c>)
 8015c10:	62a3      	str	r3, [r4, #40]	; 0x28
 8015c12:	4b05      	ldr	r3, [pc, #20]	; (8015c28 <std+0x40>)
 8015c14:	62e3      	str	r3, [r4, #44]	; 0x2c
 8015c16:	4b05      	ldr	r3, [pc, #20]	; (8015c2c <std+0x44>)
 8015c18:	6224      	str	r4, [r4, #32]
 8015c1a:	6323      	str	r3, [r4, #48]	; 0x30
 8015c1c:	bd10      	pop	{r4, pc}
 8015c1e:	bf00      	nop
 8015c20:	08016a49 	.word	0x08016a49
 8015c24:	08016a6b 	.word	0x08016a6b
 8015c28:	08016aa3 	.word	0x08016aa3
 8015c2c:	08016ac7 	.word	0x08016ac7

08015c30 <_cleanup_r>:
 8015c30:	4901      	ldr	r1, [pc, #4]	; (8015c38 <_cleanup_r+0x8>)
 8015c32:	f000 b8af 	b.w	8015d94 <_fwalk_reent>
 8015c36:	bf00      	nop
 8015c38:	08015b71 	.word	0x08015b71

08015c3c <__sfmoreglue>:
 8015c3c:	b570      	push	{r4, r5, r6, lr}
 8015c3e:	1e4a      	subs	r2, r1, #1
 8015c40:	2568      	movs	r5, #104	; 0x68
 8015c42:	4355      	muls	r5, r2
 8015c44:	460e      	mov	r6, r1
 8015c46:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8015c4a:	f000 fa09 	bl	8016060 <_malloc_r>
 8015c4e:	4604      	mov	r4, r0
 8015c50:	b140      	cbz	r0, 8015c64 <__sfmoreglue+0x28>
 8015c52:	2100      	movs	r1, #0
 8015c54:	e9c0 1600 	strd	r1, r6, [r0]
 8015c58:	300c      	adds	r0, #12
 8015c5a:	60a0      	str	r0, [r4, #8]
 8015c5c:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8015c60:	f000 f996 	bl	8015f90 <memset>
 8015c64:	4620      	mov	r0, r4
 8015c66:	bd70      	pop	{r4, r5, r6, pc}

08015c68 <__sfp_lock_acquire>:
 8015c68:	4801      	ldr	r0, [pc, #4]	; (8015c70 <__sfp_lock_acquire+0x8>)
 8015c6a:	f000 b8f2 	b.w	8015e52 <__retarget_lock_acquire_recursive>
 8015c6e:	bf00      	nop
 8015c70:	2001a174 	.word	0x2001a174

08015c74 <__sfp_lock_release>:
 8015c74:	4801      	ldr	r0, [pc, #4]	; (8015c7c <__sfp_lock_release+0x8>)
 8015c76:	f000 b8ed 	b.w	8015e54 <__retarget_lock_release_recursive>
 8015c7a:	bf00      	nop
 8015c7c:	2001a174 	.word	0x2001a174

08015c80 <__sinit_lock_acquire>:
 8015c80:	4801      	ldr	r0, [pc, #4]	; (8015c88 <__sinit_lock_acquire+0x8>)
 8015c82:	f000 b8e6 	b.w	8015e52 <__retarget_lock_acquire_recursive>
 8015c86:	bf00      	nop
 8015c88:	2001a16f 	.word	0x2001a16f

08015c8c <__sinit_lock_release>:
 8015c8c:	4801      	ldr	r0, [pc, #4]	; (8015c94 <__sinit_lock_release+0x8>)
 8015c8e:	f000 b8e1 	b.w	8015e54 <__retarget_lock_release_recursive>
 8015c92:	bf00      	nop
 8015c94:	2001a16f 	.word	0x2001a16f

08015c98 <__sinit>:
 8015c98:	b510      	push	{r4, lr}
 8015c9a:	4604      	mov	r4, r0
 8015c9c:	f7ff fff0 	bl	8015c80 <__sinit_lock_acquire>
 8015ca0:	69a3      	ldr	r3, [r4, #24]
 8015ca2:	b11b      	cbz	r3, 8015cac <__sinit+0x14>
 8015ca4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8015ca8:	f7ff bff0 	b.w	8015c8c <__sinit_lock_release>
 8015cac:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8015cb0:	6523      	str	r3, [r4, #80]	; 0x50
 8015cb2:	4b13      	ldr	r3, [pc, #76]	; (8015d00 <__sinit+0x68>)
 8015cb4:	4a13      	ldr	r2, [pc, #76]	; (8015d04 <__sinit+0x6c>)
 8015cb6:	681b      	ldr	r3, [r3, #0]
 8015cb8:	62a2      	str	r2, [r4, #40]	; 0x28
 8015cba:	42a3      	cmp	r3, r4
 8015cbc:	bf04      	itt	eq
 8015cbe:	2301      	moveq	r3, #1
 8015cc0:	61a3      	streq	r3, [r4, #24]
 8015cc2:	4620      	mov	r0, r4
 8015cc4:	f000 f820 	bl	8015d08 <__sfp>
 8015cc8:	6060      	str	r0, [r4, #4]
 8015cca:	4620      	mov	r0, r4
 8015ccc:	f000 f81c 	bl	8015d08 <__sfp>
 8015cd0:	60a0      	str	r0, [r4, #8]
 8015cd2:	4620      	mov	r0, r4
 8015cd4:	f000 f818 	bl	8015d08 <__sfp>
 8015cd8:	2200      	movs	r2, #0
 8015cda:	60e0      	str	r0, [r4, #12]
 8015cdc:	2104      	movs	r1, #4
 8015cde:	6860      	ldr	r0, [r4, #4]
 8015ce0:	f7ff ff82 	bl	8015be8 <std>
 8015ce4:	68a0      	ldr	r0, [r4, #8]
 8015ce6:	2201      	movs	r2, #1
 8015ce8:	2109      	movs	r1, #9
 8015cea:	f7ff ff7d 	bl	8015be8 <std>
 8015cee:	68e0      	ldr	r0, [r4, #12]
 8015cf0:	2202      	movs	r2, #2
 8015cf2:	2112      	movs	r1, #18
 8015cf4:	f7ff ff78 	bl	8015be8 <std>
 8015cf8:	2301      	movs	r3, #1
 8015cfa:	61a3      	str	r3, [r4, #24]
 8015cfc:	e7d2      	b.n	8015ca4 <__sinit+0xc>
 8015cfe:	bf00      	nop
 8015d00:	0801adc0 	.word	0x0801adc0
 8015d04:	08015c31 	.word	0x08015c31

08015d08 <__sfp>:
 8015d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015d0a:	4607      	mov	r7, r0
 8015d0c:	f7ff ffac 	bl	8015c68 <__sfp_lock_acquire>
 8015d10:	4b1e      	ldr	r3, [pc, #120]	; (8015d8c <__sfp+0x84>)
 8015d12:	681e      	ldr	r6, [r3, #0]
 8015d14:	69b3      	ldr	r3, [r6, #24]
 8015d16:	b913      	cbnz	r3, 8015d1e <__sfp+0x16>
 8015d18:	4630      	mov	r0, r6
 8015d1a:	f7ff ffbd 	bl	8015c98 <__sinit>
 8015d1e:	3648      	adds	r6, #72	; 0x48
 8015d20:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8015d24:	3b01      	subs	r3, #1
 8015d26:	d503      	bpl.n	8015d30 <__sfp+0x28>
 8015d28:	6833      	ldr	r3, [r6, #0]
 8015d2a:	b30b      	cbz	r3, 8015d70 <__sfp+0x68>
 8015d2c:	6836      	ldr	r6, [r6, #0]
 8015d2e:	e7f7      	b.n	8015d20 <__sfp+0x18>
 8015d30:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8015d34:	b9d5      	cbnz	r5, 8015d6c <__sfp+0x64>
 8015d36:	4b16      	ldr	r3, [pc, #88]	; (8015d90 <__sfp+0x88>)
 8015d38:	60e3      	str	r3, [r4, #12]
 8015d3a:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8015d3e:	6665      	str	r5, [r4, #100]	; 0x64
 8015d40:	f000 f886 	bl	8015e50 <__retarget_lock_init_recursive>
 8015d44:	f7ff ff96 	bl	8015c74 <__sfp_lock_release>
 8015d48:	e9c4 5501 	strd	r5, r5, [r4, #4]
 8015d4c:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8015d50:	6025      	str	r5, [r4, #0]
 8015d52:	61a5      	str	r5, [r4, #24]
 8015d54:	2208      	movs	r2, #8
 8015d56:	4629      	mov	r1, r5
 8015d58:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8015d5c:	f000 f918 	bl	8015f90 <memset>
 8015d60:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8015d64:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8015d68:	4620      	mov	r0, r4
 8015d6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015d6c:	3468      	adds	r4, #104	; 0x68
 8015d6e:	e7d9      	b.n	8015d24 <__sfp+0x1c>
 8015d70:	2104      	movs	r1, #4
 8015d72:	4638      	mov	r0, r7
 8015d74:	f7ff ff62 	bl	8015c3c <__sfmoreglue>
 8015d78:	4604      	mov	r4, r0
 8015d7a:	6030      	str	r0, [r6, #0]
 8015d7c:	2800      	cmp	r0, #0
 8015d7e:	d1d5      	bne.n	8015d2c <__sfp+0x24>
 8015d80:	f7ff ff78 	bl	8015c74 <__sfp_lock_release>
 8015d84:	230c      	movs	r3, #12
 8015d86:	603b      	str	r3, [r7, #0]
 8015d88:	e7ee      	b.n	8015d68 <__sfp+0x60>
 8015d8a:	bf00      	nop
 8015d8c:	0801adc0 	.word	0x0801adc0
 8015d90:	ffff0001 	.word	0xffff0001

08015d94 <_fwalk_reent>:
 8015d94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015d98:	4606      	mov	r6, r0
 8015d9a:	4688      	mov	r8, r1
 8015d9c:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8015da0:	2700      	movs	r7, #0
 8015da2:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8015da6:	f1b9 0901 	subs.w	r9, r9, #1
 8015daa:	d505      	bpl.n	8015db8 <_fwalk_reent+0x24>
 8015dac:	6824      	ldr	r4, [r4, #0]
 8015dae:	2c00      	cmp	r4, #0
 8015db0:	d1f7      	bne.n	8015da2 <_fwalk_reent+0xe>
 8015db2:	4638      	mov	r0, r7
 8015db4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8015db8:	89ab      	ldrh	r3, [r5, #12]
 8015dba:	2b01      	cmp	r3, #1
 8015dbc:	d907      	bls.n	8015dce <_fwalk_reent+0x3a>
 8015dbe:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8015dc2:	3301      	adds	r3, #1
 8015dc4:	d003      	beq.n	8015dce <_fwalk_reent+0x3a>
 8015dc6:	4629      	mov	r1, r5
 8015dc8:	4630      	mov	r0, r6
 8015dca:	47c0      	blx	r8
 8015dcc:	4307      	orrs	r7, r0
 8015dce:	3568      	adds	r5, #104	; 0x68
 8015dd0:	e7e9      	b.n	8015da6 <_fwalk_reent+0x12>
	...

08015dd4 <__libc_init_array>:
 8015dd4:	b570      	push	{r4, r5, r6, lr}
 8015dd6:	4d0d      	ldr	r5, [pc, #52]	; (8015e0c <__libc_init_array+0x38>)
 8015dd8:	4c0d      	ldr	r4, [pc, #52]	; (8015e10 <__libc_init_array+0x3c>)
 8015dda:	1b64      	subs	r4, r4, r5
 8015ddc:	10a4      	asrs	r4, r4, #2
 8015dde:	2600      	movs	r6, #0
 8015de0:	42a6      	cmp	r6, r4
 8015de2:	d109      	bne.n	8015df8 <__libc_init_array+0x24>
 8015de4:	4d0b      	ldr	r5, [pc, #44]	; (8015e14 <__libc_init_array+0x40>)
 8015de6:	4c0c      	ldr	r4, [pc, #48]	; (8015e18 <__libc_init_array+0x44>)
 8015de8:	f004 f924 	bl	801a034 <_init>
 8015dec:	1b64      	subs	r4, r4, r5
 8015dee:	10a4      	asrs	r4, r4, #2
 8015df0:	2600      	movs	r6, #0
 8015df2:	42a6      	cmp	r6, r4
 8015df4:	d105      	bne.n	8015e02 <__libc_init_array+0x2e>
 8015df6:	bd70      	pop	{r4, r5, r6, pc}
 8015df8:	f855 3b04 	ldr.w	r3, [r5], #4
 8015dfc:	4798      	blx	r3
 8015dfe:	3601      	adds	r6, #1
 8015e00:	e7ee      	b.n	8015de0 <__libc_init_array+0xc>
 8015e02:	f855 3b04 	ldr.w	r3, [r5], #4
 8015e06:	4798      	blx	r3
 8015e08:	3601      	adds	r6, #1
 8015e0a:	e7f2      	b.n	8015df2 <__libc_init_array+0x1e>
 8015e0c:	0801b138 	.word	0x0801b138
 8015e10:	0801b138 	.word	0x0801b138
 8015e14:	0801b138 	.word	0x0801b138
 8015e18:	0801b13c 	.word	0x0801b13c

08015e1c <__itoa>:
 8015e1c:	1e93      	subs	r3, r2, #2
 8015e1e:	2b22      	cmp	r3, #34	; 0x22
 8015e20:	b510      	push	{r4, lr}
 8015e22:	460c      	mov	r4, r1
 8015e24:	d904      	bls.n	8015e30 <__itoa+0x14>
 8015e26:	2300      	movs	r3, #0
 8015e28:	700b      	strb	r3, [r1, #0]
 8015e2a:	461c      	mov	r4, r3
 8015e2c:	4620      	mov	r0, r4
 8015e2e:	bd10      	pop	{r4, pc}
 8015e30:	2a0a      	cmp	r2, #10
 8015e32:	d109      	bne.n	8015e48 <__itoa+0x2c>
 8015e34:	2800      	cmp	r0, #0
 8015e36:	da07      	bge.n	8015e48 <__itoa+0x2c>
 8015e38:	232d      	movs	r3, #45	; 0x2d
 8015e3a:	700b      	strb	r3, [r1, #0]
 8015e3c:	4240      	negs	r0, r0
 8015e3e:	2101      	movs	r1, #1
 8015e40:	4421      	add	r1, r4
 8015e42:	f001 fd51 	bl	80178e8 <__utoa>
 8015e46:	e7f1      	b.n	8015e2c <__itoa+0x10>
 8015e48:	2100      	movs	r1, #0
 8015e4a:	e7f9      	b.n	8015e40 <__itoa+0x24>

08015e4c <itoa>:
 8015e4c:	f7ff bfe6 	b.w	8015e1c <__itoa>

08015e50 <__retarget_lock_init_recursive>:
 8015e50:	4770      	bx	lr

08015e52 <__retarget_lock_acquire_recursive>:
 8015e52:	4770      	bx	lr

08015e54 <__retarget_lock_release_recursive>:
 8015e54:	4770      	bx	lr

08015e56 <__swhatbuf_r>:
 8015e56:	b570      	push	{r4, r5, r6, lr}
 8015e58:	460e      	mov	r6, r1
 8015e5a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015e5e:	2900      	cmp	r1, #0
 8015e60:	b096      	sub	sp, #88	; 0x58
 8015e62:	4614      	mov	r4, r2
 8015e64:	461d      	mov	r5, r3
 8015e66:	da07      	bge.n	8015e78 <__swhatbuf_r+0x22>
 8015e68:	2300      	movs	r3, #0
 8015e6a:	602b      	str	r3, [r5, #0]
 8015e6c:	89b3      	ldrh	r3, [r6, #12]
 8015e6e:	061a      	lsls	r2, r3, #24
 8015e70:	d410      	bmi.n	8015e94 <__swhatbuf_r+0x3e>
 8015e72:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015e76:	e00e      	b.n	8015e96 <__swhatbuf_r+0x40>
 8015e78:	466a      	mov	r2, sp
 8015e7a:	f002 fcd1 	bl	8018820 <_fstat_r>
 8015e7e:	2800      	cmp	r0, #0
 8015e80:	dbf2      	blt.n	8015e68 <__swhatbuf_r+0x12>
 8015e82:	9a01      	ldr	r2, [sp, #4]
 8015e84:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8015e88:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8015e8c:	425a      	negs	r2, r3
 8015e8e:	415a      	adcs	r2, r3
 8015e90:	602a      	str	r2, [r5, #0]
 8015e92:	e7ee      	b.n	8015e72 <__swhatbuf_r+0x1c>
 8015e94:	2340      	movs	r3, #64	; 0x40
 8015e96:	2000      	movs	r0, #0
 8015e98:	6023      	str	r3, [r4, #0]
 8015e9a:	b016      	add	sp, #88	; 0x58
 8015e9c:	bd70      	pop	{r4, r5, r6, pc}
	...

08015ea0 <__smakebuf_r>:
 8015ea0:	898b      	ldrh	r3, [r1, #12]
 8015ea2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8015ea4:	079d      	lsls	r5, r3, #30
 8015ea6:	4606      	mov	r6, r0
 8015ea8:	460c      	mov	r4, r1
 8015eaa:	d507      	bpl.n	8015ebc <__smakebuf_r+0x1c>
 8015eac:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8015eb0:	6023      	str	r3, [r4, #0]
 8015eb2:	6123      	str	r3, [r4, #16]
 8015eb4:	2301      	movs	r3, #1
 8015eb6:	6163      	str	r3, [r4, #20]
 8015eb8:	b002      	add	sp, #8
 8015eba:	bd70      	pop	{r4, r5, r6, pc}
 8015ebc:	ab01      	add	r3, sp, #4
 8015ebe:	466a      	mov	r2, sp
 8015ec0:	f7ff ffc9 	bl	8015e56 <__swhatbuf_r>
 8015ec4:	9900      	ldr	r1, [sp, #0]
 8015ec6:	4605      	mov	r5, r0
 8015ec8:	4630      	mov	r0, r6
 8015eca:	f000 f8c9 	bl	8016060 <_malloc_r>
 8015ece:	b948      	cbnz	r0, 8015ee4 <__smakebuf_r+0x44>
 8015ed0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8015ed4:	059a      	lsls	r2, r3, #22
 8015ed6:	d4ef      	bmi.n	8015eb8 <__smakebuf_r+0x18>
 8015ed8:	f023 0303 	bic.w	r3, r3, #3
 8015edc:	f043 0302 	orr.w	r3, r3, #2
 8015ee0:	81a3      	strh	r3, [r4, #12]
 8015ee2:	e7e3      	b.n	8015eac <__smakebuf_r+0xc>
 8015ee4:	4b0d      	ldr	r3, [pc, #52]	; (8015f1c <__smakebuf_r+0x7c>)
 8015ee6:	62b3      	str	r3, [r6, #40]	; 0x28
 8015ee8:	89a3      	ldrh	r3, [r4, #12]
 8015eea:	6020      	str	r0, [r4, #0]
 8015eec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8015ef0:	81a3      	strh	r3, [r4, #12]
 8015ef2:	9b00      	ldr	r3, [sp, #0]
 8015ef4:	6163      	str	r3, [r4, #20]
 8015ef6:	9b01      	ldr	r3, [sp, #4]
 8015ef8:	6120      	str	r0, [r4, #16]
 8015efa:	b15b      	cbz	r3, 8015f14 <__smakebuf_r+0x74>
 8015efc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8015f00:	4630      	mov	r0, r6
 8015f02:	f003 f80f 	bl	8018f24 <_isatty_r>
 8015f06:	b128      	cbz	r0, 8015f14 <__smakebuf_r+0x74>
 8015f08:	89a3      	ldrh	r3, [r4, #12]
 8015f0a:	f023 0303 	bic.w	r3, r3, #3
 8015f0e:	f043 0301 	orr.w	r3, r3, #1
 8015f12:	81a3      	strh	r3, [r4, #12]
 8015f14:	89a0      	ldrh	r0, [r4, #12]
 8015f16:	4305      	orrs	r5, r0
 8015f18:	81a5      	strh	r5, [r4, #12]
 8015f1a:	e7cd      	b.n	8015eb8 <__smakebuf_r+0x18>
 8015f1c:	08015c31 	.word	0x08015c31

08015f20 <malloc>:
 8015f20:	4b02      	ldr	r3, [pc, #8]	; (8015f2c <malloc+0xc>)
 8015f22:	4601      	mov	r1, r0
 8015f24:	6818      	ldr	r0, [r3, #0]
 8015f26:	f000 b89b 	b.w	8016060 <_malloc_r>
 8015f2a:	bf00      	nop
 8015f2c:	20000140 	.word	0x20000140

08015f30 <free>:
 8015f30:	4b02      	ldr	r3, [pc, #8]	; (8015f3c <free+0xc>)
 8015f32:	4601      	mov	r1, r0
 8015f34:	6818      	ldr	r0, [r3, #0]
 8015f36:	f000 b843 	b.w	8015fc0 <_free_r>
 8015f3a:	bf00      	nop
 8015f3c:	20000140 	.word	0x20000140

08015f40 <memcpy>:
 8015f40:	440a      	add	r2, r1
 8015f42:	4291      	cmp	r1, r2
 8015f44:	f100 33ff 	add.w	r3, r0, #4294967295
 8015f48:	d100      	bne.n	8015f4c <memcpy+0xc>
 8015f4a:	4770      	bx	lr
 8015f4c:	b510      	push	{r4, lr}
 8015f4e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8015f52:	f803 4f01 	strb.w	r4, [r3, #1]!
 8015f56:	4291      	cmp	r1, r2
 8015f58:	d1f9      	bne.n	8015f4e <memcpy+0xe>
 8015f5a:	bd10      	pop	{r4, pc}

08015f5c <memmove>:
 8015f5c:	4288      	cmp	r0, r1
 8015f5e:	b510      	push	{r4, lr}
 8015f60:	eb01 0402 	add.w	r4, r1, r2
 8015f64:	d902      	bls.n	8015f6c <memmove+0x10>
 8015f66:	4284      	cmp	r4, r0
 8015f68:	4623      	mov	r3, r4
 8015f6a:	d807      	bhi.n	8015f7c <memmove+0x20>
 8015f6c:	1e43      	subs	r3, r0, #1
 8015f6e:	42a1      	cmp	r1, r4
 8015f70:	d008      	beq.n	8015f84 <memmove+0x28>
 8015f72:	f811 2b01 	ldrb.w	r2, [r1], #1
 8015f76:	f803 2f01 	strb.w	r2, [r3, #1]!
 8015f7a:	e7f8      	b.n	8015f6e <memmove+0x12>
 8015f7c:	4402      	add	r2, r0
 8015f7e:	4601      	mov	r1, r0
 8015f80:	428a      	cmp	r2, r1
 8015f82:	d100      	bne.n	8015f86 <memmove+0x2a>
 8015f84:	bd10      	pop	{r4, pc}
 8015f86:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8015f8a:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8015f8e:	e7f7      	b.n	8015f80 <memmove+0x24>

08015f90 <memset>:
 8015f90:	4402      	add	r2, r0
 8015f92:	4603      	mov	r3, r0
 8015f94:	4293      	cmp	r3, r2
 8015f96:	d100      	bne.n	8015f9a <memset+0xa>
 8015f98:	4770      	bx	lr
 8015f9a:	f803 1b01 	strb.w	r1, [r3], #1
 8015f9e:	e7f9      	b.n	8015f94 <memset+0x4>

08015fa0 <_calloc_r>:
 8015fa0:	b513      	push	{r0, r1, r4, lr}
 8015fa2:	434a      	muls	r2, r1
 8015fa4:	4611      	mov	r1, r2
 8015fa6:	9201      	str	r2, [sp, #4]
 8015fa8:	f000 f85a 	bl	8016060 <_malloc_r>
 8015fac:	4604      	mov	r4, r0
 8015fae:	b118      	cbz	r0, 8015fb8 <_calloc_r+0x18>
 8015fb0:	9a01      	ldr	r2, [sp, #4]
 8015fb2:	2100      	movs	r1, #0
 8015fb4:	f7ff ffec 	bl	8015f90 <memset>
 8015fb8:	4620      	mov	r0, r4
 8015fba:	b002      	add	sp, #8
 8015fbc:	bd10      	pop	{r4, pc}
	...

08015fc0 <_free_r>:
 8015fc0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8015fc2:	2900      	cmp	r1, #0
 8015fc4:	d048      	beq.n	8016058 <_free_r+0x98>
 8015fc6:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8015fca:	9001      	str	r0, [sp, #4]
 8015fcc:	2b00      	cmp	r3, #0
 8015fce:	f1a1 0404 	sub.w	r4, r1, #4
 8015fd2:	bfb8      	it	lt
 8015fd4:	18e4      	addlt	r4, r4, r3
 8015fd6:	f002 ffdd 	bl	8018f94 <__malloc_lock>
 8015fda:	4a20      	ldr	r2, [pc, #128]	; (801605c <_free_r+0x9c>)
 8015fdc:	9801      	ldr	r0, [sp, #4]
 8015fde:	6813      	ldr	r3, [r2, #0]
 8015fe0:	4615      	mov	r5, r2
 8015fe2:	b933      	cbnz	r3, 8015ff2 <_free_r+0x32>
 8015fe4:	6063      	str	r3, [r4, #4]
 8015fe6:	6014      	str	r4, [r2, #0]
 8015fe8:	b003      	add	sp, #12
 8015fea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8015fee:	f002 bfd7 	b.w	8018fa0 <__malloc_unlock>
 8015ff2:	42a3      	cmp	r3, r4
 8015ff4:	d90b      	bls.n	801600e <_free_r+0x4e>
 8015ff6:	6821      	ldr	r1, [r4, #0]
 8015ff8:	1862      	adds	r2, r4, r1
 8015ffa:	4293      	cmp	r3, r2
 8015ffc:	bf04      	itt	eq
 8015ffe:	681a      	ldreq	r2, [r3, #0]
 8016000:	685b      	ldreq	r3, [r3, #4]
 8016002:	6063      	str	r3, [r4, #4]
 8016004:	bf04      	itt	eq
 8016006:	1852      	addeq	r2, r2, r1
 8016008:	6022      	streq	r2, [r4, #0]
 801600a:	602c      	str	r4, [r5, #0]
 801600c:	e7ec      	b.n	8015fe8 <_free_r+0x28>
 801600e:	461a      	mov	r2, r3
 8016010:	685b      	ldr	r3, [r3, #4]
 8016012:	b10b      	cbz	r3, 8016018 <_free_r+0x58>
 8016014:	42a3      	cmp	r3, r4
 8016016:	d9fa      	bls.n	801600e <_free_r+0x4e>
 8016018:	6811      	ldr	r1, [r2, #0]
 801601a:	1855      	adds	r5, r2, r1
 801601c:	42a5      	cmp	r5, r4
 801601e:	d10b      	bne.n	8016038 <_free_r+0x78>
 8016020:	6824      	ldr	r4, [r4, #0]
 8016022:	4421      	add	r1, r4
 8016024:	1854      	adds	r4, r2, r1
 8016026:	42a3      	cmp	r3, r4
 8016028:	6011      	str	r1, [r2, #0]
 801602a:	d1dd      	bne.n	8015fe8 <_free_r+0x28>
 801602c:	681c      	ldr	r4, [r3, #0]
 801602e:	685b      	ldr	r3, [r3, #4]
 8016030:	6053      	str	r3, [r2, #4]
 8016032:	4421      	add	r1, r4
 8016034:	6011      	str	r1, [r2, #0]
 8016036:	e7d7      	b.n	8015fe8 <_free_r+0x28>
 8016038:	d902      	bls.n	8016040 <_free_r+0x80>
 801603a:	230c      	movs	r3, #12
 801603c:	6003      	str	r3, [r0, #0]
 801603e:	e7d3      	b.n	8015fe8 <_free_r+0x28>
 8016040:	6825      	ldr	r5, [r4, #0]
 8016042:	1961      	adds	r1, r4, r5
 8016044:	428b      	cmp	r3, r1
 8016046:	bf04      	itt	eq
 8016048:	6819      	ldreq	r1, [r3, #0]
 801604a:	685b      	ldreq	r3, [r3, #4]
 801604c:	6063      	str	r3, [r4, #4]
 801604e:	bf04      	itt	eq
 8016050:	1949      	addeq	r1, r1, r5
 8016052:	6021      	streq	r1, [r4, #0]
 8016054:	6054      	str	r4, [r2, #4]
 8016056:	e7c7      	b.n	8015fe8 <_free_r+0x28>
 8016058:	b003      	add	sp, #12
 801605a:	bd30      	pop	{r4, r5, pc}
 801605c:	20010da8 	.word	0x20010da8

08016060 <_malloc_r>:
 8016060:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8016062:	1ccd      	adds	r5, r1, #3
 8016064:	f025 0503 	bic.w	r5, r5, #3
 8016068:	3508      	adds	r5, #8
 801606a:	2d0c      	cmp	r5, #12
 801606c:	bf38      	it	cc
 801606e:	250c      	movcc	r5, #12
 8016070:	2d00      	cmp	r5, #0
 8016072:	4606      	mov	r6, r0
 8016074:	db01      	blt.n	801607a <_malloc_r+0x1a>
 8016076:	42a9      	cmp	r1, r5
 8016078:	d903      	bls.n	8016082 <_malloc_r+0x22>
 801607a:	230c      	movs	r3, #12
 801607c:	6033      	str	r3, [r6, #0]
 801607e:	2000      	movs	r0, #0
 8016080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8016082:	f002 ff87 	bl	8018f94 <__malloc_lock>
 8016086:	4921      	ldr	r1, [pc, #132]	; (801610c <_malloc_r+0xac>)
 8016088:	680a      	ldr	r2, [r1, #0]
 801608a:	4614      	mov	r4, r2
 801608c:	b99c      	cbnz	r4, 80160b6 <_malloc_r+0x56>
 801608e:	4f20      	ldr	r7, [pc, #128]	; (8016110 <_malloc_r+0xb0>)
 8016090:	683b      	ldr	r3, [r7, #0]
 8016092:	b923      	cbnz	r3, 801609e <_malloc_r+0x3e>
 8016094:	4621      	mov	r1, r4
 8016096:	4630      	mov	r0, r6
 8016098:	f000 fca6 	bl	80169e8 <_sbrk_r>
 801609c:	6038      	str	r0, [r7, #0]
 801609e:	4629      	mov	r1, r5
 80160a0:	4630      	mov	r0, r6
 80160a2:	f000 fca1 	bl	80169e8 <_sbrk_r>
 80160a6:	1c43      	adds	r3, r0, #1
 80160a8:	d123      	bne.n	80160f2 <_malloc_r+0x92>
 80160aa:	230c      	movs	r3, #12
 80160ac:	6033      	str	r3, [r6, #0]
 80160ae:	4630      	mov	r0, r6
 80160b0:	f002 ff76 	bl	8018fa0 <__malloc_unlock>
 80160b4:	e7e3      	b.n	801607e <_malloc_r+0x1e>
 80160b6:	6823      	ldr	r3, [r4, #0]
 80160b8:	1b5b      	subs	r3, r3, r5
 80160ba:	d417      	bmi.n	80160ec <_malloc_r+0x8c>
 80160bc:	2b0b      	cmp	r3, #11
 80160be:	d903      	bls.n	80160c8 <_malloc_r+0x68>
 80160c0:	6023      	str	r3, [r4, #0]
 80160c2:	441c      	add	r4, r3
 80160c4:	6025      	str	r5, [r4, #0]
 80160c6:	e004      	b.n	80160d2 <_malloc_r+0x72>
 80160c8:	6863      	ldr	r3, [r4, #4]
 80160ca:	42a2      	cmp	r2, r4
 80160cc:	bf0c      	ite	eq
 80160ce:	600b      	streq	r3, [r1, #0]
 80160d0:	6053      	strne	r3, [r2, #4]
 80160d2:	4630      	mov	r0, r6
 80160d4:	f002 ff64 	bl	8018fa0 <__malloc_unlock>
 80160d8:	f104 000b 	add.w	r0, r4, #11
 80160dc:	1d23      	adds	r3, r4, #4
 80160de:	f020 0007 	bic.w	r0, r0, #7
 80160e2:	1ac2      	subs	r2, r0, r3
 80160e4:	d0cc      	beq.n	8016080 <_malloc_r+0x20>
 80160e6:	1a1b      	subs	r3, r3, r0
 80160e8:	50a3      	str	r3, [r4, r2]
 80160ea:	e7c9      	b.n	8016080 <_malloc_r+0x20>
 80160ec:	4622      	mov	r2, r4
 80160ee:	6864      	ldr	r4, [r4, #4]
 80160f0:	e7cc      	b.n	801608c <_malloc_r+0x2c>
 80160f2:	1cc4      	adds	r4, r0, #3
 80160f4:	f024 0403 	bic.w	r4, r4, #3
 80160f8:	42a0      	cmp	r0, r4
 80160fa:	d0e3      	beq.n	80160c4 <_malloc_r+0x64>
 80160fc:	1a21      	subs	r1, r4, r0
 80160fe:	4630      	mov	r0, r6
 8016100:	f000 fc72 	bl	80169e8 <_sbrk_r>
 8016104:	3001      	adds	r0, #1
 8016106:	d1dd      	bne.n	80160c4 <_malloc_r+0x64>
 8016108:	e7cf      	b.n	80160aa <_malloc_r+0x4a>
 801610a:	bf00      	nop
 801610c:	20010da8 	.word	0x20010da8
 8016110:	20010dac 	.word	0x20010dac

08016114 <__cvt>:
 8016114:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8016118:	ec55 4b10 	vmov	r4, r5, d0
 801611c:	2d00      	cmp	r5, #0
 801611e:	460e      	mov	r6, r1
 8016120:	4619      	mov	r1, r3
 8016122:	462b      	mov	r3, r5
 8016124:	bfbb      	ittet	lt
 8016126:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 801612a:	461d      	movlt	r5, r3
 801612c:	2300      	movge	r3, #0
 801612e:	232d      	movlt	r3, #45	; 0x2d
 8016130:	700b      	strb	r3, [r1, #0]
 8016132:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8016134:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 8016138:	4691      	mov	r9, r2
 801613a:	f023 0820 	bic.w	r8, r3, #32
 801613e:	bfbc      	itt	lt
 8016140:	4622      	movlt	r2, r4
 8016142:	4614      	movlt	r4, r2
 8016144:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 8016148:	d005      	beq.n	8016156 <__cvt+0x42>
 801614a:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
 801614e:	d100      	bne.n	8016152 <__cvt+0x3e>
 8016150:	3601      	adds	r6, #1
 8016152:	2102      	movs	r1, #2
 8016154:	e000      	b.n	8016158 <__cvt+0x44>
 8016156:	2103      	movs	r1, #3
 8016158:	ab03      	add	r3, sp, #12
 801615a:	9301      	str	r3, [sp, #4]
 801615c:	ab02      	add	r3, sp, #8
 801615e:	9300      	str	r3, [sp, #0]
 8016160:	ec45 4b10 	vmov	d0, r4, r5
 8016164:	4653      	mov	r3, sl
 8016166:	4632      	mov	r2, r6
 8016168:	f001 fd6e 	bl	8017c48 <_dtoa_r>
 801616c:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 8016170:	4607      	mov	r7, r0
 8016172:	d102      	bne.n	801617a <__cvt+0x66>
 8016174:	f019 0f01 	tst.w	r9, #1
 8016178:	d022      	beq.n	80161c0 <__cvt+0xac>
 801617a:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 801617e:	eb07 0906 	add.w	r9, r7, r6
 8016182:	d110      	bne.n	80161a6 <__cvt+0x92>
 8016184:	783b      	ldrb	r3, [r7, #0]
 8016186:	2b30      	cmp	r3, #48	; 0x30
 8016188:	d10a      	bne.n	80161a0 <__cvt+0x8c>
 801618a:	2200      	movs	r2, #0
 801618c:	2300      	movs	r3, #0
 801618e:	4620      	mov	r0, r4
 8016190:	4629      	mov	r1, r5
 8016192:	f7ea fcc1 	bl	8000b18 <__aeabi_dcmpeq>
 8016196:	b918      	cbnz	r0, 80161a0 <__cvt+0x8c>
 8016198:	f1c6 0601 	rsb	r6, r6, #1
 801619c:	f8ca 6000 	str.w	r6, [sl]
 80161a0:	f8da 3000 	ldr.w	r3, [sl]
 80161a4:	4499      	add	r9, r3
 80161a6:	2200      	movs	r2, #0
 80161a8:	2300      	movs	r3, #0
 80161aa:	4620      	mov	r0, r4
 80161ac:	4629      	mov	r1, r5
 80161ae:	f7ea fcb3 	bl	8000b18 <__aeabi_dcmpeq>
 80161b2:	b108      	cbz	r0, 80161b8 <__cvt+0xa4>
 80161b4:	f8cd 900c 	str.w	r9, [sp, #12]
 80161b8:	2230      	movs	r2, #48	; 0x30
 80161ba:	9b03      	ldr	r3, [sp, #12]
 80161bc:	454b      	cmp	r3, r9
 80161be:	d307      	bcc.n	80161d0 <__cvt+0xbc>
 80161c0:	9b03      	ldr	r3, [sp, #12]
 80161c2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80161c4:	1bdb      	subs	r3, r3, r7
 80161c6:	4638      	mov	r0, r7
 80161c8:	6013      	str	r3, [r2, #0]
 80161ca:	b004      	add	sp, #16
 80161cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80161d0:	1c59      	adds	r1, r3, #1
 80161d2:	9103      	str	r1, [sp, #12]
 80161d4:	701a      	strb	r2, [r3, #0]
 80161d6:	e7f0      	b.n	80161ba <__cvt+0xa6>

080161d8 <__exponent>:
 80161d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80161da:	4603      	mov	r3, r0
 80161dc:	2900      	cmp	r1, #0
 80161de:	bfb8      	it	lt
 80161e0:	4249      	neglt	r1, r1
 80161e2:	f803 2b02 	strb.w	r2, [r3], #2
 80161e6:	bfb4      	ite	lt
 80161e8:	222d      	movlt	r2, #45	; 0x2d
 80161ea:	222b      	movge	r2, #43	; 0x2b
 80161ec:	2909      	cmp	r1, #9
 80161ee:	7042      	strb	r2, [r0, #1]
 80161f0:	dd2a      	ble.n	8016248 <__exponent+0x70>
 80161f2:	f10d 0407 	add.w	r4, sp, #7
 80161f6:	46a4      	mov	ip, r4
 80161f8:	270a      	movs	r7, #10
 80161fa:	46a6      	mov	lr, r4
 80161fc:	460a      	mov	r2, r1
 80161fe:	fb91 f6f7 	sdiv	r6, r1, r7
 8016202:	fb07 1516 	mls	r5, r7, r6, r1
 8016206:	3530      	adds	r5, #48	; 0x30
 8016208:	2a63      	cmp	r2, #99	; 0x63
 801620a:	f104 34ff 	add.w	r4, r4, #4294967295
 801620e:	f80e 5c01 	strb.w	r5, [lr, #-1]
 8016212:	4631      	mov	r1, r6
 8016214:	dcf1      	bgt.n	80161fa <__exponent+0x22>
 8016216:	3130      	adds	r1, #48	; 0x30
 8016218:	f1ae 0502 	sub.w	r5, lr, #2
 801621c:	f804 1c01 	strb.w	r1, [r4, #-1]
 8016220:	1c44      	adds	r4, r0, #1
 8016222:	4629      	mov	r1, r5
 8016224:	4561      	cmp	r1, ip
 8016226:	d30a      	bcc.n	801623e <__exponent+0x66>
 8016228:	f10d 0209 	add.w	r2, sp, #9
 801622c:	eba2 020e 	sub.w	r2, r2, lr
 8016230:	4565      	cmp	r5, ip
 8016232:	bf88      	it	hi
 8016234:	2200      	movhi	r2, #0
 8016236:	4413      	add	r3, r2
 8016238:	1a18      	subs	r0, r3, r0
 801623a:	b003      	add	sp, #12
 801623c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801623e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8016242:	f804 2f01 	strb.w	r2, [r4, #1]!
 8016246:	e7ed      	b.n	8016224 <__exponent+0x4c>
 8016248:	2330      	movs	r3, #48	; 0x30
 801624a:	3130      	adds	r1, #48	; 0x30
 801624c:	7083      	strb	r3, [r0, #2]
 801624e:	70c1      	strb	r1, [r0, #3]
 8016250:	1d03      	adds	r3, r0, #4
 8016252:	e7f1      	b.n	8016238 <__exponent+0x60>

08016254 <_printf_float>:
 8016254:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016258:	ed2d 8b02 	vpush	{d8}
 801625c:	b08d      	sub	sp, #52	; 0x34
 801625e:	460c      	mov	r4, r1
 8016260:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
 8016264:	4616      	mov	r6, r2
 8016266:	461f      	mov	r7, r3
 8016268:	4605      	mov	r5, r0
 801626a:	f002 fe6b 	bl	8018f44 <_localeconv_r>
 801626e:	f8d0 a000 	ldr.w	sl, [r0]
 8016272:	4650      	mov	r0, sl
 8016274:	f7e9 ffce 	bl	8000214 <strlen>
 8016278:	2300      	movs	r3, #0
 801627a:	930a      	str	r3, [sp, #40]	; 0x28
 801627c:	6823      	ldr	r3, [r4, #0]
 801627e:	9305      	str	r3, [sp, #20]
 8016280:	f8d8 3000 	ldr.w	r3, [r8]
 8016284:	f894 b018 	ldrb.w	fp, [r4, #24]
 8016288:	3307      	adds	r3, #7
 801628a:	f023 0307 	bic.w	r3, r3, #7
 801628e:	f103 0208 	add.w	r2, r3, #8
 8016292:	f8c8 2000 	str.w	r2, [r8]
 8016296:	e9d3 2300 	ldrd	r2, r3, [r3]
 801629a:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
 801629e:	e9d4 8912 	ldrd	r8, r9, [r4, #72]	; 0x48
 80162a2:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 80162a6:	9307      	str	r3, [sp, #28]
 80162a8:	f8cd 8018 	str.w	r8, [sp, #24]
 80162ac:	ee08 0a10 	vmov	s16, r0
 80162b0:	4b9f      	ldr	r3, [pc, #636]	; (8016530 <_printf_float+0x2dc>)
 80162b2:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80162b6:	f04f 32ff 	mov.w	r2, #4294967295
 80162ba:	f7ea fc5f 	bl	8000b7c <__aeabi_dcmpun>
 80162be:	bb88      	cbnz	r0, 8016324 <_printf_float+0xd0>
 80162c0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80162c4:	4b9a      	ldr	r3, [pc, #616]	; (8016530 <_printf_float+0x2dc>)
 80162c6:	f04f 32ff 	mov.w	r2, #4294967295
 80162ca:	f7ea fc39 	bl	8000b40 <__aeabi_dcmple>
 80162ce:	bb48      	cbnz	r0, 8016324 <_printf_float+0xd0>
 80162d0:	2200      	movs	r2, #0
 80162d2:	2300      	movs	r3, #0
 80162d4:	4640      	mov	r0, r8
 80162d6:	4649      	mov	r1, r9
 80162d8:	f7ea fc28 	bl	8000b2c <__aeabi_dcmplt>
 80162dc:	b110      	cbz	r0, 80162e4 <_printf_float+0x90>
 80162de:	232d      	movs	r3, #45	; 0x2d
 80162e0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80162e4:	4b93      	ldr	r3, [pc, #588]	; (8016534 <_printf_float+0x2e0>)
 80162e6:	4894      	ldr	r0, [pc, #592]	; (8016538 <_printf_float+0x2e4>)
 80162e8:	f1bb 0f47 	cmp.w	fp, #71	; 0x47
 80162ec:	bf94      	ite	ls
 80162ee:	4698      	movls	r8, r3
 80162f0:	4680      	movhi	r8, r0
 80162f2:	2303      	movs	r3, #3
 80162f4:	6123      	str	r3, [r4, #16]
 80162f6:	9b05      	ldr	r3, [sp, #20]
 80162f8:	f023 0204 	bic.w	r2, r3, #4
 80162fc:	6022      	str	r2, [r4, #0]
 80162fe:	f04f 0900 	mov.w	r9, #0
 8016302:	9700      	str	r7, [sp, #0]
 8016304:	4633      	mov	r3, r6
 8016306:	aa0b      	add	r2, sp, #44	; 0x2c
 8016308:	4621      	mov	r1, r4
 801630a:	4628      	mov	r0, r5
 801630c:	f000 f9d8 	bl	80166c0 <_printf_common>
 8016310:	3001      	adds	r0, #1
 8016312:	f040 8090 	bne.w	8016436 <_printf_float+0x1e2>
 8016316:	f04f 30ff 	mov.w	r0, #4294967295
 801631a:	b00d      	add	sp, #52	; 0x34
 801631c:	ecbd 8b02 	vpop	{d8}
 8016320:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016324:	4642      	mov	r2, r8
 8016326:	464b      	mov	r3, r9
 8016328:	4640      	mov	r0, r8
 801632a:	4649      	mov	r1, r9
 801632c:	f7ea fc26 	bl	8000b7c <__aeabi_dcmpun>
 8016330:	b140      	cbz	r0, 8016344 <_printf_float+0xf0>
 8016332:	464b      	mov	r3, r9
 8016334:	2b00      	cmp	r3, #0
 8016336:	bfbc      	itt	lt
 8016338:	232d      	movlt	r3, #45	; 0x2d
 801633a:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
 801633e:	487f      	ldr	r0, [pc, #508]	; (801653c <_printf_float+0x2e8>)
 8016340:	4b7f      	ldr	r3, [pc, #508]	; (8016540 <_printf_float+0x2ec>)
 8016342:	e7d1      	b.n	80162e8 <_printf_float+0x94>
 8016344:	6863      	ldr	r3, [r4, #4]
 8016346:	f00b 02df 	and.w	r2, fp, #223	; 0xdf
 801634a:	9206      	str	r2, [sp, #24]
 801634c:	1c5a      	adds	r2, r3, #1
 801634e:	d13f      	bne.n	80163d0 <_printf_float+0x17c>
 8016350:	2306      	movs	r3, #6
 8016352:	6063      	str	r3, [r4, #4]
 8016354:	9b05      	ldr	r3, [sp, #20]
 8016356:	6861      	ldr	r1, [r4, #4]
 8016358:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 801635c:	2300      	movs	r3, #0
 801635e:	9303      	str	r3, [sp, #12]
 8016360:	ab0a      	add	r3, sp, #40	; 0x28
 8016362:	e9cd b301 	strd	fp, r3, [sp, #4]
 8016366:	ab09      	add	r3, sp, #36	; 0x24
 8016368:	ec49 8b10 	vmov	d0, r8, r9
 801636c:	9300      	str	r3, [sp, #0]
 801636e:	6022      	str	r2, [r4, #0]
 8016370:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 8016374:	4628      	mov	r0, r5
 8016376:	f7ff fecd 	bl	8016114 <__cvt>
 801637a:	9b06      	ldr	r3, [sp, #24]
 801637c:	9909      	ldr	r1, [sp, #36]	; 0x24
 801637e:	2b47      	cmp	r3, #71	; 0x47
 8016380:	4680      	mov	r8, r0
 8016382:	d108      	bne.n	8016396 <_printf_float+0x142>
 8016384:	1cc8      	adds	r0, r1, #3
 8016386:	db02      	blt.n	801638e <_printf_float+0x13a>
 8016388:	6863      	ldr	r3, [r4, #4]
 801638a:	4299      	cmp	r1, r3
 801638c:	dd41      	ble.n	8016412 <_printf_float+0x1be>
 801638e:	f1ab 0b02 	sub.w	fp, fp, #2
 8016392:	fa5f fb8b 	uxtb.w	fp, fp
 8016396:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 801639a:	d820      	bhi.n	80163de <_printf_float+0x18a>
 801639c:	3901      	subs	r1, #1
 801639e:	465a      	mov	r2, fp
 80163a0:	f104 0050 	add.w	r0, r4, #80	; 0x50
 80163a4:	9109      	str	r1, [sp, #36]	; 0x24
 80163a6:	f7ff ff17 	bl	80161d8 <__exponent>
 80163aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80163ac:	1813      	adds	r3, r2, r0
 80163ae:	2a01      	cmp	r2, #1
 80163b0:	4681      	mov	r9, r0
 80163b2:	6123      	str	r3, [r4, #16]
 80163b4:	dc02      	bgt.n	80163bc <_printf_float+0x168>
 80163b6:	6822      	ldr	r2, [r4, #0]
 80163b8:	07d2      	lsls	r2, r2, #31
 80163ba:	d501      	bpl.n	80163c0 <_printf_float+0x16c>
 80163bc:	3301      	adds	r3, #1
 80163be:	6123      	str	r3, [r4, #16]
 80163c0:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80163c4:	2b00      	cmp	r3, #0
 80163c6:	d09c      	beq.n	8016302 <_printf_float+0xae>
 80163c8:	232d      	movs	r3, #45	; 0x2d
 80163ca:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80163ce:	e798      	b.n	8016302 <_printf_float+0xae>
 80163d0:	9a06      	ldr	r2, [sp, #24]
 80163d2:	2a47      	cmp	r2, #71	; 0x47
 80163d4:	d1be      	bne.n	8016354 <_printf_float+0x100>
 80163d6:	2b00      	cmp	r3, #0
 80163d8:	d1bc      	bne.n	8016354 <_printf_float+0x100>
 80163da:	2301      	movs	r3, #1
 80163dc:	e7b9      	b.n	8016352 <_printf_float+0xfe>
 80163de:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 80163e2:	d118      	bne.n	8016416 <_printf_float+0x1c2>
 80163e4:	2900      	cmp	r1, #0
 80163e6:	6863      	ldr	r3, [r4, #4]
 80163e8:	dd0b      	ble.n	8016402 <_printf_float+0x1ae>
 80163ea:	6121      	str	r1, [r4, #16]
 80163ec:	b913      	cbnz	r3, 80163f4 <_printf_float+0x1a0>
 80163ee:	6822      	ldr	r2, [r4, #0]
 80163f0:	07d0      	lsls	r0, r2, #31
 80163f2:	d502      	bpl.n	80163fa <_printf_float+0x1a6>
 80163f4:	3301      	adds	r3, #1
 80163f6:	440b      	add	r3, r1
 80163f8:	6123      	str	r3, [r4, #16]
 80163fa:	65a1      	str	r1, [r4, #88]	; 0x58
 80163fc:	f04f 0900 	mov.w	r9, #0
 8016400:	e7de      	b.n	80163c0 <_printf_float+0x16c>
 8016402:	b913      	cbnz	r3, 801640a <_printf_float+0x1b6>
 8016404:	6822      	ldr	r2, [r4, #0]
 8016406:	07d2      	lsls	r2, r2, #31
 8016408:	d501      	bpl.n	801640e <_printf_float+0x1ba>
 801640a:	3302      	adds	r3, #2
 801640c:	e7f4      	b.n	80163f8 <_printf_float+0x1a4>
 801640e:	2301      	movs	r3, #1
 8016410:	e7f2      	b.n	80163f8 <_printf_float+0x1a4>
 8016412:	f04f 0b67 	mov.w	fp, #103	; 0x67
 8016416:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8016418:	4299      	cmp	r1, r3
 801641a:	db05      	blt.n	8016428 <_printf_float+0x1d4>
 801641c:	6823      	ldr	r3, [r4, #0]
 801641e:	6121      	str	r1, [r4, #16]
 8016420:	07d8      	lsls	r0, r3, #31
 8016422:	d5ea      	bpl.n	80163fa <_printf_float+0x1a6>
 8016424:	1c4b      	adds	r3, r1, #1
 8016426:	e7e7      	b.n	80163f8 <_printf_float+0x1a4>
 8016428:	2900      	cmp	r1, #0
 801642a:	bfd4      	ite	le
 801642c:	f1c1 0202 	rsble	r2, r1, #2
 8016430:	2201      	movgt	r2, #1
 8016432:	4413      	add	r3, r2
 8016434:	e7e0      	b.n	80163f8 <_printf_float+0x1a4>
 8016436:	6823      	ldr	r3, [r4, #0]
 8016438:	055a      	lsls	r2, r3, #21
 801643a:	d407      	bmi.n	801644c <_printf_float+0x1f8>
 801643c:	6923      	ldr	r3, [r4, #16]
 801643e:	4642      	mov	r2, r8
 8016440:	4631      	mov	r1, r6
 8016442:	4628      	mov	r0, r5
 8016444:	47b8      	blx	r7
 8016446:	3001      	adds	r0, #1
 8016448:	d12c      	bne.n	80164a4 <_printf_float+0x250>
 801644a:	e764      	b.n	8016316 <_printf_float+0xc2>
 801644c:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8016450:	f240 80e0 	bls.w	8016614 <_printf_float+0x3c0>
 8016454:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 8016458:	2200      	movs	r2, #0
 801645a:	2300      	movs	r3, #0
 801645c:	f7ea fb5c 	bl	8000b18 <__aeabi_dcmpeq>
 8016460:	2800      	cmp	r0, #0
 8016462:	d034      	beq.n	80164ce <_printf_float+0x27a>
 8016464:	4a37      	ldr	r2, [pc, #220]	; (8016544 <_printf_float+0x2f0>)
 8016466:	2301      	movs	r3, #1
 8016468:	4631      	mov	r1, r6
 801646a:	4628      	mov	r0, r5
 801646c:	47b8      	blx	r7
 801646e:	3001      	adds	r0, #1
 8016470:	f43f af51 	beq.w	8016316 <_printf_float+0xc2>
 8016474:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 8016478:	429a      	cmp	r2, r3
 801647a:	db02      	blt.n	8016482 <_printf_float+0x22e>
 801647c:	6823      	ldr	r3, [r4, #0]
 801647e:	07d8      	lsls	r0, r3, #31
 8016480:	d510      	bpl.n	80164a4 <_printf_float+0x250>
 8016482:	ee18 3a10 	vmov	r3, s16
 8016486:	4652      	mov	r2, sl
 8016488:	4631      	mov	r1, r6
 801648a:	4628      	mov	r0, r5
 801648c:	47b8      	blx	r7
 801648e:	3001      	adds	r0, #1
 8016490:	f43f af41 	beq.w	8016316 <_printf_float+0xc2>
 8016494:	f04f 0800 	mov.w	r8, #0
 8016498:	f104 091a 	add.w	r9, r4, #26
 801649c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801649e:	3b01      	subs	r3, #1
 80164a0:	4543      	cmp	r3, r8
 80164a2:	dc09      	bgt.n	80164b8 <_printf_float+0x264>
 80164a4:	6823      	ldr	r3, [r4, #0]
 80164a6:	079b      	lsls	r3, r3, #30
 80164a8:	f100 8105 	bmi.w	80166b6 <_printf_float+0x462>
 80164ac:	68e0      	ldr	r0, [r4, #12]
 80164ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80164b0:	4298      	cmp	r0, r3
 80164b2:	bfb8      	it	lt
 80164b4:	4618      	movlt	r0, r3
 80164b6:	e730      	b.n	801631a <_printf_float+0xc6>
 80164b8:	2301      	movs	r3, #1
 80164ba:	464a      	mov	r2, r9
 80164bc:	4631      	mov	r1, r6
 80164be:	4628      	mov	r0, r5
 80164c0:	47b8      	blx	r7
 80164c2:	3001      	adds	r0, #1
 80164c4:	f43f af27 	beq.w	8016316 <_printf_float+0xc2>
 80164c8:	f108 0801 	add.w	r8, r8, #1
 80164cc:	e7e6      	b.n	801649c <_printf_float+0x248>
 80164ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80164d0:	2b00      	cmp	r3, #0
 80164d2:	dc39      	bgt.n	8016548 <_printf_float+0x2f4>
 80164d4:	4a1b      	ldr	r2, [pc, #108]	; (8016544 <_printf_float+0x2f0>)
 80164d6:	2301      	movs	r3, #1
 80164d8:	4631      	mov	r1, r6
 80164da:	4628      	mov	r0, r5
 80164dc:	47b8      	blx	r7
 80164de:	3001      	adds	r0, #1
 80164e0:	f43f af19 	beq.w	8016316 <_printf_float+0xc2>
 80164e4:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 80164e8:	4313      	orrs	r3, r2
 80164ea:	d102      	bne.n	80164f2 <_printf_float+0x29e>
 80164ec:	6823      	ldr	r3, [r4, #0]
 80164ee:	07d9      	lsls	r1, r3, #31
 80164f0:	d5d8      	bpl.n	80164a4 <_printf_float+0x250>
 80164f2:	ee18 3a10 	vmov	r3, s16
 80164f6:	4652      	mov	r2, sl
 80164f8:	4631      	mov	r1, r6
 80164fa:	4628      	mov	r0, r5
 80164fc:	47b8      	blx	r7
 80164fe:	3001      	adds	r0, #1
 8016500:	f43f af09 	beq.w	8016316 <_printf_float+0xc2>
 8016504:	f04f 0900 	mov.w	r9, #0
 8016508:	f104 0a1a 	add.w	sl, r4, #26
 801650c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801650e:	425b      	negs	r3, r3
 8016510:	454b      	cmp	r3, r9
 8016512:	dc01      	bgt.n	8016518 <_printf_float+0x2c4>
 8016514:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8016516:	e792      	b.n	801643e <_printf_float+0x1ea>
 8016518:	2301      	movs	r3, #1
 801651a:	4652      	mov	r2, sl
 801651c:	4631      	mov	r1, r6
 801651e:	4628      	mov	r0, r5
 8016520:	47b8      	blx	r7
 8016522:	3001      	adds	r0, #1
 8016524:	f43f aef7 	beq.w	8016316 <_printf_float+0xc2>
 8016528:	f109 0901 	add.w	r9, r9, #1
 801652c:	e7ee      	b.n	801650c <_printf_float+0x2b8>
 801652e:	bf00      	nop
 8016530:	7fefffff 	.word	0x7fefffff
 8016534:	0801adc4 	.word	0x0801adc4
 8016538:	0801adc8 	.word	0x0801adc8
 801653c:	0801add0 	.word	0x0801add0
 8016540:	0801adcc 	.word	0x0801adcc
 8016544:	0801add4 	.word	0x0801add4
 8016548:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801654a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 801654c:	429a      	cmp	r2, r3
 801654e:	bfa8      	it	ge
 8016550:	461a      	movge	r2, r3
 8016552:	2a00      	cmp	r2, #0
 8016554:	4691      	mov	r9, r2
 8016556:	dc37      	bgt.n	80165c8 <_printf_float+0x374>
 8016558:	f04f 0b00 	mov.w	fp, #0
 801655c:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 8016560:	f104 021a 	add.w	r2, r4, #26
 8016564:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8016566:	9305      	str	r3, [sp, #20]
 8016568:	eba3 0309 	sub.w	r3, r3, r9
 801656c:	455b      	cmp	r3, fp
 801656e:	dc33      	bgt.n	80165d8 <_printf_float+0x384>
 8016570:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 8016574:	429a      	cmp	r2, r3
 8016576:	db3b      	blt.n	80165f0 <_printf_float+0x39c>
 8016578:	6823      	ldr	r3, [r4, #0]
 801657a:	07da      	lsls	r2, r3, #31
 801657c:	d438      	bmi.n	80165f0 <_printf_float+0x39c>
 801657e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8016580:	9b05      	ldr	r3, [sp, #20]
 8016582:	9909      	ldr	r1, [sp, #36]	; 0x24
 8016584:	1ad3      	subs	r3, r2, r3
 8016586:	eba2 0901 	sub.w	r9, r2, r1
 801658a:	4599      	cmp	r9, r3
 801658c:	bfa8      	it	ge
 801658e:	4699      	movge	r9, r3
 8016590:	f1b9 0f00 	cmp.w	r9, #0
 8016594:	dc35      	bgt.n	8016602 <_printf_float+0x3ae>
 8016596:	f04f 0800 	mov.w	r8, #0
 801659a:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 801659e:	f104 0a1a 	add.w	sl, r4, #26
 80165a2:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 80165a6:	1a9b      	subs	r3, r3, r2
 80165a8:	eba3 0309 	sub.w	r3, r3, r9
 80165ac:	4543      	cmp	r3, r8
 80165ae:	f77f af79 	ble.w	80164a4 <_printf_float+0x250>
 80165b2:	2301      	movs	r3, #1
 80165b4:	4652      	mov	r2, sl
 80165b6:	4631      	mov	r1, r6
 80165b8:	4628      	mov	r0, r5
 80165ba:	47b8      	blx	r7
 80165bc:	3001      	adds	r0, #1
 80165be:	f43f aeaa 	beq.w	8016316 <_printf_float+0xc2>
 80165c2:	f108 0801 	add.w	r8, r8, #1
 80165c6:	e7ec      	b.n	80165a2 <_printf_float+0x34e>
 80165c8:	4613      	mov	r3, r2
 80165ca:	4631      	mov	r1, r6
 80165cc:	4642      	mov	r2, r8
 80165ce:	4628      	mov	r0, r5
 80165d0:	47b8      	blx	r7
 80165d2:	3001      	adds	r0, #1
 80165d4:	d1c0      	bne.n	8016558 <_printf_float+0x304>
 80165d6:	e69e      	b.n	8016316 <_printf_float+0xc2>
 80165d8:	2301      	movs	r3, #1
 80165da:	4631      	mov	r1, r6
 80165dc:	4628      	mov	r0, r5
 80165de:	9205      	str	r2, [sp, #20]
 80165e0:	47b8      	blx	r7
 80165e2:	3001      	adds	r0, #1
 80165e4:	f43f ae97 	beq.w	8016316 <_printf_float+0xc2>
 80165e8:	9a05      	ldr	r2, [sp, #20]
 80165ea:	f10b 0b01 	add.w	fp, fp, #1
 80165ee:	e7b9      	b.n	8016564 <_printf_float+0x310>
 80165f0:	ee18 3a10 	vmov	r3, s16
 80165f4:	4652      	mov	r2, sl
 80165f6:	4631      	mov	r1, r6
 80165f8:	4628      	mov	r0, r5
 80165fa:	47b8      	blx	r7
 80165fc:	3001      	adds	r0, #1
 80165fe:	d1be      	bne.n	801657e <_printf_float+0x32a>
 8016600:	e689      	b.n	8016316 <_printf_float+0xc2>
 8016602:	9a05      	ldr	r2, [sp, #20]
 8016604:	464b      	mov	r3, r9
 8016606:	4442      	add	r2, r8
 8016608:	4631      	mov	r1, r6
 801660a:	4628      	mov	r0, r5
 801660c:	47b8      	blx	r7
 801660e:	3001      	adds	r0, #1
 8016610:	d1c1      	bne.n	8016596 <_printf_float+0x342>
 8016612:	e680      	b.n	8016316 <_printf_float+0xc2>
 8016614:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8016616:	2a01      	cmp	r2, #1
 8016618:	dc01      	bgt.n	801661e <_printf_float+0x3ca>
 801661a:	07db      	lsls	r3, r3, #31
 801661c:	d538      	bpl.n	8016690 <_printf_float+0x43c>
 801661e:	2301      	movs	r3, #1
 8016620:	4642      	mov	r2, r8
 8016622:	4631      	mov	r1, r6
 8016624:	4628      	mov	r0, r5
 8016626:	47b8      	blx	r7
 8016628:	3001      	adds	r0, #1
 801662a:	f43f ae74 	beq.w	8016316 <_printf_float+0xc2>
 801662e:	ee18 3a10 	vmov	r3, s16
 8016632:	4652      	mov	r2, sl
 8016634:	4631      	mov	r1, r6
 8016636:	4628      	mov	r0, r5
 8016638:	47b8      	blx	r7
 801663a:	3001      	adds	r0, #1
 801663c:	f43f ae6b 	beq.w	8016316 <_printf_float+0xc2>
 8016640:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 8016644:	2200      	movs	r2, #0
 8016646:	2300      	movs	r3, #0
 8016648:	f7ea fa66 	bl	8000b18 <__aeabi_dcmpeq>
 801664c:	b9d8      	cbnz	r0, 8016686 <_printf_float+0x432>
 801664e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8016650:	f108 0201 	add.w	r2, r8, #1
 8016654:	3b01      	subs	r3, #1
 8016656:	4631      	mov	r1, r6
 8016658:	4628      	mov	r0, r5
 801665a:	47b8      	blx	r7
 801665c:	3001      	adds	r0, #1
 801665e:	d10e      	bne.n	801667e <_printf_float+0x42a>
 8016660:	e659      	b.n	8016316 <_printf_float+0xc2>
 8016662:	2301      	movs	r3, #1
 8016664:	4652      	mov	r2, sl
 8016666:	4631      	mov	r1, r6
 8016668:	4628      	mov	r0, r5
 801666a:	47b8      	blx	r7
 801666c:	3001      	adds	r0, #1
 801666e:	f43f ae52 	beq.w	8016316 <_printf_float+0xc2>
 8016672:	f108 0801 	add.w	r8, r8, #1
 8016676:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8016678:	3b01      	subs	r3, #1
 801667a:	4543      	cmp	r3, r8
 801667c:	dcf1      	bgt.n	8016662 <_printf_float+0x40e>
 801667e:	464b      	mov	r3, r9
 8016680:	f104 0250 	add.w	r2, r4, #80	; 0x50
 8016684:	e6dc      	b.n	8016440 <_printf_float+0x1ec>
 8016686:	f04f 0800 	mov.w	r8, #0
 801668a:	f104 0a1a 	add.w	sl, r4, #26
 801668e:	e7f2      	b.n	8016676 <_printf_float+0x422>
 8016690:	2301      	movs	r3, #1
 8016692:	4642      	mov	r2, r8
 8016694:	e7df      	b.n	8016656 <_printf_float+0x402>
 8016696:	2301      	movs	r3, #1
 8016698:	464a      	mov	r2, r9
 801669a:	4631      	mov	r1, r6
 801669c:	4628      	mov	r0, r5
 801669e:	47b8      	blx	r7
 80166a0:	3001      	adds	r0, #1
 80166a2:	f43f ae38 	beq.w	8016316 <_printf_float+0xc2>
 80166a6:	f108 0801 	add.w	r8, r8, #1
 80166aa:	68e3      	ldr	r3, [r4, #12]
 80166ac:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80166ae:	1a5b      	subs	r3, r3, r1
 80166b0:	4543      	cmp	r3, r8
 80166b2:	dcf0      	bgt.n	8016696 <_printf_float+0x442>
 80166b4:	e6fa      	b.n	80164ac <_printf_float+0x258>
 80166b6:	f04f 0800 	mov.w	r8, #0
 80166ba:	f104 0919 	add.w	r9, r4, #25
 80166be:	e7f4      	b.n	80166aa <_printf_float+0x456>

080166c0 <_printf_common>:
 80166c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80166c4:	4616      	mov	r6, r2
 80166c6:	4699      	mov	r9, r3
 80166c8:	688a      	ldr	r2, [r1, #8]
 80166ca:	690b      	ldr	r3, [r1, #16]
 80166cc:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80166d0:	4293      	cmp	r3, r2
 80166d2:	bfb8      	it	lt
 80166d4:	4613      	movlt	r3, r2
 80166d6:	6033      	str	r3, [r6, #0]
 80166d8:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 80166dc:	4607      	mov	r7, r0
 80166de:	460c      	mov	r4, r1
 80166e0:	b10a      	cbz	r2, 80166e6 <_printf_common+0x26>
 80166e2:	3301      	adds	r3, #1
 80166e4:	6033      	str	r3, [r6, #0]
 80166e6:	6823      	ldr	r3, [r4, #0]
 80166e8:	0699      	lsls	r1, r3, #26
 80166ea:	bf42      	ittt	mi
 80166ec:	6833      	ldrmi	r3, [r6, #0]
 80166ee:	3302      	addmi	r3, #2
 80166f0:	6033      	strmi	r3, [r6, #0]
 80166f2:	6825      	ldr	r5, [r4, #0]
 80166f4:	f015 0506 	ands.w	r5, r5, #6
 80166f8:	d106      	bne.n	8016708 <_printf_common+0x48>
 80166fa:	f104 0a19 	add.w	sl, r4, #25
 80166fe:	68e3      	ldr	r3, [r4, #12]
 8016700:	6832      	ldr	r2, [r6, #0]
 8016702:	1a9b      	subs	r3, r3, r2
 8016704:	42ab      	cmp	r3, r5
 8016706:	dc26      	bgt.n	8016756 <_printf_common+0x96>
 8016708:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 801670c:	1e13      	subs	r3, r2, #0
 801670e:	6822      	ldr	r2, [r4, #0]
 8016710:	bf18      	it	ne
 8016712:	2301      	movne	r3, #1
 8016714:	0692      	lsls	r2, r2, #26
 8016716:	d42b      	bmi.n	8016770 <_printf_common+0xb0>
 8016718:	f104 0243 	add.w	r2, r4, #67	; 0x43
 801671c:	4649      	mov	r1, r9
 801671e:	4638      	mov	r0, r7
 8016720:	47c0      	blx	r8
 8016722:	3001      	adds	r0, #1
 8016724:	d01e      	beq.n	8016764 <_printf_common+0xa4>
 8016726:	6823      	ldr	r3, [r4, #0]
 8016728:	68e5      	ldr	r5, [r4, #12]
 801672a:	6832      	ldr	r2, [r6, #0]
 801672c:	f003 0306 	and.w	r3, r3, #6
 8016730:	2b04      	cmp	r3, #4
 8016732:	bf08      	it	eq
 8016734:	1aad      	subeq	r5, r5, r2
 8016736:	68a3      	ldr	r3, [r4, #8]
 8016738:	6922      	ldr	r2, [r4, #16]
 801673a:	bf0c      	ite	eq
 801673c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8016740:	2500      	movne	r5, #0
 8016742:	4293      	cmp	r3, r2
 8016744:	bfc4      	itt	gt
 8016746:	1a9b      	subgt	r3, r3, r2
 8016748:	18ed      	addgt	r5, r5, r3
 801674a:	2600      	movs	r6, #0
 801674c:	341a      	adds	r4, #26
 801674e:	42b5      	cmp	r5, r6
 8016750:	d11a      	bne.n	8016788 <_printf_common+0xc8>
 8016752:	2000      	movs	r0, #0
 8016754:	e008      	b.n	8016768 <_printf_common+0xa8>
 8016756:	2301      	movs	r3, #1
 8016758:	4652      	mov	r2, sl
 801675a:	4649      	mov	r1, r9
 801675c:	4638      	mov	r0, r7
 801675e:	47c0      	blx	r8
 8016760:	3001      	adds	r0, #1
 8016762:	d103      	bne.n	801676c <_printf_common+0xac>
 8016764:	f04f 30ff 	mov.w	r0, #4294967295
 8016768:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801676c:	3501      	adds	r5, #1
 801676e:	e7c6      	b.n	80166fe <_printf_common+0x3e>
 8016770:	18e1      	adds	r1, r4, r3
 8016772:	1c5a      	adds	r2, r3, #1
 8016774:	2030      	movs	r0, #48	; 0x30
 8016776:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801677a:	4422      	add	r2, r4
 801677c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8016780:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8016784:	3302      	adds	r3, #2
 8016786:	e7c7      	b.n	8016718 <_printf_common+0x58>
 8016788:	2301      	movs	r3, #1
 801678a:	4622      	mov	r2, r4
 801678c:	4649      	mov	r1, r9
 801678e:	4638      	mov	r0, r7
 8016790:	47c0      	blx	r8
 8016792:	3001      	adds	r0, #1
 8016794:	d0e6      	beq.n	8016764 <_printf_common+0xa4>
 8016796:	3601      	adds	r6, #1
 8016798:	e7d9      	b.n	801674e <_printf_common+0x8e>
	...

0801679c <_printf_i>:
 801679c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80167a0:	460c      	mov	r4, r1
 80167a2:	4691      	mov	r9, r2
 80167a4:	7e27      	ldrb	r7, [r4, #24]
 80167a6:	990c      	ldr	r1, [sp, #48]	; 0x30
 80167a8:	2f78      	cmp	r7, #120	; 0x78
 80167aa:	4680      	mov	r8, r0
 80167ac:	469a      	mov	sl, r3
 80167ae:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80167b2:	d807      	bhi.n	80167c4 <_printf_i+0x28>
 80167b4:	2f62      	cmp	r7, #98	; 0x62
 80167b6:	d80a      	bhi.n	80167ce <_printf_i+0x32>
 80167b8:	2f00      	cmp	r7, #0
 80167ba:	f000 80d8 	beq.w	801696e <_printf_i+0x1d2>
 80167be:	2f58      	cmp	r7, #88	; 0x58
 80167c0:	f000 80a3 	beq.w	801690a <_printf_i+0x16e>
 80167c4:	f104 0642 	add.w	r6, r4, #66	; 0x42
 80167c8:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 80167cc:	e03a      	b.n	8016844 <_printf_i+0xa8>
 80167ce:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 80167d2:	2b15      	cmp	r3, #21
 80167d4:	d8f6      	bhi.n	80167c4 <_printf_i+0x28>
 80167d6:	a001      	add	r0, pc, #4	; (adr r0, 80167dc <_printf_i+0x40>)
 80167d8:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 80167dc:	08016835 	.word	0x08016835
 80167e0:	08016849 	.word	0x08016849
 80167e4:	080167c5 	.word	0x080167c5
 80167e8:	080167c5 	.word	0x080167c5
 80167ec:	080167c5 	.word	0x080167c5
 80167f0:	080167c5 	.word	0x080167c5
 80167f4:	08016849 	.word	0x08016849
 80167f8:	080167c5 	.word	0x080167c5
 80167fc:	080167c5 	.word	0x080167c5
 8016800:	080167c5 	.word	0x080167c5
 8016804:	080167c5 	.word	0x080167c5
 8016808:	08016955 	.word	0x08016955
 801680c:	08016879 	.word	0x08016879
 8016810:	08016937 	.word	0x08016937
 8016814:	080167c5 	.word	0x080167c5
 8016818:	080167c5 	.word	0x080167c5
 801681c:	08016977 	.word	0x08016977
 8016820:	080167c5 	.word	0x080167c5
 8016824:	08016879 	.word	0x08016879
 8016828:	080167c5 	.word	0x080167c5
 801682c:	080167c5 	.word	0x080167c5
 8016830:	0801693f 	.word	0x0801693f
 8016834:	680b      	ldr	r3, [r1, #0]
 8016836:	1d1a      	adds	r2, r3, #4
 8016838:	681b      	ldr	r3, [r3, #0]
 801683a:	600a      	str	r2, [r1, #0]
 801683c:	f104 0642 	add.w	r6, r4, #66	; 0x42
 8016840:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8016844:	2301      	movs	r3, #1
 8016846:	e0a3      	b.n	8016990 <_printf_i+0x1f4>
 8016848:	6825      	ldr	r5, [r4, #0]
 801684a:	6808      	ldr	r0, [r1, #0]
 801684c:	062e      	lsls	r6, r5, #24
 801684e:	f100 0304 	add.w	r3, r0, #4
 8016852:	d50a      	bpl.n	801686a <_printf_i+0xce>
 8016854:	6805      	ldr	r5, [r0, #0]
 8016856:	600b      	str	r3, [r1, #0]
 8016858:	2d00      	cmp	r5, #0
 801685a:	da03      	bge.n	8016864 <_printf_i+0xc8>
 801685c:	232d      	movs	r3, #45	; 0x2d
 801685e:	426d      	negs	r5, r5
 8016860:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8016864:	485e      	ldr	r0, [pc, #376]	; (80169e0 <_printf_i+0x244>)
 8016866:	230a      	movs	r3, #10
 8016868:	e019      	b.n	801689e <_printf_i+0x102>
 801686a:	f015 0f40 	tst.w	r5, #64	; 0x40
 801686e:	6805      	ldr	r5, [r0, #0]
 8016870:	600b      	str	r3, [r1, #0]
 8016872:	bf18      	it	ne
 8016874:	b22d      	sxthne	r5, r5
 8016876:	e7ef      	b.n	8016858 <_printf_i+0xbc>
 8016878:	680b      	ldr	r3, [r1, #0]
 801687a:	6825      	ldr	r5, [r4, #0]
 801687c:	1d18      	adds	r0, r3, #4
 801687e:	6008      	str	r0, [r1, #0]
 8016880:	0628      	lsls	r0, r5, #24
 8016882:	d501      	bpl.n	8016888 <_printf_i+0xec>
 8016884:	681d      	ldr	r5, [r3, #0]
 8016886:	e002      	b.n	801688e <_printf_i+0xf2>
 8016888:	0669      	lsls	r1, r5, #25
 801688a:	d5fb      	bpl.n	8016884 <_printf_i+0xe8>
 801688c:	881d      	ldrh	r5, [r3, #0]
 801688e:	4854      	ldr	r0, [pc, #336]	; (80169e0 <_printf_i+0x244>)
 8016890:	2f6f      	cmp	r7, #111	; 0x6f
 8016892:	bf0c      	ite	eq
 8016894:	2308      	moveq	r3, #8
 8016896:	230a      	movne	r3, #10
 8016898:	2100      	movs	r1, #0
 801689a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801689e:	6866      	ldr	r6, [r4, #4]
 80168a0:	60a6      	str	r6, [r4, #8]
 80168a2:	2e00      	cmp	r6, #0
 80168a4:	bfa2      	ittt	ge
 80168a6:	6821      	ldrge	r1, [r4, #0]
 80168a8:	f021 0104 	bicge.w	r1, r1, #4
 80168ac:	6021      	strge	r1, [r4, #0]
 80168ae:	b90d      	cbnz	r5, 80168b4 <_printf_i+0x118>
 80168b0:	2e00      	cmp	r6, #0
 80168b2:	d04d      	beq.n	8016950 <_printf_i+0x1b4>
 80168b4:	4616      	mov	r6, r2
 80168b6:	fbb5 f1f3 	udiv	r1, r5, r3
 80168ba:	fb03 5711 	mls	r7, r3, r1, r5
 80168be:	5dc7      	ldrb	r7, [r0, r7]
 80168c0:	f806 7d01 	strb.w	r7, [r6, #-1]!
 80168c4:	462f      	mov	r7, r5
 80168c6:	42bb      	cmp	r3, r7
 80168c8:	460d      	mov	r5, r1
 80168ca:	d9f4      	bls.n	80168b6 <_printf_i+0x11a>
 80168cc:	2b08      	cmp	r3, #8
 80168ce:	d10b      	bne.n	80168e8 <_printf_i+0x14c>
 80168d0:	6823      	ldr	r3, [r4, #0]
 80168d2:	07df      	lsls	r7, r3, #31
 80168d4:	d508      	bpl.n	80168e8 <_printf_i+0x14c>
 80168d6:	6923      	ldr	r3, [r4, #16]
 80168d8:	6861      	ldr	r1, [r4, #4]
 80168da:	4299      	cmp	r1, r3
 80168dc:	bfde      	ittt	le
 80168de:	2330      	movle	r3, #48	; 0x30
 80168e0:	f806 3c01 	strble.w	r3, [r6, #-1]
 80168e4:	f106 36ff 	addle.w	r6, r6, #4294967295
 80168e8:	1b92      	subs	r2, r2, r6
 80168ea:	6122      	str	r2, [r4, #16]
 80168ec:	f8cd a000 	str.w	sl, [sp]
 80168f0:	464b      	mov	r3, r9
 80168f2:	aa03      	add	r2, sp, #12
 80168f4:	4621      	mov	r1, r4
 80168f6:	4640      	mov	r0, r8
 80168f8:	f7ff fee2 	bl	80166c0 <_printf_common>
 80168fc:	3001      	adds	r0, #1
 80168fe:	d14c      	bne.n	801699a <_printf_i+0x1fe>
 8016900:	f04f 30ff 	mov.w	r0, #4294967295
 8016904:	b004      	add	sp, #16
 8016906:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801690a:	4835      	ldr	r0, [pc, #212]	; (80169e0 <_printf_i+0x244>)
 801690c:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 8016910:	6823      	ldr	r3, [r4, #0]
 8016912:	680e      	ldr	r6, [r1, #0]
 8016914:	061f      	lsls	r7, r3, #24
 8016916:	f856 5b04 	ldr.w	r5, [r6], #4
 801691a:	600e      	str	r6, [r1, #0]
 801691c:	d514      	bpl.n	8016948 <_printf_i+0x1ac>
 801691e:	07d9      	lsls	r1, r3, #31
 8016920:	bf44      	itt	mi
 8016922:	f043 0320 	orrmi.w	r3, r3, #32
 8016926:	6023      	strmi	r3, [r4, #0]
 8016928:	b91d      	cbnz	r5, 8016932 <_printf_i+0x196>
 801692a:	6823      	ldr	r3, [r4, #0]
 801692c:	f023 0320 	bic.w	r3, r3, #32
 8016930:	6023      	str	r3, [r4, #0]
 8016932:	2310      	movs	r3, #16
 8016934:	e7b0      	b.n	8016898 <_printf_i+0xfc>
 8016936:	6823      	ldr	r3, [r4, #0]
 8016938:	f043 0320 	orr.w	r3, r3, #32
 801693c:	6023      	str	r3, [r4, #0]
 801693e:	2378      	movs	r3, #120	; 0x78
 8016940:	4828      	ldr	r0, [pc, #160]	; (80169e4 <_printf_i+0x248>)
 8016942:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8016946:	e7e3      	b.n	8016910 <_printf_i+0x174>
 8016948:	065e      	lsls	r6, r3, #25
 801694a:	bf48      	it	mi
 801694c:	b2ad      	uxthmi	r5, r5
 801694e:	e7e6      	b.n	801691e <_printf_i+0x182>
 8016950:	4616      	mov	r6, r2
 8016952:	e7bb      	b.n	80168cc <_printf_i+0x130>
 8016954:	680b      	ldr	r3, [r1, #0]
 8016956:	6826      	ldr	r6, [r4, #0]
 8016958:	6960      	ldr	r0, [r4, #20]
 801695a:	1d1d      	adds	r5, r3, #4
 801695c:	600d      	str	r5, [r1, #0]
 801695e:	0635      	lsls	r5, r6, #24
 8016960:	681b      	ldr	r3, [r3, #0]
 8016962:	d501      	bpl.n	8016968 <_printf_i+0x1cc>
 8016964:	6018      	str	r0, [r3, #0]
 8016966:	e002      	b.n	801696e <_printf_i+0x1d2>
 8016968:	0671      	lsls	r1, r6, #25
 801696a:	d5fb      	bpl.n	8016964 <_printf_i+0x1c8>
 801696c:	8018      	strh	r0, [r3, #0]
 801696e:	2300      	movs	r3, #0
 8016970:	6123      	str	r3, [r4, #16]
 8016972:	4616      	mov	r6, r2
 8016974:	e7ba      	b.n	80168ec <_printf_i+0x150>
 8016976:	680b      	ldr	r3, [r1, #0]
 8016978:	1d1a      	adds	r2, r3, #4
 801697a:	600a      	str	r2, [r1, #0]
 801697c:	681e      	ldr	r6, [r3, #0]
 801697e:	6862      	ldr	r2, [r4, #4]
 8016980:	2100      	movs	r1, #0
 8016982:	4630      	mov	r0, r6
 8016984:	f7e9 fc54 	bl	8000230 <memchr>
 8016988:	b108      	cbz	r0, 801698e <_printf_i+0x1f2>
 801698a:	1b80      	subs	r0, r0, r6
 801698c:	6060      	str	r0, [r4, #4]
 801698e:	6863      	ldr	r3, [r4, #4]
 8016990:	6123      	str	r3, [r4, #16]
 8016992:	2300      	movs	r3, #0
 8016994:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8016998:	e7a8      	b.n	80168ec <_printf_i+0x150>
 801699a:	6923      	ldr	r3, [r4, #16]
 801699c:	4632      	mov	r2, r6
 801699e:	4649      	mov	r1, r9
 80169a0:	4640      	mov	r0, r8
 80169a2:	47d0      	blx	sl
 80169a4:	3001      	adds	r0, #1
 80169a6:	d0ab      	beq.n	8016900 <_printf_i+0x164>
 80169a8:	6823      	ldr	r3, [r4, #0]
 80169aa:	079b      	lsls	r3, r3, #30
 80169ac:	d413      	bmi.n	80169d6 <_printf_i+0x23a>
 80169ae:	68e0      	ldr	r0, [r4, #12]
 80169b0:	9b03      	ldr	r3, [sp, #12]
 80169b2:	4298      	cmp	r0, r3
 80169b4:	bfb8      	it	lt
 80169b6:	4618      	movlt	r0, r3
 80169b8:	e7a4      	b.n	8016904 <_printf_i+0x168>
 80169ba:	2301      	movs	r3, #1
 80169bc:	4632      	mov	r2, r6
 80169be:	4649      	mov	r1, r9
 80169c0:	4640      	mov	r0, r8
 80169c2:	47d0      	blx	sl
 80169c4:	3001      	adds	r0, #1
 80169c6:	d09b      	beq.n	8016900 <_printf_i+0x164>
 80169c8:	3501      	adds	r5, #1
 80169ca:	68e3      	ldr	r3, [r4, #12]
 80169cc:	9903      	ldr	r1, [sp, #12]
 80169ce:	1a5b      	subs	r3, r3, r1
 80169d0:	42ab      	cmp	r3, r5
 80169d2:	dcf2      	bgt.n	80169ba <_printf_i+0x21e>
 80169d4:	e7eb      	b.n	80169ae <_printf_i+0x212>
 80169d6:	2500      	movs	r5, #0
 80169d8:	f104 0619 	add.w	r6, r4, #25
 80169dc:	e7f5      	b.n	80169ca <_printf_i+0x22e>
 80169de:	bf00      	nop
 80169e0:	0801add6 	.word	0x0801add6
 80169e4:	0801ade7 	.word	0x0801ade7

080169e8 <_sbrk_r>:
 80169e8:	b538      	push	{r3, r4, r5, lr}
 80169ea:	4d06      	ldr	r5, [pc, #24]	; (8016a04 <_sbrk_r+0x1c>)
 80169ec:	2300      	movs	r3, #0
 80169ee:	4604      	mov	r4, r0
 80169f0:	4608      	mov	r0, r1
 80169f2:	602b      	str	r3, [r5, #0]
 80169f4:	f7fe ffd4 	bl	80159a0 <_sbrk>
 80169f8:	1c43      	adds	r3, r0, #1
 80169fa:	d102      	bne.n	8016a02 <_sbrk_r+0x1a>
 80169fc:	682b      	ldr	r3, [r5, #0]
 80169fe:	b103      	cbz	r3, 8016a02 <_sbrk_r+0x1a>
 8016a00:	6023      	str	r3, [r4, #0]
 8016a02:	bd38      	pop	{r3, r4, r5, pc}
 8016a04:	2001a178 	.word	0x2001a178

08016a08 <siprintf>:
 8016a08:	b40e      	push	{r1, r2, r3}
 8016a0a:	b500      	push	{lr}
 8016a0c:	b09c      	sub	sp, #112	; 0x70
 8016a0e:	ab1d      	add	r3, sp, #116	; 0x74
 8016a10:	9002      	str	r0, [sp, #8]
 8016a12:	9006      	str	r0, [sp, #24]
 8016a14:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8016a18:	4809      	ldr	r0, [pc, #36]	; (8016a40 <siprintf+0x38>)
 8016a1a:	9107      	str	r1, [sp, #28]
 8016a1c:	9104      	str	r1, [sp, #16]
 8016a1e:	4909      	ldr	r1, [pc, #36]	; (8016a44 <siprintf+0x3c>)
 8016a20:	f853 2b04 	ldr.w	r2, [r3], #4
 8016a24:	9105      	str	r1, [sp, #20]
 8016a26:	6800      	ldr	r0, [r0, #0]
 8016a28:	9301      	str	r3, [sp, #4]
 8016a2a:	a902      	add	r1, sp, #8
 8016a2c:	f002 ffd4 	bl	80199d8 <_svfiprintf_r>
 8016a30:	9b02      	ldr	r3, [sp, #8]
 8016a32:	2200      	movs	r2, #0
 8016a34:	701a      	strb	r2, [r3, #0]
 8016a36:	b01c      	add	sp, #112	; 0x70
 8016a38:	f85d eb04 	ldr.w	lr, [sp], #4
 8016a3c:	b003      	add	sp, #12
 8016a3e:	4770      	bx	lr
 8016a40:	20000140 	.word	0x20000140
 8016a44:	ffff0208 	.word	0xffff0208

08016a48 <__sread>:
 8016a48:	b510      	push	{r4, lr}
 8016a4a:	460c      	mov	r4, r1
 8016a4c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8016a50:	f003 f8c2 	bl	8019bd8 <_read_r>
 8016a54:	2800      	cmp	r0, #0
 8016a56:	bfab      	itete	ge
 8016a58:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8016a5a:	89a3      	ldrhlt	r3, [r4, #12]
 8016a5c:	181b      	addge	r3, r3, r0
 8016a5e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8016a62:	bfac      	ite	ge
 8016a64:	6563      	strge	r3, [r4, #84]	; 0x54
 8016a66:	81a3      	strhlt	r3, [r4, #12]
 8016a68:	bd10      	pop	{r4, pc}

08016a6a <__swrite>:
 8016a6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016a6e:	461f      	mov	r7, r3
 8016a70:	898b      	ldrh	r3, [r1, #12]
 8016a72:	05db      	lsls	r3, r3, #23
 8016a74:	4605      	mov	r5, r0
 8016a76:	460c      	mov	r4, r1
 8016a78:	4616      	mov	r6, r2
 8016a7a:	d505      	bpl.n	8016a88 <__swrite+0x1e>
 8016a7c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8016a80:	2302      	movs	r3, #2
 8016a82:	2200      	movs	r2, #0
 8016a84:	f002 fa62 	bl	8018f4c <_lseek_r>
 8016a88:	89a3      	ldrh	r3, [r4, #12]
 8016a8a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8016a8e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8016a92:	81a3      	strh	r3, [r4, #12]
 8016a94:	4632      	mov	r2, r6
 8016a96:	463b      	mov	r3, r7
 8016a98:	4628      	mov	r0, r5
 8016a9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8016a9e:	f000 bfb7 	b.w	8017a10 <_write_r>

08016aa2 <__sseek>:
 8016aa2:	b510      	push	{r4, lr}
 8016aa4:	460c      	mov	r4, r1
 8016aa6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8016aaa:	f002 fa4f 	bl	8018f4c <_lseek_r>
 8016aae:	1c43      	adds	r3, r0, #1
 8016ab0:	89a3      	ldrh	r3, [r4, #12]
 8016ab2:	bf15      	itete	ne
 8016ab4:	6560      	strne	r0, [r4, #84]	; 0x54
 8016ab6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8016aba:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8016abe:	81a3      	strheq	r3, [r4, #12]
 8016ac0:	bf18      	it	ne
 8016ac2:	81a3      	strhne	r3, [r4, #12]
 8016ac4:	bd10      	pop	{r4, pc}

08016ac6 <__sclose>:
 8016ac6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8016aca:	f001 b821 	b.w	8017b10 <_close_r>

08016ace <stpcpy>:
 8016ace:	4603      	mov	r3, r0
 8016ad0:	f811 2b01 	ldrb.w	r2, [r1], #1
 8016ad4:	4618      	mov	r0, r3
 8016ad6:	f803 2b01 	strb.w	r2, [r3], #1
 8016ada:	2a00      	cmp	r2, #0
 8016adc:	d1f8      	bne.n	8016ad0 <stpcpy+0x2>
 8016ade:	4770      	bx	lr

08016ae0 <strcat>:
 8016ae0:	b510      	push	{r4, lr}
 8016ae2:	4602      	mov	r2, r0
 8016ae4:	7814      	ldrb	r4, [r2, #0]
 8016ae6:	4613      	mov	r3, r2
 8016ae8:	3201      	adds	r2, #1
 8016aea:	2c00      	cmp	r4, #0
 8016aec:	d1fa      	bne.n	8016ae4 <strcat+0x4>
 8016aee:	3b01      	subs	r3, #1
 8016af0:	f811 2b01 	ldrb.w	r2, [r1], #1
 8016af4:	f803 2f01 	strb.w	r2, [r3, #1]!
 8016af8:	2a00      	cmp	r2, #0
 8016afa:	d1f9      	bne.n	8016af0 <strcat+0x10>
 8016afc:	bd10      	pop	{r4, pc}

08016afe <strchr>:
 8016afe:	b2c9      	uxtb	r1, r1
 8016b00:	4603      	mov	r3, r0
 8016b02:	f810 2b01 	ldrb.w	r2, [r0], #1
 8016b06:	b11a      	cbz	r2, 8016b10 <strchr+0x12>
 8016b08:	428a      	cmp	r2, r1
 8016b0a:	d1f9      	bne.n	8016b00 <strchr+0x2>
 8016b0c:	4618      	mov	r0, r3
 8016b0e:	4770      	bx	lr
 8016b10:	2900      	cmp	r1, #0
 8016b12:	bf18      	it	ne
 8016b14:	2300      	movne	r3, #0
 8016b16:	e7f9      	b.n	8016b0c <strchr+0xe>

08016b18 <strncmp>:
 8016b18:	b510      	push	{r4, lr}
 8016b1a:	b16a      	cbz	r2, 8016b38 <strncmp+0x20>
 8016b1c:	3901      	subs	r1, #1
 8016b1e:	1884      	adds	r4, r0, r2
 8016b20:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016b24:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8016b28:	4293      	cmp	r3, r2
 8016b2a:	d103      	bne.n	8016b34 <strncmp+0x1c>
 8016b2c:	42a0      	cmp	r0, r4
 8016b2e:	d001      	beq.n	8016b34 <strncmp+0x1c>
 8016b30:	2b00      	cmp	r3, #0
 8016b32:	d1f5      	bne.n	8016b20 <strncmp+0x8>
 8016b34:	1a98      	subs	r0, r3, r2
 8016b36:	bd10      	pop	{r4, pc}
 8016b38:	4610      	mov	r0, r2
 8016b3a:	e7fc      	b.n	8016b36 <strncmp+0x1e>

08016b3c <strncpy>:
 8016b3c:	b510      	push	{r4, lr}
 8016b3e:	3901      	subs	r1, #1
 8016b40:	4603      	mov	r3, r0
 8016b42:	b132      	cbz	r2, 8016b52 <strncpy+0x16>
 8016b44:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8016b48:	f803 4b01 	strb.w	r4, [r3], #1
 8016b4c:	3a01      	subs	r2, #1
 8016b4e:	2c00      	cmp	r4, #0
 8016b50:	d1f7      	bne.n	8016b42 <strncpy+0x6>
 8016b52:	441a      	add	r2, r3
 8016b54:	2100      	movs	r1, #0
 8016b56:	4293      	cmp	r3, r2
 8016b58:	d100      	bne.n	8016b5c <strncpy+0x20>
 8016b5a:	bd10      	pop	{r4, pc}
 8016b5c:	f803 1b01 	strb.w	r1, [r3], #1
 8016b60:	e7f9      	b.n	8016b56 <strncpy+0x1a>

08016b62 <sulp>:
 8016b62:	b570      	push	{r4, r5, r6, lr}
 8016b64:	4604      	mov	r4, r0
 8016b66:	460d      	mov	r5, r1
 8016b68:	ec45 4b10 	vmov	d0, r4, r5
 8016b6c:	4616      	mov	r6, r2
 8016b6e:	f002 fd89 	bl	8019684 <__ulp>
 8016b72:	ec51 0b10 	vmov	r0, r1, d0
 8016b76:	b17e      	cbz	r6, 8016b98 <sulp+0x36>
 8016b78:	f3c5 530a 	ubfx	r3, r5, #20, #11
 8016b7c:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8016b80:	2b00      	cmp	r3, #0
 8016b82:	dd09      	ble.n	8016b98 <sulp+0x36>
 8016b84:	051b      	lsls	r3, r3, #20
 8016b86:	f103 557f 	add.w	r5, r3, #1069547520	; 0x3fc00000
 8016b8a:	2400      	movs	r4, #0
 8016b8c:	f505 1540 	add.w	r5, r5, #3145728	; 0x300000
 8016b90:	4622      	mov	r2, r4
 8016b92:	462b      	mov	r3, r5
 8016b94:	f7e9 fd58 	bl	8000648 <__aeabi_dmul>
 8016b98:	bd70      	pop	{r4, r5, r6, pc}
 8016b9a:	0000      	movs	r0, r0
 8016b9c:	0000      	movs	r0, r0
	...

08016ba0 <_strtod_l>:
 8016ba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016ba4:	b0a3      	sub	sp, #140	; 0x8c
 8016ba6:	461f      	mov	r7, r3
 8016ba8:	2300      	movs	r3, #0
 8016baa:	931e      	str	r3, [sp, #120]	; 0x78
 8016bac:	4ba4      	ldr	r3, [pc, #656]	; (8016e40 <_strtod_l+0x2a0>)
 8016bae:	9219      	str	r2, [sp, #100]	; 0x64
 8016bb0:	681b      	ldr	r3, [r3, #0]
 8016bb2:	9307      	str	r3, [sp, #28]
 8016bb4:	4604      	mov	r4, r0
 8016bb6:	4618      	mov	r0, r3
 8016bb8:	4688      	mov	r8, r1
 8016bba:	f7e9 fb2b 	bl	8000214 <strlen>
 8016bbe:	f04f 0a00 	mov.w	sl, #0
 8016bc2:	4605      	mov	r5, r0
 8016bc4:	f04f 0b00 	mov.w	fp, #0
 8016bc8:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8016bcc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016bce:	781a      	ldrb	r2, [r3, #0]
 8016bd0:	2a2b      	cmp	r2, #43	; 0x2b
 8016bd2:	d04c      	beq.n	8016c6e <_strtod_l+0xce>
 8016bd4:	d839      	bhi.n	8016c4a <_strtod_l+0xaa>
 8016bd6:	2a0d      	cmp	r2, #13
 8016bd8:	d832      	bhi.n	8016c40 <_strtod_l+0xa0>
 8016bda:	2a08      	cmp	r2, #8
 8016bdc:	d832      	bhi.n	8016c44 <_strtod_l+0xa4>
 8016bde:	2a00      	cmp	r2, #0
 8016be0:	d03c      	beq.n	8016c5c <_strtod_l+0xbc>
 8016be2:	2300      	movs	r3, #0
 8016be4:	930e      	str	r3, [sp, #56]	; 0x38
 8016be6:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8016be8:	7833      	ldrb	r3, [r6, #0]
 8016bea:	2b30      	cmp	r3, #48	; 0x30
 8016bec:	f040 80b4 	bne.w	8016d58 <_strtod_l+0x1b8>
 8016bf0:	7873      	ldrb	r3, [r6, #1]
 8016bf2:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8016bf6:	2b58      	cmp	r3, #88	; 0x58
 8016bf8:	d16c      	bne.n	8016cd4 <_strtod_l+0x134>
 8016bfa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8016bfc:	9301      	str	r3, [sp, #4]
 8016bfe:	ab1e      	add	r3, sp, #120	; 0x78
 8016c00:	9702      	str	r7, [sp, #8]
 8016c02:	9300      	str	r3, [sp, #0]
 8016c04:	4a8f      	ldr	r2, [pc, #572]	; (8016e44 <_strtod_l+0x2a4>)
 8016c06:	ab1f      	add	r3, sp, #124	; 0x7c
 8016c08:	a91d      	add	r1, sp, #116	; 0x74
 8016c0a:	4620      	mov	r0, r4
 8016c0c:	f001 fe82 	bl	8018914 <__gethex>
 8016c10:	f010 0707 	ands.w	r7, r0, #7
 8016c14:	4605      	mov	r5, r0
 8016c16:	d005      	beq.n	8016c24 <_strtod_l+0x84>
 8016c18:	2f06      	cmp	r7, #6
 8016c1a:	d12a      	bne.n	8016c72 <_strtod_l+0xd2>
 8016c1c:	3601      	adds	r6, #1
 8016c1e:	2300      	movs	r3, #0
 8016c20:	961d      	str	r6, [sp, #116]	; 0x74
 8016c22:	930e      	str	r3, [sp, #56]	; 0x38
 8016c24:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8016c26:	2b00      	cmp	r3, #0
 8016c28:	f040 8596 	bne.w	8017758 <_strtod_l+0xbb8>
 8016c2c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8016c2e:	b1db      	cbz	r3, 8016c68 <_strtod_l+0xc8>
 8016c30:	4652      	mov	r2, sl
 8016c32:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 8016c36:	ec43 2b10 	vmov	d0, r2, r3
 8016c3a:	b023      	add	sp, #140	; 0x8c
 8016c3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016c40:	2a20      	cmp	r2, #32
 8016c42:	d1ce      	bne.n	8016be2 <_strtod_l+0x42>
 8016c44:	3301      	adds	r3, #1
 8016c46:	931d      	str	r3, [sp, #116]	; 0x74
 8016c48:	e7c0      	b.n	8016bcc <_strtod_l+0x2c>
 8016c4a:	2a2d      	cmp	r2, #45	; 0x2d
 8016c4c:	d1c9      	bne.n	8016be2 <_strtod_l+0x42>
 8016c4e:	2201      	movs	r2, #1
 8016c50:	920e      	str	r2, [sp, #56]	; 0x38
 8016c52:	1c5a      	adds	r2, r3, #1
 8016c54:	921d      	str	r2, [sp, #116]	; 0x74
 8016c56:	785b      	ldrb	r3, [r3, #1]
 8016c58:	2b00      	cmp	r3, #0
 8016c5a:	d1c4      	bne.n	8016be6 <_strtod_l+0x46>
 8016c5c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8016c5e:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8016c62:	2b00      	cmp	r3, #0
 8016c64:	f040 8576 	bne.w	8017754 <_strtod_l+0xbb4>
 8016c68:	4652      	mov	r2, sl
 8016c6a:	465b      	mov	r3, fp
 8016c6c:	e7e3      	b.n	8016c36 <_strtod_l+0x96>
 8016c6e:	2200      	movs	r2, #0
 8016c70:	e7ee      	b.n	8016c50 <_strtod_l+0xb0>
 8016c72:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8016c74:	b13a      	cbz	r2, 8016c86 <_strtod_l+0xe6>
 8016c76:	2135      	movs	r1, #53	; 0x35
 8016c78:	a820      	add	r0, sp, #128	; 0x80
 8016c7a:	f002 fe0e 	bl	801989a <__copybits>
 8016c7e:	991e      	ldr	r1, [sp, #120]	; 0x78
 8016c80:	4620      	mov	r0, r4
 8016c82:	f002 f9d3 	bl	801902c <_Bfree>
 8016c86:	3f01      	subs	r7, #1
 8016c88:	2f05      	cmp	r7, #5
 8016c8a:	d807      	bhi.n	8016c9c <_strtod_l+0xfc>
 8016c8c:	e8df f007 	tbb	[pc, r7]
 8016c90:	1d180b0e 	.word	0x1d180b0e
 8016c94:	030e      	.short	0x030e
 8016c96:	f04f 0b00 	mov.w	fp, #0
 8016c9a:	46da      	mov	sl, fp
 8016c9c:	0728      	lsls	r0, r5, #28
 8016c9e:	d5c1      	bpl.n	8016c24 <_strtod_l+0x84>
 8016ca0:	f04b 4b00 	orr.w	fp, fp, #2147483648	; 0x80000000
 8016ca4:	e7be      	b.n	8016c24 <_strtod_l+0x84>
 8016ca6:	e9dd ab20 	ldrd	sl, fp, [sp, #128]	; 0x80
 8016caa:	e7f7      	b.n	8016c9c <_strtod_l+0xfc>
 8016cac:	e9dd a320 	ldrd	sl, r3, [sp, #128]	; 0x80
 8016cb0:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 8016cb2:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8016cb6:	f202 4233 	addw	r2, r2, #1075	; 0x433
 8016cba:	ea43 5b02 	orr.w	fp, r3, r2, lsl #20
 8016cbe:	e7ed      	b.n	8016c9c <_strtod_l+0xfc>
 8016cc0:	f8df b184 	ldr.w	fp, [pc, #388]	; 8016e48 <_strtod_l+0x2a8>
 8016cc4:	f04f 0a00 	mov.w	sl, #0
 8016cc8:	e7e8      	b.n	8016c9c <_strtod_l+0xfc>
 8016cca:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
 8016cce:	f04f 3aff 	mov.w	sl, #4294967295
 8016cd2:	e7e3      	b.n	8016c9c <_strtod_l+0xfc>
 8016cd4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016cd6:	1c5a      	adds	r2, r3, #1
 8016cd8:	921d      	str	r2, [sp, #116]	; 0x74
 8016cda:	785b      	ldrb	r3, [r3, #1]
 8016cdc:	2b30      	cmp	r3, #48	; 0x30
 8016cde:	d0f9      	beq.n	8016cd4 <_strtod_l+0x134>
 8016ce0:	2b00      	cmp	r3, #0
 8016ce2:	d09f      	beq.n	8016c24 <_strtod_l+0x84>
 8016ce4:	2301      	movs	r3, #1
 8016ce6:	f04f 0900 	mov.w	r9, #0
 8016cea:	9304      	str	r3, [sp, #16]
 8016cec:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016cee:	930a      	str	r3, [sp, #40]	; 0x28
 8016cf0:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8016cf4:	464f      	mov	r7, r9
 8016cf6:	220a      	movs	r2, #10
 8016cf8:	981d      	ldr	r0, [sp, #116]	; 0x74
 8016cfa:	7806      	ldrb	r6, [r0, #0]
 8016cfc:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 8016d00:	b2d9      	uxtb	r1, r3
 8016d02:	2909      	cmp	r1, #9
 8016d04:	d92a      	bls.n	8016d5c <_strtod_l+0x1bc>
 8016d06:	9907      	ldr	r1, [sp, #28]
 8016d08:	462a      	mov	r2, r5
 8016d0a:	f7ff ff05 	bl	8016b18 <strncmp>
 8016d0e:	b398      	cbz	r0, 8016d78 <_strtod_l+0x1d8>
 8016d10:	2000      	movs	r0, #0
 8016d12:	4633      	mov	r3, r6
 8016d14:	463d      	mov	r5, r7
 8016d16:	9007      	str	r0, [sp, #28]
 8016d18:	4602      	mov	r2, r0
 8016d1a:	2b65      	cmp	r3, #101	; 0x65
 8016d1c:	d001      	beq.n	8016d22 <_strtod_l+0x182>
 8016d1e:	2b45      	cmp	r3, #69	; 0x45
 8016d20:	d118      	bne.n	8016d54 <_strtod_l+0x1b4>
 8016d22:	b91d      	cbnz	r5, 8016d2c <_strtod_l+0x18c>
 8016d24:	9b04      	ldr	r3, [sp, #16]
 8016d26:	4303      	orrs	r3, r0
 8016d28:	d098      	beq.n	8016c5c <_strtod_l+0xbc>
 8016d2a:	2500      	movs	r5, #0
 8016d2c:	f8dd 8074 	ldr.w	r8, [sp, #116]	; 0x74
 8016d30:	f108 0301 	add.w	r3, r8, #1
 8016d34:	931d      	str	r3, [sp, #116]	; 0x74
 8016d36:	f898 3001 	ldrb.w	r3, [r8, #1]
 8016d3a:	2b2b      	cmp	r3, #43	; 0x2b
 8016d3c:	d075      	beq.n	8016e2a <_strtod_l+0x28a>
 8016d3e:	2b2d      	cmp	r3, #45	; 0x2d
 8016d40:	d07b      	beq.n	8016e3a <_strtod_l+0x29a>
 8016d42:	f04f 0c00 	mov.w	ip, #0
 8016d46:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8016d4a:	2909      	cmp	r1, #9
 8016d4c:	f240 8082 	bls.w	8016e54 <_strtod_l+0x2b4>
 8016d50:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8016d54:	2600      	movs	r6, #0
 8016d56:	e09d      	b.n	8016e94 <_strtod_l+0x2f4>
 8016d58:	2300      	movs	r3, #0
 8016d5a:	e7c4      	b.n	8016ce6 <_strtod_l+0x146>
 8016d5c:	2f08      	cmp	r7, #8
 8016d5e:	bfd8      	it	le
 8016d60:	9909      	ldrle	r1, [sp, #36]	; 0x24
 8016d62:	f100 0001 	add.w	r0, r0, #1
 8016d66:	bfda      	itte	le
 8016d68:	fb02 3301 	mlale	r3, r2, r1, r3
 8016d6c:	9309      	strle	r3, [sp, #36]	; 0x24
 8016d6e:	fb02 3909 	mlagt	r9, r2, r9, r3
 8016d72:	3701      	adds	r7, #1
 8016d74:	901d      	str	r0, [sp, #116]	; 0x74
 8016d76:	e7bf      	b.n	8016cf8 <_strtod_l+0x158>
 8016d78:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016d7a:	195a      	adds	r2, r3, r5
 8016d7c:	921d      	str	r2, [sp, #116]	; 0x74
 8016d7e:	5d5b      	ldrb	r3, [r3, r5]
 8016d80:	2f00      	cmp	r7, #0
 8016d82:	d037      	beq.n	8016df4 <_strtod_l+0x254>
 8016d84:	9007      	str	r0, [sp, #28]
 8016d86:	463d      	mov	r5, r7
 8016d88:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8016d8c:	2a09      	cmp	r2, #9
 8016d8e:	d912      	bls.n	8016db6 <_strtod_l+0x216>
 8016d90:	2201      	movs	r2, #1
 8016d92:	e7c2      	b.n	8016d1a <_strtod_l+0x17a>
 8016d94:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016d96:	1c5a      	adds	r2, r3, #1
 8016d98:	921d      	str	r2, [sp, #116]	; 0x74
 8016d9a:	785b      	ldrb	r3, [r3, #1]
 8016d9c:	3001      	adds	r0, #1
 8016d9e:	2b30      	cmp	r3, #48	; 0x30
 8016da0:	d0f8      	beq.n	8016d94 <_strtod_l+0x1f4>
 8016da2:	f1a3 0231 	sub.w	r2, r3, #49	; 0x31
 8016da6:	2a08      	cmp	r2, #8
 8016da8:	f200 84db 	bhi.w	8017762 <_strtod_l+0xbc2>
 8016dac:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8016dae:	9007      	str	r0, [sp, #28]
 8016db0:	2000      	movs	r0, #0
 8016db2:	920a      	str	r2, [sp, #40]	; 0x28
 8016db4:	4605      	mov	r5, r0
 8016db6:	3b30      	subs	r3, #48	; 0x30
 8016db8:	f100 0201 	add.w	r2, r0, #1
 8016dbc:	d014      	beq.n	8016de8 <_strtod_l+0x248>
 8016dbe:	9907      	ldr	r1, [sp, #28]
 8016dc0:	4411      	add	r1, r2
 8016dc2:	9107      	str	r1, [sp, #28]
 8016dc4:	462a      	mov	r2, r5
 8016dc6:	eb00 0e05 	add.w	lr, r0, r5
 8016dca:	210a      	movs	r1, #10
 8016dcc:	4572      	cmp	r2, lr
 8016dce:	d113      	bne.n	8016df8 <_strtod_l+0x258>
 8016dd0:	182a      	adds	r2, r5, r0
 8016dd2:	2a08      	cmp	r2, #8
 8016dd4:	f105 0501 	add.w	r5, r5, #1
 8016dd8:	4405      	add	r5, r0
 8016dda:	dc1c      	bgt.n	8016e16 <_strtod_l+0x276>
 8016ddc:	9909      	ldr	r1, [sp, #36]	; 0x24
 8016dde:	220a      	movs	r2, #10
 8016de0:	fb02 3301 	mla	r3, r2, r1, r3
 8016de4:	9309      	str	r3, [sp, #36]	; 0x24
 8016de6:	2200      	movs	r2, #0
 8016de8:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016dea:	1c59      	adds	r1, r3, #1
 8016dec:	911d      	str	r1, [sp, #116]	; 0x74
 8016dee:	785b      	ldrb	r3, [r3, #1]
 8016df0:	4610      	mov	r0, r2
 8016df2:	e7c9      	b.n	8016d88 <_strtod_l+0x1e8>
 8016df4:	4638      	mov	r0, r7
 8016df6:	e7d2      	b.n	8016d9e <_strtod_l+0x1fe>
 8016df8:	2a08      	cmp	r2, #8
 8016dfa:	dc04      	bgt.n	8016e06 <_strtod_l+0x266>
 8016dfc:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8016dfe:	434e      	muls	r6, r1
 8016e00:	9609      	str	r6, [sp, #36]	; 0x24
 8016e02:	3201      	adds	r2, #1
 8016e04:	e7e2      	b.n	8016dcc <_strtod_l+0x22c>
 8016e06:	f102 0c01 	add.w	ip, r2, #1
 8016e0a:	f1bc 0f10 	cmp.w	ip, #16
 8016e0e:	bfd8      	it	le
 8016e10:	fb01 f909 	mulle.w	r9, r1, r9
 8016e14:	e7f5      	b.n	8016e02 <_strtod_l+0x262>
 8016e16:	2d10      	cmp	r5, #16
 8016e18:	bfdc      	itt	le
 8016e1a:	220a      	movle	r2, #10
 8016e1c:	fb02 3909 	mlale	r9, r2, r9, r3
 8016e20:	e7e1      	b.n	8016de6 <_strtod_l+0x246>
 8016e22:	2300      	movs	r3, #0
 8016e24:	9307      	str	r3, [sp, #28]
 8016e26:	2201      	movs	r2, #1
 8016e28:	e77c      	b.n	8016d24 <_strtod_l+0x184>
 8016e2a:	f04f 0c00 	mov.w	ip, #0
 8016e2e:	f108 0302 	add.w	r3, r8, #2
 8016e32:	931d      	str	r3, [sp, #116]	; 0x74
 8016e34:	f898 3002 	ldrb.w	r3, [r8, #2]
 8016e38:	e785      	b.n	8016d46 <_strtod_l+0x1a6>
 8016e3a:	f04f 0c01 	mov.w	ip, #1
 8016e3e:	e7f6      	b.n	8016e2e <_strtod_l+0x28e>
 8016e40:	0801af6c 	.word	0x0801af6c
 8016e44:	0801adf8 	.word	0x0801adf8
 8016e48:	7ff00000 	.word	0x7ff00000
 8016e4c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016e4e:	1c59      	adds	r1, r3, #1
 8016e50:	911d      	str	r1, [sp, #116]	; 0x74
 8016e52:	785b      	ldrb	r3, [r3, #1]
 8016e54:	2b30      	cmp	r3, #48	; 0x30
 8016e56:	d0f9      	beq.n	8016e4c <_strtod_l+0x2ac>
 8016e58:	f1a3 0131 	sub.w	r1, r3, #49	; 0x31
 8016e5c:	2908      	cmp	r1, #8
 8016e5e:	f63f af79 	bhi.w	8016d54 <_strtod_l+0x1b4>
 8016e62:	f1a3 0e30 	sub.w	lr, r3, #48	; 0x30
 8016e66:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016e68:	9308      	str	r3, [sp, #32]
 8016e6a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016e6c:	1c59      	adds	r1, r3, #1
 8016e6e:	911d      	str	r1, [sp, #116]	; 0x74
 8016e70:	785b      	ldrb	r3, [r3, #1]
 8016e72:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 8016e76:	2e09      	cmp	r6, #9
 8016e78:	d937      	bls.n	8016eea <_strtod_l+0x34a>
 8016e7a:	9e08      	ldr	r6, [sp, #32]
 8016e7c:	1b89      	subs	r1, r1, r6
 8016e7e:	2908      	cmp	r1, #8
 8016e80:	f644 661f 	movw	r6, #19999	; 0x4e1f
 8016e84:	dc02      	bgt.n	8016e8c <_strtod_l+0x2ec>
 8016e86:	4576      	cmp	r6, lr
 8016e88:	bfa8      	it	ge
 8016e8a:	4676      	movge	r6, lr
 8016e8c:	f1bc 0f00 	cmp.w	ip, #0
 8016e90:	d000      	beq.n	8016e94 <_strtod_l+0x2f4>
 8016e92:	4276      	negs	r6, r6
 8016e94:	2d00      	cmp	r5, #0
 8016e96:	d14f      	bne.n	8016f38 <_strtod_l+0x398>
 8016e98:	9904      	ldr	r1, [sp, #16]
 8016e9a:	4301      	orrs	r1, r0
 8016e9c:	f47f aec2 	bne.w	8016c24 <_strtod_l+0x84>
 8016ea0:	2a00      	cmp	r2, #0
 8016ea2:	f47f aedb 	bne.w	8016c5c <_strtod_l+0xbc>
 8016ea6:	2b69      	cmp	r3, #105	; 0x69
 8016ea8:	d027      	beq.n	8016efa <_strtod_l+0x35a>
 8016eaa:	dc24      	bgt.n	8016ef6 <_strtod_l+0x356>
 8016eac:	2b49      	cmp	r3, #73	; 0x49
 8016eae:	d024      	beq.n	8016efa <_strtod_l+0x35a>
 8016eb0:	2b4e      	cmp	r3, #78	; 0x4e
 8016eb2:	f47f aed3 	bne.w	8016c5c <_strtod_l+0xbc>
 8016eb6:	499e      	ldr	r1, [pc, #632]	; (8017130 <_strtod_l+0x590>)
 8016eb8:	a81d      	add	r0, sp, #116	; 0x74
 8016eba:	f001 ff83 	bl	8018dc4 <__match>
 8016ebe:	2800      	cmp	r0, #0
 8016ec0:	f43f aecc 	beq.w	8016c5c <_strtod_l+0xbc>
 8016ec4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016ec6:	781b      	ldrb	r3, [r3, #0]
 8016ec8:	2b28      	cmp	r3, #40	; 0x28
 8016eca:	d12d      	bne.n	8016f28 <_strtod_l+0x388>
 8016ecc:	4999      	ldr	r1, [pc, #612]	; (8017134 <_strtod_l+0x594>)
 8016ece:	aa20      	add	r2, sp, #128	; 0x80
 8016ed0:	a81d      	add	r0, sp, #116	; 0x74
 8016ed2:	f001 ff8b 	bl	8018dec <__hexnan>
 8016ed6:	2805      	cmp	r0, #5
 8016ed8:	d126      	bne.n	8016f28 <_strtod_l+0x388>
 8016eda:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8016edc:	f8dd a080 	ldr.w	sl, [sp, #128]	; 0x80
 8016ee0:	f043 4bff 	orr.w	fp, r3, #2139095040	; 0x7f800000
 8016ee4:	f44b 0be0 	orr.w	fp, fp, #7340032	; 0x700000
 8016ee8:	e69c      	b.n	8016c24 <_strtod_l+0x84>
 8016eea:	210a      	movs	r1, #10
 8016eec:	fb01 3e0e 	mla	lr, r1, lr, r3
 8016ef0:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
 8016ef4:	e7b9      	b.n	8016e6a <_strtod_l+0x2ca>
 8016ef6:	2b6e      	cmp	r3, #110	; 0x6e
 8016ef8:	e7db      	b.n	8016eb2 <_strtod_l+0x312>
 8016efa:	498f      	ldr	r1, [pc, #572]	; (8017138 <_strtod_l+0x598>)
 8016efc:	a81d      	add	r0, sp, #116	; 0x74
 8016efe:	f001 ff61 	bl	8018dc4 <__match>
 8016f02:	2800      	cmp	r0, #0
 8016f04:	f43f aeaa 	beq.w	8016c5c <_strtod_l+0xbc>
 8016f08:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016f0a:	498c      	ldr	r1, [pc, #560]	; (801713c <_strtod_l+0x59c>)
 8016f0c:	3b01      	subs	r3, #1
 8016f0e:	a81d      	add	r0, sp, #116	; 0x74
 8016f10:	931d      	str	r3, [sp, #116]	; 0x74
 8016f12:	f001 ff57 	bl	8018dc4 <__match>
 8016f16:	b910      	cbnz	r0, 8016f1e <_strtod_l+0x37e>
 8016f18:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016f1a:	3301      	adds	r3, #1
 8016f1c:	931d      	str	r3, [sp, #116]	; 0x74
 8016f1e:	f8df b22c 	ldr.w	fp, [pc, #556]	; 801714c <_strtod_l+0x5ac>
 8016f22:	f04f 0a00 	mov.w	sl, #0
 8016f26:	e67d      	b.n	8016c24 <_strtod_l+0x84>
 8016f28:	4885      	ldr	r0, [pc, #532]	; (8017140 <_strtod_l+0x5a0>)
 8016f2a:	f002 fe69 	bl	8019c00 <nan>
 8016f2e:	ed8d 0b04 	vstr	d0, [sp, #16]
 8016f32:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8016f36:	e675      	b.n	8016c24 <_strtod_l+0x84>
 8016f38:	9b07      	ldr	r3, [sp, #28]
 8016f3a:	9809      	ldr	r0, [sp, #36]	; 0x24
 8016f3c:	1af3      	subs	r3, r6, r3
 8016f3e:	2f00      	cmp	r7, #0
 8016f40:	bf08      	it	eq
 8016f42:	462f      	moveq	r7, r5
 8016f44:	2d10      	cmp	r5, #16
 8016f46:	9308      	str	r3, [sp, #32]
 8016f48:	46a8      	mov	r8, r5
 8016f4a:	bfa8      	it	ge
 8016f4c:	f04f 0810 	movge.w	r8, #16
 8016f50:	f7e9 fb00 	bl	8000554 <__aeabi_ui2d>
 8016f54:	2d09      	cmp	r5, #9
 8016f56:	4682      	mov	sl, r0
 8016f58:	468b      	mov	fp, r1
 8016f5a:	dd13      	ble.n	8016f84 <_strtod_l+0x3e4>
 8016f5c:	4b79      	ldr	r3, [pc, #484]	; (8017144 <_strtod_l+0x5a4>)
 8016f5e:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 8016f62:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
 8016f66:	f7e9 fb6f 	bl	8000648 <__aeabi_dmul>
 8016f6a:	4682      	mov	sl, r0
 8016f6c:	4648      	mov	r0, r9
 8016f6e:	468b      	mov	fp, r1
 8016f70:	f7e9 faf0 	bl	8000554 <__aeabi_ui2d>
 8016f74:	4602      	mov	r2, r0
 8016f76:	460b      	mov	r3, r1
 8016f78:	4650      	mov	r0, sl
 8016f7a:	4659      	mov	r1, fp
 8016f7c:	f7e9 f9ae 	bl	80002dc <__adddf3>
 8016f80:	4682      	mov	sl, r0
 8016f82:	468b      	mov	fp, r1
 8016f84:	2d0f      	cmp	r5, #15
 8016f86:	dc38      	bgt.n	8016ffa <_strtod_l+0x45a>
 8016f88:	9b08      	ldr	r3, [sp, #32]
 8016f8a:	2b00      	cmp	r3, #0
 8016f8c:	f43f ae4a 	beq.w	8016c24 <_strtod_l+0x84>
 8016f90:	dd24      	ble.n	8016fdc <_strtod_l+0x43c>
 8016f92:	2b16      	cmp	r3, #22
 8016f94:	dc0b      	bgt.n	8016fae <_strtod_l+0x40e>
 8016f96:	4d6b      	ldr	r5, [pc, #428]	; (8017144 <_strtod_l+0x5a4>)
 8016f98:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8016f9c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8016fa0:	4652      	mov	r2, sl
 8016fa2:	465b      	mov	r3, fp
 8016fa4:	f7e9 fb50 	bl	8000648 <__aeabi_dmul>
 8016fa8:	4682      	mov	sl, r0
 8016faa:	468b      	mov	fp, r1
 8016fac:	e63a      	b.n	8016c24 <_strtod_l+0x84>
 8016fae:	9a08      	ldr	r2, [sp, #32]
 8016fb0:	f1c5 0325 	rsb	r3, r5, #37	; 0x25
 8016fb4:	4293      	cmp	r3, r2
 8016fb6:	db20      	blt.n	8016ffa <_strtod_l+0x45a>
 8016fb8:	4c62      	ldr	r4, [pc, #392]	; (8017144 <_strtod_l+0x5a4>)
 8016fba:	f1c5 050f 	rsb	r5, r5, #15
 8016fbe:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
 8016fc2:	4652      	mov	r2, sl
 8016fc4:	465b      	mov	r3, fp
 8016fc6:	e9d1 0100 	ldrd	r0, r1, [r1]
 8016fca:	f7e9 fb3d 	bl	8000648 <__aeabi_dmul>
 8016fce:	9b08      	ldr	r3, [sp, #32]
 8016fd0:	1b5d      	subs	r5, r3, r5
 8016fd2:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 8016fd6:	e9d4 2300 	ldrd	r2, r3, [r4]
 8016fda:	e7e3      	b.n	8016fa4 <_strtod_l+0x404>
 8016fdc:	9b08      	ldr	r3, [sp, #32]
 8016fde:	3316      	adds	r3, #22
 8016fe0:	db0b      	blt.n	8016ffa <_strtod_l+0x45a>
 8016fe2:	9b07      	ldr	r3, [sp, #28]
 8016fe4:	4a57      	ldr	r2, [pc, #348]	; (8017144 <_strtod_l+0x5a4>)
 8016fe6:	1b9e      	subs	r6, r3, r6
 8016fe8:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
 8016fec:	e9d6 2300 	ldrd	r2, r3, [r6]
 8016ff0:	4650      	mov	r0, sl
 8016ff2:	4659      	mov	r1, fp
 8016ff4:	f7e9 fc52 	bl	800089c <__aeabi_ddiv>
 8016ff8:	e7d6      	b.n	8016fa8 <_strtod_l+0x408>
 8016ffa:	9b08      	ldr	r3, [sp, #32]
 8016ffc:	eba5 0808 	sub.w	r8, r5, r8
 8017000:	4498      	add	r8, r3
 8017002:	f1b8 0f00 	cmp.w	r8, #0
 8017006:	dd71      	ble.n	80170ec <_strtod_l+0x54c>
 8017008:	f018 030f 	ands.w	r3, r8, #15
 801700c:	d00a      	beq.n	8017024 <_strtod_l+0x484>
 801700e:	494d      	ldr	r1, [pc, #308]	; (8017144 <_strtod_l+0x5a4>)
 8017010:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8017014:	4652      	mov	r2, sl
 8017016:	465b      	mov	r3, fp
 8017018:	e9d1 0100 	ldrd	r0, r1, [r1]
 801701c:	f7e9 fb14 	bl	8000648 <__aeabi_dmul>
 8017020:	4682      	mov	sl, r0
 8017022:	468b      	mov	fp, r1
 8017024:	f038 080f 	bics.w	r8, r8, #15
 8017028:	d04d      	beq.n	80170c6 <_strtod_l+0x526>
 801702a:	f5b8 7f9a 	cmp.w	r8, #308	; 0x134
 801702e:	dd22      	ble.n	8017076 <_strtod_l+0x4d6>
 8017030:	2500      	movs	r5, #0
 8017032:	462e      	mov	r6, r5
 8017034:	9509      	str	r5, [sp, #36]	; 0x24
 8017036:	9507      	str	r5, [sp, #28]
 8017038:	2322      	movs	r3, #34	; 0x22
 801703a:	f8df b110 	ldr.w	fp, [pc, #272]	; 801714c <_strtod_l+0x5ac>
 801703e:	6023      	str	r3, [r4, #0]
 8017040:	f04f 0a00 	mov.w	sl, #0
 8017044:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017046:	2b00      	cmp	r3, #0
 8017048:	f43f adec 	beq.w	8016c24 <_strtod_l+0x84>
 801704c:	991e      	ldr	r1, [sp, #120]	; 0x78
 801704e:	4620      	mov	r0, r4
 8017050:	f001 ffec 	bl	801902c <_Bfree>
 8017054:	9907      	ldr	r1, [sp, #28]
 8017056:	4620      	mov	r0, r4
 8017058:	f001 ffe8 	bl	801902c <_Bfree>
 801705c:	4631      	mov	r1, r6
 801705e:	4620      	mov	r0, r4
 8017060:	f001 ffe4 	bl	801902c <_Bfree>
 8017064:	9909      	ldr	r1, [sp, #36]	; 0x24
 8017066:	4620      	mov	r0, r4
 8017068:	f001 ffe0 	bl	801902c <_Bfree>
 801706c:	4629      	mov	r1, r5
 801706e:	4620      	mov	r0, r4
 8017070:	f001 ffdc 	bl	801902c <_Bfree>
 8017074:	e5d6      	b.n	8016c24 <_strtod_l+0x84>
 8017076:	2300      	movs	r3, #0
 8017078:	ea4f 1828 	mov.w	r8, r8, asr #4
 801707c:	4650      	mov	r0, sl
 801707e:	4659      	mov	r1, fp
 8017080:	4699      	mov	r9, r3
 8017082:	f1b8 0f01 	cmp.w	r8, #1
 8017086:	dc21      	bgt.n	80170cc <_strtod_l+0x52c>
 8017088:	b10b      	cbz	r3, 801708e <_strtod_l+0x4ee>
 801708a:	4682      	mov	sl, r0
 801708c:	468b      	mov	fp, r1
 801708e:	4b2e      	ldr	r3, [pc, #184]	; (8017148 <_strtod_l+0x5a8>)
 8017090:	f1ab 7b54 	sub.w	fp, fp, #55574528	; 0x3500000
 8017094:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
 8017098:	4652      	mov	r2, sl
 801709a:	465b      	mov	r3, fp
 801709c:	e9d9 0100 	ldrd	r0, r1, [r9]
 80170a0:	f7e9 fad2 	bl	8000648 <__aeabi_dmul>
 80170a4:	4b29      	ldr	r3, [pc, #164]	; (801714c <_strtod_l+0x5ac>)
 80170a6:	460a      	mov	r2, r1
 80170a8:	400b      	ands	r3, r1
 80170aa:	4929      	ldr	r1, [pc, #164]	; (8017150 <_strtod_l+0x5b0>)
 80170ac:	428b      	cmp	r3, r1
 80170ae:	4682      	mov	sl, r0
 80170b0:	d8be      	bhi.n	8017030 <_strtod_l+0x490>
 80170b2:	f5a1 1180 	sub.w	r1, r1, #1048576	; 0x100000
 80170b6:	428b      	cmp	r3, r1
 80170b8:	bf86      	itte	hi
 80170ba:	f8df b098 	ldrhi.w	fp, [pc, #152]	; 8017154 <_strtod_l+0x5b4>
 80170be:	f04f 3aff 	movhi.w	sl, #4294967295
 80170c2:	f102 7b54 	addls.w	fp, r2, #55574528	; 0x3500000
 80170c6:	2300      	movs	r3, #0
 80170c8:	9304      	str	r3, [sp, #16]
 80170ca:	e081      	b.n	80171d0 <_strtod_l+0x630>
 80170cc:	f018 0f01 	tst.w	r8, #1
 80170d0:	d007      	beq.n	80170e2 <_strtod_l+0x542>
 80170d2:	4b1d      	ldr	r3, [pc, #116]	; (8017148 <_strtod_l+0x5a8>)
 80170d4:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 80170d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80170dc:	f7e9 fab4 	bl	8000648 <__aeabi_dmul>
 80170e0:	2301      	movs	r3, #1
 80170e2:	f109 0901 	add.w	r9, r9, #1
 80170e6:	ea4f 0868 	mov.w	r8, r8, asr #1
 80170ea:	e7ca      	b.n	8017082 <_strtod_l+0x4e2>
 80170ec:	d0eb      	beq.n	80170c6 <_strtod_l+0x526>
 80170ee:	f1c8 0800 	rsb	r8, r8, #0
 80170f2:	f018 020f 	ands.w	r2, r8, #15
 80170f6:	d00a      	beq.n	801710e <_strtod_l+0x56e>
 80170f8:	4b12      	ldr	r3, [pc, #72]	; (8017144 <_strtod_l+0x5a4>)
 80170fa:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80170fe:	4650      	mov	r0, sl
 8017100:	4659      	mov	r1, fp
 8017102:	e9d3 2300 	ldrd	r2, r3, [r3]
 8017106:	f7e9 fbc9 	bl	800089c <__aeabi_ddiv>
 801710a:	4682      	mov	sl, r0
 801710c:	468b      	mov	fp, r1
 801710e:	ea5f 1828 	movs.w	r8, r8, asr #4
 8017112:	d0d8      	beq.n	80170c6 <_strtod_l+0x526>
 8017114:	f1b8 0f1f 	cmp.w	r8, #31
 8017118:	dd1e      	ble.n	8017158 <_strtod_l+0x5b8>
 801711a:	2500      	movs	r5, #0
 801711c:	462e      	mov	r6, r5
 801711e:	9509      	str	r5, [sp, #36]	; 0x24
 8017120:	9507      	str	r5, [sp, #28]
 8017122:	2322      	movs	r3, #34	; 0x22
 8017124:	f04f 0a00 	mov.w	sl, #0
 8017128:	f04f 0b00 	mov.w	fp, #0
 801712c:	6023      	str	r3, [r4, #0]
 801712e:	e789      	b.n	8017044 <_strtod_l+0x4a4>
 8017130:	0801add1 	.word	0x0801add1
 8017134:	0801ae0c 	.word	0x0801ae0c
 8017138:	0801adc9 	.word	0x0801adc9
 801713c:	0801ae70 	.word	0x0801ae70
 8017140:	0801b128 	.word	0x0801b128
 8017144:	0801b008 	.word	0x0801b008
 8017148:	0801afe0 	.word	0x0801afe0
 801714c:	7ff00000 	.word	0x7ff00000
 8017150:	7ca00000 	.word	0x7ca00000
 8017154:	7fefffff 	.word	0x7fefffff
 8017158:	f018 0310 	ands.w	r3, r8, #16
 801715c:	bf18      	it	ne
 801715e:	236a      	movne	r3, #106	; 0x6a
 8017160:	f8df 93b4 	ldr.w	r9, [pc, #948]	; 8017518 <_strtod_l+0x978>
 8017164:	9304      	str	r3, [sp, #16]
 8017166:	4650      	mov	r0, sl
 8017168:	4659      	mov	r1, fp
 801716a:	2300      	movs	r3, #0
 801716c:	f018 0f01 	tst.w	r8, #1
 8017170:	d004      	beq.n	801717c <_strtod_l+0x5dc>
 8017172:	e9d9 2300 	ldrd	r2, r3, [r9]
 8017176:	f7e9 fa67 	bl	8000648 <__aeabi_dmul>
 801717a:	2301      	movs	r3, #1
 801717c:	ea5f 0868 	movs.w	r8, r8, asr #1
 8017180:	f109 0908 	add.w	r9, r9, #8
 8017184:	d1f2      	bne.n	801716c <_strtod_l+0x5cc>
 8017186:	b10b      	cbz	r3, 801718c <_strtod_l+0x5ec>
 8017188:	4682      	mov	sl, r0
 801718a:	468b      	mov	fp, r1
 801718c:	9b04      	ldr	r3, [sp, #16]
 801718e:	b1bb      	cbz	r3, 80171c0 <_strtod_l+0x620>
 8017190:	f3cb 530a 	ubfx	r3, fp, #20, #11
 8017194:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8017198:	2b00      	cmp	r3, #0
 801719a:	4659      	mov	r1, fp
 801719c:	dd10      	ble.n	80171c0 <_strtod_l+0x620>
 801719e:	2b1f      	cmp	r3, #31
 80171a0:	f340 8128 	ble.w	80173f4 <_strtod_l+0x854>
 80171a4:	2b34      	cmp	r3, #52	; 0x34
 80171a6:	bfde      	ittt	le
 80171a8:	3b20      	suble	r3, #32
 80171aa:	f04f 32ff 	movle.w	r2, #4294967295
 80171ae:	fa02 f303 	lslle.w	r3, r2, r3
 80171b2:	f04f 0a00 	mov.w	sl, #0
 80171b6:	bfcc      	ite	gt
 80171b8:	f04f 7b5c 	movgt.w	fp, #57671680	; 0x3700000
 80171bc:	ea03 0b01 	andle.w	fp, r3, r1
 80171c0:	2200      	movs	r2, #0
 80171c2:	2300      	movs	r3, #0
 80171c4:	4650      	mov	r0, sl
 80171c6:	4659      	mov	r1, fp
 80171c8:	f7e9 fca6 	bl	8000b18 <__aeabi_dcmpeq>
 80171cc:	2800      	cmp	r0, #0
 80171ce:	d1a4      	bne.n	801711a <_strtod_l+0x57a>
 80171d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80171d2:	9300      	str	r3, [sp, #0]
 80171d4:	990a      	ldr	r1, [sp, #40]	; 0x28
 80171d6:	462b      	mov	r3, r5
 80171d8:	463a      	mov	r2, r7
 80171da:	4620      	mov	r0, r4
 80171dc:	f001 ff92 	bl	8019104 <__s2b>
 80171e0:	9009      	str	r0, [sp, #36]	; 0x24
 80171e2:	2800      	cmp	r0, #0
 80171e4:	f43f af24 	beq.w	8017030 <_strtod_l+0x490>
 80171e8:	9b07      	ldr	r3, [sp, #28]
 80171ea:	1b9e      	subs	r6, r3, r6
 80171ec:	9b08      	ldr	r3, [sp, #32]
 80171ee:	2b00      	cmp	r3, #0
 80171f0:	bfb4      	ite	lt
 80171f2:	4633      	movlt	r3, r6
 80171f4:	2300      	movge	r3, #0
 80171f6:	9310      	str	r3, [sp, #64]	; 0x40
 80171f8:	9b08      	ldr	r3, [sp, #32]
 80171fa:	2500      	movs	r5, #0
 80171fc:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8017200:	9318      	str	r3, [sp, #96]	; 0x60
 8017202:	462e      	mov	r6, r5
 8017204:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017206:	4620      	mov	r0, r4
 8017208:	6859      	ldr	r1, [r3, #4]
 801720a:	f001 fecf 	bl	8018fac <_Balloc>
 801720e:	9007      	str	r0, [sp, #28]
 8017210:	2800      	cmp	r0, #0
 8017212:	f43f af11 	beq.w	8017038 <_strtod_l+0x498>
 8017216:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017218:	691a      	ldr	r2, [r3, #16]
 801721a:	3202      	adds	r2, #2
 801721c:	f103 010c 	add.w	r1, r3, #12
 8017220:	0092      	lsls	r2, r2, #2
 8017222:	300c      	adds	r0, #12
 8017224:	f7fe fe8c 	bl	8015f40 <memcpy>
 8017228:	ec4b ab10 	vmov	d0, sl, fp
 801722c:	aa20      	add	r2, sp, #128	; 0x80
 801722e:	a91f      	add	r1, sp, #124	; 0x7c
 8017230:	4620      	mov	r0, r4
 8017232:	e9cd ab0a 	strd	sl, fp, [sp, #40]	; 0x28
 8017236:	f002 faa1 	bl	801977c <__d2b>
 801723a:	901e      	str	r0, [sp, #120]	; 0x78
 801723c:	2800      	cmp	r0, #0
 801723e:	f43f aefb 	beq.w	8017038 <_strtod_l+0x498>
 8017242:	2101      	movs	r1, #1
 8017244:	4620      	mov	r0, r4
 8017246:	f001 fff7 	bl	8019238 <__i2b>
 801724a:	4606      	mov	r6, r0
 801724c:	2800      	cmp	r0, #0
 801724e:	f43f aef3 	beq.w	8017038 <_strtod_l+0x498>
 8017252:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8017254:	9904      	ldr	r1, [sp, #16]
 8017256:	2b00      	cmp	r3, #0
 8017258:	bfab      	itete	ge
 801725a:	9a10      	ldrge	r2, [sp, #64]	; 0x40
 801725c:	9a18      	ldrlt	r2, [sp, #96]	; 0x60
 801725e:	9f18      	ldrge	r7, [sp, #96]	; 0x60
 8017260:	f8dd 9040 	ldrlt.w	r9, [sp, #64]	; 0x40
 8017264:	bfac      	ite	ge
 8017266:	eb03 0902 	addge.w	r9, r3, r2
 801726a:	1ad7      	sublt	r7, r2, r3
 801726c:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801726e:	eba3 0801 	sub.w	r8, r3, r1
 8017272:	4490      	add	r8, r2
 8017274:	4ba3      	ldr	r3, [pc, #652]	; (8017504 <_strtod_l+0x964>)
 8017276:	f108 38ff 	add.w	r8, r8, #4294967295
 801727a:	4598      	cmp	r8, r3
 801727c:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
 8017280:	f280 80cc 	bge.w	801741c <_strtod_l+0x87c>
 8017284:	eba3 0308 	sub.w	r3, r3, r8
 8017288:	2b1f      	cmp	r3, #31
 801728a:	eba2 0203 	sub.w	r2, r2, r3
 801728e:	f04f 0101 	mov.w	r1, #1
 8017292:	f300 80b6 	bgt.w	8017402 <_strtod_l+0x862>
 8017296:	fa01 f303 	lsl.w	r3, r1, r3
 801729a:	9311      	str	r3, [sp, #68]	; 0x44
 801729c:	2300      	movs	r3, #0
 801729e:	930c      	str	r3, [sp, #48]	; 0x30
 80172a0:	eb09 0802 	add.w	r8, r9, r2
 80172a4:	9b04      	ldr	r3, [sp, #16]
 80172a6:	45c1      	cmp	r9, r8
 80172a8:	4417      	add	r7, r2
 80172aa:	441f      	add	r7, r3
 80172ac:	464b      	mov	r3, r9
 80172ae:	bfa8      	it	ge
 80172b0:	4643      	movge	r3, r8
 80172b2:	42bb      	cmp	r3, r7
 80172b4:	bfa8      	it	ge
 80172b6:	463b      	movge	r3, r7
 80172b8:	2b00      	cmp	r3, #0
 80172ba:	bfc2      	ittt	gt
 80172bc:	eba8 0803 	subgt.w	r8, r8, r3
 80172c0:	1aff      	subgt	r7, r7, r3
 80172c2:	eba9 0903 	subgt.w	r9, r9, r3
 80172c6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80172c8:	2b00      	cmp	r3, #0
 80172ca:	dd17      	ble.n	80172fc <_strtod_l+0x75c>
 80172cc:	4631      	mov	r1, r6
 80172ce:	461a      	mov	r2, r3
 80172d0:	4620      	mov	r0, r4
 80172d2:	f002 f86d 	bl	80193b0 <__pow5mult>
 80172d6:	4606      	mov	r6, r0
 80172d8:	2800      	cmp	r0, #0
 80172da:	f43f aead 	beq.w	8017038 <_strtod_l+0x498>
 80172de:	4601      	mov	r1, r0
 80172e0:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80172e2:	4620      	mov	r0, r4
 80172e4:	f001 ffbe 	bl	8019264 <__multiply>
 80172e8:	900f      	str	r0, [sp, #60]	; 0x3c
 80172ea:	2800      	cmp	r0, #0
 80172ec:	f43f aea4 	beq.w	8017038 <_strtod_l+0x498>
 80172f0:	991e      	ldr	r1, [sp, #120]	; 0x78
 80172f2:	4620      	mov	r0, r4
 80172f4:	f001 fe9a 	bl	801902c <_Bfree>
 80172f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80172fa:	931e      	str	r3, [sp, #120]	; 0x78
 80172fc:	f1b8 0f00 	cmp.w	r8, #0
 8017300:	f300 8091 	bgt.w	8017426 <_strtod_l+0x886>
 8017304:	9b08      	ldr	r3, [sp, #32]
 8017306:	2b00      	cmp	r3, #0
 8017308:	dd08      	ble.n	801731c <_strtod_l+0x77c>
 801730a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801730c:	9907      	ldr	r1, [sp, #28]
 801730e:	4620      	mov	r0, r4
 8017310:	f002 f84e 	bl	80193b0 <__pow5mult>
 8017314:	9007      	str	r0, [sp, #28]
 8017316:	2800      	cmp	r0, #0
 8017318:	f43f ae8e 	beq.w	8017038 <_strtod_l+0x498>
 801731c:	2f00      	cmp	r7, #0
 801731e:	dd08      	ble.n	8017332 <_strtod_l+0x792>
 8017320:	9907      	ldr	r1, [sp, #28]
 8017322:	463a      	mov	r2, r7
 8017324:	4620      	mov	r0, r4
 8017326:	f002 f89d 	bl	8019464 <__lshift>
 801732a:	9007      	str	r0, [sp, #28]
 801732c:	2800      	cmp	r0, #0
 801732e:	f43f ae83 	beq.w	8017038 <_strtod_l+0x498>
 8017332:	f1b9 0f00 	cmp.w	r9, #0
 8017336:	dd08      	ble.n	801734a <_strtod_l+0x7aa>
 8017338:	4631      	mov	r1, r6
 801733a:	464a      	mov	r2, r9
 801733c:	4620      	mov	r0, r4
 801733e:	f002 f891 	bl	8019464 <__lshift>
 8017342:	4606      	mov	r6, r0
 8017344:	2800      	cmp	r0, #0
 8017346:	f43f ae77 	beq.w	8017038 <_strtod_l+0x498>
 801734a:	9a07      	ldr	r2, [sp, #28]
 801734c:	991e      	ldr	r1, [sp, #120]	; 0x78
 801734e:	4620      	mov	r0, r4
 8017350:	f002 f910 	bl	8019574 <__mdiff>
 8017354:	4605      	mov	r5, r0
 8017356:	2800      	cmp	r0, #0
 8017358:	f43f ae6e 	beq.w	8017038 <_strtod_l+0x498>
 801735c:	68c3      	ldr	r3, [r0, #12]
 801735e:	930f      	str	r3, [sp, #60]	; 0x3c
 8017360:	2300      	movs	r3, #0
 8017362:	60c3      	str	r3, [r0, #12]
 8017364:	4631      	mov	r1, r6
 8017366:	f002 f8e9 	bl	801953c <__mcmp>
 801736a:	2800      	cmp	r0, #0
 801736c:	da65      	bge.n	801743a <_strtod_l+0x89a>
 801736e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8017370:	ea53 030a 	orrs.w	r3, r3, sl
 8017374:	f040 8087 	bne.w	8017486 <_strtod_l+0x8e6>
 8017378:	f3cb 0313 	ubfx	r3, fp, #0, #20
 801737c:	2b00      	cmp	r3, #0
 801737e:	f040 8082 	bne.w	8017486 <_strtod_l+0x8e6>
 8017382:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 8017386:	0d1b      	lsrs	r3, r3, #20
 8017388:	051b      	lsls	r3, r3, #20
 801738a:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 801738e:	d97a      	bls.n	8017486 <_strtod_l+0x8e6>
 8017390:	696b      	ldr	r3, [r5, #20]
 8017392:	b913      	cbnz	r3, 801739a <_strtod_l+0x7fa>
 8017394:	692b      	ldr	r3, [r5, #16]
 8017396:	2b01      	cmp	r3, #1
 8017398:	dd75      	ble.n	8017486 <_strtod_l+0x8e6>
 801739a:	4629      	mov	r1, r5
 801739c:	2201      	movs	r2, #1
 801739e:	4620      	mov	r0, r4
 80173a0:	f002 f860 	bl	8019464 <__lshift>
 80173a4:	4631      	mov	r1, r6
 80173a6:	4605      	mov	r5, r0
 80173a8:	f002 f8c8 	bl	801953c <__mcmp>
 80173ac:	2800      	cmp	r0, #0
 80173ae:	dd6a      	ble.n	8017486 <_strtod_l+0x8e6>
 80173b0:	9904      	ldr	r1, [sp, #16]
 80173b2:	4a55      	ldr	r2, [pc, #340]	; (8017508 <_strtod_l+0x968>)
 80173b4:	465b      	mov	r3, fp
 80173b6:	2900      	cmp	r1, #0
 80173b8:	f000 8085 	beq.w	80174c6 <_strtod_l+0x926>
 80173bc:	ea02 010b 	and.w	r1, r2, fp
 80173c0:	f1b1 6fd6 	cmp.w	r1, #112197632	; 0x6b00000
 80173c4:	dc7f      	bgt.n	80174c6 <_strtod_l+0x926>
 80173c6:	f1b1 7f5c 	cmp.w	r1, #57671680	; 0x3700000
 80173ca:	f77f aeaa 	ble.w	8017122 <_strtod_l+0x582>
 80173ce:	4a4f      	ldr	r2, [pc, #316]	; (801750c <_strtod_l+0x96c>)
 80173d0:	2300      	movs	r3, #0
 80173d2:	e9cd 3216 	strd	r3, r2, [sp, #88]	; 0x58
 80173d6:	4650      	mov	r0, sl
 80173d8:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 80173dc:	4659      	mov	r1, fp
 80173de:	f7e9 f933 	bl	8000648 <__aeabi_dmul>
 80173e2:	460b      	mov	r3, r1
 80173e4:	4303      	orrs	r3, r0
 80173e6:	bf08      	it	eq
 80173e8:	2322      	moveq	r3, #34	; 0x22
 80173ea:	4682      	mov	sl, r0
 80173ec:	468b      	mov	fp, r1
 80173ee:	bf08      	it	eq
 80173f0:	6023      	streq	r3, [r4, #0]
 80173f2:	e62b      	b.n	801704c <_strtod_l+0x4ac>
 80173f4:	f04f 32ff 	mov.w	r2, #4294967295
 80173f8:	fa02 f303 	lsl.w	r3, r2, r3
 80173fc:	ea03 0a0a 	and.w	sl, r3, sl
 8017400:	e6de      	b.n	80171c0 <_strtod_l+0x620>
 8017402:	f1c8 487f 	rsb	r8, r8, #4278190080	; 0xff000000
 8017406:	f508 087f 	add.w	r8, r8, #16711680	; 0xff0000
 801740a:	f508 487b 	add.w	r8, r8, #64256	; 0xfb00
 801740e:	f108 08e2 	add.w	r8, r8, #226	; 0xe2
 8017412:	fa01 f308 	lsl.w	r3, r1, r8
 8017416:	930c      	str	r3, [sp, #48]	; 0x30
 8017418:	9111      	str	r1, [sp, #68]	; 0x44
 801741a:	e741      	b.n	80172a0 <_strtod_l+0x700>
 801741c:	2300      	movs	r3, #0
 801741e:	930c      	str	r3, [sp, #48]	; 0x30
 8017420:	2301      	movs	r3, #1
 8017422:	9311      	str	r3, [sp, #68]	; 0x44
 8017424:	e73c      	b.n	80172a0 <_strtod_l+0x700>
 8017426:	991e      	ldr	r1, [sp, #120]	; 0x78
 8017428:	4642      	mov	r2, r8
 801742a:	4620      	mov	r0, r4
 801742c:	f002 f81a 	bl	8019464 <__lshift>
 8017430:	901e      	str	r0, [sp, #120]	; 0x78
 8017432:	2800      	cmp	r0, #0
 8017434:	f47f af66 	bne.w	8017304 <_strtod_l+0x764>
 8017438:	e5fe      	b.n	8017038 <_strtod_l+0x498>
 801743a:	465f      	mov	r7, fp
 801743c:	d16e      	bne.n	801751c <_strtod_l+0x97c>
 801743e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8017440:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8017444:	b342      	cbz	r2, 8017498 <_strtod_l+0x8f8>
 8017446:	4a32      	ldr	r2, [pc, #200]	; (8017510 <_strtod_l+0x970>)
 8017448:	4293      	cmp	r3, r2
 801744a:	d128      	bne.n	801749e <_strtod_l+0x8fe>
 801744c:	9b04      	ldr	r3, [sp, #16]
 801744e:	4650      	mov	r0, sl
 8017450:	b1eb      	cbz	r3, 801748e <_strtod_l+0x8ee>
 8017452:	4a2d      	ldr	r2, [pc, #180]	; (8017508 <_strtod_l+0x968>)
 8017454:	403a      	ands	r2, r7
 8017456:	f1b2 6fd4 	cmp.w	r2, #111149056	; 0x6a00000
 801745a:	f04f 31ff 	mov.w	r1, #4294967295
 801745e:	d819      	bhi.n	8017494 <_strtod_l+0x8f4>
 8017460:	0d12      	lsrs	r2, r2, #20
 8017462:	f1c2 036b 	rsb	r3, r2, #107	; 0x6b
 8017466:	fa01 f303 	lsl.w	r3, r1, r3
 801746a:	4298      	cmp	r0, r3
 801746c:	d117      	bne.n	801749e <_strtod_l+0x8fe>
 801746e:	4b29      	ldr	r3, [pc, #164]	; (8017514 <_strtod_l+0x974>)
 8017470:	429f      	cmp	r7, r3
 8017472:	d102      	bne.n	801747a <_strtod_l+0x8da>
 8017474:	3001      	adds	r0, #1
 8017476:	f43f addf 	beq.w	8017038 <_strtod_l+0x498>
 801747a:	4b23      	ldr	r3, [pc, #140]	; (8017508 <_strtod_l+0x968>)
 801747c:	403b      	ands	r3, r7
 801747e:	f503 1b80 	add.w	fp, r3, #1048576	; 0x100000
 8017482:	f04f 0a00 	mov.w	sl, #0
 8017486:	9b04      	ldr	r3, [sp, #16]
 8017488:	2b00      	cmp	r3, #0
 801748a:	d1a0      	bne.n	80173ce <_strtod_l+0x82e>
 801748c:	e5de      	b.n	801704c <_strtod_l+0x4ac>
 801748e:	f04f 33ff 	mov.w	r3, #4294967295
 8017492:	e7ea      	b.n	801746a <_strtod_l+0x8ca>
 8017494:	460b      	mov	r3, r1
 8017496:	e7e8      	b.n	801746a <_strtod_l+0x8ca>
 8017498:	ea53 030a 	orrs.w	r3, r3, sl
 801749c:	d088      	beq.n	80173b0 <_strtod_l+0x810>
 801749e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80174a0:	b1db      	cbz	r3, 80174da <_strtod_l+0x93a>
 80174a2:	423b      	tst	r3, r7
 80174a4:	d0ef      	beq.n	8017486 <_strtod_l+0x8e6>
 80174a6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80174a8:	9a04      	ldr	r2, [sp, #16]
 80174aa:	4650      	mov	r0, sl
 80174ac:	4659      	mov	r1, fp
 80174ae:	b1c3      	cbz	r3, 80174e2 <_strtod_l+0x942>
 80174b0:	f7ff fb57 	bl	8016b62 <sulp>
 80174b4:	4602      	mov	r2, r0
 80174b6:	460b      	mov	r3, r1
 80174b8:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80174bc:	f7e8 ff0e 	bl	80002dc <__adddf3>
 80174c0:	4682      	mov	sl, r0
 80174c2:	468b      	mov	fp, r1
 80174c4:	e7df      	b.n	8017486 <_strtod_l+0x8e6>
 80174c6:	4013      	ands	r3, r2
 80174c8:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 80174cc:	ea6f 5b13 	mvn.w	fp, r3, lsr #20
 80174d0:	ea6f 5b0b 	mvn.w	fp, fp, lsl #20
 80174d4:	f04f 3aff 	mov.w	sl, #4294967295
 80174d8:	e7d5      	b.n	8017486 <_strtod_l+0x8e6>
 80174da:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80174dc:	ea13 0f0a 	tst.w	r3, sl
 80174e0:	e7e0      	b.n	80174a4 <_strtod_l+0x904>
 80174e2:	f7ff fb3e 	bl	8016b62 <sulp>
 80174e6:	4602      	mov	r2, r0
 80174e8:	460b      	mov	r3, r1
 80174ea:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 80174ee:	f7e8 fef3 	bl	80002d8 <__aeabi_dsub>
 80174f2:	2200      	movs	r2, #0
 80174f4:	2300      	movs	r3, #0
 80174f6:	4682      	mov	sl, r0
 80174f8:	468b      	mov	fp, r1
 80174fa:	f7e9 fb0d 	bl	8000b18 <__aeabi_dcmpeq>
 80174fe:	2800      	cmp	r0, #0
 8017500:	d0c1      	beq.n	8017486 <_strtod_l+0x8e6>
 8017502:	e60e      	b.n	8017122 <_strtod_l+0x582>
 8017504:	fffffc02 	.word	0xfffffc02
 8017508:	7ff00000 	.word	0x7ff00000
 801750c:	39500000 	.word	0x39500000
 8017510:	000fffff 	.word	0x000fffff
 8017514:	7fefffff 	.word	0x7fefffff
 8017518:	0801ae20 	.word	0x0801ae20
 801751c:	4631      	mov	r1, r6
 801751e:	4628      	mov	r0, r5
 8017520:	f002 f988 	bl	8019834 <__ratio>
 8017524:	ec59 8b10 	vmov	r8, r9, d0
 8017528:	ee10 0a10 	vmov	r0, s0
 801752c:	2200      	movs	r2, #0
 801752e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8017532:	4649      	mov	r1, r9
 8017534:	f7e9 fb04 	bl	8000b40 <__aeabi_dcmple>
 8017538:	2800      	cmp	r0, #0
 801753a:	d07c      	beq.n	8017636 <_strtod_l+0xa96>
 801753c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801753e:	2b00      	cmp	r3, #0
 8017540:	d04c      	beq.n	80175dc <_strtod_l+0xa3c>
 8017542:	4b95      	ldr	r3, [pc, #596]	; (8017798 <_strtod_l+0xbf8>)
 8017544:	2200      	movs	r2, #0
 8017546:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 801754a:	f8df 924c 	ldr.w	r9, [pc, #588]	; 8017798 <_strtod_l+0xbf8>
 801754e:	f04f 0800 	mov.w	r8, #0
 8017552:	4b92      	ldr	r3, [pc, #584]	; (801779c <_strtod_l+0xbfc>)
 8017554:	403b      	ands	r3, r7
 8017556:	9311      	str	r3, [sp, #68]	; 0x44
 8017558:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801755a:	4b91      	ldr	r3, [pc, #580]	; (80177a0 <_strtod_l+0xc00>)
 801755c:	429a      	cmp	r2, r3
 801755e:	f040 80b2 	bne.w	80176c6 <_strtod_l+0xb26>
 8017562:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8017566:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801756a:	f1a7 7b54 	sub.w	fp, r7, #55574528	; 0x3500000
 801756e:	ec4b ab10 	vmov	d0, sl, fp
 8017572:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
 8017576:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 801757a:	f002 f883 	bl	8019684 <__ulp>
 801757e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8017582:	ec53 2b10 	vmov	r2, r3, d0
 8017586:	f7e9 f85f 	bl	8000648 <__aeabi_dmul>
 801758a:	4652      	mov	r2, sl
 801758c:	465b      	mov	r3, fp
 801758e:	f7e8 fea5 	bl	80002dc <__adddf3>
 8017592:	460b      	mov	r3, r1
 8017594:	4981      	ldr	r1, [pc, #516]	; (801779c <_strtod_l+0xbfc>)
 8017596:	4a83      	ldr	r2, [pc, #524]	; (80177a4 <_strtod_l+0xc04>)
 8017598:	4019      	ands	r1, r3
 801759a:	4291      	cmp	r1, r2
 801759c:	4682      	mov	sl, r0
 801759e:	d95e      	bls.n	801765e <_strtod_l+0xabe>
 80175a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80175a2:	f102 7254 	add.w	r2, r2, #55574528	; 0x3500000
 80175a6:	4293      	cmp	r3, r2
 80175a8:	d103      	bne.n	80175b2 <_strtod_l+0xa12>
 80175aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80175ac:	3301      	adds	r3, #1
 80175ae:	f43f ad43 	beq.w	8017038 <_strtod_l+0x498>
 80175b2:	f8df b1fc 	ldr.w	fp, [pc, #508]	; 80177b0 <_strtod_l+0xc10>
 80175b6:	f04f 3aff 	mov.w	sl, #4294967295
 80175ba:	991e      	ldr	r1, [sp, #120]	; 0x78
 80175bc:	4620      	mov	r0, r4
 80175be:	f001 fd35 	bl	801902c <_Bfree>
 80175c2:	9907      	ldr	r1, [sp, #28]
 80175c4:	4620      	mov	r0, r4
 80175c6:	f001 fd31 	bl	801902c <_Bfree>
 80175ca:	4631      	mov	r1, r6
 80175cc:	4620      	mov	r0, r4
 80175ce:	f001 fd2d 	bl	801902c <_Bfree>
 80175d2:	4629      	mov	r1, r5
 80175d4:	4620      	mov	r0, r4
 80175d6:	f001 fd29 	bl	801902c <_Bfree>
 80175da:	e613      	b.n	8017204 <_strtod_l+0x664>
 80175dc:	f1ba 0f00 	cmp.w	sl, #0
 80175e0:	d11b      	bne.n	801761a <_strtod_l+0xa7a>
 80175e2:	f3cb 0313 	ubfx	r3, fp, #0, #20
 80175e6:	b9f3      	cbnz	r3, 8017626 <_strtod_l+0xa86>
 80175e8:	4b6b      	ldr	r3, [pc, #428]	; (8017798 <_strtod_l+0xbf8>)
 80175ea:	2200      	movs	r2, #0
 80175ec:	4640      	mov	r0, r8
 80175ee:	4649      	mov	r1, r9
 80175f0:	f7e9 fa9c 	bl	8000b2c <__aeabi_dcmplt>
 80175f4:	b9d0      	cbnz	r0, 801762c <_strtod_l+0xa8c>
 80175f6:	4640      	mov	r0, r8
 80175f8:	4649      	mov	r1, r9
 80175fa:	4b6b      	ldr	r3, [pc, #428]	; (80177a8 <_strtod_l+0xc08>)
 80175fc:	2200      	movs	r2, #0
 80175fe:	f7e9 f823 	bl	8000648 <__aeabi_dmul>
 8017602:	4680      	mov	r8, r0
 8017604:	4689      	mov	r9, r1
 8017606:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 801760a:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
 801760e:	931b      	str	r3, [sp, #108]	; 0x6c
 8017610:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
 8017614:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8017618:	e79b      	b.n	8017552 <_strtod_l+0x9b2>
 801761a:	f1ba 0f01 	cmp.w	sl, #1
 801761e:	d102      	bne.n	8017626 <_strtod_l+0xa86>
 8017620:	2f00      	cmp	r7, #0
 8017622:	f43f ad7e 	beq.w	8017122 <_strtod_l+0x582>
 8017626:	4b61      	ldr	r3, [pc, #388]	; (80177ac <_strtod_l+0xc0c>)
 8017628:	2200      	movs	r2, #0
 801762a:	e78c      	b.n	8017546 <_strtod_l+0x9a6>
 801762c:	f8df 9178 	ldr.w	r9, [pc, #376]	; 80177a8 <_strtod_l+0xc08>
 8017630:	f04f 0800 	mov.w	r8, #0
 8017634:	e7e7      	b.n	8017606 <_strtod_l+0xa66>
 8017636:	4b5c      	ldr	r3, [pc, #368]	; (80177a8 <_strtod_l+0xc08>)
 8017638:	4640      	mov	r0, r8
 801763a:	4649      	mov	r1, r9
 801763c:	2200      	movs	r2, #0
 801763e:	f7e9 f803 	bl	8000648 <__aeabi_dmul>
 8017642:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8017644:	4680      	mov	r8, r0
 8017646:	4689      	mov	r9, r1
 8017648:	b933      	cbnz	r3, 8017658 <_strtod_l+0xab8>
 801764a:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 801764e:	9012      	str	r0, [sp, #72]	; 0x48
 8017650:	9313      	str	r3, [sp, #76]	; 0x4c
 8017652:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8017656:	e7dd      	b.n	8017614 <_strtod_l+0xa74>
 8017658:	e9cd 8912 	strd	r8, r9, [sp, #72]	; 0x48
 801765c:	e7f9      	b.n	8017652 <_strtod_l+0xab2>
 801765e:	f103 7b54 	add.w	fp, r3, #55574528	; 0x3500000
 8017662:	9b04      	ldr	r3, [sp, #16]
 8017664:	2b00      	cmp	r3, #0
 8017666:	d1a8      	bne.n	80175ba <_strtod_l+0xa1a>
 8017668:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 801766c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801766e:	0d1b      	lsrs	r3, r3, #20
 8017670:	051b      	lsls	r3, r3, #20
 8017672:	429a      	cmp	r2, r3
 8017674:	d1a1      	bne.n	80175ba <_strtod_l+0xa1a>
 8017676:	4640      	mov	r0, r8
 8017678:	4649      	mov	r1, r9
 801767a:	f7e9 fb45 	bl	8000d08 <__aeabi_d2lz>
 801767e:	f7e8 ffb5 	bl	80005ec <__aeabi_l2d>
 8017682:	4602      	mov	r2, r0
 8017684:	460b      	mov	r3, r1
 8017686:	4640      	mov	r0, r8
 8017688:	4649      	mov	r1, r9
 801768a:	f7e8 fe25 	bl	80002d8 <__aeabi_dsub>
 801768e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8017690:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8017694:	ea43 030a 	orr.w	r3, r3, sl
 8017698:	4313      	orrs	r3, r2
 801769a:	4680      	mov	r8, r0
 801769c:	4689      	mov	r9, r1
 801769e:	d053      	beq.n	8017748 <_strtod_l+0xba8>
 80176a0:	a335      	add	r3, pc, #212	; (adr r3, 8017778 <_strtod_l+0xbd8>)
 80176a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80176a6:	f7e9 fa41 	bl	8000b2c <__aeabi_dcmplt>
 80176aa:	2800      	cmp	r0, #0
 80176ac:	f47f acce 	bne.w	801704c <_strtod_l+0x4ac>
 80176b0:	a333      	add	r3, pc, #204	; (adr r3, 8017780 <_strtod_l+0xbe0>)
 80176b2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80176b6:	4640      	mov	r0, r8
 80176b8:	4649      	mov	r1, r9
 80176ba:	f7e9 fa55 	bl	8000b68 <__aeabi_dcmpgt>
 80176be:	2800      	cmp	r0, #0
 80176c0:	f43f af7b 	beq.w	80175ba <_strtod_l+0xa1a>
 80176c4:	e4c2      	b.n	801704c <_strtod_l+0x4ac>
 80176c6:	9b04      	ldr	r3, [sp, #16]
 80176c8:	b333      	cbz	r3, 8017718 <_strtod_l+0xb78>
 80176ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80176cc:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
 80176d0:	d822      	bhi.n	8017718 <_strtod_l+0xb78>
 80176d2:	a32d      	add	r3, pc, #180	; (adr r3, 8017788 <_strtod_l+0xbe8>)
 80176d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80176d8:	4640      	mov	r0, r8
 80176da:	4649      	mov	r1, r9
 80176dc:	f7e9 fa30 	bl	8000b40 <__aeabi_dcmple>
 80176e0:	b1a0      	cbz	r0, 801770c <_strtod_l+0xb6c>
 80176e2:	4649      	mov	r1, r9
 80176e4:	4640      	mov	r0, r8
 80176e6:	f7e9 fa87 	bl	8000bf8 <__aeabi_d2uiz>
 80176ea:	2801      	cmp	r0, #1
 80176ec:	bf38      	it	cc
 80176ee:	2001      	movcc	r0, #1
 80176f0:	f7e8 ff30 	bl	8000554 <__aeabi_ui2d>
 80176f4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80176f6:	4680      	mov	r8, r0
 80176f8:	4689      	mov	r9, r1
 80176fa:	bb13      	cbnz	r3, 8017742 <_strtod_l+0xba2>
 80176fc:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8017700:	9014      	str	r0, [sp, #80]	; 0x50
 8017702:	9315      	str	r3, [sp, #84]	; 0x54
 8017704:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 8017708:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 801770c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801770e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8017710:	f103 63d6 	add.w	r3, r3, #112197632	; 0x6b00000
 8017714:	1a9b      	subs	r3, r3, r2
 8017716:	930d      	str	r3, [sp, #52]	; 0x34
 8017718:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801771c:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 8017720:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 8017724:	f001 ffae 	bl	8019684 <__ulp>
 8017728:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801772c:	ec53 2b10 	vmov	r2, r3, d0
 8017730:	f7e8 ff8a 	bl	8000648 <__aeabi_dmul>
 8017734:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8017738:	f7e8 fdd0 	bl	80002dc <__adddf3>
 801773c:	4682      	mov	sl, r0
 801773e:	468b      	mov	fp, r1
 8017740:	e78f      	b.n	8017662 <_strtod_l+0xac2>
 8017742:	e9cd 8914 	strd	r8, r9, [sp, #80]	; 0x50
 8017746:	e7dd      	b.n	8017704 <_strtod_l+0xb64>
 8017748:	a311      	add	r3, pc, #68	; (adr r3, 8017790 <_strtod_l+0xbf0>)
 801774a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801774e:	f7e9 f9ed 	bl	8000b2c <__aeabi_dcmplt>
 8017752:	e7b4      	b.n	80176be <_strtod_l+0xb1e>
 8017754:	2300      	movs	r3, #0
 8017756:	930e      	str	r3, [sp, #56]	; 0x38
 8017758:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801775a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801775c:	6013      	str	r3, [r2, #0]
 801775e:	f7ff ba65 	b.w	8016c2c <_strtod_l+0x8c>
 8017762:	2b65      	cmp	r3, #101	; 0x65
 8017764:	f43f ab5d 	beq.w	8016e22 <_strtod_l+0x282>
 8017768:	2b45      	cmp	r3, #69	; 0x45
 801776a:	f43f ab5a 	beq.w	8016e22 <_strtod_l+0x282>
 801776e:	2201      	movs	r2, #1
 8017770:	f7ff bb92 	b.w	8016e98 <_strtod_l+0x2f8>
 8017774:	f3af 8000 	nop.w
 8017778:	94a03595 	.word	0x94a03595
 801777c:	3fdfffff 	.word	0x3fdfffff
 8017780:	35afe535 	.word	0x35afe535
 8017784:	3fe00000 	.word	0x3fe00000
 8017788:	ffc00000 	.word	0xffc00000
 801778c:	41dfffff 	.word	0x41dfffff
 8017790:	94a03595 	.word	0x94a03595
 8017794:	3fcfffff 	.word	0x3fcfffff
 8017798:	3ff00000 	.word	0x3ff00000
 801779c:	7ff00000 	.word	0x7ff00000
 80177a0:	7fe00000 	.word	0x7fe00000
 80177a4:	7c9fffff 	.word	0x7c9fffff
 80177a8:	3fe00000 	.word	0x3fe00000
 80177ac:	bff00000 	.word	0xbff00000
 80177b0:	7fefffff 	.word	0x7fefffff

080177b4 <strtod>:
 80177b4:	460a      	mov	r2, r1
 80177b6:	4601      	mov	r1, r0
 80177b8:	4802      	ldr	r0, [pc, #8]	; (80177c4 <strtod+0x10>)
 80177ba:	4b03      	ldr	r3, [pc, #12]	; (80177c8 <strtod+0x14>)
 80177bc:	6800      	ldr	r0, [r0, #0]
 80177be:	f7ff b9ef 	b.w	8016ba0 <_strtod_l>
 80177c2:	bf00      	nop
 80177c4:	20000140 	.word	0x20000140
 80177c8:	200001a8 	.word	0x200001a8

080177cc <_strtol_l.isra.0>:
 80177cc:	2b01      	cmp	r3, #1
 80177ce:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80177d2:	d001      	beq.n	80177d8 <_strtol_l.isra.0+0xc>
 80177d4:	2b24      	cmp	r3, #36	; 0x24
 80177d6:	d906      	bls.n	80177e6 <_strtol_l.isra.0+0x1a>
 80177d8:	f7fe f93e 	bl	8015a58 <__errno>
 80177dc:	2316      	movs	r3, #22
 80177de:	6003      	str	r3, [r0, #0]
 80177e0:	2000      	movs	r0, #0
 80177e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80177e6:	4f3a      	ldr	r7, [pc, #232]	; (80178d0 <_strtol_l.isra.0+0x104>)
 80177e8:	468e      	mov	lr, r1
 80177ea:	4676      	mov	r6, lr
 80177ec:	f81e 4b01 	ldrb.w	r4, [lr], #1
 80177f0:	5de5      	ldrb	r5, [r4, r7]
 80177f2:	f015 0508 	ands.w	r5, r5, #8
 80177f6:	d1f8      	bne.n	80177ea <_strtol_l.isra.0+0x1e>
 80177f8:	2c2d      	cmp	r4, #45	; 0x2d
 80177fa:	d134      	bne.n	8017866 <_strtol_l.isra.0+0x9a>
 80177fc:	f89e 4000 	ldrb.w	r4, [lr]
 8017800:	f04f 0801 	mov.w	r8, #1
 8017804:	f106 0e02 	add.w	lr, r6, #2
 8017808:	2b00      	cmp	r3, #0
 801780a:	d05c      	beq.n	80178c6 <_strtol_l.isra.0+0xfa>
 801780c:	2b10      	cmp	r3, #16
 801780e:	d10c      	bne.n	801782a <_strtol_l.isra.0+0x5e>
 8017810:	2c30      	cmp	r4, #48	; 0x30
 8017812:	d10a      	bne.n	801782a <_strtol_l.isra.0+0x5e>
 8017814:	f89e 4000 	ldrb.w	r4, [lr]
 8017818:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 801781c:	2c58      	cmp	r4, #88	; 0x58
 801781e:	d14d      	bne.n	80178bc <_strtol_l.isra.0+0xf0>
 8017820:	f89e 4001 	ldrb.w	r4, [lr, #1]
 8017824:	2310      	movs	r3, #16
 8017826:	f10e 0e02 	add.w	lr, lr, #2
 801782a:	f108 4c00 	add.w	ip, r8, #2147483648	; 0x80000000
 801782e:	f10c 3cff 	add.w	ip, ip, #4294967295
 8017832:	2600      	movs	r6, #0
 8017834:	fbbc f9f3 	udiv	r9, ip, r3
 8017838:	4635      	mov	r5, r6
 801783a:	fb03 ca19 	mls	sl, r3, r9, ip
 801783e:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
 8017842:	2f09      	cmp	r7, #9
 8017844:	d818      	bhi.n	8017878 <_strtol_l.isra.0+0xac>
 8017846:	463c      	mov	r4, r7
 8017848:	42a3      	cmp	r3, r4
 801784a:	dd24      	ble.n	8017896 <_strtol_l.isra.0+0xca>
 801784c:	2e00      	cmp	r6, #0
 801784e:	db1f      	blt.n	8017890 <_strtol_l.isra.0+0xc4>
 8017850:	45a9      	cmp	r9, r5
 8017852:	d31d      	bcc.n	8017890 <_strtol_l.isra.0+0xc4>
 8017854:	d101      	bne.n	801785a <_strtol_l.isra.0+0x8e>
 8017856:	45a2      	cmp	sl, r4
 8017858:	db1a      	blt.n	8017890 <_strtol_l.isra.0+0xc4>
 801785a:	fb05 4503 	mla	r5, r5, r3, r4
 801785e:	2601      	movs	r6, #1
 8017860:	f81e 4b01 	ldrb.w	r4, [lr], #1
 8017864:	e7eb      	b.n	801783e <_strtol_l.isra.0+0x72>
 8017866:	2c2b      	cmp	r4, #43	; 0x2b
 8017868:	bf08      	it	eq
 801786a:	f89e 4000 	ldrbeq.w	r4, [lr]
 801786e:	46a8      	mov	r8, r5
 8017870:	bf08      	it	eq
 8017872:	f106 0e02 	addeq.w	lr, r6, #2
 8017876:	e7c7      	b.n	8017808 <_strtol_l.isra.0+0x3c>
 8017878:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
 801787c:	2f19      	cmp	r7, #25
 801787e:	d801      	bhi.n	8017884 <_strtol_l.isra.0+0xb8>
 8017880:	3c37      	subs	r4, #55	; 0x37
 8017882:	e7e1      	b.n	8017848 <_strtol_l.isra.0+0x7c>
 8017884:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
 8017888:	2f19      	cmp	r7, #25
 801788a:	d804      	bhi.n	8017896 <_strtol_l.isra.0+0xca>
 801788c:	3c57      	subs	r4, #87	; 0x57
 801788e:	e7db      	b.n	8017848 <_strtol_l.isra.0+0x7c>
 8017890:	f04f 36ff 	mov.w	r6, #4294967295
 8017894:	e7e4      	b.n	8017860 <_strtol_l.isra.0+0x94>
 8017896:	2e00      	cmp	r6, #0
 8017898:	da05      	bge.n	80178a6 <_strtol_l.isra.0+0xda>
 801789a:	2322      	movs	r3, #34	; 0x22
 801789c:	6003      	str	r3, [r0, #0]
 801789e:	4665      	mov	r5, ip
 80178a0:	b942      	cbnz	r2, 80178b4 <_strtol_l.isra.0+0xe8>
 80178a2:	4628      	mov	r0, r5
 80178a4:	e79d      	b.n	80177e2 <_strtol_l.isra.0+0x16>
 80178a6:	f1b8 0f00 	cmp.w	r8, #0
 80178aa:	d000      	beq.n	80178ae <_strtol_l.isra.0+0xe2>
 80178ac:	426d      	negs	r5, r5
 80178ae:	2a00      	cmp	r2, #0
 80178b0:	d0f7      	beq.n	80178a2 <_strtol_l.isra.0+0xd6>
 80178b2:	b10e      	cbz	r6, 80178b8 <_strtol_l.isra.0+0xec>
 80178b4:	f10e 31ff 	add.w	r1, lr, #4294967295
 80178b8:	6011      	str	r1, [r2, #0]
 80178ba:	e7f2      	b.n	80178a2 <_strtol_l.isra.0+0xd6>
 80178bc:	2430      	movs	r4, #48	; 0x30
 80178be:	2b00      	cmp	r3, #0
 80178c0:	d1b3      	bne.n	801782a <_strtol_l.isra.0+0x5e>
 80178c2:	2308      	movs	r3, #8
 80178c4:	e7b1      	b.n	801782a <_strtol_l.isra.0+0x5e>
 80178c6:	2c30      	cmp	r4, #48	; 0x30
 80178c8:	d0a4      	beq.n	8017814 <_strtol_l.isra.0+0x48>
 80178ca:	230a      	movs	r3, #10
 80178cc:	e7ad      	b.n	801782a <_strtol_l.isra.0+0x5e>
 80178ce:	bf00      	nop
 80178d0:	0801ac5f 	.word	0x0801ac5f

080178d4 <strtol>:
 80178d4:	4613      	mov	r3, r2
 80178d6:	460a      	mov	r2, r1
 80178d8:	4601      	mov	r1, r0
 80178da:	4802      	ldr	r0, [pc, #8]	; (80178e4 <strtol+0x10>)
 80178dc:	6800      	ldr	r0, [r0, #0]
 80178de:	f7ff bf75 	b.w	80177cc <_strtol_l.isra.0>
 80178e2:	bf00      	nop
 80178e4:	20000140 	.word	0x20000140

080178e8 <__utoa>:
 80178e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80178ea:	4c1f      	ldr	r4, [pc, #124]	; (8017968 <__utoa+0x80>)
 80178ec:	b08b      	sub	sp, #44	; 0x2c
 80178ee:	4605      	mov	r5, r0
 80178f0:	460b      	mov	r3, r1
 80178f2:	466e      	mov	r6, sp
 80178f4:	f104 0c20 	add.w	ip, r4, #32
 80178f8:	6820      	ldr	r0, [r4, #0]
 80178fa:	6861      	ldr	r1, [r4, #4]
 80178fc:	4637      	mov	r7, r6
 80178fe:	c703      	stmia	r7!, {r0, r1}
 8017900:	3408      	adds	r4, #8
 8017902:	4564      	cmp	r4, ip
 8017904:	463e      	mov	r6, r7
 8017906:	d1f7      	bne.n	80178f8 <__utoa+0x10>
 8017908:	7921      	ldrb	r1, [r4, #4]
 801790a:	7139      	strb	r1, [r7, #4]
 801790c:	1e91      	subs	r1, r2, #2
 801790e:	6820      	ldr	r0, [r4, #0]
 8017910:	6038      	str	r0, [r7, #0]
 8017912:	2922      	cmp	r1, #34	; 0x22
 8017914:	f04f 0100 	mov.w	r1, #0
 8017918:	d904      	bls.n	8017924 <__utoa+0x3c>
 801791a:	7019      	strb	r1, [r3, #0]
 801791c:	460b      	mov	r3, r1
 801791e:	4618      	mov	r0, r3
 8017920:	b00b      	add	sp, #44	; 0x2c
 8017922:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017924:	1e58      	subs	r0, r3, #1
 8017926:	4684      	mov	ip, r0
 8017928:	fbb5 f7f2 	udiv	r7, r5, r2
 801792c:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 8017930:	fb02 5617 	mls	r6, r2, r7, r5
 8017934:	4476      	add	r6, lr
 8017936:	460c      	mov	r4, r1
 8017938:	f816 6c28 	ldrb.w	r6, [r6, #-40]
 801793c:	f80c 6f01 	strb.w	r6, [ip, #1]!
 8017940:	462e      	mov	r6, r5
 8017942:	42b2      	cmp	r2, r6
 8017944:	f101 0101 	add.w	r1, r1, #1
 8017948:	463d      	mov	r5, r7
 801794a:	d9ed      	bls.n	8017928 <__utoa+0x40>
 801794c:	2200      	movs	r2, #0
 801794e:	545a      	strb	r2, [r3, r1]
 8017950:	1919      	adds	r1, r3, r4
 8017952:	1aa5      	subs	r5, r4, r2
 8017954:	42aa      	cmp	r2, r5
 8017956:	dae2      	bge.n	801791e <__utoa+0x36>
 8017958:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 801795c:	780e      	ldrb	r6, [r1, #0]
 801795e:	7006      	strb	r6, [r0, #0]
 8017960:	3201      	adds	r2, #1
 8017962:	f801 5901 	strb.w	r5, [r1], #-1
 8017966:	e7f4      	b.n	8017952 <__utoa+0x6a>
 8017968:	0801ae48 	.word	0x0801ae48

0801796c <__swbuf_r>:
 801796c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801796e:	460e      	mov	r6, r1
 8017970:	4614      	mov	r4, r2
 8017972:	4605      	mov	r5, r0
 8017974:	b118      	cbz	r0, 801797e <__swbuf_r+0x12>
 8017976:	6983      	ldr	r3, [r0, #24]
 8017978:	b90b      	cbnz	r3, 801797e <__swbuf_r+0x12>
 801797a:	f7fe f98d 	bl	8015c98 <__sinit>
 801797e:	4b21      	ldr	r3, [pc, #132]	; (8017a04 <__swbuf_r+0x98>)
 8017980:	429c      	cmp	r4, r3
 8017982:	d12b      	bne.n	80179dc <__swbuf_r+0x70>
 8017984:	686c      	ldr	r4, [r5, #4]
 8017986:	69a3      	ldr	r3, [r4, #24]
 8017988:	60a3      	str	r3, [r4, #8]
 801798a:	89a3      	ldrh	r3, [r4, #12]
 801798c:	071a      	lsls	r2, r3, #28
 801798e:	d52f      	bpl.n	80179f0 <__swbuf_r+0x84>
 8017990:	6923      	ldr	r3, [r4, #16]
 8017992:	b36b      	cbz	r3, 80179f0 <__swbuf_r+0x84>
 8017994:	6923      	ldr	r3, [r4, #16]
 8017996:	6820      	ldr	r0, [r4, #0]
 8017998:	1ac0      	subs	r0, r0, r3
 801799a:	6963      	ldr	r3, [r4, #20]
 801799c:	b2f6      	uxtb	r6, r6
 801799e:	4283      	cmp	r3, r0
 80179a0:	4637      	mov	r7, r6
 80179a2:	dc04      	bgt.n	80179ae <__swbuf_r+0x42>
 80179a4:	4621      	mov	r1, r4
 80179a6:	4628      	mov	r0, r5
 80179a8:	f7fe f8e2 	bl	8015b70 <_fflush_r>
 80179ac:	bb30      	cbnz	r0, 80179fc <__swbuf_r+0x90>
 80179ae:	68a3      	ldr	r3, [r4, #8]
 80179b0:	3b01      	subs	r3, #1
 80179b2:	60a3      	str	r3, [r4, #8]
 80179b4:	6823      	ldr	r3, [r4, #0]
 80179b6:	1c5a      	adds	r2, r3, #1
 80179b8:	6022      	str	r2, [r4, #0]
 80179ba:	701e      	strb	r6, [r3, #0]
 80179bc:	6963      	ldr	r3, [r4, #20]
 80179be:	3001      	adds	r0, #1
 80179c0:	4283      	cmp	r3, r0
 80179c2:	d004      	beq.n	80179ce <__swbuf_r+0x62>
 80179c4:	89a3      	ldrh	r3, [r4, #12]
 80179c6:	07db      	lsls	r3, r3, #31
 80179c8:	d506      	bpl.n	80179d8 <__swbuf_r+0x6c>
 80179ca:	2e0a      	cmp	r6, #10
 80179cc:	d104      	bne.n	80179d8 <__swbuf_r+0x6c>
 80179ce:	4621      	mov	r1, r4
 80179d0:	4628      	mov	r0, r5
 80179d2:	f7fe f8cd 	bl	8015b70 <_fflush_r>
 80179d6:	b988      	cbnz	r0, 80179fc <__swbuf_r+0x90>
 80179d8:	4638      	mov	r0, r7
 80179da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80179dc:	4b0a      	ldr	r3, [pc, #40]	; (8017a08 <__swbuf_r+0x9c>)
 80179de:	429c      	cmp	r4, r3
 80179e0:	d101      	bne.n	80179e6 <__swbuf_r+0x7a>
 80179e2:	68ac      	ldr	r4, [r5, #8]
 80179e4:	e7cf      	b.n	8017986 <__swbuf_r+0x1a>
 80179e6:	4b09      	ldr	r3, [pc, #36]	; (8017a0c <__swbuf_r+0xa0>)
 80179e8:	429c      	cmp	r4, r3
 80179ea:	bf08      	it	eq
 80179ec:	68ec      	ldreq	r4, [r5, #12]
 80179ee:	e7ca      	b.n	8017986 <__swbuf_r+0x1a>
 80179f0:	4621      	mov	r1, r4
 80179f2:	4628      	mov	r0, r5
 80179f4:	f000 f81e 	bl	8017a34 <__swsetup_r>
 80179f8:	2800      	cmp	r0, #0
 80179fa:	d0cb      	beq.n	8017994 <__swbuf_r+0x28>
 80179fc:	f04f 37ff 	mov.w	r7, #4294967295
 8017a00:	e7ea      	b.n	80179d8 <__swbuf_r+0x6c>
 8017a02:	bf00      	nop
 8017a04:	0801ad80 	.word	0x0801ad80
 8017a08:	0801ada0 	.word	0x0801ada0
 8017a0c:	0801ad60 	.word	0x0801ad60

08017a10 <_write_r>:
 8017a10:	b538      	push	{r3, r4, r5, lr}
 8017a12:	4d07      	ldr	r5, [pc, #28]	; (8017a30 <_write_r+0x20>)
 8017a14:	4604      	mov	r4, r0
 8017a16:	4608      	mov	r0, r1
 8017a18:	4611      	mov	r1, r2
 8017a1a:	2200      	movs	r2, #0
 8017a1c:	602a      	str	r2, [r5, #0]
 8017a1e:	461a      	mov	r2, r3
 8017a20:	f7fd ffee 	bl	8015a00 <_write>
 8017a24:	1c43      	adds	r3, r0, #1
 8017a26:	d102      	bne.n	8017a2e <_write_r+0x1e>
 8017a28:	682b      	ldr	r3, [r5, #0]
 8017a2a:	b103      	cbz	r3, 8017a2e <_write_r+0x1e>
 8017a2c:	6023      	str	r3, [r4, #0]
 8017a2e:	bd38      	pop	{r3, r4, r5, pc}
 8017a30:	2001a178 	.word	0x2001a178

08017a34 <__swsetup_r>:
 8017a34:	4b32      	ldr	r3, [pc, #200]	; (8017b00 <__swsetup_r+0xcc>)
 8017a36:	b570      	push	{r4, r5, r6, lr}
 8017a38:	681d      	ldr	r5, [r3, #0]
 8017a3a:	4606      	mov	r6, r0
 8017a3c:	460c      	mov	r4, r1
 8017a3e:	b125      	cbz	r5, 8017a4a <__swsetup_r+0x16>
 8017a40:	69ab      	ldr	r3, [r5, #24]
 8017a42:	b913      	cbnz	r3, 8017a4a <__swsetup_r+0x16>
 8017a44:	4628      	mov	r0, r5
 8017a46:	f7fe f927 	bl	8015c98 <__sinit>
 8017a4a:	4b2e      	ldr	r3, [pc, #184]	; (8017b04 <__swsetup_r+0xd0>)
 8017a4c:	429c      	cmp	r4, r3
 8017a4e:	d10f      	bne.n	8017a70 <__swsetup_r+0x3c>
 8017a50:	686c      	ldr	r4, [r5, #4]
 8017a52:	89a3      	ldrh	r3, [r4, #12]
 8017a54:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8017a58:	0719      	lsls	r1, r3, #28
 8017a5a:	d42c      	bmi.n	8017ab6 <__swsetup_r+0x82>
 8017a5c:	06dd      	lsls	r5, r3, #27
 8017a5e:	d411      	bmi.n	8017a84 <__swsetup_r+0x50>
 8017a60:	2309      	movs	r3, #9
 8017a62:	6033      	str	r3, [r6, #0]
 8017a64:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8017a68:	81a3      	strh	r3, [r4, #12]
 8017a6a:	f04f 30ff 	mov.w	r0, #4294967295
 8017a6e:	e03e      	b.n	8017aee <__swsetup_r+0xba>
 8017a70:	4b25      	ldr	r3, [pc, #148]	; (8017b08 <__swsetup_r+0xd4>)
 8017a72:	429c      	cmp	r4, r3
 8017a74:	d101      	bne.n	8017a7a <__swsetup_r+0x46>
 8017a76:	68ac      	ldr	r4, [r5, #8]
 8017a78:	e7eb      	b.n	8017a52 <__swsetup_r+0x1e>
 8017a7a:	4b24      	ldr	r3, [pc, #144]	; (8017b0c <__swsetup_r+0xd8>)
 8017a7c:	429c      	cmp	r4, r3
 8017a7e:	bf08      	it	eq
 8017a80:	68ec      	ldreq	r4, [r5, #12]
 8017a82:	e7e6      	b.n	8017a52 <__swsetup_r+0x1e>
 8017a84:	0758      	lsls	r0, r3, #29
 8017a86:	d512      	bpl.n	8017aae <__swsetup_r+0x7a>
 8017a88:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8017a8a:	b141      	cbz	r1, 8017a9e <__swsetup_r+0x6a>
 8017a8c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8017a90:	4299      	cmp	r1, r3
 8017a92:	d002      	beq.n	8017a9a <__swsetup_r+0x66>
 8017a94:	4630      	mov	r0, r6
 8017a96:	f7fe fa93 	bl	8015fc0 <_free_r>
 8017a9a:	2300      	movs	r3, #0
 8017a9c:	6363      	str	r3, [r4, #52]	; 0x34
 8017a9e:	89a3      	ldrh	r3, [r4, #12]
 8017aa0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8017aa4:	81a3      	strh	r3, [r4, #12]
 8017aa6:	2300      	movs	r3, #0
 8017aa8:	6063      	str	r3, [r4, #4]
 8017aaa:	6923      	ldr	r3, [r4, #16]
 8017aac:	6023      	str	r3, [r4, #0]
 8017aae:	89a3      	ldrh	r3, [r4, #12]
 8017ab0:	f043 0308 	orr.w	r3, r3, #8
 8017ab4:	81a3      	strh	r3, [r4, #12]
 8017ab6:	6923      	ldr	r3, [r4, #16]
 8017ab8:	b94b      	cbnz	r3, 8017ace <__swsetup_r+0x9a>
 8017aba:	89a3      	ldrh	r3, [r4, #12]
 8017abc:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8017ac0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8017ac4:	d003      	beq.n	8017ace <__swsetup_r+0x9a>
 8017ac6:	4621      	mov	r1, r4
 8017ac8:	4630      	mov	r0, r6
 8017aca:	f7fe f9e9 	bl	8015ea0 <__smakebuf_r>
 8017ace:	89a0      	ldrh	r0, [r4, #12]
 8017ad0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8017ad4:	f010 0301 	ands.w	r3, r0, #1
 8017ad8:	d00a      	beq.n	8017af0 <__swsetup_r+0xbc>
 8017ada:	2300      	movs	r3, #0
 8017adc:	60a3      	str	r3, [r4, #8]
 8017ade:	6963      	ldr	r3, [r4, #20]
 8017ae0:	425b      	negs	r3, r3
 8017ae2:	61a3      	str	r3, [r4, #24]
 8017ae4:	6923      	ldr	r3, [r4, #16]
 8017ae6:	b943      	cbnz	r3, 8017afa <__swsetup_r+0xc6>
 8017ae8:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8017aec:	d1ba      	bne.n	8017a64 <__swsetup_r+0x30>
 8017aee:	bd70      	pop	{r4, r5, r6, pc}
 8017af0:	0781      	lsls	r1, r0, #30
 8017af2:	bf58      	it	pl
 8017af4:	6963      	ldrpl	r3, [r4, #20]
 8017af6:	60a3      	str	r3, [r4, #8]
 8017af8:	e7f4      	b.n	8017ae4 <__swsetup_r+0xb0>
 8017afa:	2000      	movs	r0, #0
 8017afc:	e7f7      	b.n	8017aee <__swsetup_r+0xba>
 8017afe:	bf00      	nop
 8017b00:	20000140 	.word	0x20000140
 8017b04:	0801ad80 	.word	0x0801ad80
 8017b08:	0801ada0 	.word	0x0801ada0
 8017b0c:	0801ad60 	.word	0x0801ad60

08017b10 <_close_r>:
 8017b10:	b538      	push	{r3, r4, r5, lr}
 8017b12:	4d06      	ldr	r5, [pc, #24]	; (8017b2c <_close_r+0x1c>)
 8017b14:	2300      	movs	r3, #0
 8017b16:	4604      	mov	r4, r0
 8017b18:	4608      	mov	r0, r1
 8017b1a:	602b      	str	r3, [r5, #0]
 8017b1c:	f7fd ff7e 	bl	8015a1c <_close>
 8017b20:	1c43      	adds	r3, r0, #1
 8017b22:	d102      	bne.n	8017b2a <_close_r+0x1a>
 8017b24:	682b      	ldr	r3, [r5, #0]
 8017b26:	b103      	cbz	r3, 8017b2a <_close_r+0x1a>
 8017b28:	6023      	str	r3, [r4, #0]
 8017b2a:	bd38      	pop	{r3, r4, r5, pc}
 8017b2c:	2001a178 	.word	0x2001a178

08017b30 <quorem>:
 8017b30:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017b34:	6903      	ldr	r3, [r0, #16]
 8017b36:	690c      	ldr	r4, [r1, #16]
 8017b38:	42a3      	cmp	r3, r4
 8017b3a:	4607      	mov	r7, r0
 8017b3c:	f2c0 8081 	blt.w	8017c42 <quorem+0x112>
 8017b40:	3c01      	subs	r4, #1
 8017b42:	f101 0814 	add.w	r8, r1, #20
 8017b46:	f100 0514 	add.w	r5, r0, #20
 8017b4a:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8017b4e:	9301      	str	r3, [sp, #4]
 8017b50:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8017b54:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8017b58:	3301      	adds	r3, #1
 8017b5a:	429a      	cmp	r2, r3
 8017b5c:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 8017b60:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 8017b64:	fbb2 f6f3 	udiv	r6, r2, r3
 8017b68:	d331      	bcc.n	8017bce <quorem+0x9e>
 8017b6a:	f04f 0e00 	mov.w	lr, #0
 8017b6e:	4640      	mov	r0, r8
 8017b70:	46ac      	mov	ip, r5
 8017b72:	46f2      	mov	sl, lr
 8017b74:	f850 2b04 	ldr.w	r2, [r0], #4
 8017b78:	b293      	uxth	r3, r2
 8017b7a:	fb06 e303 	mla	r3, r6, r3, lr
 8017b7e:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8017b82:	b29b      	uxth	r3, r3
 8017b84:	ebaa 0303 	sub.w	r3, sl, r3
 8017b88:	0c12      	lsrs	r2, r2, #16
 8017b8a:	f8dc a000 	ldr.w	sl, [ip]
 8017b8e:	fb06 e202 	mla	r2, r6, r2, lr
 8017b92:	fa13 f38a 	uxtah	r3, r3, sl
 8017b96:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 8017b9a:	fa1f fa82 	uxth.w	sl, r2
 8017b9e:	f8dc 2000 	ldr.w	r2, [ip]
 8017ba2:	ebca 4212 	rsb	r2, sl, r2, lsr #16
 8017ba6:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8017baa:	b29b      	uxth	r3, r3
 8017bac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8017bb0:	4581      	cmp	r9, r0
 8017bb2:	f84c 3b04 	str.w	r3, [ip], #4
 8017bb6:	ea4f 4a22 	mov.w	sl, r2, asr #16
 8017bba:	d2db      	bcs.n	8017b74 <quorem+0x44>
 8017bbc:	f855 300b 	ldr.w	r3, [r5, fp]
 8017bc0:	b92b      	cbnz	r3, 8017bce <quorem+0x9e>
 8017bc2:	9b01      	ldr	r3, [sp, #4]
 8017bc4:	3b04      	subs	r3, #4
 8017bc6:	429d      	cmp	r5, r3
 8017bc8:	461a      	mov	r2, r3
 8017bca:	d32e      	bcc.n	8017c2a <quorem+0xfa>
 8017bcc:	613c      	str	r4, [r7, #16]
 8017bce:	4638      	mov	r0, r7
 8017bd0:	f001 fcb4 	bl	801953c <__mcmp>
 8017bd4:	2800      	cmp	r0, #0
 8017bd6:	db24      	blt.n	8017c22 <quorem+0xf2>
 8017bd8:	3601      	adds	r6, #1
 8017bda:	4628      	mov	r0, r5
 8017bdc:	f04f 0c00 	mov.w	ip, #0
 8017be0:	f858 2b04 	ldr.w	r2, [r8], #4
 8017be4:	f8d0 e000 	ldr.w	lr, [r0]
 8017be8:	b293      	uxth	r3, r2
 8017bea:	ebac 0303 	sub.w	r3, ip, r3
 8017bee:	0c12      	lsrs	r2, r2, #16
 8017bf0:	fa13 f38e 	uxtah	r3, r3, lr
 8017bf4:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 8017bf8:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8017bfc:	b29b      	uxth	r3, r3
 8017bfe:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8017c02:	45c1      	cmp	r9, r8
 8017c04:	f840 3b04 	str.w	r3, [r0], #4
 8017c08:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8017c0c:	d2e8      	bcs.n	8017be0 <quorem+0xb0>
 8017c0e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8017c12:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8017c16:	b922      	cbnz	r2, 8017c22 <quorem+0xf2>
 8017c18:	3b04      	subs	r3, #4
 8017c1a:	429d      	cmp	r5, r3
 8017c1c:	461a      	mov	r2, r3
 8017c1e:	d30a      	bcc.n	8017c36 <quorem+0x106>
 8017c20:	613c      	str	r4, [r7, #16]
 8017c22:	4630      	mov	r0, r6
 8017c24:	b003      	add	sp, #12
 8017c26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017c2a:	6812      	ldr	r2, [r2, #0]
 8017c2c:	3b04      	subs	r3, #4
 8017c2e:	2a00      	cmp	r2, #0
 8017c30:	d1cc      	bne.n	8017bcc <quorem+0x9c>
 8017c32:	3c01      	subs	r4, #1
 8017c34:	e7c7      	b.n	8017bc6 <quorem+0x96>
 8017c36:	6812      	ldr	r2, [r2, #0]
 8017c38:	3b04      	subs	r3, #4
 8017c3a:	2a00      	cmp	r2, #0
 8017c3c:	d1f0      	bne.n	8017c20 <quorem+0xf0>
 8017c3e:	3c01      	subs	r4, #1
 8017c40:	e7eb      	b.n	8017c1a <quorem+0xea>
 8017c42:	2000      	movs	r0, #0
 8017c44:	e7ee      	b.n	8017c24 <quorem+0xf4>
	...

08017c48 <_dtoa_r>:
 8017c48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017c4c:	ed2d 8b02 	vpush	{d8}
 8017c50:	ec57 6b10 	vmov	r6, r7, d0
 8017c54:	b095      	sub	sp, #84	; 0x54
 8017c56:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8017c58:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 8017c5c:	9105      	str	r1, [sp, #20]
 8017c5e:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8017c62:	4604      	mov	r4, r0
 8017c64:	9209      	str	r2, [sp, #36]	; 0x24
 8017c66:	930f      	str	r3, [sp, #60]	; 0x3c
 8017c68:	b975      	cbnz	r5, 8017c88 <_dtoa_r+0x40>
 8017c6a:	2010      	movs	r0, #16
 8017c6c:	f7fe f958 	bl	8015f20 <malloc>
 8017c70:	4602      	mov	r2, r0
 8017c72:	6260      	str	r0, [r4, #36]	; 0x24
 8017c74:	b920      	cbnz	r0, 8017c80 <_dtoa_r+0x38>
 8017c76:	4bb2      	ldr	r3, [pc, #712]	; (8017f40 <_dtoa_r+0x2f8>)
 8017c78:	21ea      	movs	r1, #234	; 0xea
 8017c7a:	48b2      	ldr	r0, [pc, #712]	; (8017f44 <_dtoa_r+0x2fc>)
 8017c7c:	f001 ffd6 	bl	8019c2c <__assert_func>
 8017c80:	e9c0 5501 	strd	r5, r5, [r0, #4]
 8017c84:	6005      	str	r5, [r0, #0]
 8017c86:	60c5      	str	r5, [r0, #12]
 8017c88:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8017c8a:	6819      	ldr	r1, [r3, #0]
 8017c8c:	b151      	cbz	r1, 8017ca4 <_dtoa_r+0x5c>
 8017c8e:	685a      	ldr	r2, [r3, #4]
 8017c90:	604a      	str	r2, [r1, #4]
 8017c92:	2301      	movs	r3, #1
 8017c94:	4093      	lsls	r3, r2
 8017c96:	608b      	str	r3, [r1, #8]
 8017c98:	4620      	mov	r0, r4
 8017c9a:	f001 f9c7 	bl	801902c <_Bfree>
 8017c9e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8017ca0:	2200      	movs	r2, #0
 8017ca2:	601a      	str	r2, [r3, #0]
 8017ca4:	1e3b      	subs	r3, r7, #0
 8017ca6:	bfb9      	ittee	lt
 8017ca8:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 8017cac:	9303      	strlt	r3, [sp, #12]
 8017cae:	2300      	movge	r3, #0
 8017cb0:	f8c8 3000 	strge.w	r3, [r8]
 8017cb4:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8017cb8:	4ba3      	ldr	r3, [pc, #652]	; (8017f48 <_dtoa_r+0x300>)
 8017cba:	bfbc      	itt	lt
 8017cbc:	2201      	movlt	r2, #1
 8017cbe:	f8c8 2000 	strlt.w	r2, [r8]
 8017cc2:	ea33 0309 	bics.w	r3, r3, r9
 8017cc6:	d11b      	bne.n	8017d00 <_dtoa_r+0xb8>
 8017cc8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8017cca:	f242 730f 	movw	r3, #9999	; 0x270f
 8017cce:	6013      	str	r3, [r2, #0]
 8017cd0:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8017cd4:	4333      	orrs	r3, r6
 8017cd6:	f000 857a 	beq.w	80187ce <_dtoa_r+0xb86>
 8017cda:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8017cdc:	b963      	cbnz	r3, 8017cf8 <_dtoa_r+0xb0>
 8017cde:	4b9b      	ldr	r3, [pc, #620]	; (8017f4c <_dtoa_r+0x304>)
 8017ce0:	e024      	b.n	8017d2c <_dtoa_r+0xe4>
 8017ce2:	4b9b      	ldr	r3, [pc, #620]	; (8017f50 <_dtoa_r+0x308>)
 8017ce4:	9300      	str	r3, [sp, #0]
 8017ce6:	3308      	adds	r3, #8
 8017ce8:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8017cea:	6013      	str	r3, [r2, #0]
 8017cec:	9800      	ldr	r0, [sp, #0]
 8017cee:	b015      	add	sp, #84	; 0x54
 8017cf0:	ecbd 8b02 	vpop	{d8}
 8017cf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017cf8:	4b94      	ldr	r3, [pc, #592]	; (8017f4c <_dtoa_r+0x304>)
 8017cfa:	9300      	str	r3, [sp, #0]
 8017cfc:	3303      	adds	r3, #3
 8017cfe:	e7f3      	b.n	8017ce8 <_dtoa_r+0xa0>
 8017d00:	ed9d 7b02 	vldr	d7, [sp, #8]
 8017d04:	2200      	movs	r2, #0
 8017d06:	ec51 0b17 	vmov	r0, r1, d7
 8017d0a:	2300      	movs	r3, #0
 8017d0c:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 8017d10:	f7e8 ff02 	bl	8000b18 <__aeabi_dcmpeq>
 8017d14:	4680      	mov	r8, r0
 8017d16:	b158      	cbz	r0, 8017d30 <_dtoa_r+0xe8>
 8017d18:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8017d1a:	2301      	movs	r3, #1
 8017d1c:	6013      	str	r3, [r2, #0]
 8017d1e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8017d20:	2b00      	cmp	r3, #0
 8017d22:	f000 8551 	beq.w	80187c8 <_dtoa_r+0xb80>
 8017d26:	488b      	ldr	r0, [pc, #556]	; (8017f54 <_dtoa_r+0x30c>)
 8017d28:	6018      	str	r0, [r3, #0]
 8017d2a:	1e43      	subs	r3, r0, #1
 8017d2c:	9300      	str	r3, [sp, #0]
 8017d2e:	e7dd      	b.n	8017cec <_dtoa_r+0xa4>
 8017d30:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 8017d34:	aa12      	add	r2, sp, #72	; 0x48
 8017d36:	a913      	add	r1, sp, #76	; 0x4c
 8017d38:	4620      	mov	r0, r4
 8017d3a:	f001 fd1f 	bl	801977c <__d2b>
 8017d3e:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8017d42:	4683      	mov	fp, r0
 8017d44:	2d00      	cmp	r5, #0
 8017d46:	d07c      	beq.n	8017e42 <_dtoa_r+0x1fa>
 8017d48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8017d4a:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
 8017d4e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8017d52:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8017d56:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 8017d5a:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 8017d5e:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8017d62:	4b7d      	ldr	r3, [pc, #500]	; (8017f58 <_dtoa_r+0x310>)
 8017d64:	2200      	movs	r2, #0
 8017d66:	4630      	mov	r0, r6
 8017d68:	4639      	mov	r1, r7
 8017d6a:	f7e8 fab5 	bl	80002d8 <__aeabi_dsub>
 8017d6e:	a36e      	add	r3, pc, #440	; (adr r3, 8017f28 <_dtoa_r+0x2e0>)
 8017d70:	e9d3 2300 	ldrd	r2, r3, [r3]
 8017d74:	f7e8 fc68 	bl	8000648 <__aeabi_dmul>
 8017d78:	a36d      	add	r3, pc, #436	; (adr r3, 8017f30 <_dtoa_r+0x2e8>)
 8017d7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8017d7e:	f7e8 faad 	bl	80002dc <__adddf3>
 8017d82:	4606      	mov	r6, r0
 8017d84:	4628      	mov	r0, r5
 8017d86:	460f      	mov	r7, r1
 8017d88:	f7e8 fbf4 	bl	8000574 <__aeabi_i2d>
 8017d8c:	a36a      	add	r3, pc, #424	; (adr r3, 8017f38 <_dtoa_r+0x2f0>)
 8017d8e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8017d92:	f7e8 fc59 	bl	8000648 <__aeabi_dmul>
 8017d96:	4602      	mov	r2, r0
 8017d98:	460b      	mov	r3, r1
 8017d9a:	4630      	mov	r0, r6
 8017d9c:	4639      	mov	r1, r7
 8017d9e:	f7e8 fa9d 	bl	80002dc <__adddf3>
 8017da2:	4606      	mov	r6, r0
 8017da4:	460f      	mov	r7, r1
 8017da6:	f7e8 feff 	bl	8000ba8 <__aeabi_d2iz>
 8017daa:	2200      	movs	r2, #0
 8017dac:	4682      	mov	sl, r0
 8017dae:	2300      	movs	r3, #0
 8017db0:	4630      	mov	r0, r6
 8017db2:	4639      	mov	r1, r7
 8017db4:	f7e8 feba 	bl	8000b2c <__aeabi_dcmplt>
 8017db8:	b148      	cbz	r0, 8017dce <_dtoa_r+0x186>
 8017dba:	4650      	mov	r0, sl
 8017dbc:	f7e8 fbda 	bl	8000574 <__aeabi_i2d>
 8017dc0:	4632      	mov	r2, r6
 8017dc2:	463b      	mov	r3, r7
 8017dc4:	f7e8 fea8 	bl	8000b18 <__aeabi_dcmpeq>
 8017dc8:	b908      	cbnz	r0, 8017dce <_dtoa_r+0x186>
 8017dca:	f10a 3aff 	add.w	sl, sl, #4294967295
 8017dce:	f1ba 0f16 	cmp.w	sl, #22
 8017dd2:	d854      	bhi.n	8017e7e <_dtoa_r+0x236>
 8017dd4:	4b61      	ldr	r3, [pc, #388]	; (8017f5c <_dtoa_r+0x314>)
 8017dd6:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8017dda:	e9d3 2300 	ldrd	r2, r3, [r3]
 8017dde:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8017de2:	f7e8 fea3 	bl	8000b2c <__aeabi_dcmplt>
 8017de6:	2800      	cmp	r0, #0
 8017de8:	d04b      	beq.n	8017e82 <_dtoa_r+0x23a>
 8017dea:	f10a 3aff 	add.w	sl, sl, #4294967295
 8017dee:	2300      	movs	r3, #0
 8017df0:	930e      	str	r3, [sp, #56]	; 0x38
 8017df2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8017df4:	1b5d      	subs	r5, r3, r5
 8017df6:	1e6b      	subs	r3, r5, #1
 8017df8:	9304      	str	r3, [sp, #16]
 8017dfa:	bf43      	ittte	mi
 8017dfc:	2300      	movmi	r3, #0
 8017dfe:	f1c5 0801 	rsbmi	r8, r5, #1
 8017e02:	9304      	strmi	r3, [sp, #16]
 8017e04:	f04f 0800 	movpl.w	r8, #0
 8017e08:	f1ba 0f00 	cmp.w	sl, #0
 8017e0c:	db3b      	blt.n	8017e86 <_dtoa_r+0x23e>
 8017e0e:	9b04      	ldr	r3, [sp, #16]
 8017e10:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8017e14:	4453      	add	r3, sl
 8017e16:	9304      	str	r3, [sp, #16]
 8017e18:	2300      	movs	r3, #0
 8017e1a:	9306      	str	r3, [sp, #24]
 8017e1c:	9b05      	ldr	r3, [sp, #20]
 8017e1e:	2b09      	cmp	r3, #9
 8017e20:	d869      	bhi.n	8017ef6 <_dtoa_r+0x2ae>
 8017e22:	2b05      	cmp	r3, #5
 8017e24:	bfc4      	itt	gt
 8017e26:	3b04      	subgt	r3, #4
 8017e28:	9305      	strgt	r3, [sp, #20]
 8017e2a:	9b05      	ldr	r3, [sp, #20]
 8017e2c:	f1a3 0302 	sub.w	r3, r3, #2
 8017e30:	bfcc      	ite	gt
 8017e32:	2500      	movgt	r5, #0
 8017e34:	2501      	movle	r5, #1
 8017e36:	2b03      	cmp	r3, #3
 8017e38:	d869      	bhi.n	8017f0e <_dtoa_r+0x2c6>
 8017e3a:	e8df f003 	tbb	[pc, r3]
 8017e3e:	4e2c      	.short	0x4e2c
 8017e40:	5a4c      	.short	0x5a4c
 8017e42:	e9dd 5312 	ldrd	r5, r3, [sp, #72]	; 0x48
 8017e46:	441d      	add	r5, r3
 8017e48:	f205 4332 	addw	r3, r5, #1074	; 0x432
 8017e4c:	2b20      	cmp	r3, #32
 8017e4e:	bfc1      	itttt	gt
 8017e50:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 8017e54:	f205 4012 	addwgt	r0, r5, #1042	; 0x412
 8017e58:	fa09 f303 	lslgt.w	r3, r9, r3
 8017e5c:	fa26 f000 	lsrgt.w	r0, r6, r0
 8017e60:	bfda      	itte	le
 8017e62:	f1c3 0320 	rsble	r3, r3, #32
 8017e66:	fa06 f003 	lslle.w	r0, r6, r3
 8017e6a:	4318      	orrgt	r0, r3
 8017e6c:	f7e8 fb72 	bl	8000554 <__aeabi_ui2d>
 8017e70:	2301      	movs	r3, #1
 8017e72:	4606      	mov	r6, r0
 8017e74:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 8017e78:	3d01      	subs	r5, #1
 8017e7a:	9310      	str	r3, [sp, #64]	; 0x40
 8017e7c:	e771      	b.n	8017d62 <_dtoa_r+0x11a>
 8017e7e:	2301      	movs	r3, #1
 8017e80:	e7b6      	b.n	8017df0 <_dtoa_r+0x1a8>
 8017e82:	900e      	str	r0, [sp, #56]	; 0x38
 8017e84:	e7b5      	b.n	8017df2 <_dtoa_r+0x1aa>
 8017e86:	f1ca 0300 	rsb	r3, sl, #0
 8017e8a:	9306      	str	r3, [sp, #24]
 8017e8c:	2300      	movs	r3, #0
 8017e8e:	eba8 080a 	sub.w	r8, r8, sl
 8017e92:	930d      	str	r3, [sp, #52]	; 0x34
 8017e94:	e7c2      	b.n	8017e1c <_dtoa_r+0x1d4>
 8017e96:	2300      	movs	r3, #0
 8017e98:	9308      	str	r3, [sp, #32]
 8017e9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017e9c:	2b00      	cmp	r3, #0
 8017e9e:	dc39      	bgt.n	8017f14 <_dtoa_r+0x2cc>
 8017ea0:	f04f 0901 	mov.w	r9, #1
 8017ea4:	f8cd 9004 	str.w	r9, [sp, #4]
 8017ea8:	464b      	mov	r3, r9
 8017eaa:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8017eae:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8017eb0:	2200      	movs	r2, #0
 8017eb2:	6042      	str	r2, [r0, #4]
 8017eb4:	2204      	movs	r2, #4
 8017eb6:	f102 0614 	add.w	r6, r2, #20
 8017eba:	429e      	cmp	r6, r3
 8017ebc:	6841      	ldr	r1, [r0, #4]
 8017ebe:	d92f      	bls.n	8017f20 <_dtoa_r+0x2d8>
 8017ec0:	4620      	mov	r0, r4
 8017ec2:	f001 f873 	bl	8018fac <_Balloc>
 8017ec6:	9000      	str	r0, [sp, #0]
 8017ec8:	2800      	cmp	r0, #0
 8017eca:	d14b      	bne.n	8017f64 <_dtoa_r+0x31c>
 8017ecc:	4b24      	ldr	r3, [pc, #144]	; (8017f60 <_dtoa_r+0x318>)
 8017ece:	4602      	mov	r2, r0
 8017ed0:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8017ed4:	e6d1      	b.n	8017c7a <_dtoa_r+0x32>
 8017ed6:	2301      	movs	r3, #1
 8017ed8:	e7de      	b.n	8017e98 <_dtoa_r+0x250>
 8017eda:	2300      	movs	r3, #0
 8017edc:	9308      	str	r3, [sp, #32]
 8017ede:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017ee0:	eb0a 0903 	add.w	r9, sl, r3
 8017ee4:	f109 0301 	add.w	r3, r9, #1
 8017ee8:	2b01      	cmp	r3, #1
 8017eea:	9301      	str	r3, [sp, #4]
 8017eec:	bfb8      	it	lt
 8017eee:	2301      	movlt	r3, #1
 8017ef0:	e7dd      	b.n	8017eae <_dtoa_r+0x266>
 8017ef2:	2301      	movs	r3, #1
 8017ef4:	e7f2      	b.n	8017edc <_dtoa_r+0x294>
 8017ef6:	2501      	movs	r5, #1
 8017ef8:	2300      	movs	r3, #0
 8017efa:	9305      	str	r3, [sp, #20]
 8017efc:	9508      	str	r5, [sp, #32]
 8017efe:	f04f 39ff 	mov.w	r9, #4294967295
 8017f02:	2200      	movs	r2, #0
 8017f04:	f8cd 9004 	str.w	r9, [sp, #4]
 8017f08:	2312      	movs	r3, #18
 8017f0a:	9209      	str	r2, [sp, #36]	; 0x24
 8017f0c:	e7cf      	b.n	8017eae <_dtoa_r+0x266>
 8017f0e:	2301      	movs	r3, #1
 8017f10:	9308      	str	r3, [sp, #32]
 8017f12:	e7f4      	b.n	8017efe <_dtoa_r+0x2b6>
 8017f14:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8017f18:	f8cd 9004 	str.w	r9, [sp, #4]
 8017f1c:	464b      	mov	r3, r9
 8017f1e:	e7c6      	b.n	8017eae <_dtoa_r+0x266>
 8017f20:	3101      	adds	r1, #1
 8017f22:	6041      	str	r1, [r0, #4]
 8017f24:	0052      	lsls	r2, r2, #1
 8017f26:	e7c6      	b.n	8017eb6 <_dtoa_r+0x26e>
 8017f28:	636f4361 	.word	0x636f4361
 8017f2c:	3fd287a7 	.word	0x3fd287a7
 8017f30:	8b60c8b3 	.word	0x8b60c8b3
 8017f34:	3fc68a28 	.word	0x3fc68a28
 8017f38:	509f79fb 	.word	0x509f79fb
 8017f3c:	3fd34413 	.word	0x3fd34413
 8017f40:	0801ae7a 	.word	0x0801ae7a
 8017f44:	0801ae91 	.word	0x0801ae91
 8017f48:	7ff00000 	.word	0x7ff00000
 8017f4c:	0801ae76 	.word	0x0801ae76
 8017f50:	0801ae6d 	.word	0x0801ae6d
 8017f54:	0801add5 	.word	0x0801add5
 8017f58:	3ff80000 	.word	0x3ff80000
 8017f5c:	0801b008 	.word	0x0801b008
 8017f60:	0801aef0 	.word	0x0801aef0
 8017f64:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8017f66:	9a00      	ldr	r2, [sp, #0]
 8017f68:	601a      	str	r2, [r3, #0]
 8017f6a:	9b01      	ldr	r3, [sp, #4]
 8017f6c:	2b0e      	cmp	r3, #14
 8017f6e:	f200 80ad 	bhi.w	80180cc <_dtoa_r+0x484>
 8017f72:	2d00      	cmp	r5, #0
 8017f74:	f000 80aa 	beq.w	80180cc <_dtoa_r+0x484>
 8017f78:	f1ba 0f00 	cmp.w	sl, #0
 8017f7c:	dd36      	ble.n	8017fec <_dtoa_r+0x3a4>
 8017f7e:	4ac3      	ldr	r2, [pc, #780]	; (801828c <_dtoa_r+0x644>)
 8017f80:	f00a 030f 	and.w	r3, sl, #15
 8017f84:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8017f88:	ed93 7b00 	vldr	d7, [r3]
 8017f8c:	f41a 7f80 	tst.w	sl, #256	; 0x100
 8017f90:	ea4f 172a 	mov.w	r7, sl, asr #4
 8017f94:	eeb0 8a47 	vmov.f32	s16, s14
 8017f98:	eef0 8a67 	vmov.f32	s17, s15
 8017f9c:	d016      	beq.n	8017fcc <_dtoa_r+0x384>
 8017f9e:	4bbc      	ldr	r3, [pc, #752]	; (8018290 <_dtoa_r+0x648>)
 8017fa0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8017fa4:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8017fa8:	f7e8 fc78 	bl	800089c <__aeabi_ddiv>
 8017fac:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8017fb0:	f007 070f 	and.w	r7, r7, #15
 8017fb4:	2503      	movs	r5, #3
 8017fb6:	4eb6      	ldr	r6, [pc, #728]	; (8018290 <_dtoa_r+0x648>)
 8017fb8:	b957      	cbnz	r7, 8017fd0 <_dtoa_r+0x388>
 8017fba:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8017fbe:	ec53 2b18 	vmov	r2, r3, d8
 8017fc2:	f7e8 fc6b 	bl	800089c <__aeabi_ddiv>
 8017fc6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8017fca:	e029      	b.n	8018020 <_dtoa_r+0x3d8>
 8017fcc:	2502      	movs	r5, #2
 8017fce:	e7f2      	b.n	8017fb6 <_dtoa_r+0x36e>
 8017fd0:	07f9      	lsls	r1, r7, #31
 8017fd2:	d508      	bpl.n	8017fe6 <_dtoa_r+0x39e>
 8017fd4:	ec51 0b18 	vmov	r0, r1, d8
 8017fd8:	e9d6 2300 	ldrd	r2, r3, [r6]
 8017fdc:	f7e8 fb34 	bl	8000648 <__aeabi_dmul>
 8017fe0:	ec41 0b18 	vmov	d8, r0, r1
 8017fe4:	3501      	adds	r5, #1
 8017fe6:	107f      	asrs	r7, r7, #1
 8017fe8:	3608      	adds	r6, #8
 8017fea:	e7e5      	b.n	8017fb8 <_dtoa_r+0x370>
 8017fec:	f000 80a6 	beq.w	801813c <_dtoa_r+0x4f4>
 8017ff0:	f1ca 0600 	rsb	r6, sl, #0
 8017ff4:	4ba5      	ldr	r3, [pc, #660]	; (801828c <_dtoa_r+0x644>)
 8017ff6:	4fa6      	ldr	r7, [pc, #664]	; (8018290 <_dtoa_r+0x648>)
 8017ff8:	f006 020f 	and.w	r2, r6, #15
 8017ffc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8018000:	e9d3 2300 	ldrd	r2, r3, [r3]
 8018004:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8018008:	f7e8 fb1e 	bl	8000648 <__aeabi_dmul>
 801800c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8018010:	1136      	asrs	r6, r6, #4
 8018012:	2300      	movs	r3, #0
 8018014:	2502      	movs	r5, #2
 8018016:	2e00      	cmp	r6, #0
 8018018:	f040 8085 	bne.w	8018126 <_dtoa_r+0x4de>
 801801c:	2b00      	cmp	r3, #0
 801801e:	d1d2      	bne.n	8017fc6 <_dtoa_r+0x37e>
 8018020:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018022:	2b00      	cmp	r3, #0
 8018024:	f000 808c 	beq.w	8018140 <_dtoa_r+0x4f8>
 8018028:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 801802c:	4b99      	ldr	r3, [pc, #612]	; (8018294 <_dtoa_r+0x64c>)
 801802e:	2200      	movs	r2, #0
 8018030:	4630      	mov	r0, r6
 8018032:	4639      	mov	r1, r7
 8018034:	f7e8 fd7a 	bl	8000b2c <__aeabi_dcmplt>
 8018038:	2800      	cmp	r0, #0
 801803a:	f000 8081 	beq.w	8018140 <_dtoa_r+0x4f8>
 801803e:	9b01      	ldr	r3, [sp, #4]
 8018040:	2b00      	cmp	r3, #0
 8018042:	d07d      	beq.n	8018140 <_dtoa_r+0x4f8>
 8018044:	f1b9 0f00 	cmp.w	r9, #0
 8018048:	dd3c      	ble.n	80180c4 <_dtoa_r+0x47c>
 801804a:	f10a 33ff 	add.w	r3, sl, #4294967295
 801804e:	9307      	str	r3, [sp, #28]
 8018050:	2200      	movs	r2, #0
 8018052:	4b91      	ldr	r3, [pc, #580]	; (8018298 <_dtoa_r+0x650>)
 8018054:	4630      	mov	r0, r6
 8018056:	4639      	mov	r1, r7
 8018058:	f7e8 faf6 	bl	8000648 <__aeabi_dmul>
 801805c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8018060:	3501      	adds	r5, #1
 8018062:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 8018066:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 801806a:	4628      	mov	r0, r5
 801806c:	f7e8 fa82 	bl	8000574 <__aeabi_i2d>
 8018070:	4632      	mov	r2, r6
 8018072:	463b      	mov	r3, r7
 8018074:	f7e8 fae8 	bl	8000648 <__aeabi_dmul>
 8018078:	4b88      	ldr	r3, [pc, #544]	; (801829c <_dtoa_r+0x654>)
 801807a:	2200      	movs	r2, #0
 801807c:	f7e8 f92e 	bl	80002dc <__adddf3>
 8018080:	f1a1 7350 	sub.w	r3, r1, #54525952	; 0x3400000
 8018084:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8018088:	9303      	str	r3, [sp, #12]
 801808a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801808c:	2b00      	cmp	r3, #0
 801808e:	d15c      	bne.n	801814a <_dtoa_r+0x502>
 8018090:	4b83      	ldr	r3, [pc, #524]	; (80182a0 <_dtoa_r+0x658>)
 8018092:	2200      	movs	r2, #0
 8018094:	4630      	mov	r0, r6
 8018096:	4639      	mov	r1, r7
 8018098:	f7e8 f91e 	bl	80002d8 <__aeabi_dsub>
 801809c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80180a0:	4606      	mov	r6, r0
 80180a2:	460f      	mov	r7, r1
 80180a4:	f7e8 fd60 	bl	8000b68 <__aeabi_dcmpgt>
 80180a8:	2800      	cmp	r0, #0
 80180aa:	f040 8296 	bne.w	80185da <_dtoa_r+0x992>
 80180ae:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 80180b2:	4630      	mov	r0, r6
 80180b4:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 80180b8:	4639      	mov	r1, r7
 80180ba:	f7e8 fd37 	bl	8000b2c <__aeabi_dcmplt>
 80180be:	2800      	cmp	r0, #0
 80180c0:	f040 8288 	bne.w	80185d4 <_dtoa_r+0x98c>
 80180c4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 80180c8:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80180cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80180ce:	2b00      	cmp	r3, #0
 80180d0:	f2c0 8158 	blt.w	8018384 <_dtoa_r+0x73c>
 80180d4:	f1ba 0f0e 	cmp.w	sl, #14
 80180d8:	f300 8154 	bgt.w	8018384 <_dtoa_r+0x73c>
 80180dc:	4b6b      	ldr	r3, [pc, #428]	; (801828c <_dtoa_r+0x644>)
 80180de:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 80180e2:	e9d3 8900 	ldrd	r8, r9, [r3]
 80180e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80180e8:	2b00      	cmp	r3, #0
 80180ea:	f280 80e3 	bge.w	80182b4 <_dtoa_r+0x66c>
 80180ee:	9b01      	ldr	r3, [sp, #4]
 80180f0:	2b00      	cmp	r3, #0
 80180f2:	f300 80df 	bgt.w	80182b4 <_dtoa_r+0x66c>
 80180f6:	f040 826d 	bne.w	80185d4 <_dtoa_r+0x98c>
 80180fa:	4b69      	ldr	r3, [pc, #420]	; (80182a0 <_dtoa_r+0x658>)
 80180fc:	2200      	movs	r2, #0
 80180fe:	4640      	mov	r0, r8
 8018100:	4649      	mov	r1, r9
 8018102:	f7e8 faa1 	bl	8000648 <__aeabi_dmul>
 8018106:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801810a:	f7e8 fd23 	bl	8000b54 <__aeabi_dcmpge>
 801810e:	9e01      	ldr	r6, [sp, #4]
 8018110:	4637      	mov	r7, r6
 8018112:	2800      	cmp	r0, #0
 8018114:	f040 8243 	bne.w	801859e <_dtoa_r+0x956>
 8018118:	9d00      	ldr	r5, [sp, #0]
 801811a:	2331      	movs	r3, #49	; 0x31
 801811c:	f805 3b01 	strb.w	r3, [r5], #1
 8018120:	f10a 0a01 	add.w	sl, sl, #1
 8018124:	e23f      	b.n	80185a6 <_dtoa_r+0x95e>
 8018126:	07f2      	lsls	r2, r6, #31
 8018128:	d505      	bpl.n	8018136 <_dtoa_r+0x4ee>
 801812a:	e9d7 2300 	ldrd	r2, r3, [r7]
 801812e:	f7e8 fa8b 	bl	8000648 <__aeabi_dmul>
 8018132:	3501      	adds	r5, #1
 8018134:	2301      	movs	r3, #1
 8018136:	1076      	asrs	r6, r6, #1
 8018138:	3708      	adds	r7, #8
 801813a:	e76c      	b.n	8018016 <_dtoa_r+0x3ce>
 801813c:	2502      	movs	r5, #2
 801813e:	e76f      	b.n	8018020 <_dtoa_r+0x3d8>
 8018140:	9b01      	ldr	r3, [sp, #4]
 8018142:	f8cd a01c 	str.w	sl, [sp, #28]
 8018146:	930c      	str	r3, [sp, #48]	; 0x30
 8018148:	e78d      	b.n	8018066 <_dtoa_r+0x41e>
 801814a:	9900      	ldr	r1, [sp, #0]
 801814c:	980c      	ldr	r0, [sp, #48]	; 0x30
 801814e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8018150:	4b4e      	ldr	r3, [pc, #312]	; (801828c <_dtoa_r+0x644>)
 8018152:	ed9d 7b02 	vldr	d7, [sp, #8]
 8018156:	4401      	add	r1, r0
 8018158:	9102      	str	r1, [sp, #8]
 801815a:	9908      	ldr	r1, [sp, #32]
 801815c:	eeb0 8a47 	vmov.f32	s16, s14
 8018160:	eef0 8a67 	vmov.f32	s17, s15
 8018164:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8018168:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 801816c:	2900      	cmp	r1, #0
 801816e:	d045      	beq.n	80181fc <_dtoa_r+0x5b4>
 8018170:	494c      	ldr	r1, [pc, #304]	; (80182a4 <_dtoa_r+0x65c>)
 8018172:	2000      	movs	r0, #0
 8018174:	f7e8 fb92 	bl	800089c <__aeabi_ddiv>
 8018178:	ec53 2b18 	vmov	r2, r3, d8
 801817c:	f7e8 f8ac 	bl	80002d8 <__aeabi_dsub>
 8018180:	9d00      	ldr	r5, [sp, #0]
 8018182:	ec41 0b18 	vmov	d8, r0, r1
 8018186:	4639      	mov	r1, r7
 8018188:	4630      	mov	r0, r6
 801818a:	f7e8 fd0d 	bl	8000ba8 <__aeabi_d2iz>
 801818e:	900c      	str	r0, [sp, #48]	; 0x30
 8018190:	f7e8 f9f0 	bl	8000574 <__aeabi_i2d>
 8018194:	4602      	mov	r2, r0
 8018196:	460b      	mov	r3, r1
 8018198:	4630      	mov	r0, r6
 801819a:	4639      	mov	r1, r7
 801819c:	f7e8 f89c 	bl	80002d8 <__aeabi_dsub>
 80181a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80181a2:	3330      	adds	r3, #48	; 0x30
 80181a4:	f805 3b01 	strb.w	r3, [r5], #1
 80181a8:	ec53 2b18 	vmov	r2, r3, d8
 80181ac:	4606      	mov	r6, r0
 80181ae:	460f      	mov	r7, r1
 80181b0:	f7e8 fcbc 	bl	8000b2c <__aeabi_dcmplt>
 80181b4:	2800      	cmp	r0, #0
 80181b6:	d165      	bne.n	8018284 <_dtoa_r+0x63c>
 80181b8:	4632      	mov	r2, r6
 80181ba:	463b      	mov	r3, r7
 80181bc:	4935      	ldr	r1, [pc, #212]	; (8018294 <_dtoa_r+0x64c>)
 80181be:	2000      	movs	r0, #0
 80181c0:	f7e8 f88a 	bl	80002d8 <__aeabi_dsub>
 80181c4:	ec53 2b18 	vmov	r2, r3, d8
 80181c8:	f7e8 fcb0 	bl	8000b2c <__aeabi_dcmplt>
 80181cc:	2800      	cmp	r0, #0
 80181ce:	f040 80b9 	bne.w	8018344 <_dtoa_r+0x6fc>
 80181d2:	9b02      	ldr	r3, [sp, #8]
 80181d4:	429d      	cmp	r5, r3
 80181d6:	f43f af75 	beq.w	80180c4 <_dtoa_r+0x47c>
 80181da:	4b2f      	ldr	r3, [pc, #188]	; (8018298 <_dtoa_r+0x650>)
 80181dc:	ec51 0b18 	vmov	r0, r1, d8
 80181e0:	2200      	movs	r2, #0
 80181e2:	f7e8 fa31 	bl	8000648 <__aeabi_dmul>
 80181e6:	4b2c      	ldr	r3, [pc, #176]	; (8018298 <_dtoa_r+0x650>)
 80181e8:	ec41 0b18 	vmov	d8, r0, r1
 80181ec:	2200      	movs	r2, #0
 80181ee:	4630      	mov	r0, r6
 80181f0:	4639      	mov	r1, r7
 80181f2:	f7e8 fa29 	bl	8000648 <__aeabi_dmul>
 80181f6:	4606      	mov	r6, r0
 80181f8:	460f      	mov	r7, r1
 80181fa:	e7c4      	b.n	8018186 <_dtoa_r+0x53e>
 80181fc:	ec51 0b17 	vmov	r0, r1, d7
 8018200:	f7e8 fa22 	bl	8000648 <__aeabi_dmul>
 8018204:	9b02      	ldr	r3, [sp, #8]
 8018206:	9d00      	ldr	r5, [sp, #0]
 8018208:	930c      	str	r3, [sp, #48]	; 0x30
 801820a:	ec41 0b18 	vmov	d8, r0, r1
 801820e:	4639      	mov	r1, r7
 8018210:	4630      	mov	r0, r6
 8018212:	f7e8 fcc9 	bl	8000ba8 <__aeabi_d2iz>
 8018216:	9011      	str	r0, [sp, #68]	; 0x44
 8018218:	f7e8 f9ac 	bl	8000574 <__aeabi_i2d>
 801821c:	4602      	mov	r2, r0
 801821e:	460b      	mov	r3, r1
 8018220:	4630      	mov	r0, r6
 8018222:	4639      	mov	r1, r7
 8018224:	f7e8 f858 	bl	80002d8 <__aeabi_dsub>
 8018228:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801822a:	3330      	adds	r3, #48	; 0x30
 801822c:	f805 3b01 	strb.w	r3, [r5], #1
 8018230:	9b02      	ldr	r3, [sp, #8]
 8018232:	429d      	cmp	r5, r3
 8018234:	4606      	mov	r6, r0
 8018236:	460f      	mov	r7, r1
 8018238:	f04f 0200 	mov.w	r2, #0
 801823c:	d134      	bne.n	80182a8 <_dtoa_r+0x660>
 801823e:	4b19      	ldr	r3, [pc, #100]	; (80182a4 <_dtoa_r+0x65c>)
 8018240:	ec51 0b18 	vmov	r0, r1, d8
 8018244:	f7e8 f84a 	bl	80002dc <__adddf3>
 8018248:	4602      	mov	r2, r0
 801824a:	460b      	mov	r3, r1
 801824c:	4630      	mov	r0, r6
 801824e:	4639      	mov	r1, r7
 8018250:	f7e8 fc8a 	bl	8000b68 <__aeabi_dcmpgt>
 8018254:	2800      	cmp	r0, #0
 8018256:	d175      	bne.n	8018344 <_dtoa_r+0x6fc>
 8018258:	ec53 2b18 	vmov	r2, r3, d8
 801825c:	4911      	ldr	r1, [pc, #68]	; (80182a4 <_dtoa_r+0x65c>)
 801825e:	2000      	movs	r0, #0
 8018260:	f7e8 f83a 	bl	80002d8 <__aeabi_dsub>
 8018264:	4602      	mov	r2, r0
 8018266:	460b      	mov	r3, r1
 8018268:	4630      	mov	r0, r6
 801826a:	4639      	mov	r1, r7
 801826c:	f7e8 fc5e 	bl	8000b2c <__aeabi_dcmplt>
 8018270:	2800      	cmp	r0, #0
 8018272:	f43f af27 	beq.w	80180c4 <_dtoa_r+0x47c>
 8018276:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8018278:	1e6b      	subs	r3, r5, #1
 801827a:	930c      	str	r3, [sp, #48]	; 0x30
 801827c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8018280:	2b30      	cmp	r3, #48	; 0x30
 8018282:	d0f8      	beq.n	8018276 <_dtoa_r+0x62e>
 8018284:	f8dd a01c 	ldr.w	sl, [sp, #28]
 8018288:	e04a      	b.n	8018320 <_dtoa_r+0x6d8>
 801828a:	bf00      	nop
 801828c:	0801b008 	.word	0x0801b008
 8018290:	0801afe0 	.word	0x0801afe0
 8018294:	3ff00000 	.word	0x3ff00000
 8018298:	40240000 	.word	0x40240000
 801829c:	401c0000 	.word	0x401c0000
 80182a0:	40140000 	.word	0x40140000
 80182a4:	3fe00000 	.word	0x3fe00000
 80182a8:	4baf      	ldr	r3, [pc, #700]	; (8018568 <_dtoa_r+0x920>)
 80182aa:	f7e8 f9cd 	bl	8000648 <__aeabi_dmul>
 80182ae:	4606      	mov	r6, r0
 80182b0:	460f      	mov	r7, r1
 80182b2:	e7ac      	b.n	801820e <_dtoa_r+0x5c6>
 80182b4:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80182b8:	9d00      	ldr	r5, [sp, #0]
 80182ba:	4642      	mov	r2, r8
 80182bc:	464b      	mov	r3, r9
 80182be:	4630      	mov	r0, r6
 80182c0:	4639      	mov	r1, r7
 80182c2:	f7e8 faeb 	bl	800089c <__aeabi_ddiv>
 80182c6:	f7e8 fc6f 	bl	8000ba8 <__aeabi_d2iz>
 80182ca:	9002      	str	r0, [sp, #8]
 80182cc:	f7e8 f952 	bl	8000574 <__aeabi_i2d>
 80182d0:	4642      	mov	r2, r8
 80182d2:	464b      	mov	r3, r9
 80182d4:	f7e8 f9b8 	bl	8000648 <__aeabi_dmul>
 80182d8:	4602      	mov	r2, r0
 80182da:	460b      	mov	r3, r1
 80182dc:	4630      	mov	r0, r6
 80182de:	4639      	mov	r1, r7
 80182e0:	f7e7 fffa 	bl	80002d8 <__aeabi_dsub>
 80182e4:	9e02      	ldr	r6, [sp, #8]
 80182e6:	9f01      	ldr	r7, [sp, #4]
 80182e8:	3630      	adds	r6, #48	; 0x30
 80182ea:	f805 6b01 	strb.w	r6, [r5], #1
 80182ee:	9e00      	ldr	r6, [sp, #0]
 80182f0:	1bae      	subs	r6, r5, r6
 80182f2:	42b7      	cmp	r7, r6
 80182f4:	4602      	mov	r2, r0
 80182f6:	460b      	mov	r3, r1
 80182f8:	d137      	bne.n	801836a <_dtoa_r+0x722>
 80182fa:	f7e7 ffef 	bl	80002dc <__adddf3>
 80182fe:	4642      	mov	r2, r8
 8018300:	464b      	mov	r3, r9
 8018302:	4606      	mov	r6, r0
 8018304:	460f      	mov	r7, r1
 8018306:	f7e8 fc2f 	bl	8000b68 <__aeabi_dcmpgt>
 801830a:	b9c8      	cbnz	r0, 8018340 <_dtoa_r+0x6f8>
 801830c:	4642      	mov	r2, r8
 801830e:	464b      	mov	r3, r9
 8018310:	4630      	mov	r0, r6
 8018312:	4639      	mov	r1, r7
 8018314:	f7e8 fc00 	bl	8000b18 <__aeabi_dcmpeq>
 8018318:	b110      	cbz	r0, 8018320 <_dtoa_r+0x6d8>
 801831a:	9b02      	ldr	r3, [sp, #8]
 801831c:	07d9      	lsls	r1, r3, #31
 801831e:	d40f      	bmi.n	8018340 <_dtoa_r+0x6f8>
 8018320:	4620      	mov	r0, r4
 8018322:	4659      	mov	r1, fp
 8018324:	f000 fe82 	bl	801902c <_Bfree>
 8018328:	2300      	movs	r3, #0
 801832a:	702b      	strb	r3, [r5, #0]
 801832c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801832e:	f10a 0001 	add.w	r0, sl, #1
 8018332:	6018      	str	r0, [r3, #0]
 8018334:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8018336:	2b00      	cmp	r3, #0
 8018338:	f43f acd8 	beq.w	8017cec <_dtoa_r+0xa4>
 801833c:	601d      	str	r5, [r3, #0]
 801833e:	e4d5      	b.n	8017cec <_dtoa_r+0xa4>
 8018340:	f8cd a01c 	str.w	sl, [sp, #28]
 8018344:	462b      	mov	r3, r5
 8018346:	461d      	mov	r5, r3
 8018348:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 801834c:	2a39      	cmp	r2, #57	; 0x39
 801834e:	d108      	bne.n	8018362 <_dtoa_r+0x71a>
 8018350:	9a00      	ldr	r2, [sp, #0]
 8018352:	429a      	cmp	r2, r3
 8018354:	d1f7      	bne.n	8018346 <_dtoa_r+0x6fe>
 8018356:	9a07      	ldr	r2, [sp, #28]
 8018358:	9900      	ldr	r1, [sp, #0]
 801835a:	3201      	adds	r2, #1
 801835c:	9207      	str	r2, [sp, #28]
 801835e:	2230      	movs	r2, #48	; 0x30
 8018360:	700a      	strb	r2, [r1, #0]
 8018362:	781a      	ldrb	r2, [r3, #0]
 8018364:	3201      	adds	r2, #1
 8018366:	701a      	strb	r2, [r3, #0]
 8018368:	e78c      	b.n	8018284 <_dtoa_r+0x63c>
 801836a:	4b7f      	ldr	r3, [pc, #508]	; (8018568 <_dtoa_r+0x920>)
 801836c:	2200      	movs	r2, #0
 801836e:	f7e8 f96b 	bl	8000648 <__aeabi_dmul>
 8018372:	2200      	movs	r2, #0
 8018374:	2300      	movs	r3, #0
 8018376:	4606      	mov	r6, r0
 8018378:	460f      	mov	r7, r1
 801837a:	f7e8 fbcd 	bl	8000b18 <__aeabi_dcmpeq>
 801837e:	2800      	cmp	r0, #0
 8018380:	d09b      	beq.n	80182ba <_dtoa_r+0x672>
 8018382:	e7cd      	b.n	8018320 <_dtoa_r+0x6d8>
 8018384:	9a08      	ldr	r2, [sp, #32]
 8018386:	2a00      	cmp	r2, #0
 8018388:	f000 80c4 	beq.w	8018514 <_dtoa_r+0x8cc>
 801838c:	9a05      	ldr	r2, [sp, #20]
 801838e:	2a01      	cmp	r2, #1
 8018390:	f300 80a8 	bgt.w	80184e4 <_dtoa_r+0x89c>
 8018394:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8018396:	2a00      	cmp	r2, #0
 8018398:	f000 80a0 	beq.w	80184dc <_dtoa_r+0x894>
 801839c:	f203 4333 	addw	r3, r3, #1075	; 0x433
 80183a0:	9e06      	ldr	r6, [sp, #24]
 80183a2:	4645      	mov	r5, r8
 80183a4:	9a04      	ldr	r2, [sp, #16]
 80183a6:	2101      	movs	r1, #1
 80183a8:	441a      	add	r2, r3
 80183aa:	4620      	mov	r0, r4
 80183ac:	4498      	add	r8, r3
 80183ae:	9204      	str	r2, [sp, #16]
 80183b0:	f000 ff42 	bl	8019238 <__i2b>
 80183b4:	4607      	mov	r7, r0
 80183b6:	2d00      	cmp	r5, #0
 80183b8:	dd0b      	ble.n	80183d2 <_dtoa_r+0x78a>
 80183ba:	9b04      	ldr	r3, [sp, #16]
 80183bc:	2b00      	cmp	r3, #0
 80183be:	dd08      	ble.n	80183d2 <_dtoa_r+0x78a>
 80183c0:	42ab      	cmp	r3, r5
 80183c2:	9a04      	ldr	r2, [sp, #16]
 80183c4:	bfa8      	it	ge
 80183c6:	462b      	movge	r3, r5
 80183c8:	eba8 0803 	sub.w	r8, r8, r3
 80183cc:	1aed      	subs	r5, r5, r3
 80183ce:	1ad3      	subs	r3, r2, r3
 80183d0:	9304      	str	r3, [sp, #16]
 80183d2:	9b06      	ldr	r3, [sp, #24]
 80183d4:	b1fb      	cbz	r3, 8018416 <_dtoa_r+0x7ce>
 80183d6:	9b08      	ldr	r3, [sp, #32]
 80183d8:	2b00      	cmp	r3, #0
 80183da:	f000 809f 	beq.w	801851c <_dtoa_r+0x8d4>
 80183de:	2e00      	cmp	r6, #0
 80183e0:	dd11      	ble.n	8018406 <_dtoa_r+0x7be>
 80183e2:	4639      	mov	r1, r7
 80183e4:	4632      	mov	r2, r6
 80183e6:	4620      	mov	r0, r4
 80183e8:	f000 ffe2 	bl	80193b0 <__pow5mult>
 80183ec:	465a      	mov	r2, fp
 80183ee:	4601      	mov	r1, r0
 80183f0:	4607      	mov	r7, r0
 80183f2:	4620      	mov	r0, r4
 80183f4:	f000 ff36 	bl	8019264 <__multiply>
 80183f8:	4659      	mov	r1, fp
 80183fa:	9007      	str	r0, [sp, #28]
 80183fc:	4620      	mov	r0, r4
 80183fe:	f000 fe15 	bl	801902c <_Bfree>
 8018402:	9b07      	ldr	r3, [sp, #28]
 8018404:	469b      	mov	fp, r3
 8018406:	9b06      	ldr	r3, [sp, #24]
 8018408:	1b9a      	subs	r2, r3, r6
 801840a:	d004      	beq.n	8018416 <_dtoa_r+0x7ce>
 801840c:	4659      	mov	r1, fp
 801840e:	4620      	mov	r0, r4
 8018410:	f000 ffce 	bl	80193b0 <__pow5mult>
 8018414:	4683      	mov	fp, r0
 8018416:	2101      	movs	r1, #1
 8018418:	4620      	mov	r0, r4
 801841a:	f000 ff0d 	bl	8019238 <__i2b>
 801841e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8018420:	2b00      	cmp	r3, #0
 8018422:	4606      	mov	r6, r0
 8018424:	dd7c      	ble.n	8018520 <_dtoa_r+0x8d8>
 8018426:	461a      	mov	r2, r3
 8018428:	4601      	mov	r1, r0
 801842a:	4620      	mov	r0, r4
 801842c:	f000 ffc0 	bl	80193b0 <__pow5mult>
 8018430:	9b05      	ldr	r3, [sp, #20]
 8018432:	2b01      	cmp	r3, #1
 8018434:	4606      	mov	r6, r0
 8018436:	dd76      	ble.n	8018526 <_dtoa_r+0x8de>
 8018438:	2300      	movs	r3, #0
 801843a:	9306      	str	r3, [sp, #24]
 801843c:	6933      	ldr	r3, [r6, #16]
 801843e:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8018442:	6918      	ldr	r0, [r3, #16]
 8018444:	f000 fea8 	bl	8019198 <__hi0bits>
 8018448:	f1c0 0020 	rsb	r0, r0, #32
 801844c:	9b04      	ldr	r3, [sp, #16]
 801844e:	4418      	add	r0, r3
 8018450:	f010 001f 	ands.w	r0, r0, #31
 8018454:	f000 8086 	beq.w	8018564 <_dtoa_r+0x91c>
 8018458:	f1c0 0320 	rsb	r3, r0, #32
 801845c:	2b04      	cmp	r3, #4
 801845e:	dd7f      	ble.n	8018560 <_dtoa_r+0x918>
 8018460:	f1c0 001c 	rsb	r0, r0, #28
 8018464:	9b04      	ldr	r3, [sp, #16]
 8018466:	4403      	add	r3, r0
 8018468:	4480      	add	r8, r0
 801846a:	4405      	add	r5, r0
 801846c:	9304      	str	r3, [sp, #16]
 801846e:	f1b8 0f00 	cmp.w	r8, #0
 8018472:	dd05      	ble.n	8018480 <_dtoa_r+0x838>
 8018474:	4659      	mov	r1, fp
 8018476:	4642      	mov	r2, r8
 8018478:	4620      	mov	r0, r4
 801847a:	f000 fff3 	bl	8019464 <__lshift>
 801847e:	4683      	mov	fp, r0
 8018480:	9b04      	ldr	r3, [sp, #16]
 8018482:	2b00      	cmp	r3, #0
 8018484:	dd05      	ble.n	8018492 <_dtoa_r+0x84a>
 8018486:	4631      	mov	r1, r6
 8018488:	461a      	mov	r2, r3
 801848a:	4620      	mov	r0, r4
 801848c:	f000 ffea 	bl	8019464 <__lshift>
 8018490:	4606      	mov	r6, r0
 8018492:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018494:	2b00      	cmp	r3, #0
 8018496:	d069      	beq.n	801856c <_dtoa_r+0x924>
 8018498:	4631      	mov	r1, r6
 801849a:	4658      	mov	r0, fp
 801849c:	f001 f84e 	bl	801953c <__mcmp>
 80184a0:	2800      	cmp	r0, #0
 80184a2:	da63      	bge.n	801856c <_dtoa_r+0x924>
 80184a4:	2300      	movs	r3, #0
 80184a6:	4659      	mov	r1, fp
 80184a8:	220a      	movs	r2, #10
 80184aa:	4620      	mov	r0, r4
 80184ac:	f000 fde0 	bl	8019070 <__multadd>
 80184b0:	9b08      	ldr	r3, [sp, #32]
 80184b2:	f10a 3aff 	add.w	sl, sl, #4294967295
 80184b6:	4683      	mov	fp, r0
 80184b8:	2b00      	cmp	r3, #0
 80184ba:	f000 818f 	beq.w	80187dc <_dtoa_r+0xb94>
 80184be:	4639      	mov	r1, r7
 80184c0:	2300      	movs	r3, #0
 80184c2:	220a      	movs	r2, #10
 80184c4:	4620      	mov	r0, r4
 80184c6:	f000 fdd3 	bl	8019070 <__multadd>
 80184ca:	f1b9 0f00 	cmp.w	r9, #0
 80184ce:	4607      	mov	r7, r0
 80184d0:	f300 808e 	bgt.w	80185f0 <_dtoa_r+0x9a8>
 80184d4:	9b05      	ldr	r3, [sp, #20]
 80184d6:	2b02      	cmp	r3, #2
 80184d8:	dc50      	bgt.n	801857c <_dtoa_r+0x934>
 80184da:	e089      	b.n	80185f0 <_dtoa_r+0x9a8>
 80184dc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80184de:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80184e2:	e75d      	b.n	80183a0 <_dtoa_r+0x758>
 80184e4:	9b01      	ldr	r3, [sp, #4]
 80184e6:	1e5e      	subs	r6, r3, #1
 80184e8:	9b06      	ldr	r3, [sp, #24]
 80184ea:	42b3      	cmp	r3, r6
 80184ec:	bfbf      	itttt	lt
 80184ee:	9b06      	ldrlt	r3, [sp, #24]
 80184f0:	9606      	strlt	r6, [sp, #24]
 80184f2:	1af2      	sublt	r2, r6, r3
 80184f4:	9b0d      	ldrlt	r3, [sp, #52]	; 0x34
 80184f6:	bfb6      	itet	lt
 80184f8:	189b      	addlt	r3, r3, r2
 80184fa:	1b9e      	subge	r6, r3, r6
 80184fc:	930d      	strlt	r3, [sp, #52]	; 0x34
 80184fe:	9b01      	ldr	r3, [sp, #4]
 8018500:	bfb8      	it	lt
 8018502:	2600      	movlt	r6, #0
 8018504:	2b00      	cmp	r3, #0
 8018506:	bfb5      	itete	lt
 8018508:	eba8 0503 	sublt.w	r5, r8, r3
 801850c:	9b01      	ldrge	r3, [sp, #4]
 801850e:	2300      	movlt	r3, #0
 8018510:	4645      	movge	r5, r8
 8018512:	e747      	b.n	80183a4 <_dtoa_r+0x75c>
 8018514:	9e06      	ldr	r6, [sp, #24]
 8018516:	9f08      	ldr	r7, [sp, #32]
 8018518:	4645      	mov	r5, r8
 801851a:	e74c      	b.n	80183b6 <_dtoa_r+0x76e>
 801851c:	9a06      	ldr	r2, [sp, #24]
 801851e:	e775      	b.n	801840c <_dtoa_r+0x7c4>
 8018520:	9b05      	ldr	r3, [sp, #20]
 8018522:	2b01      	cmp	r3, #1
 8018524:	dc18      	bgt.n	8018558 <_dtoa_r+0x910>
 8018526:	9b02      	ldr	r3, [sp, #8]
 8018528:	b9b3      	cbnz	r3, 8018558 <_dtoa_r+0x910>
 801852a:	9b03      	ldr	r3, [sp, #12]
 801852c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8018530:	b9a3      	cbnz	r3, 801855c <_dtoa_r+0x914>
 8018532:	9b03      	ldr	r3, [sp, #12]
 8018534:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8018538:	0d1b      	lsrs	r3, r3, #20
 801853a:	051b      	lsls	r3, r3, #20
 801853c:	b12b      	cbz	r3, 801854a <_dtoa_r+0x902>
 801853e:	9b04      	ldr	r3, [sp, #16]
 8018540:	3301      	adds	r3, #1
 8018542:	9304      	str	r3, [sp, #16]
 8018544:	f108 0801 	add.w	r8, r8, #1
 8018548:	2301      	movs	r3, #1
 801854a:	9306      	str	r3, [sp, #24]
 801854c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801854e:	2b00      	cmp	r3, #0
 8018550:	f47f af74 	bne.w	801843c <_dtoa_r+0x7f4>
 8018554:	2001      	movs	r0, #1
 8018556:	e779      	b.n	801844c <_dtoa_r+0x804>
 8018558:	2300      	movs	r3, #0
 801855a:	e7f6      	b.n	801854a <_dtoa_r+0x902>
 801855c:	9b02      	ldr	r3, [sp, #8]
 801855e:	e7f4      	b.n	801854a <_dtoa_r+0x902>
 8018560:	d085      	beq.n	801846e <_dtoa_r+0x826>
 8018562:	4618      	mov	r0, r3
 8018564:	301c      	adds	r0, #28
 8018566:	e77d      	b.n	8018464 <_dtoa_r+0x81c>
 8018568:	40240000 	.word	0x40240000
 801856c:	9b01      	ldr	r3, [sp, #4]
 801856e:	2b00      	cmp	r3, #0
 8018570:	dc38      	bgt.n	80185e4 <_dtoa_r+0x99c>
 8018572:	9b05      	ldr	r3, [sp, #20]
 8018574:	2b02      	cmp	r3, #2
 8018576:	dd35      	ble.n	80185e4 <_dtoa_r+0x99c>
 8018578:	f8dd 9004 	ldr.w	r9, [sp, #4]
 801857c:	f1b9 0f00 	cmp.w	r9, #0
 8018580:	d10d      	bne.n	801859e <_dtoa_r+0x956>
 8018582:	4631      	mov	r1, r6
 8018584:	464b      	mov	r3, r9
 8018586:	2205      	movs	r2, #5
 8018588:	4620      	mov	r0, r4
 801858a:	f000 fd71 	bl	8019070 <__multadd>
 801858e:	4601      	mov	r1, r0
 8018590:	4606      	mov	r6, r0
 8018592:	4658      	mov	r0, fp
 8018594:	f000 ffd2 	bl	801953c <__mcmp>
 8018598:	2800      	cmp	r0, #0
 801859a:	f73f adbd 	bgt.w	8018118 <_dtoa_r+0x4d0>
 801859e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80185a0:	9d00      	ldr	r5, [sp, #0]
 80185a2:	ea6f 0a03 	mvn.w	sl, r3
 80185a6:	f04f 0800 	mov.w	r8, #0
 80185aa:	4631      	mov	r1, r6
 80185ac:	4620      	mov	r0, r4
 80185ae:	f000 fd3d 	bl	801902c <_Bfree>
 80185b2:	2f00      	cmp	r7, #0
 80185b4:	f43f aeb4 	beq.w	8018320 <_dtoa_r+0x6d8>
 80185b8:	f1b8 0f00 	cmp.w	r8, #0
 80185bc:	d005      	beq.n	80185ca <_dtoa_r+0x982>
 80185be:	45b8      	cmp	r8, r7
 80185c0:	d003      	beq.n	80185ca <_dtoa_r+0x982>
 80185c2:	4641      	mov	r1, r8
 80185c4:	4620      	mov	r0, r4
 80185c6:	f000 fd31 	bl	801902c <_Bfree>
 80185ca:	4639      	mov	r1, r7
 80185cc:	4620      	mov	r0, r4
 80185ce:	f000 fd2d 	bl	801902c <_Bfree>
 80185d2:	e6a5      	b.n	8018320 <_dtoa_r+0x6d8>
 80185d4:	2600      	movs	r6, #0
 80185d6:	4637      	mov	r7, r6
 80185d8:	e7e1      	b.n	801859e <_dtoa_r+0x956>
 80185da:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80185dc:	f8dd a01c 	ldr.w	sl, [sp, #28]
 80185e0:	4637      	mov	r7, r6
 80185e2:	e599      	b.n	8018118 <_dtoa_r+0x4d0>
 80185e4:	9b08      	ldr	r3, [sp, #32]
 80185e6:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80185ea:	2b00      	cmp	r3, #0
 80185ec:	f000 80fd 	beq.w	80187ea <_dtoa_r+0xba2>
 80185f0:	2d00      	cmp	r5, #0
 80185f2:	dd05      	ble.n	8018600 <_dtoa_r+0x9b8>
 80185f4:	4639      	mov	r1, r7
 80185f6:	462a      	mov	r2, r5
 80185f8:	4620      	mov	r0, r4
 80185fa:	f000 ff33 	bl	8019464 <__lshift>
 80185fe:	4607      	mov	r7, r0
 8018600:	9b06      	ldr	r3, [sp, #24]
 8018602:	2b00      	cmp	r3, #0
 8018604:	d05c      	beq.n	80186c0 <_dtoa_r+0xa78>
 8018606:	6879      	ldr	r1, [r7, #4]
 8018608:	4620      	mov	r0, r4
 801860a:	f000 fccf 	bl	8018fac <_Balloc>
 801860e:	4605      	mov	r5, r0
 8018610:	b928      	cbnz	r0, 801861e <_dtoa_r+0x9d6>
 8018612:	4b80      	ldr	r3, [pc, #512]	; (8018814 <_dtoa_r+0xbcc>)
 8018614:	4602      	mov	r2, r0
 8018616:	f240 21ea 	movw	r1, #746	; 0x2ea
 801861a:	f7ff bb2e 	b.w	8017c7a <_dtoa_r+0x32>
 801861e:	693a      	ldr	r2, [r7, #16]
 8018620:	3202      	adds	r2, #2
 8018622:	0092      	lsls	r2, r2, #2
 8018624:	f107 010c 	add.w	r1, r7, #12
 8018628:	300c      	adds	r0, #12
 801862a:	f7fd fc89 	bl	8015f40 <memcpy>
 801862e:	2201      	movs	r2, #1
 8018630:	4629      	mov	r1, r5
 8018632:	4620      	mov	r0, r4
 8018634:	f000 ff16 	bl	8019464 <__lshift>
 8018638:	9b00      	ldr	r3, [sp, #0]
 801863a:	3301      	adds	r3, #1
 801863c:	9301      	str	r3, [sp, #4]
 801863e:	9b00      	ldr	r3, [sp, #0]
 8018640:	444b      	add	r3, r9
 8018642:	9307      	str	r3, [sp, #28]
 8018644:	9b02      	ldr	r3, [sp, #8]
 8018646:	f003 0301 	and.w	r3, r3, #1
 801864a:	46b8      	mov	r8, r7
 801864c:	9306      	str	r3, [sp, #24]
 801864e:	4607      	mov	r7, r0
 8018650:	9b01      	ldr	r3, [sp, #4]
 8018652:	4631      	mov	r1, r6
 8018654:	3b01      	subs	r3, #1
 8018656:	4658      	mov	r0, fp
 8018658:	9302      	str	r3, [sp, #8]
 801865a:	f7ff fa69 	bl	8017b30 <quorem>
 801865e:	4603      	mov	r3, r0
 8018660:	3330      	adds	r3, #48	; 0x30
 8018662:	9004      	str	r0, [sp, #16]
 8018664:	4641      	mov	r1, r8
 8018666:	4658      	mov	r0, fp
 8018668:	9308      	str	r3, [sp, #32]
 801866a:	f000 ff67 	bl	801953c <__mcmp>
 801866e:	463a      	mov	r2, r7
 8018670:	4681      	mov	r9, r0
 8018672:	4631      	mov	r1, r6
 8018674:	4620      	mov	r0, r4
 8018676:	f000 ff7d 	bl	8019574 <__mdiff>
 801867a:	68c2      	ldr	r2, [r0, #12]
 801867c:	9b08      	ldr	r3, [sp, #32]
 801867e:	4605      	mov	r5, r0
 8018680:	bb02      	cbnz	r2, 80186c4 <_dtoa_r+0xa7c>
 8018682:	4601      	mov	r1, r0
 8018684:	4658      	mov	r0, fp
 8018686:	f000 ff59 	bl	801953c <__mcmp>
 801868a:	9b08      	ldr	r3, [sp, #32]
 801868c:	4602      	mov	r2, r0
 801868e:	4629      	mov	r1, r5
 8018690:	4620      	mov	r0, r4
 8018692:	e9cd 3208 	strd	r3, r2, [sp, #32]
 8018696:	f000 fcc9 	bl	801902c <_Bfree>
 801869a:	9b05      	ldr	r3, [sp, #20]
 801869c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801869e:	9d01      	ldr	r5, [sp, #4]
 80186a0:	ea43 0102 	orr.w	r1, r3, r2
 80186a4:	9b06      	ldr	r3, [sp, #24]
 80186a6:	430b      	orrs	r3, r1
 80186a8:	9b08      	ldr	r3, [sp, #32]
 80186aa:	d10d      	bne.n	80186c8 <_dtoa_r+0xa80>
 80186ac:	2b39      	cmp	r3, #57	; 0x39
 80186ae:	d029      	beq.n	8018704 <_dtoa_r+0xabc>
 80186b0:	f1b9 0f00 	cmp.w	r9, #0
 80186b4:	dd01      	ble.n	80186ba <_dtoa_r+0xa72>
 80186b6:	9b04      	ldr	r3, [sp, #16]
 80186b8:	3331      	adds	r3, #49	; 0x31
 80186ba:	9a02      	ldr	r2, [sp, #8]
 80186bc:	7013      	strb	r3, [r2, #0]
 80186be:	e774      	b.n	80185aa <_dtoa_r+0x962>
 80186c0:	4638      	mov	r0, r7
 80186c2:	e7b9      	b.n	8018638 <_dtoa_r+0x9f0>
 80186c4:	2201      	movs	r2, #1
 80186c6:	e7e2      	b.n	801868e <_dtoa_r+0xa46>
 80186c8:	f1b9 0f00 	cmp.w	r9, #0
 80186cc:	db06      	blt.n	80186dc <_dtoa_r+0xa94>
 80186ce:	9905      	ldr	r1, [sp, #20]
 80186d0:	ea41 0909 	orr.w	r9, r1, r9
 80186d4:	9906      	ldr	r1, [sp, #24]
 80186d6:	ea59 0101 	orrs.w	r1, r9, r1
 80186da:	d120      	bne.n	801871e <_dtoa_r+0xad6>
 80186dc:	2a00      	cmp	r2, #0
 80186de:	ddec      	ble.n	80186ba <_dtoa_r+0xa72>
 80186e0:	4659      	mov	r1, fp
 80186e2:	2201      	movs	r2, #1
 80186e4:	4620      	mov	r0, r4
 80186e6:	9301      	str	r3, [sp, #4]
 80186e8:	f000 febc 	bl	8019464 <__lshift>
 80186ec:	4631      	mov	r1, r6
 80186ee:	4683      	mov	fp, r0
 80186f0:	f000 ff24 	bl	801953c <__mcmp>
 80186f4:	2800      	cmp	r0, #0
 80186f6:	9b01      	ldr	r3, [sp, #4]
 80186f8:	dc02      	bgt.n	8018700 <_dtoa_r+0xab8>
 80186fa:	d1de      	bne.n	80186ba <_dtoa_r+0xa72>
 80186fc:	07da      	lsls	r2, r3, #31
 80186fe:	d5dc      	bpl.n	80186ba <_dtoa_r+0xa72>
 8018700:	2b39      	cmp	r3, #57	; 0x39
 8018702:	d1d8      	bne.n	80186b6 <_dtoa_r+0xa6e>
 8018704:	9a02      	ldr	r2, [sp, #8]
 8018706:	2339      	movs	r3, #57	; 0x39
 8018708:	7013      	strb	r3, [r2, #0]
 801870a:	462b      	mov	r3, r5
 801870c:	461d      	mov	r5, r3
 801870e:	3b01      	subs	r3, #1
 8018710:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8018714:	2a39      	cmp	r2, #57	; 0x39
 8018716:	d050      	beq.n	80187ba <_dtoa_r+0xb72>
 8018718:	3201      	adds	r2, #1
 801871a:	701a      	strb	r2, [r3, #0]
 801871c:	e745      	b.n	80185aa <_dtoa_r+0x962>
 801871e:	2a00      	cmp	r2, #0
 8018720:	dd03      	ble.n	801872a <_dtoa_r+0xae2>
 8018722:	2b39      	cmp	r3, #57	; 0x39
 8018724:	d0ee      	beq.n	8018704 <_dtoa_r+0xabc>
 8018726:	3301      	adds	r3, #1
 8018728:	e7c7      	b.n	80186ba <_dtoa_r+0xa72>
 801872a:	9a01      	ldr	r2, [sp, #4]
 801872c:	9907      	ldr	r1, [sp, #28]
 801872e:	f802 3c01 	strb.w	r3, [r2, #-1]
 8018732:	428a      	cmp	r2, r1
 8018734:	d02a      	beq.n	801878c <_dtoa_r+0xb44>
 8018736:	4659      	mov	r1, fp
 8018738:	2300      	movs	r3, #0
 801873a:	220a      	movs	r2, #10
 801873c:	4620      	mov	r0, r4
 801873e:	f000 fc97 	bl	8019070 <__multadd>
 8018742:	45b8      	cmp	r8, r7
 8018744:	4683      	mov	fp, r0
 8018746:	f04f 0300 	mov.w	r3, #0
 801874a:	f04f 020a 	mov.w	r2, #10
 801874e:	4641      	mov	r1, r8
 8018750:	4620      	mov	r0, r4
 8018752:	d107      	bne.n	8018764 <_dtoa_r+0xb1c>
 8018754:	f000 fc8c 	bl	8019070 <__multadd>
 8018758:	4680      	mov	r8, r0
 801875a:	4607      	mov	r7, r0
 801875c:	9b01      	ldr	r3, [sp, #4]
 801875e:	3301      	adds	r3, #1
 8018760:	9301      	str	r3, [sp, #4]
 8018762:	e775      	b.n	8018650 <_dtoa_r+0xa08>
 8018764:	f000 fc84 	bl	8019070 <__multadd>
 8018768:	4639      	mov	r1, r7
 801876a:	4680      	mov	r8, r0
 801876c:	2300      	movs	r3, #0
 801876e:	220a      	movs	r2, #10
 8018770:	4620      	mov	r0, r4
 8018772:	f000 fc7d 	bl	8019070 <__multadd>
 8018776:	4607      	mov	r7, r0
 8018778:	e7f0      	b.n	801875c <_dtoa_r+0xb14>
 801877a:	f1b9 0f00 	cmp.w	r9, #0
 801877e:	9a00      	ldr	r2, [sp, #0]
 8018780:	bfcc      	ite	gt
 8018782:	464d      	movgt	r5, r9
 8018784:	2501      	movle	r5, #1
 8018786:	4415      	add	r5, r2
 8018788:	f04f 0800 	mov.w	r8, #0
 801878c:	4659      	mov	r1, fp
 801878e:	2201      	movs	r2, #1
 8018790:	4620      	mov	r0, r4
 8018792:	9301      	str	r3, [sp, #4]
 8018794:	f000 fe66 	bl	8019464 <__lshift>
 8018798:	4631      	mov	r1, r6
 801879a:	4683      	mov	fp, r0
 801879c:	f000 fece 	bl	801953c <__mcmp>
 80187a0:	2800      	cmp	r0, #0
 80187a2:	dcb2      	bgt.n	801870a <_dtoa_r+0xac2>
 80187a4:	d102      	bne.n	80187ac <_dtoa_r+0xb64>
 80187a6:	9b01      	ldr	r3, [sp, #4]
 80187a8:	07db      	lsls	r3, r3, #31
 80187aa:	d4ae      	bmi.n	801870a <_dtoa_r+0xac2>
 80187ac:	462b      	mov	r3, r5
 80187ae:	461d      	mov	r5, r3
 80187b0:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 80187b4:	2a30      	cmp	r2, #48	; 0x30
 80187b6:	d0fa      	beq.n	80187ae <_dtoa_r+0xb66>
 80187b8:	e6f7      	b.n	80185aa <_dtoa_r+0x962>
 80187ba:	9a00      	ldr	r2, [sp, #0]
 80187bc:	429a      	cmp	r2, r3
 80187be:	d1a5      	bne.n	801870c <_dtoa_r+0xac4>
 80187c0:	f10a 0a01 	add.w	sl, sl, #1
 80187c4:	2331      	movs	r3, #49	; 0x31
 80187c6:	e779      	b.n	80186bc <_dtoa_r+0xa74>
 80187c8:	4b13      	ldr	r3, [pc, #76]	; (8018818 <_dtoa_r+0xbd0>)
 80187ca:	f7ff baaf 	b.w	8017d2c <_dtoa_r+0xe4>
 80187ce:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80187d0:	2b00      	cmp	r3, #0
 80187d2:	f47f aa86 	bne.w	8017ce2 <_dtoa_r+0x9a>
 80187d6:	4b11      	ldr	r3, [pc, #68]	; (801881c <_dtoa_r+0xbd4>)
 80187d8:	f7ff baa8 	b.w	8017d2c <_dtoa_r+0xe4>
 80187dc:	f1b9 0f00 	cmp.w	r9, #0
 80187e0:	dc03      	bgt.n	80187ea <_dtoa_r+0xba2>
 80187e2:	9b05      	ldr	r3, [sp, #20]
 80187e4:	2b02      	cmp	r3, #2
 80187e6:	f73f aec9 	bgt.w	801857c <_dtoa_r+0x934>
 80187ea:	9d00      	ldr	r5, [sp, #0]
 80187ec:	4631      	mov	r1, r6
 80187ee:	4658      	mov	r0, fp
 80187f0:	f7ff f99e 	bl	8017b30 <quorem>
 80187f4:	f100 0330 	add.w	r3, r0, #48	; 0x30
 80187f8:	f805 3b01 	strb.w	r3, [r5], #1
 80187fc:	9a00      	ldr	r2, [sp, #0]
 80187fe:	1aaa      	subs	r2, r5, r2
 8018800:	4591      	cmp	r9, r2
 8018802:	ddba      	ble.n	801877a <_dtoa_r+0xb32>
 8018804:	4659      	mov	r1, fp
 8018806:	2300      	movs	r3, #0
 8018808:	220a      	movs	r2, #10
 801880a:	4620      	mov	r0, r4
 801880c:	f000 fc30 	bl	8019070 <__multadd>
 8018810:	4683      	mov	fp, r0
 8018812:	e7eb      	b.n	80187ec <_dtoa_r+0xba4>
 8018814:	0801aef0 	.word	0x0801aef0
 8018818:	0801add4 	.word	0x0801add4
 801881c:	0801ae6d 	.word	0x0801ae6d

08018820 <_fstat_r>:
 8018820:	b538      	push	{r3, r4, r5, lr}
 8018822:	4d07      	ldr	r5, [pc, #28]	; (8018840 <_fstat_r+0x20>)
 8018824:	2300      	movs	r3, #0
 8018826:	4604      	mov	r4, r0
 8018828:	4608      	mov	r0, r1
 801882a:	4611      	mov	r1, r2
 801882c:	602b      	str	r3, [r5, #0]
 801882e:	f7fd f8f9 	bl	8015a24 <_fstat>
 8018832:	1c43      	adds	r3, r0, #1
 8018834:	d102      	bne.n	801883c <_fstat_r+0x1c>
 8018836:	682b      	ldr	r3, [r5, #0]
 8018838:	b103      	cbz	r3, 801883c <_fstat_r+0x1c>
 801883a:	6023      	str	r3, [r4, #0]
 801883c:	bd38      	pop	{r3, r4, r5, pc}
 801883e:	bf00      	nop
 8018840:	2001a178 	.word	0x2001a178

08018844 <rshift>:
 8018844:	6903      	ldr	r3, [r0, #16]
 8018846:	ebb3 1f61 	cmp.w	r3, r1, asr #5
 801884a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801884e:	ea4f 1261 	mov.w	r2, r1, asr #5
 8018852:	f100 0414 	add.w	r4, r0, #20
 8018856:	dd45      	ble.n	80188e4 <rshift+0xa0>
 8018858:	f011 011f 	ands.w	r1, r1, #31
 801885c:	eb04 0683 	add.w	r6, r4, r3, lsl #2
 8018860:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 8018864:	d10c      	bne.n	8018880 <rshift+0x3c>
 8018866:	f100 0710 	add.w	r7, r0, #16
 801886a:	4629      	mov	r1, r5
 801886c:	42b1      	cmp	r1, r6
 801886e:	d334      	bcc.n	80188da <rshift+0x96>
 8018870:	1a9b      	subs	r3, r3, r2
 8018872:	009b      	lsls	r3, r3, #2
 8018874:	1eea      	subs	r2, r5, #3
 8018876:	4296      	cmp	r6, r2
 8018878:	bf38      	it	cc
 801887a:	2300      	movcc	r3, #0
 801887c:	4423      	add	r3, r4
 801887e:	e015      	b.n	80188ac <rshift+0x68>
 8018880:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
 8018884:	f1c1 0820 	rsb	r8, r1, #32
 8018888:	40cf      	lsrs	r7, r1
 801888a:	f105 0e04 	add.w	lr, r5, #4
 801888e:	46a1      	mov	r9, r4
 8018890:	4576      	cmp	r6, lr
 8018892:	46f4      	mov	ip, lr
 8018894:	d815      	bhi.n	80188c2 <rshift+0x7e>
 8018896:	1a9b      	subs	r3, r3, r2
 8018898:	009a      	lsls	r2, r3, #2
 801889a:	3a04      	subs	r2, #4
 801889c:	3501      	adds	r5, #1
 801889e:	42ae      	cmp	r6, r5
 80188a0:	bf38      	it	cc
 80188a2:	2200      	movcc	r2, #0
 80188a4:	18a3      	adds	r3, r4, r2
 80188a6:	50a7      	str	r7, [r4, r2]
 80188a8:	b107      	cbz	r7, 80188ac <rshift+0x68>
 80188aa:	3304      	adds	r3, #4
 80188ac:	1b1a      	subs	r2, r3, r4
 80188ae:	42a3      	cmp	r3, r4
 80188b0:	ea4f 02a2 	mov.w	r2, r2, asr #2
 80188b4:	bf08      	it	eq
 80188b6:	2300      	moveq	r3, #0
 80188b8:	6102      	str	r2, [r0, #16]
 80188ba:	bf08      	it	eq
 80188bc:	6143      	streq	r3, [r0, #20]
 80188be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80188c2:	f8dc c000 	ldr.w	ip, [ip]
 80188c6:	fa0c fc08 	lsl.w	ip, ip, r8
 80188ca:	ea4c 0707 	orr.w	r7, ip, r7
 80188ce:	f849 7b04 	str.w	r7, [r9], #4
 80188d2:	f85e 7b04 	ldr.w	r7, [lr], #4
 80188d6:	40cf      	lsrs	r7, r1
 80188d8:	e7da      	b.n	8018890 <rshift+0x4c>
 80188da:	f851 cb04 	ldr.w	ip, [r1], #4
 80188de:	f847 cf04 	str.w	ip, [r7, #4]!
 80188e2:	e7c3      	b.n	801886c <rshift+0x28>
 80188e4:	4623      	mov	r3, r4
 80188e6:	e7e1      	b.n	80188ac <rshift+0x68>

080188e8 <__hexdig_fun>:
 80188e8:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 80188ec:	2b09      	cmp	r3, #9
 80188ee:	d802      	bhi.n	80188f6 <__hexdig_fun+0xe>
 80188f0:	3820      	subs	r0, #32
 80188f2:	b2c0      	uxtb	r0, r0
 80188f4:	4770      	bx	lr
 80188f6:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 80188fa:	2b05      	cmp	r3, #5
 80188fc:	d801      	bhi.n	8018902 <__hexdig_fun+0x1a>
 80188fe:	3847      	subs	r0, #71	; 0x47
 8018900:	e7f7      	b.n	80188f2 <__hexdig_fun+0xa>
 8018902:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 8018906:	2b05      	cmp	r3, #5
 8018908:	d801      	bhi.n	801890e <__hexdig_fun+0x26>
 801890a:	3827      	subs	r0, #39	; 0x27
 801890c:	e7f1      	b.n	80188f2 <__hexdig_fun+0xa>
 801890e:	2000      	movs	r0, #0
 8018910:	4770      	bx	lr
	...

08018914 <__gethex>:
 8018914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018918:	ed2d 8b02 	vpush	{d8}
 801891c:	b089      	sub	sp, #36	; 0x24
 801891e:	ee08 0a10 	vmov	s16, r0
 8018922:	9304      	str	r3, [sp, #16]
 8018924:	4bbc      	ldr	r3, [pc, #752]	; (8018c18 <__gethex+0x304>)
 8018926:	681b      	ldr	r3, [r3, #0]
 8018928:	9301      	str	r3, [sp, #4]
 801892a:	4618      	mov	r0, r3
 801892c:	468b      	mov	fp, r1
 801892e:	4690      	mov	r8, r2
 8018930:	f7e7 fc70 	bl	8000214 <strlen>
 8018934:	9b01      	ldr	r3, [sp, #4]
 8018936:	f8db 2000 	ldr.w	r2, [fp]
 801893a:	4403      	add	r3, r0
 801893c:	4682      	mov	sl, r0
 801893e:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8018942:	9305      	str	r3, [sp, #20]
 8018944:	1c93      	adds	r3, r2, #2
 8018946:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
 801894a:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
 801894e:	32fe      	adds	r2, #254	; 0xfe
 8018950:	18d1      	adds	r1, r2, r3
 8018952:	461f      	mov	r7, r3
 8018954:	f813 0b01 	ldrb.w	r0, [r3], #1
 8018958:	9100      	str	r1, [sp, #0]
 801895a:	2830      	cmp	r0, #48	; 0x30
 801895c:	d0f8      	beq.n	8018950 <__gethex+0x3c>
 801895e:	f7ff ffc3 	bl	80188e8 <__hexdig_fun>
 8018962:	4604      	mov	r4, r0
 8018964:	2800      	cmp	r0, #0
 8018966:	d13a      	bne.n	80189de <__gethex+0xca>
 8018968:	9901      	ldr	r1, [sp, #4]
 801896a:	4652      	mov	r2, sl
 801896c:	4638      	mov	r0, r7
 801896e:	f7fe f8d3 	bl	8016b18 <strncmp>
 8018972:	4605      	mov	r5, r0
 8018974:	2800      	cmp	r0, #0
 8018976:	d168      	bne.n	8018a4a <__gethex+0x136>
 8018978:	f817 000a 	ldrb.w	r0, [r7, sl]
 801897c:	eb07 060a 	add.w	r6, r7, sl
 8018980:	f7ff ffb2 	bl	80188e8 <__hexdig_fun>
 8018984:	2800      	cmp	r0, #0
 8018986:	d062      	beq.n	8018a4e <__gethex+0x13a>
 8018988:	4633      	mov	r3, r6
 801898a:	7818      	ldrb	r0, [r3, #0]
 801898c:	2830      	cmp	r0, #48	; 0x30
 801898e:	461f      	mov	r7, r3
 8018990:	f103 0301 	add.w	r3, r3, #1
 8018994:	d0f9      	beq.n	801898a <__gethex+0x76>
 8018996:	f7ff ffa7 	bl	80188e8 <__hexdig_fun>
 801899a:	2301      	movs	r3, #1
 801899c:	fab0 f480 	clz	r4, r0
 80189a0:	0964      	lsrs	r4, r4, #5
 80189a2:	4635      	mov	r5, r6
 80189a4:	9300      	str	r3, [sp, #0]
 80189a6:	463a      	mov	r2, r7
 80189a8:	4616      	mov	r6, r2
 80189aa:	3201      	adds	r2, #1
 80189ac:	7830      	ldrb	r0, [r6, #0]
 80189ae:	f7ff ff9b 	bl	80188e8 <__hexdig_fun>
 80189b2:	2800      	cmp	r0, #0
 80189b4:	d1f8      	bne.n	80189a8 <__gethex+0x94>
 80189b6:	9901      	ldr	r1, [sp, #4]
 80189b8:	4652      	mov	r2, sl
 80189ba:	4630      	mov	r0, r6
 80189bc:	f7fe f8ac 	bl	8016b18 <strncmp>
 80189c0:	b980      	cbnz	r0, 80189e4 <__gethex+0xd0>
 80189c2:	b94d      	cbnz	r5, 80189d8 <__gethex+0xc4>
 80189c4:	eb06 050a 	add.w	r5, r6, sl
 80189c8:	462a      	mov	r2, r5
 80189ca:	4616      	mov	r6, r2
 80189cc:	3201      	adds	r2, #1
 80189ce:	7830      	ldrb	r0, [r6, #0]
 80189d0:	f7ff ff8a 	bl	80188e8 <__hexdig_fun>
 80189d4:	2800      	cmp	r0, #0
 80189d6:	d1f8      	bne.n	80189ca <__gethex+0xb6>
 80189d8:	1bad      	subs	r5, r5, r6
 80189da:	00ad      	lsls	r5, r5, #2
 80189dc:	e004      	b.n	80189e8 <__gethex+0xd4>
 80189de:	2400      	movs	r4, #0
 80189e0:	4625      	mov	r5, r4
 80189e2:	e7e0      	b.n	80189a6 <__gethex+0x92>
 80189e4:	2d00      	cmp	r5, #0
 80189e6:	d1f7      	bne.n	80189d8 <__gethex+0xc4>
 80189e8:	7833      	ldrb	r3, [r6, #0]
 80189ea:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80189ee:	2b50      	cmp	r3, #80	; 0x50
 80189f0:	d13b      	bne.n	8018a6a <__gethex+0x156>
 80189f2:	7873      	ldrb	r3, [r6, #1]
 80189f4:	2b2b      	cmp	r3, #43	; 0x2b
 80189f6:	d02c      	beq.n	8018a52 <__gethex+0x13e>
 80189f8:	2b2d      	cmp	r3, #45	; 0x2d
 80189fa:	d02e      	beq.n	8018a5a <__gethex+0x146>
 80189fc:	1c71      	adds	r1, r6, #1
 80189fe:	f04f 0900 	mov.w	r9, #0
 8018a02:	7808      	ldrb	r0, [r1, #0]
 8018a04:	f7ff ff70 	bl	80188e8 <__hexdig_fun>
 8018a08:	1e43      	subs	r3, r0, #1
 8018a0a:	b2db      	uxtb	r3, r3
 8018a0c:	2b18      	cmp	r3, #24
 8018a0e:	d82c      	bhi.n	8018a6a <__gethex+0x156>
 8018a10:	f1a0 0210 	sub.w	r2, r0, #16
 8018a14:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8018a18:	f7ff ff66 	bl	80188e8 <__hexdig_fun>
 8018a1c:	1e43      	subs	r3, r0, #1
 8018a1e:	b2db      	uxtb	r3, r3
 8018a20:	2b18      	cmp	r3, #24
 8018a22:	d91d      	bls.n	8018a60 <__gethex+0x14c>
 8018a24:	f1b9 0f00 	cmp.w	r9, #0
 8018a28:	d000      	beq.n	8018a2c <__gethex+0x118>
 8018a2a:	4252      	negs	r2, r2
 8018a2c:	4415      	add	r5, r2
 8018a2e:	f8cb 1000 	str.w	r1, [fp]
 8018a32:	b1e4      	cbz	r4, 8018a6e <__gethex+0x15a>
 8018a34:	9b00      	ldr	r3, [sp, #0]
 8018a36:	2b00      	cmp	r3, #0
 8018a38:	bf14      	ite	ne
 8018a3a:	2700      	movne	r7, #0
 8018a3c:	2706      	moveq	r7, #6
 8018a3e:	4638      	mov	r0, r7
 8018a40:	b009      	add	sp, #36	; 0x24
 8018a42:	ecbd 8b02 	vpop	{d8}
 8018a46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018a4a:	463e      	mov	r6, r7
 8018a4c:	4625      	mov	r5, r4
 8018a4e:	2401      	movs	r4, #1
 8018a50:	e7ca      	b.n	80189e8 <__gethex+0xd4>
 8018a52:	f04f 0900 	mov.w	r9, #0
 8018a56:	1cb1      	adds	r1, r6, #2
 8018a58:	e7d3      	b.n	8018a02 <__gethex+0xee>
 8018a5a:	f04f 0901 	mov.w	r9, #1
 8018a5e:	e7fa      	b.n	8018a56 <__gethex+0x142>
 8018a60:	230a      	movs	r3, #10
 8018a62:	fb03 0202 	mla	r2, r3, r2, r0
 8018a66:	3a10      	subs	r2, #16
 8018a68:	e7d4      	b.n	8018a14 <__gethex+0x100>
 8018a6a:	4631      	mov	r1, r6
 8018a6c:	e7df      	b.n	8018a2e <__gethex+0x11a>
 8018a6e:	1bf3      	subs	r3, r6, r7
 8018a70:	3b01      	subs	r3, #1
 8018a72:	4621      	mov	r1, r4
 8018a74:	2b07      	cmp	r3, #7
 8018a76:	dc0b      	bgt.n	8018a90 <__gethex+0x17c>
 8018a78:	ee18 0a10 	vmov	r0, s16
 8018a7c:	f000 fa96 	bl	8018fac <_Balloc>
 8018a80:	4604      	mov	r4, r0
 8018a82:	b940      	cbnz	r0, 8018a96 <__gethex+0x182>
 8018a84:	4b65      	ldr	r3, [pc, #404]	; (8018c1c <__gethex+0x308>)
 8018a86:	4602      	mov	r2, r0
 8018a88:	21de      	movs	r1, #222	; 0xde
 8018a8a:	4865      	ldr	r0, [pc, #404]	; (8018c20 <__gethex+0x30c>)
 8018a8c:	f001 f8ce 	bl	8019c2c <__assert_func>
 8018a90:	3101      	adds	r1, #1
 8018a92:	105b      	asrs	r3, r3, #1
 8018a94:	e7ee      	b.n	8018a74 <__gethex+0x160>
 8018a96:	f100 0914 	add.w	r9, r0, #20
 8018a9a:	f04f 0b00 	mov.w	fp, #0
 8018a9e:	f1ca 0301 	rsb	r3, sl, #1
 8018aa2:	f8cd 9008 	str.w	r9, [sp, #8]
 8018aa6:	f8cd b000 	str.w	fp, [sp]
 8018aaa:	9306      	str	r3, [sp, #24]
 8018aac:	42b7      	cmp	r7, r6
 8018aae:	d340      	bcc.n	8018b32 <__gethex+0x21e>
 8018ab0:	9802      	ldr	r0, [sp, #8]
 8018ab2:	9b00      	ldr	r3, [sp, #0]
 8018ab4:	f840 3b04 	str.w	r3, [r0], #4
 8018ab8:	eba0 0009 	sub.w	r0, r0, r9
 8018abc:	1080      	asrs	r0, r0, #2
 8018abe:	0146      	lsls	r6, r0, #5
 8018ac0:	6120      	str	r0, [r4, #16]
 8018ac2:	4618      	mov	r0, r3
 8018ac4:	f000 fb68 	bl	8019198 <__hi0bits>
 8018ac8:	1a30      	subs	r0, r6, r0
 8018aca:	f8d8 6000 	ldr.w	r6, [r8]
 8018ace:	42b0      	cmp	r0, r6
 8018ad0:	dd63      	ble.n	8018b9a <__gethex+0x286>
 8018ad2:	1b87      	subs	r7, r0, r6
 8018ad4:	4639      	mov	r1, r7
 8018ad6:	4620      	mov	r0, r4
 8018ad8:	f000 ff02 	bl	80198e0 <__any_on>
 8018adc:	4682      	mov	sl, r0
 8018ade:	b1a8      	cbz	r0, 8018b0c <__gethex+0x1f8>
 8018ae0:	1e7b      	subs	r3, r7, #1
 8018ae2:	1159      	asrs	r1, r3, #5
 8018ae4:	f003 021f 	and.w	r2, r3, #31
 8018ae8:	f859 1021 	ldr.w	r1, [r9, r1, lsl #2]
 8018aec:	f04f 0a01 	mov.w	sl, #1
 8018af0:	fa0a f202 	lsl.w	r2, sl, r2
 8018af4:	420a      	tst	r2, r1
 8018af6:	d009      	beq.n	8018b0c <__gethex+0x1f8>
 8018af8:	4553      	cmp	r3, sl
 8018afa:	dd05      	ble.n	8018b08 <__gethex+0x1f4>
 8018afc:	1eb9      	subs	r1, r7, #2
 8018afe:	4620      	mov	r0, r4
 8018b00:	f000 feee 	bl	80198e0 <__any_on>
 8018b04:	2800      	cmp	r0, #0
 8018b06:	d145      	bne.n	8018b94 <__gethex+0x280>
 8018b08:	f04f 0a02 	mov.w	sl, #2
 8018b0c:	4639      	mov	r1, r7
 8018b0e:	4620      	mov	r0, r4
 8018b10:	f7ff fe98 	bl	8018844 <rshift>
 8018b14:	443d      	add	r5, r7
 8018b16:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8018b1a:	42ab      	cmp	r3, r5
 8018b1c:	da4c      	bge.n	8018bb8 <__gethex+0x2a4>
 8018b1e:	ee18 0a10 	vmov	r0, s16
 8018b22:	4621      	mov	r1, r4
 8018b24:	f000 fa82 	bl	801902c <_Bfree>
 8018b28:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018b2a:	2300      	movs	r3, #0
 8018b2c:	6013      	str	r3, [r2, #0]
 8018b2e:	27a3      	movs	r7, #163	; 0xa3
 8018b30:	e785      	b.n	8018a3e <__gethex+0x12a>
 8018b32:	1e73      	subs	r3, r6, #1
 8018b34:	9a05      	ldr	r2, [sp, #20]
 8018b36:	9303      	str	r3, [sp, #12]
 8018b38:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 8018b3c:	4293      	cmp	r3, r2
 8018b3e:	d019      	beq.n	8018b74 <__gethex+0x260>
 8018b40:	f1bb 0f20 	cmp.w	fp, #32
 8018b44:	d107      	bne.n	8018b56 <__gethex+0x242>
 8018b46:	9b02      	ldr	r3, [sp, #8]
 8018b48:	9a00      	ldr	r2, [sp, #0]
 8018b4a:	f843 2b04 	str.w	r2, [r3], #4
 8018b4e:	9302      	str	r3, [sp, #8]
 8018b50:	2300      	movs	r3, #0
 8018b52:	9300      	str	r3, [sp, #0]
 8018b54:	469b      	mov	fp, r3
 8018b56:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 8018b5a:	f7ff fec5 	bl	80188e8 <__hexdig_fun>
 8018b5e:	9b00      	ldr	r3, [sp, #0]
 8018b60:	f000 000f 	and.w	r0, r0, #15
 8018b64:	fa00 f00b 	lsl.w	r0, r0, fp
 8018b68:	4303      	orrs	r3, r0
 8018b6a:	9300      	str	r3, [sp, #0]
 8018b6c:	f10b 0b04 	add.w	fp, fp, #4
 8018b70:	9b03      	ldr	r3, [sp, #12]
 8018b72:	e00d      	b.n	8018b90 <__gethex+0x27c>
 8018b74:	9b03      	ldr	r3, [sp, #12]
 8018b76:	9a06      	ldr	r2, [sp, #24]
 8018b78:	4413      	add	r3, r2
 8018b7a:	42bb      	cmp	r3, r7
 8018b7c:	d3e0      	bcc.n	8018b40 <__gethex+0x22c>
 8018b7e:	4618      	mov	r0, r3
 8018b80:	9901      	ldr	r1, [sp, #4]
 8018b82:	9307      	str	r3, [sp, #28]
 8018b84:	4652      	mov	r2, sl
 8018b86:	f7fd ffc7 	bl	8016b18 <strncmp>
 8018b8a:	9b07      	ldr	r3, [sp, #28]
 8018b8c:	2800      	cmp	r0, #0
 8018b8e:	d1d7      	bne.n	8018b40 <__gethex+0x22c>
 8018b90:	461e      	mov	r6, r3
 8018b92:	e78b      	b.n	8018aac <__gethex+0x198>
 8018b94:	f04f 0a03 	mov.w	sl, #3
 8018b98:	e7b8      	b.n	8018b0c <__gethex+0x1f8>
 8018b9a:	da0a      	bge.n	8018bb2 <__gethex+0x29e>
 8018b9c:	1a37      	subs	r7, r6, r0
 8018b9e:	4621      	mov	r1, r4
 8018ba0:	ee18 0a10 	vmov	r0, s16
 8018ba4:	463a      	mov	r2, r7
 8018ba6:	f000 fc5d 	bl	8019464 <__lshift>
 8018baa:	1bed      	subs	r5, r5, r7
 8018bac:	4604      	mov	r4, r0
 8018bae:	f100 0914 	add.w	r9, r0, #20
 8018bb2:	f04f 0a00 	mov.w	sl, #0
 8018bb6:	e7ae      	b.n	8018b16 <__gethex+0x202>
 8018bb8:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8018bbc:	42a8      	cmp	r0, r5
 8018bbe:	dd72      	ble.n	8018ca6 <__gethex+0x392>
 8018bc0:	1b45      	subs	r5, r0, r5
 8018bc2:	42ae      	cmp	r6, r5
 8018bc4:	dc36      	bgt.n	8018c34 <__gethex+0x320>
 8018bc6:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8018bca:	2b02      	cmp	r3, #2
 8018bcc:	d02a      	beq.n	8018c24 <__gethex+0x310>
 8018bce:	2b03      	cmp	r3, #3
 8018bd0:	d02c      	beq.n	8018c2c <__gethex+0x318>
 8018bd2:	2b01      	cmp	r3, #1
 8018bd4:	d115      	bne.n	8018c02 <__gethex+0x2ee>
 8018bd6:	42ae      	cmp	r6, r5
 8018bd8:	d113      	bne.n	8018c02 <__gethex+0x2ee>
 8018bda:	2e01      	cmp	r6, #1
 8018bdc:	d10b      	bne.n	8018bf6 <__gethex+0x2e2>
 8018bde:	9a04      	ldr	r2, [sp, #16]
 8018be0:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8018be4:	6013      	str	r3, [r2, #0]
 8018be6:	2301      	movs	r3, #1
 8018be8:	6123      	str	r3, [r4, #16]
 8018bea:	f8c9 3000 	str.w	r3, [r9]
 8018bee:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8018bf0:	2762      	movs	r7, #98	; 0x62
 8018bf2:	601c      	str	r4, [r3, #0]
 8018bf4:	e723      	b.n	8018a3e <__gethex+0x12a>
 8018bf6:	1e71      	subs	r1, r6, #1
 8018bf8:	4620      	mov	r0, r4
 8018bfa:	f000 fe71 	bl	80198e0 <__any_on>
 8018bfe:	2800      	cmp	r0, #0
 8018c00:	d1ed      	bne.n	8018bde <__gethex+0x2ca>
 8018c02:	ee18 0a10 	vmov	r0, s16
 8018c06:	4621      	mov	r1, r4
 8018c08:	f000 fa10 	bl	801902c <_Bfree>
 8018c0c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018c0e:	2300      	movs	r3, #0
 8018c10:	6013      	str	r3, [r2, #0]
 8018c12:	2750      	movs	r7, #80	; 0x50
 8018c14:	e713      	b.n	8018a3e <__gethex+0x12a>
 8018c16:	bf00      	nop
 8018c18:	0801af6c 	.word	0x0801af6c
 8018c1c:	0801aef0 	.word	0x0801aef0
 8018c20:	0801af01 	.word	0x0801af01
 8018c24:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8018c26:	2b00      	cmp	r3, #0
 8018c28:	d1eb      	bne.n	8018c02 <__gethex+0x2ee>
 8018c2a:	e7d8      	b.n	8018bde <__gethex+0x2ca>
 8018c2c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8018c2e:	2b00      	cmp	r3, #0
 8018c30:	d1d5      	bne.n	8018bde <__gethex+0x2ca>
 8018c32:	e7e6      	b.n	8018c02 <__gethex+0x2ee>
 8018c34:	1e6f      	subs	r7, r5, #1
 8018c36:	f1ba 0f00 	cmp.w	sl, #0
 8018c3a:	d131      	bne.n	8018ca0 <__gethex+0x38c>
 8018c3c:	b127      	cbz	r7, 8018c48 <__gethex+0x334>
 8018c3e:	4639      	mov	r1, r7
 8018c40:	4620      	mov	r0, r4
 8018c42:	f000 fe4d 	bl	80198e0 <__any_on>
 8018c46:	4682      	mov	sl, r0
 8018c48:	117b      	asrs	r3, r7, #5
 8018c4a:	2101      	movs	r1, #1
 8018c4c:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 8018c50:	f007 071f 	and.w	r7, r7, #31
 8018c54:	fa01 f707 	lsl.w	r7, r1, r7
 8018c58:	421f      	tst	r7, r3
 8018c5a:	4629      	mov	r1, r5
 8018c5c:	4620      	mov	r0, r4
 8018c5e:	bf18      	it	ne
 8018c60:	f04a 0a02 	orrne.w	sl, sl, #2
 8018c64:	1b76      	subs	r6, r6, r5
 8018c66:	f7ff fded 	bl	8018844 <rshift>
 8018c6a:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8018c6e:	2702      	movs	r7, #2
 8018c70:	f1ba 0f00 	cmp.w	sl, #0
 8018c74:	d048      	beq.n	8018d08 <__gethex+0x3f4>
 8018c76:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8018c7a:	2b02      	cmp	r3, #2
 8018c7c:	d015      	beq.n	8018caa <__gethex+0x396>
 8018c7e:	2b03      	cmp	r3, #3
 8018c80:	d017      	beq.n	8018cb2 <__gethex+0x39e>
 8018c82:	2b01      	cmp	r3, #1
 8018c84:	d109      	bne.n	8018c9a <__gethex+0x386>
 8018c86:	f01a 0f02 	tst.w	sl, #2
 8018c8a:	d006      	beq.n	8018c9a <__gethex+0x386>
 8018c8c:	f8d9 0000 	ldr.w	r0, [r9]
 8018c90:	ea4a 0a00 	orr.w	sl, sl, r0
 8018c94:	f01a 0f01 	tst.w	sl, #1
 8018c98:	d10e      	bne.n	8018cb8 <__gethex+0x3a4>
 8018c9a:	f047 0710 	orr.w	r7, r7, #16
 8018c9e:	e033      	b.n	8018d08 <__gethex+0x3f4>
 8018ca0:	f04f 0a01 	mov.w	sl, #1
 8018ca4:	e7d0      	b.n	8018c48 <__gethex+0x334>
 8018ca6:	2701      	movs	r7, #1
 8018ca8:	e7e2      	b.n	8018c70 <__gethex+0x35c>
 8018caa:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8018cac:	f1c3 0301 	rsb	r3, r3, #1
 8018cb0:	9315      	str	r3, [sp, #84]	; 0x54
 8018cb2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8018cb4:	2b00      	cmp	r3, #0
 8018cb6:	d0f0      	beq.n	8018c9a <__gethex+0x386>
 8018cb8:	f8d4 b010 	ldr.w	fp, [r4, #16]
 8018cbc:	f104 0314 	add.w	r3, r4, #20
 8018cc0:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 8018cc4:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 8018cc8:	f04f 0c00 	mov.w	ip, #0
 8018ccc:	4618      	mov	r0, r3
 8018cce:	f853 2b04 	ldr.w	r2, [r3], #4
 8018cd2:	f1b2 3fff 	cmp.w	r2, #4294967295
 8018cd6:	d01c      	beq.n	8018d12 <__gethex+0x3fe>
 8018cd8:	3201      	adds	r2, #1
 8018cda:	6002      	str	r2, [r0, #0]
 8018cdc:	2f02      	cmp	r7, #2
 8018cde:	f104 0314 	add.w	r3, r4, #20
 8018ce2:	d13f      	bne.n	8018d64 <__gethex+0x450>
 8018ce4:	f8d8 2000 	ldr.w	r2, [r8]
 8018ce8:	3a01      	subs	r2, #1
 8018cea:	42b2      	cmp	r2, r6
 8018cec:	d10a      	bne.n	8018d04 <__gethex+0x3f0>
 8018cee:	1171      	asrs	r1, r6, #5
 8018cf0:	2201      	movs	r2, #1
 8018cf2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8018cf6:	f006 061f 	and.w	r6, r6, #31
 8018cfa:	fa02 f606 	lsl.w	r6, r2, r6
 8018cfe:	421e      	tst	r6, r3
 8018d00:	bf18      	it	ne
 8018d02:	4617      	movne	r7, r2
 8018d04:	f047 0720 	orr.w	r7, r7, #32
 8018d08:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8018d0a:	601c      	str	r4, [r3, #0]
 8018d0c:	9b04      	ldr	r3, [sp, #16]
 8018d0e:	601d      	str	r5, [r3, #0]
 8018d10:	e695      	b.n	8018a3e <__gethex+0x12a>
 8018d12:	4299      	cmp	r1, r3
 8018d14:	f843 cc04 	str.w	ip, [r3, #-4]
 8018d18:	d8d8      	bhi.n	8018ccc <__gethex+0x3b8>
 8018d1a:	68a3      	ldr	r3, [r4, #8]
 8018d1c:	459b      	cmp	fp, r3
 8018d1e:	db19      	blt.n	8018d54 <__gethex+0x440>
 8018d20:	6861      	ldr	r1, [r4, #4]
 8018d22:	ee18 0a10 	vmov	r0, s16
 8018d26:	3101      	adds	r1, #1
 8018d28:	f000 f940 	bl	8018fac <_Balloc>
 8018d2c:	4681      	mov	r9, r0
 8018d2e:	b918      	cbnz	r0, 8018d38 <__gethex+0x424>
 8018d30:	4b1a      	ldr	r3, [pc, #104]	; (8018d9c <__gethex+0x488>)
 8018d32:	4602      	mov	r2, r0
 8018d34:	2184      	movs	r1, #132	; 0x84
 8018d36:	e6a8      	b.n	8018a8a <__gethex+0x176>
 8018d38:	6922      	ldr	r2, [r4, #16]
 8018d3a:	3202      	adds	r2, #2
 8018d3c:	f104 010c 	add.w	r1, r4, #12
 8018d40:	0092      	lsls	r2, r2, #2
 8018d42:	300c      	adds	r0, #12
 8018d44:	f7fd f8fc 	bl	8015f40 <memcpy>
 8018d48:	4621      	mov	r1, r4
 8018d4a:	ee18 0a10 	vmov	r0, s16
 8018d4e:	f000 f96d 	bl	801902c <_Bfree>
 8018d52:	464c      	mov	r4, r9
 8018d54:	6923      	ldr	r3, [r4, #16]
 8018d56:	1c5a      	adds	r2, r3, #1
 8018d58:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8018d5c:	6122      	str	r2, [r4, #16]
 8018d5e:	2201      	movs	r2, #1
 8018d60:	615a      	str	r2, [r3, #20]
 8018d62:	e7bb      	b.n	8018cdc <__gethex+0x3c8>
 8018d64:	6922      	ldr	r2, [r4, #16]
 8018d66:	455a      	cmp	r2, fp
 8018d68:	dd0b      	ble.n	8018d82 <__gethex+0x46e>
 8018d6a:	2101      	movs	r1, #1
 8018d6c:	4620      	mov	r0, r4
 8018d6e:	f7ff fd69 	bl	8018844 <rshift>
 8018d72:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8018d76:	3501      	adds	r5, #1
 8018d78:	42ab      	cmp	r3, r5
 8018d7a:	f6ff aed0 	blt.w	8018b1e <__gethex+0x20a>
 8018d7e:	2701      	movs	r7, #1
 8018d80:	e7c0      	b.n	8018d04 <__gethex+0x3f0>
 8018d82:	f016 061f 	ands.w	r6, r6, #31
 8018d86:	d0fa      	beq.n	8018d7e <__gethex+0x46a>
 8018d88:	449a      	add	sl, r3
 8018d8a:	f1c6 0620 	rsb	r6, r6, #32
 8018d8e:	f85a 0c04 	ldr.w	r0, [sl, #-4]
 8018d92:	f000 fa01 	bl	8019198 <__hi0bits>
 8018d96:	42b0      	cmp	r0, r6
 8018d98:	dbe7      	blt.n	8018d6a <__gethex+0x456>
 8018d9a:	e7f0      	b.n	8018d7e <__gethex+0x46a>
 8018d9c:	0801aef0 	.word	0x0801aef0

08018da0 <L_shift>:
 8018da0:	f1c2 0208 	rsb	r2, r2, #8
 8018da4:	0092      	lsls	r2, r2, #2
 8018da6:	b570      	push	{r4, r5, r6, lr}
 8018da8:	f1c2 0620 	rsb	r6, r2, #32
 8018dac:	6843      	ldr	r3, [r0, #4]
 8018dae:	6804      	ldr	r4, [r0, #0]
 8018db0:	fa03 f506 	lsl.w	r5, r3, r6
 8018db4:	432c      	orrs	r4, r5
 8018db6:	40d3      	lsrs	r3, r2
 8018db8:	6004      	str	r4, [r0, #0]
 8018dba:	f840 3f04 	str.w	r3, [r0, #4]!
 8018dbe:	4288      	cmp	r0, r1
 8018dc0:	d3f4      	bcc.n	8018dac <L_shift+0xc>
 8018dc2:	bd70      	pop	{r4, r5, r6, pc}

08018dc4 <__match>:
 8018dc4:	b530      	push	{r4, r5, lr}
 8018dc6:	6803      	ldr	r3, [r0, #0]
 8018dc8:	3301      	adds	r3, #1
 8018dca:	f811 4b01 	ldrb.w	r4, [r1], #1
 8018dce:	b914      	cbnz	r4, 8018dd6 <__match+0x12>
 8018dd0:	6003      	str	r3, [r0, #0]
 8018dd2:	2001      	movs	r0, #1
 8018dd4:	bd30      	pop	{r4, r5, pc}
 8018dd6:	f813 2b01 	ldrb.w	r2, [r3], #1
 8018dda:	f1a2 0541 	sub.w	r5, r2, #65	; 0x41
 8018dde:	2d19      	cmp	r5, #25
 8018de0:	bf98      	it	ls
 8018de2:	3220      	addls	r2, #32
 8018de4:	42a2      	cmp	r2, r4
 8018de6:	d0f0      	beq.n	8018dca <__match+0x6>
 8018de8:	2000      	movs	r0, #0
 8018dea:	e7f3      	b.n	8018dd4 <__match+0x10>

08018dec <__hexnan>:
 8018dec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018df0:	680b      	ldr	r3, [r1, #0]
 8018df2:	6801      	ldr	r1, [r0, #0]
 8018df4:	115e      	asrs	r6, r3, #5
 8018df6:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8018dfa:	f013 031f 	ands.w	r3, r3, #31
 8018dfe:	b087      	sub	sp, #28
 8018e00:	bf18      	it	ne
 8018e02:	3604      	addne	r6, #4
 8018e04:	2500      	movs	r5, #0
 8018e06:	1f37      	subs	r7, r6, #4
 8018e08:	4682      	mov	sl, r0
 8018e0a:	4690      	mov	r8, r2
 8018e0c:	9301      	str	r3, [sp, #4]
 8018e0e:	f846 5c04 	str.w	r5, [r6, #-4]
 8018e12:	46b9      	mov	r9, r7
 8018e14:	463c      	mov	r4, r7
 8018e16:	9502      	str	r5, [sp, #8]
 8018e18:	46ab      	mov	fp, r5
 8018e1a:	784a      	ldrb	r2, [r1, #1]
 8018e1c:	1c4b      	adds	r3, r1, #1
 8018e1e:	9303      	str	r3, [sp, #12]
 8018e20:	b342      	cbz	r2, 8018e74 <__hexnan+0x88>
 8018e22:	4610      	mov	r0, r2
 8018e24:	9105      	str	r1, [sp, #20]
 8018e26:	9204      	str	r2, [sp, #16]
 8018e28:	f7ff fd5e 	bl	80188e8 <__hexdig_fun>
 8018e2c:	2800      	cmp	r0, #0
 8018e2e:	d14f      	bne.n	8018ed0 <__hexnan+0xe4>
 8018e30:	9a04      	ldr	r2, [sp, #16]
 8018e32:	9905      	ldr	r1, [sp, #20]
 8018e34:	2a20      	cmp	r2, #32
 8018e36:	d818      	bhi.n	8018e6a <__hexnan+0x7e>
 8018e38:	9b02      	ldr	r3, [sp, #8]
 8018e3a:	459b      	cmp	fp, r3
 8018e3c:	dd13      	ble.n	8018e66 <__hexnan+0x7a>
 8018e3e:	454c      	cmp	r4, r9
 8018e40:	d206      	bcs.n	8018e50 <__hexnan+0x64>
 8018e42:	2d07      	cmp	r5, #7
 8018e44:	dc04      	bgt.n	8018e50 <__hexnan+0x64>
 8018e46:	462a      	mov	r2, r5
 8018e48:	4649      	mov	r1, r9
 8018e4a:	4620      	mov	r0, r4
 8018e4c:	f7ff ffa8 	bl	8018da0 <L_shift>
 8018e50:	4544      	cmp	r4, r8
 8018e52:	d950      	bls.n	8018ef6 <__hexnan+0x10a>
 8018e54:	2300      	movs	r3, #0
 8018e56:	f1a4 0904 	sub.w	r9, r4, #4
 8018e5a:	f844 3c04 	str.w	r3, [r4, #-4]
 8018e5e:	f8cd b008 	str.w	fp, [sp, #8]
 8018e62:	464c      	mov	r4, r9
 8018e64:	461d      	mov	r5, r3
 8018e66:	9903      	ldr	r1, [sp, #12]
 8018e68:	e7d7      	b.n	8018e1a <__hexnan+0x2e>
 8018e6a:	2a29      	cmp	r2, #41	; 0x29
 8018e6c:	d156      	bne.n	8018f1c <__hexnan+0x130>
 8018e6e:	3102      	adds	r1, #2
 8018e70:	f8ca 1000 	str.w	r1, [sl]
 8018e74:	f1bb 0f00 	cmp.w	fp, #0
 8018e78:	d050      	beq.n	8018f1c <__hexnan+0x130>
 8018e7a:	454c      	cmp	r4, r9
 8018e7c:	d206      	bcs.n	8018e8c <__hexnan+0xa0>
 8018e7e:	2d07      	cmp	r5, #7
 8018e80:	dc04      	bgt.n	8018e8c <__hexnan+0xa0>
 8018e82:	462a      	mov	r2, r5
 8018e84:	4649      	mov	r1, r9
 8018e86:	4620      	mov	r0, r4
 8018e88:	f7ff ff8a 	bl	8018da0 <L_shift>
 8018e8c:	4544      	cmp	r4, r8
 8018e8e:	d934      	bls.n	8018efa <__hexnan+0x10e>
 8018e90:	f1a8 0204 	sub.w	r2, r8, #4
 8018e94:	4623      	mov	r3, r4
 8018e96:	f853 1b04 	ldr.w	r1, [r3], #4
 8018e9a:	f842 1f04 	str.w	r1, [r2, #4]!
 8018e9e:	429f      	cmp	r7, r3
 8018ea0:	d2f9      	bcs.n	8018e96 <__hexnan+0xaa>
 8018ea2:	1b3b      	subs	r3, r7, r4
 8018ea4:	f023 0303 	bic.w	r3, r3, #3
 8018ea8:	3304      	adds	r3, #4
 8018eaa:	3401      	adds	r4, #1
 8018eac:	3e03      	subs	r6, #3
 8018eae:	42b4      	cmp	r4, r6
 8018eb0:	bf88      	it	hi
 8018eb2:	2304      	movhi	r3, #4
 8018eb4:	4443      	add	r3, r8
 8018eb6:	2200      	movs	r2, #0
 8018eb8:	f843 2b04 	str.w	r2, [r3], #4
 8018ebc:	429f      	cmp	r7, r3
 8018ebe:	d2fb      	bcs.n	8018eb8 <__hexnan+0xcc>
 8018ec0:	683b      	ldr	r3, [r7, #0]
 8018ec2:	b91b      	cbnz	r3, 8018ecc <__hexnan+0xe0>
 8018ec4:	4547      	cmp	r7, r8
 8018ec6:	d127      	bne.n	8018f18 <__hexnan+0x12c>
 8018ec8:	2301      	movs	r3, #1
 8018eca:	603b      	str	r3, [r7, #0]
 8018ecc:	2005      	movs	r0, #5
 8018ece:	e026      	b.n	8018f1e <__hexnan+0x132>
 8018ed0:	3501      	adds	r5, #1
 8018ed2:	2d08      	cmp	r5, #8
 8018ed4:	f10b 0b01 	add.w	fp, fp, #1
 8018ed8:	dd06      	ble.n	8018ee8 <__hexnan+0xfc>
 8018eda:	4544      	cmp	r4, r8
 8018edc:	d9c3      	bls.n	8018e66 <__hexnan+0x7a>
 8018ede:	2300      	movs	r3, #0
 8018ee0:	f844 3c04 	str.w	r3, [r4, #-4]
 8018ee4:	2501      	movs	r5, #1
 8018ee6:	3c04      	subs	r4, #4
 8018ee8:	6822      	ldr	r2, [r4, #0]
 8018eea:	f000 000f 	and.w	r0, r0, #15
 8018eee:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 8018ef2:	6022      	str	r2, [r4, #0]
 8018ef4:	e7b7      	b.n	8018e66 <__hexnan+0x7a>
 8018ef6:	2508      	movs	r5, #8
 8018ef8:	e7b5      	b.n	8018e66 <__hexnan+0x7a>
 8018efa:	9b01      	ldr	r3, [sp, #4]
 8018efc:	2b00      	cmp	r3, #0
 8018efe:	d0df      	beq.n	8018ec0 <__hexnan+0xd4>
 8018f00:	f04f 32ff 	mov.w	r2, #4294967295
 8018f04:	f1c3 0320 	rsb	r3, r3, #32
 8018f08:	fa22 f303 	lsr.w	r3, r2, r3
 8018f0c:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8018f10:	401a      	ands	r2, r3
 8018f12:	f846 2c04 	str.w	r2, [r6, #-4]
 8018f16:	e7d3      	b.n	8018ec0 <__hexnan+0xd4>
 8018f18:	3f04      	subs	r7, #4
 8018f1a:	e7d1      	b.n	8018ec0 <__hexnan+0xd4>
 8018f1c:	2004      	movs	r0, #4
 8018f1e:	b007      	add	sp, #28
 8018f20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08018f24 <_isatty_r>:
 8018f24:	b538      	push	{r3, r4, r5, lr}
 8018f26:	4d06      	ldr	r5, [pc, #24]	; (8018f40 <_isatty_r+0x1c>)
 8018f28:	2300      	movs	r3, #0
 8018f2a:	4604      	mov	r4, r0
 8018f2c:	4608      	mov	r0, r1
 8018f2e:	602b      	str	r3, [r5, #0]
 8018f30:	f7fc fd7e 	bl	8015a30 <_isatty>
 8018f34:	1c43      	adds	r3, r0, #1
 8018f36:	d102      	bne.n	8018f3e <_isatty_r+0x1a>
 8018f38:	682b      	ldr	r3, [r5, #0]
 8018f3a:	b103      	cbz	r3, 8018f3e <_isatty_r+0x1a>
 8018f3c:	6023      	str	r3, [r4, #0]
 8018f3e:	bd38      	pop	{r3, r4, r5, pc}
 8018f40:	2001a178 	.word	0x2001a178

08018f44 <_localeconv_r>:
 8018f44:	4800      	ldr	r0, [pc, #0]	; (8018f48 <_localeconv_r+0x4>)
 8018f46:	4770      	bx	lr
 8018f48:	20000298 	.word	0x20000298

08018f4c <_lseek_r>:
 8018f4c:	b538      	push	{r3, r4, r5, lr}
 8018f4e:	4d07      	ldr	r5, [pc, #28]	; (8018f6c <_lseek_r+0x20>)
 8018f50:	4604      	mov	r4, r0
 8018f52:	4608      	mov	r0, r1
 8018f54:	4611      	mov	r1, r2
 8018f56:	2200      	movs	r2, #0
 8018f58:	602a      	str	r2, [r5, #0]
 8018f5a:	461a      	mov	r2, r3
 8018f5c:	f7fc fd6a 	bl	8015a34 <_lseek>
 8018f60:	1c43      	adds	r3, r0, #1
 8018f62:	d102      	bne.n	8018f6a <_lseek_r+0x1e>
 8018f64:	682b      	ldr	r3, [r5, #0]
 8018f66:	b103      	cbz	r3, 8018f6a <_lseek_r+0x1e>
 8018f68:	6023      	str	r3, [r4, #0]
 8018f6a:	bd38      	pop	{r3, r4, r5, pc}
 8018f6c:	2001a178 	.word	0x2001a178

08018f70 <__ascii_mbtowc>:
 8018f70:	b082      	sub	sp, #8
 8018f72:	b901      	cbnz	r1, 8018f76 <__ascii_mbtowc+0x6>
 8018f74:	a901      	add	r1, sp, #4
 8018f76:	b142      	cbz	r2, 8018f8a <__ascii_mbtowc+0x1a>
 8018f78:	b14b      	cbz	r3, 8018f8e <__ascii_mbtowc+0x1e>
 8018f7a:	7813      	ldrb	r3, [r2, #0]
 8018f7c:	600b      	str	r3, [r1, #0]
 8018f7e:	7812      	ldrb	r2, [r2, #0]
 8018f80:	1e10      	subs	r0, r2, #0
 8018f82:	bf18      	it	ne
 8018f84:	2001      	movne	r0, #1
 8018f86:	b002      	add	sp, #8
 8018f88:	4770      	bx	lr
 8018f8a:	4610      	mov	r0, r2
 8018f8c:	e7fb      	b.n	8018f86 <__ascii_mbtowc+0x16>
 8018f8e:	f06f 0001 	mvn.w	r0, #1
 8018f92:	e7f8      	b.n	8018f86 <__ascii_mbtowc+0x16>

08018f94 <__malloc_lock>:
 8018f94:	4801      	ldr	r0, [pc, #4]	; (8018f9c <__malloc_lock+0x8>)
 8018f96:	f7fc bf5c 	b.w	8015e52 <__retarget_lock_acquire_recursive>
 8018f9a:	bf00      	nop
 8018f9c:	2001a170 	.word	0x2001a170

08018fa0 <__malloc_unlock>:
 8018fa0:	4801      	ldr	r0, [pc, #4]	; (8018fa8 <__malloc_unlock+0x8>)
 8018fa2:	f7fc bf57 	b.w	8015e54 <__retarget_lock_release_recursive>
 8018fa6:	bf00      	nop
 8018fa8:	2001a170 	.word	0x2001a170

08018fac <_Balloc>:
 8018fac:	b570      	push	{r4, r5, r6, lr}
 8018fae:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8018fb0:	4604      	mov	r4, r0
 8018fb2:	460d      	mov	r5, r1
 8018fb4:	b976      	cbnz	r6, 8018fd4 <_Balloc+0x28>
 8018fb6:	2010      	movs	r0, #16
 8018fb8:	f7fc ffb2 	bl	8015f20 <malloc>
 8018fbc:	4602      	mov	r2, r0
 8018fbe:	6260      	str	r0, [r4, #36]	; 0x24
 8018fc0:	b920      	cbnz	r0, 8018fcc <_Balloc+0x20>
 8018fc2:	4b18      	ldr	r3, [pc, #96]	; (8019024 <_Balloc+0x78>)
 8018fc4:	4818      	ldr	r0, [pc, #96]	; (8019028 <_Balloc+0x7c>)
 8018fc6:	2166      	movs	r1, #102	; 0x66
 8018fc8:	f000 fe30 	bl	8019c2c <__assert_func>
 8018fcc:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8018fd0:	6006      	str	r6, [r0, #0]
 8018fd2:	60c6      	str	r6, [r0, #12]
 8018fd4:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8018fd6:	68f3      	ldr	r3, [r6, #12]
 8018fd8:	b183      	cbz	r3, 8018ffc <_Balloc+0x50>
 8018fda:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8018fdc:	68db      	ldr	r3, [r3, #12]
 8018fde:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8018fe2:	b9b8      	cbnz	r0, 8019014 <_Balloc+0x68>
 8018fe4:	2101      	movs	r1, #1
 8018fe6:	fa01 f605 	lsl.w	r6, r1, r5
 8018fea:	1d72      	adds	r2, r6, #5
 8018fec:	0092      	lsls	r2, r2, #2
 8018fee:	4620      	mov	r0, r4
 8018ff0:	f7fc ffd6 	bl	8015fa0 <_calloc_r>
 8018ff4:	b160      	cbz	r0, 8019010 <_Balloc+0x64>
 8018ff6:	e9c0 5601 	strd	r5, r6, [r0, #4]
 8018ffa:	e00e      	b.n	801901a <_Balloc+0x6e>
 8018ffc:	2221      	movs	r2, #33	; 0x21
 8018ffe:	2104      	movs	r1, #4
 8019000:	4620      	mov	r0, r4
 8019002:	f7fc ffcd 	bl	8015fa0 <_calloc_r>
 8019006:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8019008:	60f0      	str	r0, [r6, #12]
 801900a:	68db      	ldr	r3, [r3, #12]
 801900c:	2b00      	cmp	r3, #0
 801900e:	d1e4      	bne.n	8018fda <_Balloc+0x2e>
 8019010:	2000      	movs	r0, #0
 8019012:	bd70      	pop	{r4, r5, r6, pc}
 8019014:	6802      	ldr	r2, [r0, #0]
 8019016:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 801901a:	2300      	movs	r3, #0
 801901c:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8019020:	e7f7      	b.n	8019012 <_Balloc+0x66>
 8019022:	bf00      	nop
 8019024:	0801ae7a 	.word	0x0801ae7a
 8019028:	0801af80 	.word	0x0801af80

0801902c <_Bfree>:
 801902c:	b570      	push	{r4, r5, r6, lr}
 801902e:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8019030:	4605      	mov	r5, r0
 8019032:	460c      	mov	r4, r1
 8019034:	b976      	cbnz	r6, 8019054 <_Bfree+0x28>
 8019036:	2010      	movs	r0, #16
 8019038:	f7fc ff72 	bl	8015f20 <malloc>
 801903c:	4602      	mov	r2, r0
 801903e:	6268      	str	r0, [r5, #36]	; 0x24
 8019040:	b920      	cbnz	r0, 801904c <_Bfree+0x20>
 8019042:	4b09      	ldr	r3, [pc, #36]	; (8019068 <_Bfree+0x3c>)
 8019044:	4809      	ldr	r0, [pc, #36]	; (801906c <_Bfree+0x40>)
 8019046:	218a      	movs	r1, #138	; 0x8a
 8019048:	f000 fdf0 	bl	8019c2c <__assert_func>
 801904c:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8019050:	6006      	str	r6, [r0, #0]
 8019052:	60c6      	str	r6, [r0, #12]
 8019054:	b13c      	cbz	r4, 8019066 <_Bfree+0x3a>
 8019056:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8019058:	6862      	ldr	r2, [r4, #4]
 801905a:	68db      	ldr	r3, [r3, #12]
 801905c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8019060:	6021      	str	r1, [r4, #0]
 8019062:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8019066:	bd70      	pop	{r4, r5, r6, pc}
 8019068:	0801ae7a 	.word	0x0801ae7a
 801906c:	0801af80 	.word	0x0801af80

08019070 <__multadd>:
 8019070:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8019074:	690e      	ldr	r6, [r1, #16]
 8019076:	4607      	mov	r7, r0
 8019078:	4698      	mov	r8, r3
 801907a:	460c      	mov	r4, r1
 801907c:	f101 0014 	add.w	r0, r1, #20
 8019080:	2300      	movs	r3, #0
 8019082:	6805      	ldr	r5, [r0, #0]
 8019084:	b2a9      	uxth	r1, r5
 8019086:	fb02 8101 	mla	r1, r2, r1, r8
 801908a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
 801908e:	0c2d      	lsrs	r5, r5, #16
 8019090:	fb02 c505 	mla	r5, r2, r5, ip
 8019094:	b289      	uxth	r1, r1
 8019096:	3301      	adds	r3, #1
 8019098:	eb01 4105 	add.w	r1, r1, r5, lsl #16
 801909c:	429e      	cmp	r6, r3
 801909e:	f840 1b04 	str.w	r1, [r0], #4
 80190a2:	ea4f 4815 	mov.w	r8, r5, lsr #16
 80190a6:	dcec      	bgt.n	8019082 <__multadd+0x12>
 80190a8:	f1b8 0f00 	cmp.w	r8, #0
 80190ac:	d022      	beq.n	80190f4 <__multadd+0x84>
 80190ae:	68a3      	ldr	r3, [r4, #8]
 80190b0:	42b3      	cmp	r3, r6
 80190b2:	dc19      	bgt.n	80190e8 <__multadd+0x78>
 80190b4:	6861      	ldr	r1, [r4, #4]
 80190b6:	4638      	mov	r0, r7
 80190b8:	3101      	adds	r1, #1
 80190ba:	f7ff ff77 	bl	8018fac <_Balloc>
 80190be:	4605      	mov	r5, r0
 80190c0:	b928      	cbnz	r0, 80190ce <__multadd+0x5e>
 80190c2:	4602      	mov	r2, r0
 80190c4:	4b0d      	ldr	r3, [pc, #52]	; (80190fc <__multadd+0x8c>)
 80190c6:	480e      	ldr	r0, [pc, #56]	; (8019100 <__multadd+0x90>)
 80190c8:	21b5      	movs	r1, #181	; 0xb5
 80190ca:	f000 fdaf 	bl	8019c2c <__assert_func>
 80190ce:	6922      	ldr	r2, [r4, #16]
 80190d0:	3202      	adds	r2, #2
 80190d2:	f104 010c 	add.w	r1, r4, #12
 80190d6:	0092      	lsls	r2, r2, #2
 80190d8:	300c      	adds	r0, #12
 80190da:	f7fc ff31 	bl	8015f40 <memcpy>
 80190de:	4621      	mov	r1, r4
 80190e0:	4638      	mov	r0, r7
 80190e2:	f7ff ffa3 	bl	801902c <_Bfree>
 80190e6:	462c      	mov	r4, r5
 80190e8:	eb04 0386 	add.w	r3, r4, r6, lsl #2
 80190ec:	3601      	adds	r6, #1
 80190ee:	f8c3 8014 	str.w	r8, [r3, #20]
 80190f2:	6126      	str	r6, [r4, #16]
 80190f4:	4620      	mov	r0, r4
 80190f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80190fa:	bf00      	nop
 80190fc:	0801aef0 	.word	0x0801aef0
 8019100:	0801af80 	.word	0x0801af80

08019104 <__s2b>:
 8019104:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8019108:	460c      	mov	r4, r1
 801910a:	4615      	mov	r5, r2
 801910c:	461f      	mov	r7, r3
 801910e:	2209      	movs	r2, #9
 8019110:	3308      	adds	r3, #8
 8019112:	4606      	mov	r6, r0
 8019114:	fb93 f3f2 	sdiv	r3, r3, r2
 8019118:	2100      	movs	r1, #0
 801911a:	2201      	movs	r2, #1
 801911c:	429a      	cmp	r2, r3
 801911e:	db09      	blt.n	8019134 <__s2b+0x30>
 8019120:	4630      	mov	r0, r6
 8019122:	f7ff ff43 	bl	8018fac <_Balloc>
 8019126:	b940      	cbnz	r0, 801913a <__s2b+0x36>
 8019128:	4602      	mov	r2, r0
 801912a:	4b19      	ldr	r3, [pc, #100]	; (8019190 <__s2b+0x8c>)
 801912c:	4819      	ldr	r0, [pc, #100]	; (8019194 <__s2b+0x90>)
 801912e:	21ce      	movs	r1, #206	; 0xce
 8019130:	f000 fd7c 	bl	8019c2c <__assert_func>
 8019134:	0052      	lsls	r2, r2, #1
 8019136:	3101      	adds	r1, #1
 8019138:	e7f0      	b.n	801911c <__s2b+0x18>
 801913a:	9b08      	ldr	r3, [sp, #32]
 801913c:	6143      	str	r3, [r0, #20]
 801913e:	2d09      	cmp	r5, #9
 8019140:	f04f 0301 	mov.w	r3, #1
 8019144:	6103      	str	r3, [r0, #16]
 8019146:	dd16      	ble.n	8019176 <__s2b+0x72>
 8019148:	f104 0909 	add.w	r9, r4, #9
 801914c:	46c8      	mov	r8, r9
 801914e:	442c      	add	r4, r5
 8019150:	f818 3b01 	ldrb.w	r3, [r8], #1
 8019154:	4601      	mov	r1, r0
 8019156:	3b30      	subs	r3, #48	; 0x30
 8019158:	220a      	movs	r2, #10
 801915a:	4630      	mov	r0, r6
 801915c:	f7ff ff88 	bl	8019070 <__multadd>
 8019160:	45a0      	cmp	r8, r4
 8019162:	d1f5      	bne.n	8019150 <__s2b+0x4c>
 8019164:	f1a5 0408 	sub.w	r4, r5, #8
 8019168:	444c      	add	r4, r9
 801916a:	1b2d      	subs	r5, r5, r4
 801916c:	1963      	adds	r3, r4, r5
 801916e:	42bb      	cmp	r3, r7
 8019170:	db04      	blt.n	801917c <__s2b+0x78>
 8019172:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8019176:	340a      	adds	r4, #10
 8019178:	2509      	movs	r5, #9
 801917a:	e7f6      	b.n	801916a <__s2b+0x66>
 801917c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8019180:	4601      	mov	r1, r0
 8019182:	3b30      	subs	r3, #48	; 0x30
 8019184:	220a      	movs	r2, #10
 8019186:	4630      	mov	r0, r6
 8019188:	f7ff ff72 	bl	8019070 <__multadd>
 801918c:	e7ee      	b.n	801916c <__s2b+0x68>
 801918e:	bf00      	nop
 8019190:	0801aef0 	.word	0x0801aef0
 8019194:	0801af80 	.word	0x0801af80

08019198 <__hi0bits>:
 8019198:	0c03      	lsrs	r3, r0, #16
 801919a:	041b      	lsls	r3, r3, #16
 801919c:	b9d3      	cbnz	r3, 80191d4 <__hi0bits+0x3c>
 801919e:	0400      	lsls	r0, r0, #16
 80191a0:	2310      	movs	r3, #16
 80191a2:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 80191a6:	bf04      	itt	eq
 80191a8:	0200      	lsleq	r0, r0, #8
 80191aa:	3308      	addeq	r3, #8
 80191ac:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 80191b0:	bf04      	itt	eq
 80191b2:	0100      	lsleq	r0, r0, #4
 80191b4:	3304      	addeq	r3, #4
 80191b6:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 80191ba:	bf04      	itt	eq
 80191bc:	0080      	lsleq	r0, r0, #2
 80191be:	3302      	addeq	r3, #2
 80191c0:	2800      	cmp	r0, #0
 80191c2:	db05      	blt.n	80191d0 <__hi0bits+0x38>
 80191c4:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 80191c8:	f103 0301 	add.w	r3, r3, #1
 80191cc:	bf08      	it	eq
 80191ce:	2320      	moveq	r3, #32
 80191d0:	4618      	mov	r0, r3
 80191d2:	4770      	bx	lr
 80191d4:	2300      	movs	r3, #0
 80191d6:	e7e4      	b.n	80191a2 <__hi0bits+0xa>

080191d8 <__lo0bits>:
 80191d8:	6803      	ldr	r3, [r0, #0]
 80191da:	f013 0207 	ands.w	r2, r3, #7
 80191de:	4601      	mov	r1, r0
 80191e0:	d00b      	beq.n	80191fa <__lo0bits+0x22>
 80191e2:	07da      	lsls	r2, r3, #31
 80191e4:	d424      	bmi.n	8019230 <__lo0bits+0x58>
 80191e6:	0798      	lsls	r0, r3, #30
 80191e8:	bf49      	itett	mi
 80191ea:	085b      	lsrmi	r3, r3, #1
 80191ec:	089b      	lsrpl	r3, r3, #2
 80191ee:	2001      	movmi	r0, #1
 80191f0:	600b      	strmi	r3, [r1, #0]
 80191f2:	bf5c      	itt	pl
 80191f4:	600b      	strpl	r3, [r1, #0]
 80191f6:	2002      	movpl	r0, #2
 80191f8:	4770      	bx	lr
 80191fa:	b298      	uxth	r0, r3
 80191fc:	b9b0      	cbnz	r0, 801922c <__lo0bits+0x54>
 80191fe:	0c1b      	lsrs	r3, r3, #16
 8019200:	2010      	movs	r0, #16
 8019202:	f013 0fff 	tst.w	r3, #255	; 0xff
 8019206:	bf04      	itt	eq
 8019208:	0a1b      	lsreq	r3, r3, #8
 801920a:	3008      	addeq	r0, #8
 801920c:	071a      	lsls	r2, r3, #28
 801920e:	bf04      	itt	eq
 8019210:	091b      	lsreq	r3, r3, #4
 8019212:	3004      	addeq	r0, #4
 8019214:	079a      	lsls	r2, r3, #30
 8019216:	bf04      	itt	eq
 8019218:	089b      	lsreq	r3, r3, #2
 801921a:	3002      	addeq	r0, #2
 801921c:	07da      	lsls	r2, r3, #31
 801921e:	d403      	bmi.n	8019228 <__lo0bits+0x50>
 8019220:	085b      	lsrs	r3, r3, #1
 8019222:	f100 0001 	add.w	r0, r0, #1
 8019226:	d005      	beq.n	8019234 <__lo0bits+0x5c>
 8019228:	600b      	str	r3, [r1, #0]
 801922a:	4770      	bx	lr
 801922c:	4610      	mov	r0, r2
 801922e:	e7e8      	b.n	8019202 <__lo0bits+0x2a>
 8019230:	2000      	movs	r0, #0
 8019232:	4770      	bx	lr
 8019234:	2020      	movs	r0, #32
 8019236:	4770      	bx	lr

08019238 <__i2b>:
 8019238:	b510      	push	{r4, lr}
 801923a:	460c      	mov	r4, r1
 801923c:	2101      	movs	r1, #1
 801923e:	f7ff feb5 	bl	8018fac <_Balloc>
 8019242:	4602      	mov	r2, r0
 8019244:	b928      	cbnz	r0, 8019252 <__i2b+0x1a>
 8019246:	4b05      	ldr	r3, [pc, #20]	; (801925c <__i2b+0x24>)
 8019248:	4805      	ldr	r0, [pc, #20]	; (8019260 <__i2b+0x28>)
 801924a:	f44f 71a0 	mov.w	r1, #320	; 0x140
 801924e:	f000 fced 	bl	8019c2c <__assert_func>
 8019252:	2301      	movs	r3, #1
 8019254:	6144      	str	r4, [r0, #20]
 8019256:	6103      	str	r3, [r0, #16]
 8019258:	bd10      	pop	{r4, pc}
 801925a:	bf00      	nop
 801925c:	0801aef0 	.word	0x0801aef0
 8019260:	0801af80 	.word	0x0801af80

08019264 <__multiply>:
 8019264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019268:	4614      	mov	r4, r2
 801926a:	690a      	ldr	r2, [r1, #16]
 801926c:	6923      	ldr	r3, [r4, #16]
 801926e:	429a      	cmp	r2, r3
 8019270:	bfb8      	it	lt
 8019272:	460b      	movlt	r3, r1
 8019274:	460d      	mov	r5, r1
 8019276:	bfbc      	itt	lt
 8019278:	4625      	movlt	r5, r4
 801927a:	461c      	movlt	r4, r3
 801927c:	f8d5 a010 	ldr.w	sl, [r5, #16]
 8019280:	f8d4 9010 	ldr.w	r9, [r4, #16]
 8019284:	68ab      	ldr	r3, [r5, #8]
 8019286:	6869      	ldr	r1, [r5, #4]
 8019288:	eb0a 0709 	add.w	r7, sl, r9
 801928c:	42bb      	cmp	r3, r7
 801928e:	b085      	sub	sp, #20
 8019290:	bfb8      	it	lt
 8019292:	3101      	addlt	r1, #1
 8019294:	f7ff fe8a 	bl	8018fac <_Balloc>
 8019298:	b930      	cbnz	r0, 80192a8 <__multiply+0x44>
 801929a:	4602      	mov	r2, r0
 801929c:	4b42      	ldr	r3, [pc, #264]	; (80193a8 <__multiply+0x144>)
 801929e:	4843      	ldr	r0, [pc, #268]	; (80193ac <__multiply+0x148>)
 80192a0:	f240 115d 	movw	r1, #349	; 0x15d
 80192a4:	f000 fcc2 	bl	8019c2c <__assert_func>
 80192a8:	f100 0614 	add.w	r6, r0, #20
 80192ac:	eb06 0887 	add.w	r8, r6, r7, lsl #2
 80192b0:	4633      	mov	r3, r6
 80192b2:	2200      	movs	r2, #0
 80192b4:	4543      	cmp	r3, r8
 80192b6:	d31e      	bcc.n	80192f6 <__multiply+0x92>
 80192b8:	f105 0c14 	add.w	ip, r5, #20
 80192bc:	f104 0314 	add.w	r3, r4, #20
 80192c0:	eb0c 0c8a 	add.w	ip, ip, sl, lsl #2
 80192c4:	eb03 0289 	add.w	r2, r3, r9, lsl #2
 80192c8:	9202      	str	r2, [sp, #8]
 80192ca:	ebac 0205 	sub.w	r2, ip, r5
 80192ce:	3a15      	subs	r2, #21
 80192d0:	f022 0203 	bic.w	r2, r2, #3
 80192d4:	3204      	adds	r2, #4
 80192d6:	f105 0115 	add.w	r1, r5, #21
 80192da:	458c      	cmp	ip, r1
 80192dc:	bf38      	it	cc
 80192de:	2204      	movcc	r2, #4
 80192e0:	9201      	str	r2, [sp, #4]
 80192e2:	9a02      	ldr	r2, [sp, #8]
 80192e4:	9303      	str	r3, [sp, #12]
 80192e6:	429a      	cmp	r2, r3
 80192e8:	d808      	bhi.n	80192fc <__multiply+0x98>
 80192ea:	2f00      	cmp	r7, #0
 80192ec:	dc55      	bgt.n	801939a <__multiply+0x136>
 80192ee:	6107      	str	r7, [r0, #16]
 80192f0:	b005      	add	sp, #20
 80192f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80192f6:	f843 2b04 	str.w	r2, [r3], #4
 80192fa:	e7db      	b.n	80192b4 <__multiply+0x50>
 80192fc:	f8b3 a000 	ldrh.w	sl, [r3]
 8019300:	f1ba 0f00 	cmp.w	sl, #0
 8019304:	d020      	beq.n	8019348 <__multiply+0xe4>
 8019306:	f105 0e14 	add.w	lr, r5, #20
 801930a:	46b1      	mov	r9, r6
 801930c:	2200      	movs	r2, #0
 801930e:	f85e 4b04 	ldr.w	r4, [lr], #4
 8019312:	f8d9 b000 	ldr.w	fp, [r9]
 8019316:	b2a1      	uxth	r1, r4
 8019318:	fa1f fb8b 	uxth.w	fp, fp
 801931c:	fb0a b101 	mla	r1, sl, r1, fp
 8019320:	4411      	add	r1, r2
 8019322:	f8d9 2000 	ldr.w	r2, [r9]
 8019326:	0c24      	lsrs	r4, r4, #16
 8019328:	0c12      	lsrs	r2, r2, #16
 801932a:	fb0a 2404 	mla	r4, sl, r4, r2
 801932e:	eb04 4411 	add.w	r4, r4, r1, lsr #16
 8019332:	b289      	uxth	r1, r1
 8019334:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 8019338:	45f4      	cmp	ip, lr
 801933a:	f849 1b04 	str.w	r1, [r9], #4
 801933e:	ea4f 4214 	mov.w	r2, r4, lsr #16
 8019342:	d8e4      	bhi.n	801930e <__multiply+0xaa>
 8019344:	9901      	ldr	r1, [sp, #4]
 8019346:	5072      	str	r2, [r6, r1]
 8019348:	9a03      	ldr	r2, [sp, #12]
 801934a:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 801934e:	3304      	adds	r3, #4
 8019350:	f1b9 0f00 	cmp.w	r9, #0
 8019354:	d01f      	beq.n	8019396 <__multiply+0x132>
 8019356:	6834      	ldr	r4, [r6, #0]
 8019358:	f105 0114 	add.w	r1, r5, #20
 801935c:	46b6      	mov	lr, r6
 801935e:	f04f 0a00 	mov.w	sl, #0
 8019362:	880a      	ldrh	r2, [r1, #0]
 8019364:	f8be b002 	ldrh.w	fp, [lr, #2]
 8019368:	fb09 b202 	mla	r2, r9, r2, fp
 801936c:	4492      	add	sl, r2
 801936e:	b2a4      	uxth	r4, r4
 8019370:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
 8019374:	f84e 4b04 	str.w	r4, [lr], #4
 8019378:	f851 4b04 	ldr.w	r4, [r1], #4
 801937c:	f8be 2000 	ldrh.w	r2, [lr]
 8019380:	0c24      	lsrs	r4, r4, #16
 8019382:	fb09 2404 	mla	r4, r9, r4, r2
 8019386:	eb04 441a 	add.w	r4, r4, sl, lsr #16
 801938a:	458c      	cmp	ip, r1
 801938c:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 8019390:	d8e7      	bhi.n	8019362 <__multiply+0xfe>
 8019392:	9a01      	ldr	r2, [sp, #4]
 8019394:	50b4      	str	r4, [r6, r2]
 8019396:	3604      	adds	r6, #4
 8019398:	e7a3      	b.n	80192e2 <__multiply+0x7e>
 801939a:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 801939e:	2b00      	cmp	r3, #0
 80193a0:	d1a5      	bne.n	80192ee <__multiply+0x8a>
 80193a2:	3f01      	subs	r7, #1
 80193a4:	e7a1      	b.n	80192ea <__multiply+0x86>
 80193a6:	bf00      	nop
 80193a8:	0801aef0 	.word	0x0801aef0
 80193ac:	0801af80 	.word	0x0801af80

080193b0 <__pow5mult>:
 80193b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80193b4:	4615      	mov	r5, r2
 80193b6:	f012 0203 	ands.w	r2, r2, #3
 80193ba:	4606      	mov	r6, r0
 80193bc:	460f      	mov	r7, r1
 80193be:	d007      	beq.n	80193d0 <__pow5mult+0x20>
 80193c0:	4c25      	ldr	r4, [pc, #148]	; (8019458 <__pow5mult+0xa8>)
 80193c2:	3a01      	subs	r2, #1
 80193c4:	2300      	movs	r3, #0
 80193c6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 80193ca:	f7ff fe51 	bl	8019070 <__multadd>
 80193ce:	4607      	mov	r7, r0
 80193d0:	10ad      	asrs	r5, r5, #2
 80193d2:	d03d      	beq.n	8019450 <__pow5mult+0xa0>
 80193d4:	6a74      	ldr	r4, [r6, #36]	; 0x24
 80193d6:	b97c      	cbnz	r4, 80193f8 <__pow5mult+0x48>
 80193d8:	2010      	movs	r0, #16
 80193da:	f7fc fda1 	bl	8015f20 <malloc>
 80193de:	4602      	mov	r2, r0
 80193e0:	6270      	str	r0, [r6, #36]	; 0x24
 80193e2:	b928      	cbnz	r0, 80193f0 <__pow5mult+0x40>
 80193e4:	4b1d      	ldr	r3, [pc, #116]	; (801945c <__pow5mult+0xac>)
 80193e6:	481e      	ldr	r0, [pc, #120]	; (8019460 <__pow5mult+0xb0>)
 80193e8:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 80193ec:	f000 fc1e 	bl	8019c2c <__assert_func>
 80193f0:	e9c0 4401 	strd	r4, r4, [r0, #4]
 80193f4:	6004      	str	r4, [r0, #0]
 80193f6:	60c4      	str	r4, [r0, #12]
 80193f8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 80193fc:	f8d8 4008 	ldr.w	r4, [r8, #8]
 8019400:	b94c      	cbnz	r4, 8019416 <__pow5mult+0x66>
 8019402:	f240 2171 	movw	r1, #625	; 0x271
 8019406:	4630      	mov	r0, r6
 8019408:	f7ff ff16 	bl	8019238 <__i2b>
 801940c:	2300      	movs	r3, #0
 801940e:	f8c8 0008 	str.w	r0, [r8, #8]
 8019412:	4604      	mov	r4, r0
 8019414:	6003      	str	r3, [r0, #0]
 8019416:	f04f 0900 	mov.w	r9, #0
 801941a:	07eb      	lsls	r3, r5, #31
 801941c:	d50a      	bpl.n	8019434 <__pow5mult+0x84>
 801941e:	4639      	mov	r1, r7
 8019420:	4622      	mov	r2, r4
 8019422:	4630      	mov	r0, r6
 8019424:	f7ff ff1e 	bl	8019264 <__multiply>
 8019428:	4639      	mov	r1, r7
 801942a:	4680      	mov	r8, r0
 801942c:	4630      	mov	r0, r6
 801942e:	f7ff fdfd 	bl	801902c <_Bfree>
 8019432:	4647      	mov	r7, r8
 8019434:	106d      	asrs	r5, r5, #1
 8019436:	d00b      	beq.n	8019450 <__pow5mult+0xa0>
 8019438:	6820      	ldr	r0, [r4, #0]
 801943a:	b938      	cbnz	r0, 801944c <__pow5mult+0x9c>
 801943c:	4622      	mov	r2, r4
 801943e:	4621      	mov	r1, r4
 8019440:	4630      	mov	r0, r6
 8019442:	f7ff ff0f 	bl	8019264 <__multiply>
 8019446:	6020      	str	r0, [r4, #0]
 8019448:	f8c0 9000 	str.w	r9, [r0]
 801944c:	4604      	mov	r4, r0
 801944e:	e7e4      	b.n	801941a <__pow5mult+0x6a>
 8019450:	4638      	mov	r0, r7
 8019452:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8019456:	bf00      	nop
 8019458:	0801b0d0 	.word	0x0801b0d0
 801945c:	0801ae7a 	.word	0x0801ae7a
 8019460:	0801af80 	.word	0x0801af80

08019464 <__lshift>:
 8019464:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8019468:	460c      	mov	r4, r1
 801946a:	6849      	ldr	r1, [r1, #4]
 801946c:	6923      	ldr	r3, [r4, #16]
 801946e:	eb03 1862 	add.w	r8, r3, r2, asr #5
 8019472:	68a3      	ldr	r3, [r4, #8]
 8019474:	4607      	mov	r7, r0
 8019476:	4691      	mov	r9, r2
 8019478:	ea4f 1a62 	mov.w	sl, r2, asr #5
 801947c:	f108 0601 	add.w	r6, r8, #1
 8019480:	42b3      	cmp	r3, r6
 8019482:	db0b      	blt.n	801949c <__lshift+0x38>
 8019484:	4638      	mov	r0, r7
 8019486:	f7ff fd91 	bl	8018fac <_Balloc>
 801948a:	4605      	mov	r5, r0
 801948c:	b948      	cbnz	r0, 80194a2 <__lshift+0x3e>
 801948e:	4602      	mov	r2, r0
 8019490:	4b28      	ldr	r3, [pc, #160]	; (8019534 <__lshift+0xd0>)
 8019492:	4829      	ldr	r0, [pc, #164]	; (8019538 <__lshift+0xd4>)
 8019494:	f240 11d9 	movw	r1, #473	; 0x1d9
 8019498:	f000 fbc8 	bl	8019c2c <__assert_func>
 801949c:	3101      	adds	r1, #1
 801949e:	005b      	lsls	r3, r3, #1
 80194a0:	e7ee      	b.n	8019480 <__lshift+0x1c>
 80194a2:	2300      	movs	r3, #0
 80194a4:	f100 0114 	add.w	r1, r0, #20
 80194a8:	f100 0210 	add.w	r2, r0, #16
 80194ac:	4618      	mov	r0, r3
 80194ae:	4553      	cmp	r3, sl
 80194b0:	db33      	blt.n	801951a <__lshift+0xb6>
 80194b2:	6920      	ldr	r0, [r4, #16]
 80194b4:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 80194b8:	f104 0314 	add.w	r3, r4, #20
 80194bc:	f019 091f 	ands.w	r9, r9, #31
 80194c0:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 80194c4:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 80194c8:	d02b      	beq.n	8019522 <__lshift+0xbe>
 80194ca:	f1c9 0e20 	rsb	lr, r9, #32
 80194ce:	468a      	mov	sl, r1
 80194d0:	2200      	movs	r2, #0
 80194d2:	6818      	ldr	r0, [r3, #0]
 80194d4:	fa00 f009 	lsl.w	r0, r0, r9
 80194d8:	4302      	orrs	r2, r0
 80194da:	f84a 2b04 	str.w	r2, [sl], #4
 80194de:	f853 2b04 	ldr.w	r2, [r3], #4
 80194e2:	459c      	cmp	ip, r3
 80194e4:	fa22 f20e 	lsr.w	r2, r2, lr
 80194e8:	d8f3      	bhi.n	80194d2 <__lshift+0x6e>
 80194ea:	ebac 0304 	sub.w	r3, ip, r4
 80194ee:	3b15      	subs	r3, #21
 80194f0:	f023 0303 	bic.w	r3, r3, #3
 80194f4:	3304      	adds	r3, #4
 80194f6:	f104 0015 	add.w	r0, r4, #21
 80194fa:	4584      	cmp	ip, r0
 80194fc:	bf38      	it	cc
 80194fe:	2304      	movcc	r3, #4
 8019500:	50ca      	str	r2, [r1, r3]
 8019502:	b10a      	cbz	r2, 8019508 <__lshift+0xa4>
 8019504:	f108 0602 	add.w	r6, r8, #2
 8019508:	3e01      	subs	r6, #1
 801950a:	4638      	mov	r0, r7
 801950c:	612e      	str	r6, [r5, #16]
 801950e:	4621      	mov	r1, r4
 8019510:	f7ff fd8c 	bl	801902c <_Bfree>
 8019514:	4628      	mov	r0, r5
 8019516:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801951a:	f842 0f04 	str.w	r0, [r2, #4]!
 801951e:	3301      	adds	r3, #1
 8019520:	e7c5      	b.n	80194ae <__lshift+0x4a>
 8019522:	3904      	subs	r1, #4
 8019524:	f853 2b04 	ldr.w	r2, [r3], #4
 8019528:	f841 2f04 	str.w	r2, [r1, #4]!
 801952c:	459c      	cmp	ip, r3
 801952e:	d8f9      	bhi.n	8019524 <__lshift+0xc0>
 8019530:	e7ea      	b.n	8019508 <__lshift+0xa4>
 8019532:	bf00      	nop
 8019534:	0801aef0 	.word	0x0801aef0
 8019538:	0801af80 	.word	0x0801af80

0801953c <__mcmp>:
 801953c:	b530      	push	{r4, r5, lr}
 801953e:	6902      	ldr	r2, [r0, #16]
 8019540:	690c      	ldr	r4, [r1, #16]
 8019542:	1b12      	subs	r2, r2, r4
 8019544:	d10e      	bne.n	8019564 <__mcmp+0x28>
 8019546:	f100 0314 	add.w	r3, r0, #20
 801954a:	3114      	adds	r1, #20
 801954c:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 8019550:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8019554:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 8019558:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 801955c:	42a5      	cmp	r5, r4
 801955e:	d003      	beq.n	8019568 <__mcmp+0x2c>
 8019560:	d305      	bcc.n	801956e <__mcmp+0x32>
 8019562:	2201      	movs	r2, #1
 8019564:	4610      	mov	r0, r2
 8019566:	bd30      	pop	{r4, r5, pc}
 8019568:	4283      	cmp	r3, r0
 801956a:	d3f3      	bcc.n	8019554 <__mcmp+0x18>
 801956c:	e7fa      	b.n	8019564 <__mcmp+0x28>
 801956e:	f04f 32ff 	mov.w	r2, #4294967295
 8019572:	e7f7      	b.n	8019564 <__mcmp+0x28>

08019574 <__mdiff>:
 8019574:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019578:	460c      	mov	r4, r1
 801957a:	4606      	mov	r6, r0
 801957c:	4611      	mov	r1, r2
 801957e:	4620      	mov	r0, r4
 8019580:	4617      	mov	r7, r2
 8019582:	f7ff ffdb 	bl	801953c <__mcmp>
 8019586:	1e05      	subs	r5, r0, #0
 8019588:	d110      	bne.n	80195ac <__mdiff+0x38>
 801958a:	4629      	mov	r1, r5
 801958c:	4630      	mov	r0, r6
 801958e:	f7ff fd0d 	bl	8018fac <_Balloc>
 8019592:	b930      	cbnz	r0, 80195a2 <__mdiff+0x2e>
 8019594:	4b39      	ldr	r3, [pc, #228]	; (801967c <__mdiff+0x108>)
 8019596:	4602      	mov	r2, r0
 8019598:	f240 2132 	movw	r1, #562	; 0x232
 801959c:	4838      	ldr	r0, [pc, #224]	; (8019680 <__mdiff+0x10c>)
 801959e:	f000 fb45 	bl	8019c2c <__assert_func>
 80195a2:	2301      	movs	r3, #1
 80195a4:	e9c0 3504 	strd	r3, r5, [r0, #16]
 80195a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80195ac:	bfa4      	itt	ge
 80195ae:	463b      	movge	r3, r7
 80195b0:	4627      	movge	r7, r4
 80195b2:	4630      	mov	r0, r6
 80195b4:	6879      	ldr	r1, [r7, #4]
 80195b6:	bfa6      	itte	ge
 80195b8:	461c      	movge	r4, r3
 80195ba:	2500      	movge	r5, #0
 80195bc:	2501      	movlt	r5, #1
 80195be:	f7ff fcf5 	bl	8018fac <_Balloc>
 80195c2:	b920      	cbnz	r0, 80195ce <__mdiff+0x5a>
 80195c4:	4b2d      	ldr	r3, [pc, #180]	; (801967c <__mdiff+0x108>)
 80195c6:	4602      	mov	r2, r0
 80195c8:	f44f 7110 	mov.w	r1, #576	; 0x240
 80195cc:	e7e6      	b.n	801959c <__mdiff+0x28>
 80195ce:	693e      	ldr	r6, [r7, #16]
 80195d0:	60c5      	str	r5, [r0, #12]
 80195d2:	6925      	ldr	r5, [r4, #16]
 80195d4:	f107 0114 	add.w	r1, r7, #20
 80195d8:	f104 0914 	add.w	r9, r4, #20
 80195dc:	f100 0e14 	add.w	lr, r0, #20
 80195e0:	f107 0210 	add.w	r2, r7, #16
 80195e4:	eb01 0c86 	add.w	ip, r1, r6, lsl #2
 80195e8:	eb09 0585 	add.w	r5, r9, r5, lsl #2
 80195ec:	46f2      	mov	sl, lr
 80195ee:	2700      	movs	r7, #0
 80195f0:	f859 3b04 	ldr.w	r3, [r9], #4
 80195f4:	f852 bf04 	ldr.w	fp, [r2, #4]!
 80195f8:	fa1f f883 	uxth.w	r8, r3
 80195fc:	fa17 f78b 	uxtah	r7, r7, fp
 8019600:	0c1b      	lsrs	r3, r3, #16
 8019602:	eba7 0808 	sub.w	r8, r7, r8
 8019606:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 801960a:	eb03 4328 	add.w	r3, r3, r8, asr #16
 801960e:	fa1f f888 	uxth.w	r8, r8
 8019612:	141f      	asrs	r7, r3, #16
 8019614:	454d      	cmp	r5, r9
 8019616:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 801961a:	f84a 3b04 	str.w	r3, [sl], #4
 801961e:	d8e7      	bhi.n	80195f0 <__mdiff+0x7c>
 8019620:	1b2b      	subs	r3, r5, r4
 8019622:	3b15      	subs	r3, #21
 8019624:	f023 0303 	bic.w	r3, r3, #3
 8019628:	3304      	adds	r3, #4
 801962a:	3415      	adds	r4, #21
 801962c:	42a5      	cmp	r5, r4
 801962e:	bf38      	it	cc
 8019630:	2304      	movcc	r3, #4
 8019632:	4419      	add	r1, r3
 8019634:	4473      	add	r3, lr
 8019636:	469e      	mov	lr, r3
 8019638:	460d      	mov	r5, r1
 801963a:	4565      	cmp	r5, ip
 801963c:	d30e      	bcc.n	801965c <__mdiff+0xe8>
 801963e:	f10c 0203 	add.w	r2, ip, #3
 8019642:	1a52      	subs	r2, r2, r1
 8019644:	f022 0203 	bic.w	r2, r2, #3
 8019648:	3903      	subs	r1, #3
 801964a:	458c      	cmp	ip, r1
 801964c:	bf38      	it	cc
 801964e:	2200      	movcc	r2, #0
 8019650:	441a      	add	r2, r3
 8019652:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 8019656:	b17b      	cbz	r3, 8019678 <__mdiff+0x104>
 8019658:	6106      	str	r6, [r0, #16]
 801965a:	e7a5      	b.n	80195a8 <__mdiff+0x34>
 801965c:	f855 8b04 	ldr.w	r8, [r5], #4
 8019660:	fa17 f488 	uxtah	r4, r7, r8
 8019664:	1422      	asrs	r2, r4, #16
 8019666:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 801966a:	b2a4      	uxth	r4, r4
 801966c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8019670:	f84e 4b04 	str.w	r4, [lr], #4
 8019674:	1417      	asrs	r7, r2, #16
 8019676:	e7e0      	b.n	801963a <__mdiff+0xc6>
 8019678:	3e01      	subs	r6, #1
 801967a:	e7ea      	b.n	8019652 <__mdiff+0xde>
 801967c:	0801aef0 	.word	0x0801aef0
 8019680:	0801af80 	.word	0x0801af80

08019684 <__ulp>:
 8019684:	b082      	sub	sp, #8
 8019686:	ed8d 0b00 	vstr	d0, [sp]
 801968a:	9b01      	ldr	r3, [sp, #4]
 801968c:	4912      	ldr	r1, [pc, #72]	; (80196d8 <__ulp+0x54>)
 801968e:	4019      	ands	r1, r3
 8019690:	f1a1 7150 	sub.w	r1, r1, #54525952	; 0x3400000
 8019694:	2900      	cmp	r1, #0
 8019696:	dd05      	ble.n	80196a4 <__ulp+0x20>
 8019698:	2200      	movs	r2, #0
 801969a:	460b      	mov	r3, r1
 801969c:	ec43 2b10 	vmov	d0, r2, r3
 80196a0:	b002      	add	sp, #8
 80196a2:	4770      	bx	lr
 80196a4:	4249      	negs	r1, r1
 80196a6:	f1b1 7fa0 	cmp.w	r1, #20971520	; 0x1400000
 80196aa:	ea4f 5021 	mov.w	r0, r1, asr #20
 80196ae:	f04f 0200 	mov.w	r2, #0
 80196b2:	f04f 0300 	mov.w	r3, #0
 80196b6:	da04      	bge.n	80196c2 <__ulp+0x3e>
 80196b8:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 80196bc:	fa41 f300 	asr.w	r3, r1, r0
 80196c0:	e7ec      	b.n	801969c <__ulp+0x18>
 80196c2:	f1a0 0114 	sub.w	r1, r0, #20
 80196c6:	291e      	cmp	r1, #30
 80196c8:	bfda      	itte	le
 80196ca:	f04f 4000 	movle.w	r0, #2147483648	; 0x80000000
 80196ce:	fa20 f101 	lsrle.w	r1, r0, r1
 80196d2:	2101      	movgt	r1, #1
 80196d4:	460a      	mov	r2, r1
 80196d6:	e7e1      	b.n	801969c <__ulp+0x18>
 80196d8:	7ff00000 	.word	0x7ff00000

080196dc <__b2d>:
 80196dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80196de:	6905      	ldr	r5, [r0, #16]
 80196e0:	f100 0714 	add.w	r7, r0, #20
 80196e4:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 80196e8:	1f2e      	subs	r6, r5, #4
 80196ea:	f855 4c04 	ldr.w	r4, [r5, #-4]
 80196ee:	4620      	mov	r0, r4
 80196f0:	f7ff fd52 	bl	8019198 <__hi0bits>
 80196f4:	f1c0 0320 	rsb	r3, r0, #32
 80196f8:	280a      	cmp	r0, #10
 80196fa:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8019778 <__b2d+0x9c>
 80196fe:	600b      	str	r3, [r1, #0]
 8019700:	dc14      	bgt.n	801972c <__b2d+0x50>
 8019702:	f1c0 0e0b 	rsb	lr, r0, #11
 8019706:	fa24 f10e 	lsr.w	r1, r4, lr
 801970a:	42b7      	cmp	r7, r6
 801970c:	ea41 030c 	orr.w	r3, r1, ip
 8019710:	bf34      	ite	cc
 8019712:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
 8019716:	2100      	movcs	r1, #0
 8019718:	3015      	adds	r0, #21
 801971a:	fa04 f000 	lsl.w	r0, r4, r0
 801971e:	fa21 f10e 	lsr.w	r1, r1, lr
 8019722:	ea40 0201 	orr.w	r2, r0, r1
 8019726:	ec43 2b10 	vmov	d0, r2, r3
 801972a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801972c:	42b7      	cmp	r7, r6
 801972e:	bf3a      	itte	cc
 8019730:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
 8019734:	f1a5 0608 	subcc.w	r6, r5, #8
 8019738:	2100      	movcs	r1, #0
 801973a:	380b      	subs	r0, #11
 801973c:	d017      	beq.n	801976e <__b2d+0x92>
 801973e:	f1c0 0c20 	rsb	ip, r0, #32
 8019742:	fa04 f500 	lsl.w	r5, r4, r0
 8019746:	42be      	cmp	r6, r7
 8019748:	fa21 f40c 	lsr.w	r4, r1, ip
 801974c:	ea45 0504 	orr.w	r5, r5, r4
 8019750:	bf8c      	ite	hi
 8019752:	f856 4c04 	ldrhi.w	r4, [r6, #-4]
 8019756:	2400      	movls	r4, #0
 8019758:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
 801975c:	fa01 f000 	lsl.w	r0, r1, r0
 8019760:	fa24 f40c 	lsr.w	r4, r4, ip
 8019764:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8019768:	ea40 0204 	orr.w	r2, r0, r4
 801976c:	e7db      	b.n	8019726 <__b2d+0x4a>
 801976e:	ea44 030c 	orr.w	r3, r4, ip
 8019772:	460a      	mov	r2, r1
 8019774:	e7d7      	b.n	8019726 <__b2d+0x4a>
 8019776:	bf00      	nop
 8019778:	3ff00000 	.word	0x3ff00000

0801977c <__d2b>:
 801977c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8019780:	4689      	mov	r9, r1
 8019782:	2101      	movs	r1, #1
 8019784:	ec57 6b10 	vmov	r6, r7, d0
 8019788:	4690      	mov	r8, r2
 801978a:	f7ff fc0f 	bl	8018fac <_Balloc>
 801978e:	4604      	mov	r4, r0
 8019790:	b930      	cbnz	r0, 80197a0 <__d2b+0x24>
 8019792:	4602      	mov	r2, r0
 8019794:	4b25      	ldr	r3, [pc, #148]	; (801982c <__d2b+0xb0>)
 8019796:	4826      	ldr	r0, [pc, #152]	; (8019830 <__d2b+0xb4>)
 8019798:	f240 310a 	movw	r1, #778	; 0x30a
 801979c:	f000 fa46 	bl	8019c2c <__assert_func>
 80197a0:	f3c7 550a 	ubfx	r5, r7, #20, #11
 80197a4:	f3c7 0313 	ubfx	r3, r7, #0, #20
 80197a8:	bb35      	cbnz	r5, 80197f8 <__d2b+0x7c>
 80197aa:	2e00      	cmp	r6, #0
 80197ac:	9301      	str	r3, [sp, #4]
 80197ae:	d028      	beq.n	8019802 <__d2b+0x86>
 80197b0:	4668      	mov	r0, sp
 80197b2:	9600      	str	r6, [sp, #0]
 80197b4:	f7ff fd10 	bl	80191d8 <__lo0bits>
 80197b8:	9900      	ldr	r1, [sp, #0]
 80197ba:	b300      	cbz	r0, 80197fe <__d2b+0x82>
 80197bc:	9a01      	ldr	r2, [sp, #4]
 80197be:	f1c0 0320 	rsb	r3, r0, #32
 80197c2:	fa02 f303 	lsl.w	r3, r2, r3
 80197c6:	430b      	orrs	r3, r1
 80197c8:	40c2      	lsrs	r2, r0
 80197ca:	6163      	str	r3, [r4, #20]
 80197cc:	9201      	str	r2, [sp, #4]
 80197ce:	9b01      	ldr	r3, [sp, #4]
 80197d0:	61a3      	str	r3, [r4, #24]
 80197d2:	2b00      	cmp	r3, #0
 80197d4:	bf14      	ite	ne
 80197d6:	2202      	movne	r2, #2
 80197d8:	2201      	moveq	r2, #1
 80197da:	6122      	str	r2, [r4, #16]
 80197dc:	b1d5      	cbz	r5, 8019814 <__d2b+0x98>
 80197de:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 80197e2:	4405      	add	r5, r0
 80197e4:	f8c9 5000 	str.w	r5, [r9]
 80197e8:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 80197ec:	f8c8 0000 	str.w	r0, [r8]
 80197f0:	4620      	mov	r0, r4
 80197f2:	b003      	add	sp, #12
 80197f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80197f8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80197fc:	e7d5      	b.n	80197aa <__d2b+0x2e>
 80197fe:	6161      	str	r1, [r4, #20]
 8019800:	e7e5      	b.n	80197ce <__d2b+0x52>
 8019802:	a801      	add	r0, sp, #4
 8019804:	f7ff fce8 	bl	80191d8 <__lo0bits>
 8019808:	9b01      	ldr	r3, [sp, #4]
 801980a:	6163      	str	r3, [r4, #20]
 801980c:	2201      	movs	r2, #1
 801980e:	6122      	str	r2, [r4, #16]
 8019810:	3020      	adds	r0, #32
 8019812:	e7e3      	b.n	80197dc <__d2b+0x60>
 8019814:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8019818:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 801981c:	f8c9 0000 	str.w	r0, [r9]
 8019820:	6918      	ldr	r0, [r3, #16]
 8019822:	f7ff fcb9 	bl	8019198 <__hi0bits>
 8019826:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 801982a:	e7df      	b.n	80197ec <__d2b+0x70>
 801982c:	0801aef0 	.word	0x0801aef0
 8019830:	0801af80 	.word	0x0801af80

08019834 <__ratio>:
 8019834:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019838:	4688      	mov	r8, r1
 801983a:	4669      	mov	r1, sp
 801983c:	4681      	mov	r9, r0
 801983e:	f7ff ff4d 	bl	80196dc <__b2d>
 8019842:	a901      	add	r1, sp, #4
 8019844:	4640      	mov	r0, r8
 8019846:	ec55 4b10 	vmov	r4, r5, d0
 801984a:	f7ff ff47 	bl	80196dc <__b2d>
 801984e:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8019852:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8019856:	eba3 0c02 	sub.w	ip, r3, r2
 801985a:	e9dd 3200 	ldrd	r3, r2, [sp]
 801985e:	1a9b      	subs	r3, r3, r2
 8019860:	eb03 134c 	add.w	r3, r3, ip, lsl #5
 8019864:	ec51 0b10 	vmov	r0, r1, d0
 8019868:	2b00      	cmp	r3, #0
 801986a:	bfd6      	itet	le
 801986c:	460a      	movle	r2, r1
 801986e:	462a      	movgt	r2, r5
 8019870:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
 8019874:	468b      	mov	fp, r1
 8019876:	462f      	mov	r7, r5
 8019878:	bfd4      	ite	le
 801987a:	eb02 5b03 	addle.w	fp, r2, r3, lsl #20
 801987e:	eb02 5703 	addgt.w	r7, r2, r3, lsl #20
 8019882:	4620      	mov	r0, r4
 8019884:	ee10 2a10 	vmov	r2, s0
 8019888:	465b      	mov	r3, fp
 801988a:	4639      	mov	r1, r7
 801988c:	f7e7 f806 	bl	800089c <__aeabi_ddiv>
 8019890:	ec41 0b10 	vmov	d0, r0, r1
 8019894:	b003      	add	sp, #12
 8019896:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801989a <__copybits>:
 801989a:	3901      	subs	r1, #1
 801989c:	b570      	push	{r4, r5, r6, lr}
 801989e:	1149      	asrs	r1, r1, #5
 80198a0:	6914      	ldr	r4, [r2, #16]
 80198a2:	3101      	adds	r1, #1
 80198a4:	f102 0314 	add.w	r3, r2, #20
 80198a8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80198ac:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80198b0:	1f05      	subs	r5, r0, #4
 80198b2:	42a3      	cmp	r3, r4
 80198b4:	d30c      	bcc.n	80198d0 <__copybits+0x36>
 80198b6:	1aa3      	subs	r3, r4, r2
 80198b8:	3b11      	subs	r3, #17
 80198ba:	f023 0303 	bic.w	r3, r3, #3
 80198be:	3211      	adds	r2, #17
 80198c0:	42a2      	cmp	r2, r4
 80198c2:	bf88      	it	hi
 80198c4:	2300      	movhi	r3, #0
 80198c6:	4418      	add	r0, r3
 80198c8:	2300      	movs	r3, #0
 80198ca:	4288      	cmp	r0, r1
 80198cc:	d305      	bcc.n	80198da <__copybits+0x40>
 80198ce:	bd70      	pop	{r4, r5, r6, pc}
 80198d0:	f853 6b04 	ldr.w	r6, [r3], #4
 80198d4:	f845 6f04 	str.w	r6, [r5, #4]!
 80198d8:	e7eb      	b.n	80198b2 <__copybits+0x18>
 80198da:	f840 3b04 	str.w	r3, [r0], #4
 80198de:	e7f4      	b.n	80198ca <__copybits+0x30>

080198e0 <__any_on>:
 80198e0:	f100 0214 	add.w	r2, r0, #20
 80198e4:	6900      	ldr	r0, [r0, #16]
 80198e6:	114b      	asrs	r3, r1, #5
 80198e8:	4298      	cmp	r0, r3
 80198ea:	b510      	push	{r4, lr}
 80198ec:	db11      	blt.n	8019912 <__any_on+0x32>
 80198ee:	dd0a      	ble.n	8019906 <__any_on+0x26>
 80198f0:	f011 011f 	ands.w	r1, r1, #31
 80198f4:	d007      	beq.n	8019906 <__any_on+0x26>
 80198f6:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 80198fa:	fa24 f001 	lsr.w	r0, r4, r1
 80198fe:	fa00 f101 	lsl.w	r1, r0, r1
 8019902:	428c      	cmp	r4, r1
 8019904:	d10b      	bne.n	801991e <__any_on+0x3e>
 8019906:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801990a:	4293      	cmp	r3, r2
 801990c:	d803      	bhi.n	8019916 <__any_on+0x36>
 801990e:	2000      	movs	r0, #0
 8019910:	bd10      	pop	{r4, pc}
 8019912:	4603      	mov	r3, r0
 8019914:	e7f7      	b.n	8019906 <__any_on+0x26>
 8019916:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 801991a:	2900      	cmp	r1, #0
 801991c:	d0f5      	beq.n	801990a <__any_on+0x2a>
 801991e:	2001      	movs	r0, #1
 8019920:	e7f6      	b.n	8019910 <__any_on+0x30>

08019922 <__ssputs_r>:
 8019922:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8019926:	688e      	ldr	r6, [r1, #8]
 8019928:	429e      	cmp	r6, r3
 801992a:	4682      	mov	sl, r0
 801992c:	460c      	mov	r4, r1
 801992e:	4690      	mov	r8, r2
 8019930:	461f      	mov	r7, r3
 8019932:	d838      	bhi.n	80199a6 <__ssputs_r+0x84>
 8019934:	898a      	ldrh	r2, [r1, #12]
 8019936:	f412 6f90 	tst.w	r2, #1152	; 0x480
 801993a:	d032      	beq.n	80199a2 <__ssputs_r+0x80>
 801993c:	6825      	ldr	r5, [r4, #0]
 801993e:	6909      	ldr	r1, [r1, #16]
 8019940:	eba5 0901 	sub.w	r9, r5, r1
 8019944:	6965      	ldr	r5, [r4, #20]
 8019946:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 801994a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 801994e:	3301      	adds	r3, #1
 8019950:	444b      	add	r3, r9
 8019952:	106d      	asrs	r5, r5, #1
 8019954:	429d      	cmp	r5, r3
 8019956:	bf38      	it	cc
 8019958:	461d      	movcc	r5, r3
 801995a:	0553      	lsls	r3, r2, #21
 801995c:	d531      	bpl.n	80199c2 <__ssputs_r+0xa0>
 801995e:	4629      	mov	r1, r5
 8019960:	f7fc fb7e 	bl	8016060 <_malloc_r>
 8019964:	4606      	mov	r6, r0
 8019966:	b950      	cbnz	r0, 801997e <__ssputs_r+0x5c>
 8019968:	230c      	movs	r3, #12
 801996a:	f8ca 3000 	str.w	r3, [sl]
 801996e:	89a3      	ldrh	r3, [r4, #12]
 8019970:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8019974:	81a3      	strh	r3, [r4, #12]
 8019976:	f04f 30ff 	mov.w	r0, #4294967295
 801997a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801997e:	6921      	ldr	r1, [r4, #16]
 8019980:	464a      	mov	r2, r9
 8019982:	f7fc fadd 	bl	8015f40 <memcpy>
 8019986:	89a3      	ldrh	r3, [r4, #12]
 8019988:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 801998c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8019990:	81a3      	strh	r3, [r4, #12]
 8019992:	6126      	str	r6, [r4, #16]
 8019994:	6165      	str	r5, [r4, #20]
 8019996:	444e      	add	r6, r9
 8019998:	eba5 0509 	sub.w	r5, r5, r9
 801999c:	6026      	str	r6, [r4, #0]
 801999e:	60a5      	str	r5, [r4, #8]
 80199a0:	463e      	mov	r6, r7
 80199a2:	42be      	cmp	r6, r7
 80199a4:	d900      	bls.n	80199a8 <__ssputs_r+0x86>
 80199a6:	463e      	mov	r6, r7
 80199a8:	4632      	mov	r2, r6
 80199aa:	6820      	ldr	r0, [r4, #0]
 80199ac:	4641      	mov	r1, r8
 80199ae:	f7fc fad5 	bl	8015f5c <memmove>
 80199b2:	68a3      	ldr	r3, [r4, #8]
 80199b4:	6822      	ldr	r2, [r4, #0]
 80199b6:	1b9b      	subs	r3, r3, r6
 80199b8:	4432      	add	r2, r6
 80199ba:	60a3      	str	r3, [r4, #8]
 80199bc:	6022      	str	r2, [r4, #0]
 80199be:	2000      	movs	r0, #0
 80199c0:	e7db      	b.n	801997a <__ssputs_r+0x58>
 80199c2:	462a      	mov	r2, r5
 80199c4:	f000 f962 	bl	8019c8c <_realloc_r>
 80199c8:	4606      	mov	r6, r0
 80199ca:	2800      	cmp	r0, #0
 80199cc:	d1e1      	bne.n	8019992 <__ssputs_r+0x70>
 80199ce:	6921      	ldr	r1, [r4, #16]
 80199d0:	4650      	mov	r0, sl
 80199d2:	f7fc faf5 	bl	8015fc0 <_free_r>
 80199d6:	e7c7      	b.n	8019968 <__ssputs_r+0x46>

080199d8 <_svfiprintf_r>:
 80199d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80199dc:	4698      	mov	r8, r3
 80199de:	898b      	ldrh	r3, [r1, #12]
 80199e0:	061b      	lsls	r3, r3, #24
 80199e2:	b09d      	sub	sp, #116	; 0x74
 80199e4:	4607      	mov	r7, r0
 80199e6:	460d      	mov	r5, r1
 80199e8:	4614      	mov	r4, r2
 80199ea:	d50e      	bpl.n	8019a0a <_svfiprintf_r+0x32>
 80199ec:	690b      	ldr	r3, [r1, #16]
 80199ee:	b963      	cbnz	r3, 8019a0a <_svfiprintf_r+0x32>
 80199f0:	2140      	movs	r1, #64	; 0x40
 80199f2:	f7fc fb35 	bl	8016060 <_malloc_r>
 80199f6:	6028      	str	r0, [r5, #0]
 80199f8:	6128      	str	r0, [r5, #16]
 80199fa:	b920      	cbnz	r0, 8019a06 <_svfiprintf_r+0x2e>
 80199fc:	230c      	movs	r3, #12
 80199fe:	603b      	str	r3, [r7, #0]
 8019a00:	f04f 30ff 	mov.w	r0, #4294967295
 8019a04:	e0d1      	b.n	8019baa <_svfiprintf_r+0x1d2>
 8019a06:	2340      	movs	r3, #64	; 0x40
 8019a08:	616b      	str	r3, [r5, #20]
 8019a0a:	2300      	movs	r3, #0
 8019a0c:	9309      	str	r3, [sp, #36]	; 0x24
 8019a0e:	2320      	movs	r3, #32
 8019a10:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8019a14:	f8cd 800c 	str.w	r8, [sp, #12]
 8019a18:	2330      	movs	r3, #48	; 0x30
 8019a1a:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8019bc4 <_svfiprintf_r+0x1ec>
 8019a1e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8019a22:	f04f 0901 	mov.w	r9, #1
 8019a26:	4623      	mov	r3, r4
 8019a28:	469a      	mov	sl, r3
 8019a2a:	f813 2b01 	ldrb.w	r2, [r3], #1
 8019a2e:	b10a      	cbz	r2, 8019a34 <_svfiprintf_r+0x5c>
 8019a30:	2a25      	cmp	r2, #37	; 0x25
 8019a32:	d1f9      	bne.n	8019a28 <_svfiprintf_r+0x50>
 8019a34:	ebba 0b04 	subs.w	fp, sl, r4
 8019a38:	d00b      	beq.n	8019a52 <_svfiprintf_r+0x7a>
 8019a3a:	465b      	mov	r3, fp
 8019a3c:	4622      	mov	r2, r4
 8019a3e:	4629      	mov	r1, r5
 8019a40:	4638      	mov	r0, r7
 8019a42:	f7ff ff6e 	bl	8019922 <__ssputs_r>
 8019a46:	3001      	adds	r0, #1
 8019a48:	f000 80aa 	beq.w	8019ba0 <_svfiprintf_r+0x1c8>
 8019a4c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8019a4e:	445a      	add	r2, fp
 8019a50:	9209      	str	r2, [sp, #36]	; 0x24
 8019a52:	f89a 3000 	ldrb.w	r3, [sl]
 8019a56:	2b00      	cmp	r3, #0
 8019a58:	f000 80a2 	beq.w	8019ba0 <_svfiprintf_r+0x1c8>
 8019a5c:	2300      	movs	r3, #0
 8019a5e:	f04f 32ff 	mov.w	r2, #4294967295
 8019a62:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8019a66:	f10a 0a01 	add.w	sl, sl, #1
 8019a6a:	9304      	str	r3, [sp, #16]
 8019a6c:	9307      	str	r3, [sp, #28]
 8019a6e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8019a72:	931a      	str	r3, [sp, #104]	; 0x68
 8019a74:	4654      	mov	r4, sl
 8019a76:	2205      	movs	r2, #5
 8019a78:	f814 1b01 	ldrb.w	r1, [r4], #1
 8019a7c:	4851      	ldr	r0, [pc, #324]	; (8019bc4 <_svfiprintf_r+0x1ec>)
 8019a7e:	f7e6 fbd7 	bl	8000230 <memchr>
 8019a82:	9a04      	ldr	r2, [sp, #16]
 8019a84:	b9d8      	cbnz	r0, 8019abe <_svfiprintf_r+0xe6>
 8019a86:	06d0      	lsls	r0, r2, #27
 8019a88:	bf44      	itt	mi
 8019a8a:	2320      	movmi	r3, #32
 8019a8c:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8019a90:	0711      	lsls	r1, r2, #28
 8019a92:	bf44      	itt	mi
 8019a94:	232b      	movmi	r3, #43	; 0x2b
 8019a96:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8019a9a:	f89a 3000 	ldrb.w	r3, [sl]
 8019a9e:	2b2a      	cmp	r3, #42	; 0x2a
 8019aa0:	d015      	beq.n	8019ace <_svfiprintf_r+0xf6>
 8019aa2:	9a07      	ldr	r2, [sp, #28]
 8019aa4:	4654      	mov	r4, sl
 8019aa6:	2000      	movs	r0, #0
 8019aa8:	f04f 0c0a 	mov.w	ip, #10
 8019aac:	4621      	mov	r1, r4
 8019aae:	f811 3b01 	ldrb.w	r3, [r1], #1
 8019ab2:	3b30      	subs	r3, #48	; 0x30
 8019ab4:	2b09      	cmp	r3, #9
 8019ab6:	d94e      	bls.n	8019b56 <_svfiprintf_r+0x17e>
 8019ab8:	b1b0      	cbz	r0, 8019ae8 <_svfiprintf_r+0x110>
 8019aba:	9207      	str	r2, [sp, #28]
 8019abc:	e014      	b.n	8019ae8 <_svfiprintf_r+0x110>
 8019abe:	eba0 0308 	sub.w	r3, r0, r8
 8019ac2:	fa09 f303 	lsl.w	r3, r9, r3
 8019ac6:	4313      	orrs	r3, r2
 8019ac8:	9304      	str	r3, [sp, #16]
 8019aca:	46a2      	mov	sl, r4
 8019acc:	e7d2      	b.n	8019a74 <_svfiprintf_r+0x9c>
 8019ace:	9b03      	ldr	r3, [sp, #12]
 8019ad0:	1d19      	adds	r1, r3, #4
 8019ad2:	681b      	ldr	r3, [r3, #0]
 8019ad4:	9103      	str	r1, [sp, #12]
 8019ad6:	2b00      	cmp	r3, #0
 8019ad8:	bfbb      	ittet	lt
 8019ada:	425b      	neglt	r3, r3
 8019adc:	f042 0202 	orrlt.w	r2, r2, #2
 8019ae0:	9307      	strge	r3, [sp, #28]
 8019ae2:	9307      	strlt	r3, [sp, #28]
 8019ae4:	bfb8      	it	lt
 8019ae6:	9204      	strlt	r2, [sp, #16]
 8019ae8:	7823      	ldrb	r3, [r4, #0]
 8019aea:	2b2e      	cmp	r3, #46	; 0x2e
 8019aec:	d10c      	bne.n	8019b08 <_svfiprintf_r+0x130>
 8019aee:	7863      	ldrb	r3, [r4, #1]
 8019af0:	2b2a      	cmp	r3, #42	; 0x2a
 8019af2:	d135      	bne.n	8019b60 <_svfiprintf_r+0x188>
 8019af4:	9b03      	ldr	r3, [sp, #12]
 8019af6:	1d1a      	adds	r2, r3, #4
 8019af8:	681b      	ldr	r3, [r3, #0]
 8019afa:	9203      	str	r2, [sp, #12]
 8019afc:	2b00      	cmp	r3, #0
 8019afe:	bfb8      	it	lt
 8019b00:	f04f 33ff 	movlt.w	r3, #4294967295
 8019b04:	3402      	adds	r4, #2
 8019b06:	9305      	str	r3, [sp, #20]
 8019b08:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 8019bd4 <_svfiprintf_r+0x1fc>
 8019b0c:	7821      	ldrb	r1, [r4, #0]
 8019b0e:	2203      	movs	r2, #3
 8019b10:	4650      	mov	r0, sl
 8019b12:	f7e6 fb8d 	bl	8000230 <memchr>
 8019b16:	b140      	cbz	r0, 8019b2a <_svfiprintf_r+0x152>
 8019b18:	2340      	movs	r3, #64	; 0x40
 8019b1a:	eba0 000a 	sub.w	r0, r0, sl
 8019b1e:	fa03 f000 	lsl.w	r0, r3, r0
 8019b22:	9b04      	ldr	r3, [sp, #16]
 8019b24:	4303      	orrs	r3, r0
 8019b26:	3401      	adds	r4, #1
 8019b28:	9304      	str	r3, [sp, #16]
 8019b2a:	f814 1b01 	ldrb.w	r1, [r4], #1
 8019b2e:	4826      	ldr	r0, [pc, #152]	; (8019bc8 <_svfiprintf_r+0x1f0>)
 8019b30:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8019b34:	2206      	movs	r2, #6
 8019b36:	f7e6 fb7b 	bl	8000230 <memchr>
 8019b3a:	2800      	cmp	r0, #0
 8019b3c:	d038      	beq.n	8019bb0 <_svfiprintf_r+0x1d8>
 8019b3e:	4b23      	ldr	r3, [pc, #140]	; (8019bcc <_svfiprintf_r+0x1f4>)
 8019b40:	bb1b      	cbnz	r3, 8019b8a <_svfiprintf_r+0x1b2>
 8019b42:	9b03      	ldr	r3, [sp, #12]
 8019b44:	3307      	adds	r3, #7
 8019b46:	f023 0307 	bic.w	r3, r3, #7
 8019b4a:	3308      	adds	r3, #8
 8019b4c:	9303      	str	r3, [sp, #12]
 8019b4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8019b50:	4433      	add	r3, r6
 8019b52:	9309      	str	r3, [sp, #36]	; 0x24
 8019b54:	e767      	b.n	8019a26 <_svfiprintf_r+0x4e>
 8019b56:	fb0c 3202 	mla	r2, ip, r2, r3
 8019b5a:	460c      	mov	r4, r1
 8019b5c:	2001      	movs	r0, #1
 8019b5e:	e7a5      	b.n	8019aac <_svfiprintf_r+0xd4>
 8019b60:	2300      	movs	r3, #0
 8019b62:	3401      	adds	r4, #1
 8019b64:	9305      	str	r3, [sp, #20]
 8019b66:	4619      	mov	r1, r3
 8019b68:	f04f 0c0a 	mov.w	ip, #10
 8019b6c:	4620      	mov	r0, r4
 8019b6e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8019b72:	3a30      	subs	r2, #48	; 0x30
 8019b74:	2a09      	cmp	r2, #9
 8019b76:	d903      	bls.n	8019b80 <_svfiprintf_r+0x1a8>
 8019b78:	2b00      	cmp	r3, #0
 8019b7a:	d0c5      	beq.n	8019b08 <_svfiprintf_r+0x130>
 8019b7c:	9105      	str	r1, [sp, #20]
 8019b7e:	e7c3      	b.n	8019b08 <_svfiprintf_r+0x130>
 8019b80:	fb0c 2101 	mla	r1, ip, r1, r2
 8019b84:	4604      	mov	r4, r0
 8019b86:	2301      	movs	r3, #1
 8019b88:	e7f0      	b.n	8019b6c <_svfiprintf_r+0x194>
 8019b8a:	ab03      	add	r3, sp, #12
 8019b8c:	9300      	str	r3, [sp, #0]
 8019b8e:	462a      	mov	r2, r5
 8019b90:	4b0f      	ldr	r3, [pc, #60]	; (8019bd0 <_svfiprintf_r+0x1f8>)
 8019b92:	a904      	add	r1, sp, #16
 8019b94:	4638      	mov	r0, r7
 8019b96:	f7fc fb5d 	bl	8016254 <_printf_float>
 8019b9a:	1c42      	adds	r2, r0, #1
 8019b9c:	4606      	mov	r6, r0
 8019b9e:	d1d6      	bne.n	8019b4e <_svfiprintf_r+0x176>
 8019ba0:	89ab      	ldrh	r3, [r5, #12]
 8019ba2:	065b      	lsls	r3, r3, #25
 8019ba4:	f53f af2c 	bmi.w	8019a00 <_svfiprintf_r+0x28>
 8019ba8:	9809      	ldr	r0, [sp, #36]	; 0x24
 8019baa:	b01d      	add	sp, #116	; 0x74
 8019bac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019bb0:	ab03      	add	r3, sp, #12
 8019bb2:	9300      	str	r3, [sp, #0]
 8019bb4:	462a      	mov	r2, r5
 8019bb6:	4b06      	ldr	r3, [pc, #24]	; (8019bd0 <_svfiprintf_r+0x1f8>)
 8019bb8:	a904      	add	r1, sp, #16
 8019bba:	4638      	mov	r0, r7
 8019bbc:	f7fc fdee 	bl	801679c <_printf_i>
 8019bc0:	e7eb      	b.n	8019b9a <_svfiprintf_r+0x1c2>
 8019bc2:	bf00      	nop
 8019bc4:	0801b0dc 	.word	0x0801b0dc
 8019bc8:	0801b0e6 	.word	0x0801b0e6
 8019bcc:	08016255 	.word	0x08016255
 8019bd0:	08019923 	.word	0x08019923
 8019bd4:	0801b0e2 	.word	0x0801b0e2

08019bd8 <_read_r>:
 8019bd8:	b538      	push	{r3, r4, r5, lr}
 8019bda:	4d07      	ldr	r5, [pc, #28]	; (8019bf8 <_read_r+0x20>)
 8019bdc:	4604      	mov	r4, r0
 8019bde:	4608      	mov	r0, r1
 8019be0:	4611      	mov	r1, r2
 8019be2:	2200      	movs	r2, #0
 8019be4:	602a      	str	r2, [r5, #0]
 8019be6:	461a      	mov	r2, r3
 8019be8:	f7fb ff26 	bl	8015a38 <_read>
 8019bec:	1c43      	adds	r3, r0, #1
 8019bee:	d102      	bne.n	8019bf6 <_read_r+0x1e>
 8019bf0:	682b      	ldr	r3, [r5, #0]
 8019bf2:	b103      	cbz	r3, 8019bf6 <_read_r+0x1e>
 8019bf4:	6023      	str	r3, [r4, #0]
 8019bf6:	bd38      	pop	{r3, r4, r5, pc}
 8019bf8:	2001a178 	.word	0x2001a178
 8019bfc:	00000000 	.word	0x00000000

08019c00 <nan>:
 8019c00:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8019c08 <nan+0x8>
 8019c04:	4770      	bx	lr
 8019c06:	bf00      	nop
 8019c08:	00000000 	.word	0x00000000
 8019c0c:	7ff80000 	.word	0x7ff80000

08019c10 <__ascii_wctomb>:
 8019c10:	b149      	cbz	r1, 8019c26 <__ascii_wctomb+0x16>
 8019c12:	2aff      	cmp	r2, #255	; 0xff
 8019c14:	bf85      	ittet	hi
 8019c16:	238a      	movhi	r3, #138	; 0x8a
 8019c18:	6003      	strhi	r3, [r0, #0]
 8019c1a:	700a      	strbls	r2, [r1, #0]
 8019c1c:	f04f 30ff 	movhi.w	r0, #4294967295
 8019c20:	bf98      	it	ls
 8019c22:	2001      	movls	r0, #1
 8019c24:	4770      	bx	lr
 8019c26:	4608      	mov	r0, r1
 8019c28:	4770      	bx	lr
	...

08019c2c <__assert_func>:
 8019c2c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8019c2e:	4614      	mov	r4, r2
 8019c30:	461a      	mov	r2, r3
 8019c32:	4b09      	ldr	r3, [pc, #36]	; (8019c58 <__assert_func+0x2c>)
 8019c34:	681b      	ldr	r3, [r3, #0]
 8019c36:	4605      	mov	r5, r0
 8019c38:	68d8      	ldr	r0, [r3, #12]
 8019c3a:	b14c      	cbz	r4, 8019c50 <__assert_func+0x24>
 8019c3c:	4b07      	ldr	r3, [pc, #28]	; (8019c5c <__assert_func+0x30>)
 8019c3e:	9100      	str	r1, [sp, #0]
 8019c40:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8019c44:	4906      	ldr	r1, [pc, #24]	; (8019c60 <__assert_func+0x34>)
 8019c46:	462b      	mov	r3, r5
 8019c48:	f000 f80e 	bl	8019c68 <fiprintf>
 8019c4c:	f000 f99e 	bl	8019f8c <abort>
 8019c50:	4b04      	ldr	r3, [pc, #16]	; (8019c64 <__assert_func+0x38>)
 8019c52:	461c      	mov	r4, r3
 8019c54:	e7f3      	b.n	8019c3e <__assert_func+0x12>
 8019c56:	bf00      	nop
 8019c58:	20000140 	.word	0x20000140
 8019c5c:	0801b0ed 	.word	0x0801b0ed
 8019c60:	0801b0fa 	.word	0x0801b0fa
 8019c64:	0801b128 	.word	0x0801b128

08019c68 <fiprintf>:
 8019c68:	b40e      	push	{r1, r2, r3}
 8019c6a:	b503      	push	{r0, r1, lr}
 8019c6c:	4601      	mov	r1, r0
 8019c6e:	ab03      	add	r3, sp, #12
 8019c70:	4805      	ldr	r0, [pc, #20]	; (8019c88 <fiprintf+0x20>)
 8019c72:	f853 2b04 	ldr.w	r2, [r3], #4
 8019c76:	6800      	ldr	r0, [r0, #0]
 8019c78:	9301      	str	r3, [sp, #4]
 8019c7a:	f000 f857 	bl	8019d2c <_vfiprintf_r>
 8019c7e:	b002      	add	sp, #8
 8019c80:	f85d eb04 	ldr.w	lr, [sp], #4
 8019c84:	b003      	add	sp, #12
 8019c86:	4770      	bx	lr
 8019c88:	20000140 	.word	0x20000140

08019c8c <_realloc_r>:
 8019c8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019c8e:	4607      	mov	r7, r0
 8019c90:	4614      	mov	r4, r2
 8019c92:	460e      	mov	r6, r1
 8019c94:	b921      	cbnz	r1, 8019ca0 <_realloc_r+0x14>
 8019c96:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8019c9a:	4611      	mov	r1, r2
 8019c9c:	f7fc b9e0 	b.w	8016060 <_malloc_r>
 8019ca0:	b922      	cbnz	r2, 8019cac <_realloc_r+0x20>
 8019ca2:	f7fc f98d 	bl	8015fc0 <_free_r>
 8019ca6:	4625      	mov	r5, r4
 8019ca8:	4628      	mov	r0, r5
 8019caa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8019cac:	f000 f975 	bl	8019f9a <_malloc_usable_size_r>
 8019cb0:	42a0      	cmp	r0, r4
 8019cb2:	d20f      	bcs.n	8019cd4 <_realloc_r+0x48>
 8019cb4:	4621      	mov	r1, r4
 8019cb6:	4638      	mov	r0, r7
 8019cb8:	f7fc f9d2 	bl	8016060 <_malloc_r>
 8019cbc:	4605      	mov	r5, r0
 8019cbe:	2800      	cmp	r0, #0
 8019cc0:	d0f2      	beq.n	8019ca8 <_realloc_r+0x1c>
 8019cc2:	4631      	mov	r1, r6
 8019cc4:	4622      	mov	r2, r4
 8019cc6:	f7fc f93b 	bl	8015f40 <memcpy>
 8019cca:	4631      	mov	r1, r6
 8019ccc:	4638      	mov	r0, r7
 8019cce:	f7fc f977 	bl	8015fc0 <_free_r>
 8019cd2:	e7e9      	b.n	8019ca8 <_realloc_r+0x1c>
 8019cd4:	4635      	mov	r5, r6
 8019cd6:	e7e7      	b.n	8019ca8 <_realloc_r+0x1c>

08019cd8 <__sfputc_r>:
 8019cd8:	6893      	ldr	r3, [r2, #8]
 8019cda:	3b01      	subs	r3, #1
 8019cdc:	2b00      	cmp	r3, #0
 8019cde:	b410      	push	{r4}
 8019ce0:	6093      	str	r3, [r2, #8]
 8019ce2:	da08      	bge.n	8019cf6 <__sfputc_r+0x1e>
 8019ce4:	6994      	ldr	r4, [r2, #24]
 8019ce6:	42a3      	cmp	r3, r4
 8019ce8:	db01      	blt.n	8019cee <__sfputc_r+0x16>
 8019cea:	290a      	cmp	r1, #10
 8019cec:	d103      	bne.n	8019cf6 <__sfputc_r+0x1e>
 8019cee:	f85d 4b04 	ldr.w	r4, [sp], #4
 8019cf2:	f7fd be3b 	b.w	801796c <__swbuf_r>
 8019cf6:	6813      	ldr	r3, [r2, #0]
 8019cf8:	1c58      	adds	r0, r3, #1
 8019cfa:	6010      	str	r0, [r2, #0]
 8019cfc:	7019      	strb	r1, [r3, #0]
 8019cfe:	4608      	mov	r0, r1
 8019d00:	f85d 4b04 	ldr.w	r4, [sp], #4
 8019d04:	4770      	bx	lr

08019d06 <__sfputs_r>:
 8019d06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019d08:	4606      	mov	r6, r0
 8019d0a:	460f      	mov	r7, r1
 8019d0c:	4614      	mov	r4, r2
 8019d0e:	18d5      	adds	r5, r2, r3
 8019d10:	42ac      	cmp	r4, r5
 8019d12:	d101      	bne.n	8019d18 <__sfputs_r+0x12>
 8019d14:	2000      	movs	r0, #0
 8019d16:	e007      	b.n	8019d28 <__sfputs_r+0x22>
 8019d18:	f814 1b01 	ldrb.w	r1, [r4], #1
 8019d1c:	463a      	mov	r2, r7
 8019d1e:	4630      	mov	r0, r6
 8019d20:	f7ff ffda 	bl	8019cd8 <__sfputc_r>
 8019d24:	1c43      	adds	r3, r0, #1
 8019d26:	d1f3      	bne.n	8019d10 <__sfputs_r+0xa>
 8019d28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08019d2c <_vfiprintf_r>:
 8019d2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019d30:	460d      	mov	r5, r1
 8019d32:	b09d      	sub	sp, #116	; 0x74
 8019d34:	4614      	mov	r4, r2
 8019d36:	4698      	mov	r8, r3
 8019d38:	4606      	mov	r6, r0
 8019d3a:	b118      	cbz	r0, 8019d44 <_vfiprintf_r+0x18>
 8019d3c:	6983      	ldr	r3, [r0, #24]
 8019d3e:	b90b      	cbnz	r3, 8019d44 <_vfiprintf_r+0x18>
 8019d40:	f7fb ffaa 	bl	8015c98 <__sinit>
 8019d44:	4b89      	ldr	r3, [pc, #548]	; (8019f6c <_vfiprintf_r+0x240>)
 8019d46:	429d      	cmp	r5, r3
 8019d48:	d11b      	bne.n	8019d82 <_vfiprintf_r+0x56>
 8019d4a:	6875      	ldr	r5, [r6, #4]
 8019d4c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8019d4e:	07d9      	lsls	r1, r3, #31
 8019d50:	d405      	bmi.n	8019d5e <_vfiprintf_r+0x32>
 8019d52:	89ab      	ldrh	r3, [r5, #12]
 8019d54:	059a      	lsls	r2, r3, #22
 8019d56:	d402      	bmi.n	8019d5e <_vfiprintf_r+0x32>
 8019d58:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8019d5a:	f7fc f87a 	bl	8015e52 <__retarget_lock_acquire_recursive>
 8019d5e:	89ab      	ldrh	r3, [r5, #12]
 8019d60:	071b      	lsls	r3, r3, #28
 8019d62:	d501      	bpl.n	8019d68 <_vfiprintf_r+0x3c>
 8019d64:	692b      	ldr	r3, [r5, #16]
 8019d66:	b9eb      	cbnz	r3, 8019da4 <_vfiprintf_r+0x78>
 8019d68:	4629      	mov	r1, r5
 8019d6a:	4630      	mov	r0, r6
 8019d6c:	f7fd fe62 	bl	8017a34 <__swsetup_r>
 8019d70:	b1c0      	cbz	r0, 8019da4 <_vfiprintf_r+0x78>
 8019d72:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8019d74:	07dc      	lsls	r4, r3, #31
 8019d76:	d50e      	bpl.n	8019d96 <_vfiprintf_r+0x6a>
 8019d78:	f04f 30ff 	mov.w	r0, #4294967295
 8019d7c:	b01d      	add	sp, #116	; 0x74
 8019d7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019d82:	4b7b      	ldr	r3, [pc, #492]	; (8019f70 <_vfiprintf_r+0x244>)
 8019d84:	429d      	cmp	r5, r3
 8019d86:	d101      	bne.n	8019d8c <_vfiprintf_r+0x60>
 8019d88:	68b5      	ldr	r5, [r6, #8]
 8019d8a:	e7df      	b.n	8019d4c <_vfiprintf_r+0x20>
 8019d8c:	4b79      	ldr	r3, [pc, #484]	; (8019f74 <_vfiprintf_r+0x248>)
 8019d8e:	429d      	cmp	r5, r3
 8019d90:	bf08      	it	eq
 8019d92:	68f5      	ldreq	r5, [r6, #12]
 8019d94:	e7da      	b.n	8019d4c <_vfiprintf_r+0x20>
 8019d96:	89ab      	ldrh	r3, [r5, #12]
 8019d98:	0598      	lsls	r0, r3, #22
 8019d9a:	d4ed      	bmi.n	8019d78 <_vfiprintf_r+0x4c>
 8019d9c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8019d9e:	f7fc f859 	bl	8015e54 <__retarget_lock_release_recursive>
 8019da2:	e7e9      	b.n	8019d78 <_vfiprintf_r+0x4c>
 8019da4:	2300      	movs	r3, #0
 8019da6:	9309      	str	r3, [sp, #36]	; 0x24
 8019da8:	2320      	movs	r3, #32
 8019daa:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8019dae:	f8cd 800c 	str.w	r8, [sp, #12]
 8019db2:	2330      	movs	r3, #48	; 0x30
 8019db4:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8019f78 <_vfiprintf_r+0x24c>
 8019db8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8019dbc:	f04f 0901 	mov.w	r9, #1
 8019dc0:	4623      	mov	r3, r4
 8019dc2:	469a      	mov	sl, r3
 8019dc4:	f813 2b01 	ldrb.w	r2, [r3], #1
 8019dc8:	b10a      	cbz	r2, 8019dce <_vfiprintf_r+0xa2>
 8019dca:	2a25      	cmp	r2, #37	; 0x25
 8019dcc:	d1f9      	bne.n	8019dc2 <_vfiprintf_r+0x96>
 8019dce:	ebba 0b04 	subs.w	fp, sl, r4
 8019dd2:	d00b      	beq.n	8019dec <_vfiprintf_r+0xc0>
 8019dd4:	465b      	mov	r3, fp
 8019dd6:	4622      	mov	r2, r4
 8019dd8:	4629      	mov	r1, r5
 8019dda:	4630      	mov	r0, r6
 8019ddc:	f7ff ff93 	bl	8019d06 <__sfputs_r>
 8019de0:	3001      	adds	r0, #1
 8019de2:	f000 80aa 	beq.w	8019f3a <_vfiprintf_r+0x20e>
 8019de6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8019de8:	445a      	add	r2, fp
 8019dea:	9209      	str	r2, [sp, #36]	; 0x24
 8019dec:	f89a 3000 	ldrb.w	r3, [sl]
 8019df0:	2b00      	cmp	r3, #0
 8019df2:	f000 80a2 	beq.w	8019f3a <_vfiprintf_r+0x20e>
 8019df6:	2300      	movs	r3, #0
 8019df8:	f04f 32ff 	mov.w	r2, #4294967295
 8019dfc:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8019e00:	f10a 0a01 	add.w	sl, sl, #1
 8019e04:	9304      	str	r3, [sp, #16]
 8019e06:	9307      	str	r3, [sp, #28]
 8019e08:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8019e0c:	931a      	str	r3, [sp, #104]	; 0x68
 8019e0e:	4654      	mov	r4, sl
 8019e10:	2205      	movs	r2, #5
 8019e12:	f814 1b01 	ldrb.w	r1, [r4], #1
 8019e16:	4858      	ldr	r0, [pc, #352]	; (8019f78 <_vfiprintf_r+0x24c>)
 8019e18:	f7e6 fa0a 	bl	8000230 <memchr>
 8019e1c:	9a04      	ldr	r2, [sp, #16]
 8019e1e:	b9d8      	cbnz	r0, 8019e58 <_vfiprintf_r+0x12c>
 8019e20:	06d1      	lsls	r1, r2, #27
 8019e22:	bf44      	itt	mi
 8019e24:	2320      	movmi	r3, #32
 8019e26:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8019e2a:	0713      	lsls	r3, r2, #28
 8019e2c:	bf44      	itt	mi
 8019e2e:	232b      	movmi	r3, #43	; 0x2b
 8019e30:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8019e34:	f89a 3000 	ldrb.w	r3, [sl]
 8019e38:	2b2a      	cmp	r3, #42	; 0x2a
 8019e3a:	d015      	beq.n	8019e68 <_vfiprintf_r+0x13c>
 8019e3c:	9a07      	ldr	r2, [sp, #28]
 8019e3e:	4654      	mov	r4, sl
 8019e40:	2000      	movs	r0, #0
 8019e42:	f04f 0c0a 	mov.w	ip, #10
 8019e46:	4621      	mov	r1, r4
 8019e48:	f811 3b01 	ldrb.w	r3, [r1], #1
 8019e4c:	3b30      	subs	r3, #48	; 0x30
 8019e4e:	2b09      	cmp	r3, #9
 8019e50:	d94e      	bls.n	8019ef0 <_vfiprintf_r+0x1c4>
 8019e52:	b1b0      	cbz	r0, 8019e82 <_vfiprintf_r+0x156>
 8019e54:	9207      	str	r2, [sp, #28]
 8019e56:	e014      	b.n	8019e82 <_vfiprintf_r+0x156>
 8019e58:	eba0 0308 	sub.w	r3, r0, r8
 8019e5c:	fa09 f303 	lsl.w	r3, r9, r3
 8019e60:	4313      	orrs	r3, r2
 8019e62:	9304      	str	r3, [sp, #16]
 8019e64:	46a2      	mov	sl, r4
 8019e66:	e7d2      	b.n	8019e0e <_vfiprintf_r+0xe2>
 8019e68:	9b03      	ldr	r3, [sp, #12]
 8019e6a:	1d19      	adds	r1, r3, #4
 8019e6c:	681b      	ldr	r3, [r3, #0]
 8019e6e:	9103      	str	r1, [sp, #12]
 8019e70:	2b00      	cmp	r3, #0
 8019e72:	bfbb      	ittet	lt
 8019e74:	425b      	neglt	r3, r3
 8019e76:	f042 0202 	orrlt.w	r2, r2, #2
 8019e7a:	9307      	strge	r3, [sp, #28]
 8019e7c:	9307      	strlt	r3, [sp, #28]
 8019e7e:	bfb8      	it	lt
 8019e80:	9204      	strlt	r2, [sp, #16]
 8019e82:	7823      	ldrb	r3, [r4, #0]
 8019e84:	2b2e      	cmp	r3, #46	; 0x2e
 8019e86:	d10c      	bne.n	8019ea2 <_vfiprintf_r+0x176>
 8019e88:	7863      	ldrb	r3, [r4, #1]
 8019e8a:	2b2a      	cmp	r3, #42	; 0x2a
 8019e8c:	d135      	bne.n	8019efa <_vfiprintf_r+0x1ce>
 8019e8e:	9b03      	ldr	r3, [sp, #12]
 8019e90:	1d1a      	adds	r2, r3, #4
 8019e92:	681b      	ldr	r3, [r3, #0]
 8019e94:	9203      	str	r2, [sp, #12]
 8019e96:	2b00      	cmp	r3, #0
 8019e98:	bfb8      	it	lt
 8019e9a:	f04f 33ff 	movlt.w	r3, #4294967295
 8019e9e:	3402      	adds	r4, #2
 8019ea0:	9305      	str	r3, [sp, #20]
 8019ea2:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 8019f88 <_vfiprintf_r+0x25c>
 8019ea6:	7821      	ldrb	r1, [r4, #0]
 8019ea8:	2203      	movs	r2, #3
 8019eaa:	4650      	mov	r0, sl
 8019eac:	f7e6 f9c0 	bl	8000230 <memchr>
 8019eb0:	b140      	cbz	r0, 8019ec4 <_vfiprintf_r+0x198>
 8019eb2:	2340      	movs	r3, #64	; 0x40
 8019eb4:	eba0 000a 	sub.w	r0, r0, sl
 8019eb8:	fa03 f000 	lsl.w	r0, r3, r0
 8019ebc:	9b04      	ldr	r3, [sp, #16]
 8019ebe:	4303      	orrs	r3, r0
 8019ec0:	3401      	adds	r4, #1
 8019ec2:	9304      	str	r3, [sp, #16]
 8019ec4:	f814 1b01 	ldrb.w	r1, [r4], #1
 8019ec8:	482c      	ldr	r0, [pc, #176]	; (8019f7c <_vfiprintf_r+0x250>)
 8019eca:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8019ece:	2206      	movs	r2, #6
 8019ed0:	f7e6 f9ae 	bl	8000230 <memchr>
 8019ed4:	2800      	cmp	r0, #0
 8019ed6:	d03f      	beq.n	8019f58 <_vfiprintf_r+0x22c>
 8019ed8:	4b29      	ldr	r3, [pc, #164]	; (8019f80 <_vfiprintf_r+0x254>)
 8019eda:	bb1b      	cbnz	r3, 8019f24 <_vfiprintf_r+0x1f8>
 8019edc:	9b03      	ldr	r3, [sp, #12]
 8019ede:	3307      	adds	r3, #7
 8019ee0:	f023 0307 	bic.w	r3, r3, #7
 8019ee4:	3308      	adds	r3, #8
 8019ee6:	9303      	str	r3, [sp, #12]
 8019ee8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8019eea:	443b      	add	r3, r7
 8019eec:	9309      	str	r3, [sp, #36]	; 0x24
 8019eee:	e767      	b.n	8019dc0 <_vfiprintf_r+0x94>
 8019ef0:	fb0c 3202 	mla	r2, ip, r2, r3
 8019ef4:	460c      	mov	r4, r1
 8019ef6:	2001      	movs	r0, #1
 8019ef8:	e7a5      	b.n	8019e46 <_vfiprintf_r+0x11a>
 8019efa:	2300      	movs	r3, #0
 8019efc:	3401      	adds	r4, #1
 8019efe:	9305      	str	r3, [sp, #20]
 8019f00:	4619      	mov	r1, r3
 8019f02:	f04f 0c0a 	mov.w	ip, #10
 8019f06:	4620      	mov	r0, r4
 8019f08:	f810 2b01 	ldrb.w	r2, [r0], #1
 8019f0c:	3a30      	subs	r2, #48	; 0x30
 8019f0e:	2a09      	cmp	r2, #9
 8019f10:	d903      	bls.n	8019f1a <_vfiprintf_r+0x1ee>
 8019f12:	2b00      	cmp	r3, #0
 8019f14:	d0c5      	beq.n	8019ea2 <_vfiprintf_r+0x176>
 8019f16:	9105      	str	r1, [sp, #20]
 8019f18:	e7c3      	b.n	8019ea2 <_vfiprintf_r+0x176>
 8019f1a:	fb0c 2101 	mla	r1, ip, r1, r2
 8019f1e:	4604      	mov	r4, r0
 8019f20:	2301      	movs	r3, #1
 8019f22:	e7f0      	b.n	8019f06 <_vfiprintf_r+0x1da>
 8019f24:	ab03      	add	r3, sp, #12
 8019f26:	9300      	str	r3, [sp, #0]
 8019f28:	462a      	mov	r2, r5
 8019f2a:	4b16      	ldr	r3, [pc, #88]	; (8019f84 <_vfiprintf_r+0x258>)
 8019f2c:	a904      	add	r1, sp, #16
 8019f2e:	4630      	mov	r0, r6
 8019f30:	f7fc f990 	bl	8016254 <_printf_float>
 8019f34:	4607      	mov	r7, r0
 8019f36:	1c78      	adds	r0, r7, #1
 8019f38:	d1d6      	bne.n	8019ee8 <_vfiprintf_r+0x1bc>
 8019f3a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8019f3c:	07d9      	lsls	r1, r3, #31
 8019f3e:	d405      	bmi.n	8019f4c <_vfiprintf_r+0x220>
 8019f40:	89ab      	ldrh	r3, [r5, #12]
 8019f42:	059a      	lsls	r2, r3, #22
 8019f44:	d402      	bmi.n	8019f4c <_vfiprintf_r+0x220>
 8019f46:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8019f48:	f7fb ff84 	bl	8015e54 <__retarget_lock_release_recursive>
 8019f4c:	89ab      	ldrh	r3, [r5, #12]
 8019f4e:	065b      	lsls	r3, r3, #25
 8019f50:	f53f af12 	bmi.w	8019d78 <_vfiprintf_r+0x4c>
 8019f54:	9809      	ldr	r0, [sp, #36]	; 0x24
 8019f56:	e711      	b.n	8019d7c <_vfiprintf_r+0x50>
 8019f58:	ab03      	add	r3, sp, #12
 8019f5a:	9300      	str	r3, [sp, #0]
 8019f5c:	462a      	mov	r2, r5
 8019f5e:	4b09      	ldr	r3, [pc, #36]	; (8019f84 <_vfiprintf_r+0x258>)
 8019f60:	a904      	add	r1, sp, #16
 8019f62:	4630      	mov	r0, r6
 8019f64:	f7fc fc1a 	bl	801679c <_printf_i>
 8019f68:	e7e4      	b.n	8019f34 <_vfiprintf_r+0x208>
 8019f6a:	bf00      	nop
 8019f6c:	0801ad80 	.word	0x0801ad80
 8019f70:	0801ada0 	.word	0x0801ada0
 8019f74:	0801ad60 	.word	0x0801ad60
 8019f78:	0801b0dc 	.word	0x0801b0dc
 8019f7c:	0801b0e6 	.word	0x0801b0e6
 8019f80:	08016255 	.word	0x08016255
 8019f84:	08019d07 	.word	0x08019d07
 8019f88:	0801b0e2 	.word	0x0801b0e2

08019f8c <abort>:
 8019f8c:	b508      	push	{r3, lr}
 8019f8e:	2006      	movs	r0, #6
 8019f90:	f000 f834 	bl	8019ffc <raise>
 8019f94:	2001      	movs	r0, #1
 8019f96:	f7fb fd2d 	bl	80159f4 <_exit>

08019f9a <_malloc_usable_size_r>:
 8019f9a:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8019f9e:	1f18      	subs	r0, r3, #4
 8019fa0:	2b00      	cmp	r3, #0
 8019fa2:	bfbc      	itt	lt
 8019fa4:	580b      	ldrlt	r3, [r1, r0]
 8019fa6:	18c0      	addlt	r0, r0, r3
 8019fa8:	4770      	bx	lr

08019faa <_raise_r>:
 8019faa:	291f      	cmp	r1, #31
 8019fac:	b538      	push	{r3, r4, r5, lr}
 8019fae:	4604      	mov	r4, r0
 8019fb0:	460d      	mov	r5, r1
 8019fb2:	d904      	bls.n	8019fbe <_raise_r+0x14>
 8019fb4:	2316      	movs	r3, #22
 8019fb6:	6003      	str	r3, [r0, #0]
 8019fb8:	f04f 30ff 	mov.w	r0, #4294967295
 8019fbc:	bd38      	pop	{r3, r4, r5, pc}
 8019fbe:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8019fc0:	b112      	cbz	r2, 8019fc8 <_raise_r+0x1e>
 8019fc2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8019fc6:	b94b      	cbnz	r3, 8019fdc <_raise_r+0x32>
 8019fc8:	4620      	mov	r0, r4
 8019fca:	f000 f831 	bl	801a030 <_getpid_r>
 8019fce:	462a      	mov	r2, r5
 8019fd0:	4601      	mov	r1, r0
 8019fd2:	4620      	mov	r0, r4
 8019fd4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8019fd8:	f000 b818 	b.w	801a00c <_kill_r>
 8019fdc:	2b01      	cmp	r3, #1
 8019fde:	d00a      	beq.n	8019ff6 <_raise_r+0x4c>
 8019fe0:	1c59      	adds	r1, r3, #1
 8019fe2:	d103      	bne.n	8019fec <_raise_r+0x42>
 8019fe4:	2316      	movs	r3, #22
 8019fe6:	6003      	str	r3, [r0, #0]
 8019fe8:	2001      	movs	r0, #1
 8019fea:	e7e7      	b.n	8019fbc <_raise_r+0x12>
 8019fec:	2400      	movs	r4, #0
 8019fee:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 8019ff2:	4628      	mov	r0, r5
 8019ff4:	4798      	blx	r3
 8019ff6:	2000      	movs	r0, #0
 8019ff8:	e7e0      	b.n	8019fbc <_raise_r+0x12>
	...

08019ffc <raise>:
 8019ffc:	4b02      	ldr	r3, [pc, #8]	; (801a008 <raise+0xc>)
 8019ffe:	4601      	mov	r1, r0
 801a000:	6818      	ldr	r0, [r3, #0]
 801a002:	f7ff bfd2 	b.w	8019faa <_raise_r>
 801a006:	bf00      	nop
 801a008:	20000140 	.word	0x20000140

0801a00c <_kill_r>:
 801a00c:	b538      	push	{r3, r4, r5, lr}
 801a00e:	4d07      	ldr	r5, [pc, #28]	; (801a02c <_kill_r+0x20>)
 801a010:	2300      	movs	r3, #0
 801a012:	4604      	mov	r4, r0
 801a014:	4608      	mov	r0, r1
 801a016:	4611      	mov	r1, r2
 801a018:	602b      	str	r3, [r5, #0]
 801a01a:	f7fb fce3 	bl	80159e4 <_kill>
 801a01e:	1c43      	adds	r3, r0, #1
 801a020:	d102      	bne.n	801a028 <_kill_r+0x1c>
 801a022:	682b      	ldr	r3, [r5, #0]
 801a024:	b103      	cbz	r3, 801a028 <_kill_r+0x1c>
 801a026:	6023      	str	r3, [r4, #0]
 801a028:	bd38      	pop	{r3, r4, r5, pc}
 801a02a:	bf00      	nop
 801a02c:	2001a178 	.word	0x2001a178

0801a030 <_getpid_r>:
 801a030:	f7fb bcd6 	b.w	80159e0 <_getpid>

0801a034 <_init>:
 801a034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a036:	bf00      	nop
 801a038:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801a03a:	bc08      	pop	{r3}
 801a03c:	469e      	mov	lr, r3
 801a03e:	4770      	bx	lr

0801a040 <_fini>:
 801a040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a042:	bf00      	nop
 801a044:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801a046:	bc08      	pop	{r3}
 801a048:	469e      	mov	lr, r3
 801a04a:	4770      	bx	lr
 801a04c:	0000      	movs	r0, r0
	...
